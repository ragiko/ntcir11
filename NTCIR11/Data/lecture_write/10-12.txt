はい豊橋技科大のですおはようございます
本日は部分距離空上の索引付けに基づく音声ドキュメントからの検索語検出という発表を致します
でこの発表は昨日から発表がございますＳＰＯＫＥＮ ＴＥＲＭ ＤＥＴＥＣＴＩＯＮの発表です
でそのＳＰＯＫＥＮ ＴＥＲＭ ＤＥＴＥＣＴＩＯＮに関して新しい全く新しい手法を提案したいと思います
ただまだ評価のところは十分ではなくて実験結果は非常に準備段階の予備的なものに限られますけれども今日の発表はアルゴリズムを中心にご紹介したいと思っております
はいでまず研究の目的ですがこちらは昨日何回も発表がありましたので言うまでもないと思いますけれども
ＳＰＯＫＥＮ ＴＥＲＭ ＤＥＴＥＣＴＩＯＮというのは音声ドキュメントから入力したパターンが発話されている位置を特定するという問題です
でこのＳＰＯＫＥＮＴＥＲＭ ＤＥＴＥＣＴＩＯＮの手法にはいろいろありますけどもその中でなるべく高速で高精度であるという手法が望ましいというふうに考えられます
でさらに言いますと
手法はできるだけ利用し易いと
いろんなところに応用できるというような手法が望ましいであろうというふうに考えられます
でこの発表はそのＳＴＤの問題に対する新しい手法を提案します
で本発表では先ほど述べましたように提案手法のアルゴリズムを中心に
報告をすると
いうふうにさせていただきたいと思います
はいでまず最初に句中ですけれども
音声ドキュメント検索というのは二つございますで検索語検出というものと内容検索というものと二種類ございます
で検索語検出が今考えているものでこれはクエリーとして与えられたパターンが現れている位置を音声ドキュメントから特定しようという問題を解こうとそういう
問題です
でこれに対しまして内容検索の方はクエリーとしてはユーザーがこういうものを欲しいとこういう文章が欲しいという表現を与えて
その表現に合致するような
適合する
文章というのを文書コレクションの中から探しましょうというこういう問題ですね
で
だから下の方は必ずしもタームが一致する必要がないわけです
で普通テキストの分野だと検索といいますと下の方の内容検索を方を指しますけれども音声の場合では上のＴｅｒｍＤｅｔｅｃｔｉｏｎの方も自明なものではないので
むしろこちらの方がさかんに研究されてるという状況にございます
はいそれでそのＳＰＯＫＥＮ ＴＥＲＭ ＤＥＴＥＣＴＩＯＮに関する関連研究ですけどもまとめますとだいたいこういった手法が提案されています
で一番ベーシックな基本的な方法は連続ＤＰマッチングで解こうという方法です
ただ連続ＤＰマッチングですと検索対象の文章全部なめないといけませんので効率が悪いと
でそこで
索引付けをすることによって効率化しようという手法がいくつか提案されてます
で一つ目の代表的な手法これはほとんどの人がこちらなんですけどもインバーテッドファイルを使いましょうという方法です
でこれはテキストでもよく使われる方法でいわば辞書を作っておきましょうということですね検索したい
ものの辞書を作っておいてその辞書に載っているものに関してはその位置を
すぐに引けるというような索引を作っておきましょうと
いう必要が
そういう符丁になってます
でこちらの方は辞書が必要でそこに載ってないものはもう検索されないわけですね
だそこが
ちょっと音声ドキュメント対象にする場合は問題で
音声ドキュメントだとゆれがありますので必ずしも全ての
文字列をここに載せるというのは必ずしも容易ではないと
で昨日のの発表はこちらの方で
そこの索引付けの方をいろいろと工夫されて
いろんなパターンを載せてるというようなこと発表だったと思います
でもう一つの方法は
サッフィクスアレイを使うという手法でこれは
昨日ご発表がありました
の発表に相当します
でこちらの方は
どういう手法かというとその検索対象のドキュメントの方を
圧縮しまして
ドキュメントの共通部分をＴｒｅｅ状に圧縮して
同じところはまとめて検索できるようにすると
いうことでその上でＤＰマッチングをしてやろうという手法ですね
で
ただこの方法だと音声ドキュメントの場合やはり
認識に揺れがあるというところが
大きな
問題になりまして
テキストの場合だと一意に決まるのでそこで圧縮がうまくいきますけれどもおそらくいろいろな認識法たくさんの認識方法がある中で
その中で共通部分を見つけるというような
かなり扱いは難しいであろうと
いうふうに想像できます
でまたいずれの手法ですね従来のいずれの手法も
検索の問題に対しては閾値を使っていると
検索したいものがどのぐらい
誤りが許されているかという閾値を設定してその閾値内の
距離を持つような候補を出すというような問題を
解いてるという手法になっています
はいで
この関連分野としてテキストの分野ではその揺れを許して誤りを許して検索をするという問題は近似文字列照合という分野で研究が行われています
でその近似文字列照合の中で代表的な手法というのはこちらの作品付けの手法で代表的な手法はこちらの三つの手法になっ
ています
で最初の二つは先ほどの二つにちょうど対応してると
いうような手法になっています
でもう一つ
トリ空間上の索引ていうのがあるんですねで
今回の手法はこちらのトリ空間上の索引というのを使うという手法になっています
で簡単にこれらの手法の紹介をしたいと思いますがまずサッフィクスツリーを使う方法ですけどもこれ細かくは説明しませんけども
Ｔｒｅｅ上に対象文章の共通部分をこれパッキングしておくわけですね圧縮しておくと
そうすると共通部分をここの上で
ＤＰマッチングすることができるということになると
そこで
探索をしていて誤り超過をしたところを枝刈りをしてやると
それで深さ優先で探索するとここが
ちょうどＤＰ表がスタックのように使えて
バックトラックすることでまた別のパスを探すというように
探索はできるとこういう手法になっております
はいでもう一つのＮグラム索引を使うという手法ですけどこちらはパーティショニングと
呼ばれる方法を使って検索するという手法が知られています
これはどういうことかというと
誤り許される誤りの
数ですねこれをエラーレベルと
言いますがそのエラーレベルプラス一個分にパターンを分割してやると
いう手法です例えば
アブラカダブラというのがありますと
これを誤り二まで許して
検索しましょうと
いう時にはこれを
三つに分割するわけです
三つのパターンに
分割します
そうしますとこの三つのうちの必ず一つは
誤り無しでもし
テキスト上に存在するなら誤り無しで存在するということが保障されますのでそこに関して
Ｎグラム索引を使って検索しましょうと
そういう手法ですね
で
例えばバイグラム索引を使いますとこのパターンをバイグラムに分解してやって
テキストで索引付けされているバイグラムを探すわけですね
そうするとここのＣＡＤＡというとこが見つかると
でこういうのが見つかるとこの近辺に答えがあると
いうふうに
ある可能性があるということがわかるのであとはこの周辺で
オンラインの近似文字列照合手法を使って探索をしましょうということになります
で最後の距離空間上の索引付けですけどもこれは
どういう方法かというと
距離空間がありましてそこにオブジェクトが点在してると
いうような状況を考えます
でそこで
クエリーこれもまたオブジェクトで検索クエリーってのがここにポンと与えられるとで距離空間上で
この中で一番近いものオブジェクトは何ですかというのを探そうとそういう問題を解こうと
いう手法です
で
その時にこれら全部をですね全部に対して距離を求めてやると
効率が悪いわけですね計算コストが高くなってしまう
そこで索引付けをしてこのこれを効率的に求めましょうということをやっています
でどういう索引付けをするかですけれども
手法はいくつかあるんですけども
代表的なのはピボットを使うと
オブジェクトの中から
少数のピボットというのを選んでおいて
でこのピボットから他のオブジェクトへの
距離というのを予め計算しておくと
いうことをします
そうすると
クエリーがこれを索引付けと呼ぶわけですねこれが索引付けに相当する
で新しいクエリーが現れた時はそのピボットとの距離を
計算すると
それで
そうすると予め求めておいた距離を使って
この間のオブジェクト間の距離が
近似的に計算できるということになります
でこういう事象で効率的に探しましょうという方法が
距離空間上の索引付けという手法になります
はい関連研究を簡単に説明しましたが提案手法はこれらの手法のうち
今までＳＴＤ問題には使われていなかったこの距離空間上の索引とこれを使いましょうという手法に相当すると
いうことになります
はいでまず最初にその提案手法の位置づけについて簡単にまとめたいと思います提案手法は距離空間上の索引付けを利用すると今言ったように
そういう手法になっていると
でもうちょっと細かく言うと距離空間を部分空間に分けるんですねでその部分空間上で距離を測って
索引付けをするという方法になっています
でまた別の見方をしますと提案手法は
そのＳＴＤ問題を直線件数の問題として定式したものであるというふうに考えることができます
でそこで画像では直線件数法としてハフ変換というのが知られています
でこれを
ＳＴＤ問題に適応応用した手法であるというふうにみることもできます
で特徴としましては
まず一点として閾値を
必要としないという大きな特徴があります
で閾値の予めこのぐらいが欲しいというのは設定する必要が無いと
で提案手法だと距離順に出力するということが可能になります
でもう一つ
音声認識だと
認識の候補がいろいろ出て
くるんですけども
その複数候補の扱いが
非常に容易にできますアルゴリズムの変更無しに
そのまま適用できるという特徴があります
はい
それででは提案手法について説明してまいります
提案手法はＳＴＤの問題直線検出問題として考えようとでこれをどうこれはどういうことかというと
こちらの図を見ていただけるとわかると思うんですが
検索語を縦軸に取って今検索したい語パターンですねこれを縦軸に取って対象の音声ドキュメントを横軸に取るとこれは非常に長い
音声ドキュメントの音素列になるわけですね
でそうするとこの平面状の格子点には
音素間の距離がこうやって与えられると
いうような
平面が与えられるということになります
で距離が近い
遠いということで画像で言うと画素濃度みたいに相当するような点がこの平面上に定義されるわけですね
でその中で
画素濃度の濃いつまり距離が小さいような点を結んでここに直線がこう現れるであろうと
でこういう直線を検出するという問題としてＳＴＤの問題を考えましょうと
いうことに
ができます
でただＳＴＤの場合はですね固有の特徴を使うことができると
いうことですね画像の直線件数の場合には画素
画像がその場で与えられてオンラインで
この直線を
検出しなきゃいけないんですけども
ＳＴＤの場合はこの横ですね横の
検索対象のドキュメントの音素列これが予め与えられてます
だから前処理できるわけですねここは
予め与えられてるという大きな特徴があります
でこれを使って
でここは与えられているので
ここの横のとこですね短冊状に区切った
各音素ごとの
距離のベクトル
ですねここが予め計算しておくこと
ができると
いう大きな特徴が
あります
ですので検索語が入ってきたらば
この短冊状の距離ベクトルを
の検索語の音素順に並べてやると
この
画素平面がそのまま再現できると
いうことになりますこういう特徴があると
でさらに
この
距離ベクトルですねこれは予め
ソートしておくことができます
ここは距離がそれぞれ位置で
定義されているわけですけどもそれを
その距離順にソートをしておくと
いうことができますどこが一番最もらしいかと
いうのを予め調べておくということが
できます
ででソートをして
で実際には距離は必要無いんですがその位置を
ソートしておくと距離順に位置をソートしておくということをしておきますで
このソートされたベクトルこれを索引
索引として使いましょうと
いうのが提案法のアイデアです
はい
ではもうちょっと細かく提案法説明しますとまず
前処理として今の距離順にソートされたベクトルを作っておきますでこれは音素ですね音素の種類ごとに
検索対象長だけ
先ほど言ったように距離は必ずしも必要は無いんですけども
位置のベクトルというのを作っておくと
ちょっと説明のために距離と位置のペアにしてますけども
ソートの時にだけ距離は使うということになります
で
こういう
行列を作っておいて
でここ距離順にソートをしておくと
いうことを予め全ての音素に対して
やっておくということをしますこれが索引付けに相当します
そして
実際に検索の時にどうするかというと
検索の時にはパターンが入ってきますのでこのパターンに従って今の
音素のベクトルですねこれを並べてやると
いうことがことをします検索語のパターンに従って
その音素を
予め求めておいたベクトルから取ってきて
並べてやるということをします
で
これは先ほど言いましたように距離順にソートされてるわけですね
で一番距離の小さいものが上の方に
入ってると
でこれをスタック的に使いますスタックのように使って
距離の小さい方をスタックトップだというふうに見なして利用するということをします
そして
こういうのを作っておいてあと
検索対象の各位置について投票箱というのを用意しておきます
でここに対して
どんどん投票していくわけですけども
要はここの
スタックのトップですねここから距離の一番小さいものを一つ選んで
でそれに相当する位置に投票をすると
いうことですね
で今の場合ここ
Kの
一番距離が小さいところここに投票がくると
でこれに対して直線に対応するこの斜め方向のここに
ここがこれに関する検索位置になりますのでここに
一応投票するということであると
これを繰り返していくわけですね
で次のもっとも小さいものに対して同じように投票すると
いうのをどんどんどんどん
繰り返すと
いうことを
やっていくと
いうことをします
そうすると
最終的にはここが投票箱がたまると
検索語長までたまるというところが
見つかりますここが
まさに今見つけたかった検索語が現れたとこであると
いうことですねここを出力しましょうというふうに
やっていくと
でこれを続けていくことで特に閾値を
設定することなくもっともらしいものから
もっともらしい
発話箇所順に高速な検索語検索が可能になるとこういう原理で
ございます
はいで今のは非常に基本的なところを
説明したんですけども一番単純なアルゴリズムを説明しましたけども
これこのアルゴリズムを一般化すると実際の場面に適応するという方法がいくつか考えられます
で一つは最適化アルゴリズムで実は今紹介した手法は必ずしも距離の一番小さいものから得られるというような保障されないんですね
でこれをもうちょっと考えてやると
必ず一番小さいものから出すということを保障するアルゴリズムを構成することができます
ただちょっと
複雑になりますので予稿集のほうには載せておりましたので興味のある方はそちらをご覧下さいここではちょっと説明
省かせていただきます
で
二番目の
一般化方法として複数認識候補に
対応しましょうというのがあります
でこの提案手法はですねコンフュージョンネットワークとか
で表せたソーセージ型の複数
候補に表現にそのまま対応することが可能ですこれはちょっとあとで説明します
でもう一つ
直線検出と言いましたけども実際は
おわかりのように挿入とか脱落誤りがあるので直線にはならないわけですね
で直線に対応直線以外の
折れ線に対応するというために何か対策をしなきゃいけないと
でここに対策三の手法がいくつか考えられます
この
後半の二つについてちょっと説明したいと思います
でまず複数認識候補の扱いですけどもこれは非常にストレートで
提案手法っていうのは
各音素と検索位置の間の
距離を
使えば良いとそれが定義されれば良いと
いうことになります
つまりこれに対してこの位置で
どういう距離かというのがわかれば良いとだから
ここが複数候補になっても
その複数候補とその各音素との間が定義できれば
良いわけですね
それそういった距離
距離が定義できれば
今のアルゴリズムでそのまま
複数候補が扱えると
いうことになります
でそういう距離としては例えば
ソーセージ型で複数候補が
あったとした時にその距離の中で重み付きで最小のものを使うとか
こういったような例これは一つの例ですけども例えばこういうような
距離を何か用意すれば
普通候補に対応できると
ということになります
次に挿入削除誤りへの対応ですけれども
実際には直線にはならずにこういった折れ線になるわけですね
でこれにどう対応するかですけども
一番単純な方法はこの折れ線に対応するような投票箱を用意して
そこで
投票回数を見るというのが
単純な方法ですが
候補の数が非常に多くなっていろんなパターンをみつけな用意しなきゃいけないのでこれは
大変になると
ちょっと工夫が必要だと思います
でもう一つの解決方法としては
その距離をやっぱり操作をして多少折れ曲がっていても対応できるような距離尺度にしてしまおうという方法が考えられます具体的には隣接する音素ですねこの隣接する音素に関しても
考慮した距離尺度を与えると
で例えばそういう例としては
これこれの最小値を使うとか
中心を重視した重み付けで距離を作るとかこういった
距離
関数を作ってやると
でそうすると
いわば
曲線の直線の時の直線をちょっと太くしたような直線を検出するというようなことに相当しますけども多少の
以前に相当対応できるというような
方法になると
いうふうに考えております
はい
で最後に
非常に簡単な評価実験をやってみました
で
実験は音声ドキュメントワーキンググループで
構築した
検索語検出のテストコレクションの
コア講演を対象にしてるものを使いましたこれの未知語セットと
既知語セットを使いました
ついでベースラインとして連続ＤＰマッチングと比較して
どうかというのを
比べてみました
で音素間距離としてはこれは何を使っても良いんですけれども今回は比較的利用しやすかった音素弁別特徴の
ハミング距離を使ったとこれは昨日の先生の
発表に使われてた距離に相当します
それでこれが連続ＤＰマッチングですね
はい
で
実験結果ですけども
累積距離０でとりあえず
高速化は可能かどうかというのを調べた程度なんですけども連続ＤＰと提案手法で精度は
変わらないと
で処理時間に関しては
一応高速化はできるということを確認しました
だけども高速化はできたんですけどまだまだまだ十分ではないと
連続ＤＰは索引付けなしの手法なんで索引付け手法
が勝つのは当たり前だと思って一応その確認はしましたという程度の結果です
で
それにしてもまだこの差っていうのはまだ十分ではないかなあというふうに私としては考えています
で
なんであまり早くなんか長かったということなんですけども理由の一つとしては
音素で索引付けすると
最初に距離０でマッチするとこが結構あるんですねでそこに関してはもうぜーんぶ投票するということになってしまうので
そこで
結局のこと検索対象の大部分のところで探索をしなきゃならないということになってしまうそこが問題であろうと
いうふうに考えてます
はいでまとめますＳＰＯＫＥＮ ＴＥＲＭ ＤＥＴＥＣＴＩＯＮに対する新しい検索アルゴリズムを提案しました
で索引付けの手法になっていて
大きな特徴は閾値を必要としないで
もっともらしい候補から順番に検索結果を
検出すると
で音声認識の結果の複数候補をそのまま使えるというのも特徴になっています
で昨日先生のお話にありましたようにアルゴリズムは単純な方が良いと
で先ほど見ていただいたようにこのアルゴリズムは非常に単純です
単純なアルゴリズムで構成可能と
いう特徴もあります
で予備実験で一応確認はしましたけど性能はまだまだ十分ではないと考えてます
で対策としては音節とか音節列とかですねもうちょっと距離に差がつくような
大きな単位で索引付けをする
必要があるとあるいはその距離尺度をもうちょっと見直して
距離に差がつくような
尺度が必要であろうと
いうふうに考えております
はい以上で発表を終わりますありがとうございました
