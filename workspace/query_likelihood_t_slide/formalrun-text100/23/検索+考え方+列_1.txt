
文字列検索(直感的な文字列検索とKMP法)
文字列に対する検索
以前、表の中からある特定の値を持つデータを探し出す「探索
」を学習しましたが、そのときは「このキーをもったレコードを探し出しなさい」と指示しました。
では、文字列の場合はどうなるのでしょうか?
文字列の検索では、文字の並びが重要なので、「文字abcがこの順番に並んだ場所を探し出しなさい」というように指定します。
ここで、「探したい文字の並び」のことをパターンといいます。
今の例は「パターンabcを探し出しなさい」と言い換えることができます。
また、検索される文字列のことをテキストと呼びます。
つまり、文字列の検索とは、「テキスト中で指定されたパターンが出現する場所を見つける操作」と定義することができます。
力まかせのアルゴリズム
文字列の検索を行うのに、真っ先に思いつくのは、次のようなアルゴリズムでしょう。
まず最初にテキストの先頭にパターンを重ね合わせます。
そしてパターンとテキストを比較して、両者が一致すれば検索は成功です。
もし一致しなければ、パターンを1文字分だけ後ろにずらして、パターンとテキストを再び比較します。
この手順を繰り返し行い、パターンとテキストが一致しないまま、テキストの最後尾に行き当たれば、パターンはテキスト中に含まれない—つまり、検索は失敗した—ことになります。
図をもとに検索の過程を見てみましょう。
ここではabacbというテキストに対してacというパターンを検索しています。
まずパターンをテキストの1文字目に合わせて比較を行います(1)。
パターンの1文字目とテキストの1文字目は、ともにaなので一致します。
しかし、パターンの2文字目とテキストの2文字目は一致しないので、パターンを1文字分右にずらします(2)。
しかし、やはりパターンとテキストが一致しないので、再びパターンを右に1文字ずらします(3)。
今度は、テキストとパターンが完全に一致するので、ここで検索は成功します。このアルゴリズムはとても素朴なもので、要するに力任せに検索を行うだけです。
そのため、brute-force algorithmと呼ばれます。
日本語にすれば力まかせのアルゴリズムとでもいうところでしょう。
では、具体的なアルゴリズムを考えてみます。
このbrute_force_search関数は、テキストが格納されるtext、パターンが格納されるpatternの2つ のパラメータを受け取り,パターンが見つかった位置を返します。
またパター ンが見つからなかった場合には-1を返します。
テキスト,パターンの位置情報を それぞれ管理するのに変数i,jを用いることにします。
/* 文字列textから文字列patternを検索する(力まかせ法) */
int brute_force_search(char text[], char pattern[])
{
int i = 0; /* 注目しているテキストの位置 */
int j = 0; /* 注目しているパターンの位置 */
int text_len, patn_len;
text_len = strlen(text);    /* テキストの長さをセット */
patn_len = strlen(pattern); /* パターンの長さをセット */
/* テキストの最後尾に行き当たるか、パターンが見つかるまで繰り返す */      while ( i 力まかせのアルゴリズムの計算量
力まかせのアルゴリズムの計算量はどのくらいになるでしょうか?
文字列 の探索の計算量は,テキスト1文字とパターン1文字の比較の同数を基準とし て表すのが適当でしょう。
上のアルゴリズムでいえば,13行目のwhileループが何回 実行されるかを考えることになります。
計算量が,テキストの長さとパターン の長さの関数になるのは明らかでしょう。
これ以降,テキストの長さをn文 字,パターンの長さをm
文字として話を進めていきましょう。まず最悪のケースに文字の比較が何回必要になるかを考えてみましょう。
た とえば,テキスト,パターンともに,先頭からaが連続して続き,最後の1 文字だけがbになっている,というようなケースがこれに当たります。
ここでは,パターンをテキストと動合わせる位置は全部で(n
-m+1) 通りあります。
そして,そのすべての位置についてパターン長(つまりm)回 の文字の比較が行われます。
したがって,文字の比較は,合計でm(n-m+1) 回行われることになります。
ここで,ー般にn(テキストの長さ)のほうがm(パターンの長さ)よりも十分に大きいので,
n-m+1はnとみなすことができ ます。
したがって,力まかせのアルゴリズムの計算量はO(mn
)となります。しかし,日本語や英語のような自然言語や,Cのようなプログラミング言語 では,最悪のケースはほとんど起こりえません。
なぜなら,自然言語やプログ ラミング言語では文字の種類が多いので,たいていの場合,パターンの先頭の 数文字を調べるだけですんでしまうからです。
つまり,病的なケースを除き, パターンの長さとは無関係に,計算量は実質的にO
(n)となります。
もちろん, 文字の種類が少ない場合−−たとえば、ビット列−−には,パターンの長さm
が効いてくることになります。実用的な見地からすれば,力まかせ法でも十分に高速だといえます。
たとえ ば1文字(または文字列)をサーチする機械語命令を備えたCPUもありますが, このような命令は(ほとんどの場合)力まかせ法で実現されています。
このよう なCPUでは,これから紹介するKMP法やBM法
といった洗練されたアルゴ リズムを使うよりも,(力まかせ法を実行する)機械語命令を使うほうが速い可 能性があります。
洗練されたアルゴリズム
力まかせのアルゴリズムは古くから知られ,広く使われていました(もちろ ん現在でも広く使われています)。
このアルゴリズムは,最悪の場合,計算量 がO(mn)になりますが,通常はO
(n)で実行することができます。
そのため に,この分野では長期にわたって,力まかせ法が唯一のアルゴリズムとして知 られていました。
しかし1970年に,S.A.Cookが「最悪の場合でも文字の比較をm
+nに比例 した回数だけ行う文字列探索アルゴリズムが存在する」ということを理論的に 証明しました。
そして,この証明をもとに,D.E.KnuthとV.R.Prattの2人 が,実用になる文字列探索アルゴリズムを得ることに成功しました。
また,彼 らとは独立して,J.H.Morrisがテキストエディタを作成する過程でほぼ同じ アルゴリズムを発見しています。
このアルゴリズムは3人(Knuth,Morris, Pratt)の名前をとってKMP法
と呼ばれます。
KMP法の計算量はO(n)になります。また,1977年にR.S.BoyerとJ.S.Mooreが,より高速なアルゴリズムを発 表しています。
このアルゴリズムは,2人の名前をとってBM法と呼ばれます。 BM法は,最悪の場合でも
O(n),平均的な場合(文字の種類が多く,パター ンがあまり長くない)にはO
(n/m)の計算量です。実用上の見地からすれば,KMP法よりもBM法のほうが重要です。
なぜな ら,KMP法は最悪でもO(n)に収まるとはいえ,力まかせ法よりも処理が複 雑なために定数項部分が大きくなり,結局メリットが相殺されてしまうからで す。
これに対して,BM法は,パターンとテキストを1回比較することによって, パターンを2文字以上ずらすことができます。
そのために,平均すると文字の 比較の回数が,KMP法や力まかせ法に比べて数分の1ですみます。
ですから, BM法のほうが実用性が高いということができます。Knuth-Morris-Prattのアルゴリズム
KMP法の原理
カまかせのアルゴリズムでは,テキストとパターンが一致しなかった場合, パターンを1文字分ずらして,再びパターンの先頭から比較を行っていきます。
つまり,途中までの比較で得られた情報を捨ててしまっているわけです。
そこ で,この情報を活用して,パターンの何文字目までがテキストに一致したかに 応じて,パターンをずらす分量を決めることを考えましょう。
まず,前処理として,パターンに含まれる各文字について,その文字で不一 致になったときにパターンをどれだけずらせばよいかを調べて表にしておきま す。
そして,探索を行うときには,この表をもとにパターンをずらしていくと いうのがKMP法の基本的な考え方です。
例として,tartarという6文字のパターンを探索することを考えてみましょ う。1文字目で失敗した場合には,パターンを1つ右にずらして,テキスト上 の次の文字から比較を行います。このようすを右図(1)に示します。ここ で,テキスト中の'?'という文字はパターンと一致しない文字を表しています。 また,テキストを指している矢印は,現在注目している文字を表すポインタで す。ここでは,ポインタを1つ進めて,パターンを1つずらして,再ぴ先頭か ら比較することになります。
文字列検索(直感的な文字列検索とKMP法)
