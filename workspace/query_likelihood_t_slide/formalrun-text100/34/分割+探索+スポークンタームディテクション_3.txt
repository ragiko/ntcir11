【0001】【発明の属する技術分野】本発明は、デジタル放送システムによって提供される情報サービスを利用するためのアプリケーションのインターフェースに関する。特に、本発明は、放送システムにおける受信機を制御するとともに、放送信号のチャンネルで搬送されるコンテンツへのアクセスを提供するアプリケーションプログラミングのインターフェース装置(以下、APIと称する)に関する。
【0002】【従来の技術】以下、本発明の背景について、DAB規格「無線放送システム:移動、携帯及び固定受信機に対するデジタル音声放送(DAB)(Radio broadcasting systems: Digital Audio Broadcasting (DAB) to mobile, portable, and fixed receivers)」、ETSI, ETS 300 401, 1997年5月、第2版を例として説明する。DAB規格は、送信側から任意数の受信側への種々の情報サービスの送信をサポートするデジタル放送システムを実現するための国際規格である。この情報サービスの例としては、オーディオストリームアプリケーション、ビデオストリームアプリケーション、ハイパーテキストアプリケーション、画像又はテキストスライドショーアプリケーション、ニュースティッカアプリケーション、Javaベースアプリケーション等がある。【0003】1つのDAB放送信号によって、約1.5Mbit/sの速度で伝送されている情報に同時にアクセスすることができる。このような信号はアンサンブルと呼ばれる。1つのDAB受信機は、同じ位置において2以上のアンサンブルを受信することができるが、一度には1つしか受信することができない。各アンサンブルは、1つのサービスのみ又は多数のサービスを有するDAB信号を表している。アンサンブルは、異なる種類のアプリケーションを有するサービスを組み合わせることができる。一般的な例として、幾つかのラジオ局(オーディオストリームアプリケーション)と、ハイパーテキストアプリケーション又はスライドショーとして提供される気象、金融、イベント、ニュース等の情報サービスとにアクセスするアンサンブルがある。一般的に、これらの全てのサービスは、同一のアンサンブルに属しているときは、同時にアクセスすることができる。【0004】図15は、放送のソース信号の1タイムフレームの一般的な構造を示すフォーマットである。このタイムフレームは、ある周期、例えば24msで繰り返される。タイムフレームは、同期チャンネル1、サービス情報チャンネル2、所定数(N)のサービスチャンネル3(サービス#1〜#N)によって構成される。デジタル放送システムの受信機は、同期チャンネル1を用いて信号の同期をとる。サービス情報チャンネル2は、利用可能なサービスの数、これらのサービスによって提供される情報の種類、これらのサービスへのアクセス方法についての情報を提供する。各サービスチャンネル3は、サービスデータを提供する。通常、これらのデータは、データ放送に適したフォーマットに符号化されている。【0005】DABシステムは、固定、携帯、移動の各環境において受信できるように設計されている。特に、移動環境では、受信状態が刻々変化する。受信品質は、受信障害のない状態、時折受信障害が発生する状態、全く受信できない状態等の様々である。ハードウェア又はソフトウェアのアプリケーションは、これらの様々な状態に対応しなければならない。受信障害は、移動環境においては一般的に発生し、その障害がユーザに感知されないようにしなければならない。各受信障害をエラーとして取り扱うのは適切ではない。したがって、アプリケーションには、受信状態に適切に対応できるように、受信状態を監視する手法を設ける必要がある。【0006】双方向通信環境では、クライアントがある情報を要求する。配信される情報は、クライアントとサーバ間の現在のコンテキストの状態によって識別される。一方、一方向放送環境では、多数のクライアントのための情報が伝送される。したがって、データは、関係がある情報のみを抽出するために、自己記述的でなければならない。この情報は、全体としてサービスに関するものであれば、一般的にサービス情報チャンネル2で配信され、各サービスの情報オブジェクトのいずれかに関するものであれば、サービスチャンネル3のうちの1つで配信される。各サービスチャンネル3は、配信される情報に対してシステム固有のフォーマットを用いる。
【0008】【課題を解決するための手段】本発明の目的は、請求項1に記載するアプリケーションプログラミングのインターフェース装置及び請求項31に記載するクライアントによって達成することができ、その好適な実施例については、それぞれ従属する請求項に定義される。【0009】本発明を適用したAPI及びクライアントは、一方向放送受信機のクライアント/放送受信機インターフェースに対して双方向通信環境の機能を実現する。これは、クライアントが、APIの全機能を定義するAPIの独自要求サブインターフェースを介してAPIに要求を送ることができ、また、APIが、APIによって定義される確認通知サブインターフェースを介して、要求された情報を含むことが可能な確認及び/又は通知メッセージをクライアントに送ることができるからである。【0010】サービスのアクセス構造は、提供されるサービスの種類によって異なる。ラジオ番組等のオーディオストリームを有するサービスの場合、送信されるデータは全て、アプリケーションに受信及び供給されて処理されなければならない。ユーザが情報オブジェクト(例えば、ハイパーテキスト)のセットを自由にナビゲートするようなアプリケーションの場合、全ての情報が周期的に放送され、要求された情報のみが放送から抽出される。典型的なデータの流れを図16に示す。図16では、ある文書、すなわち、default.html、pic1.jpg、xyz.html、pic2.jpg、News.html、abc.htmlが周期的に放送される。一連の画像又はテキストをユーザに提供するスライドショーアプリケーションの場合、受信障害に対処するため、情報を提供すべきときに送信するか、あるいは、予め何度か情報を送信しておく。これらの場合、アプリケーション処理に対するサポートが与えられれば、アプリケーションプログラマ又は設計者が行う作業は簡単になる。【0011】ハイパーテキストアプリケーションでは、あるHTMLページを参照するリンクがクリックされた後に、このページの要求がAPIに与えられる。本発明を適用したAPIの基礎となるシステムは、このページに対するフィルタを設定し、それが放送されるまで聴く。受信後は、このページはアプリケーションに提供される。受信後に要求を取り消してもよく、APIは、放送を聴いて要求されたページの更新をアプリケーションに通知することができる。APIによって供給されるこのアプリケーション処理サポートは、2以上のアプリケーションが同時にサービスにアクセスしているときや、キャッシュを考慮するときに特に有用である。後者の場合、アクセス時間を改善するため、受信したオブジェクトのコピーを記憶するためにメモリが使用される。したがって、基礎となるAPIがサービスのアクセスを提供すれば、アプリケーションにとっては得である。【0012】本発明は、放送システムによって提供される情報にアクセスするためのアプリケーションプログラミングのインターフェース装置を提供することがわかる。これは、いわゆるハイレベルAPIであり、コマンドとして表す概念がアプリケーションプログラマ又は設計者のニーズを反映するようにされたものである。この分野のアプリケーションプログラマ又は設計者の作業は、情報サービスを魅力的なものとして提供することである。このため、アプリケーションプログラマ又は設計者は、不要なシステム固有の詳細事項に関心を持たない。本発明によれば、ハイレベルAPIによって双方向通信環境が形成されるので、アプリケーションの開発時間が改善され、第三者によるアプリケーション形成の許容が増す。【0013】さらに、APIは、放送システムによって提供される情報サービスへのアクセスの全ての面を含む。すなわち、放送媒体及び提供されるサービスのコンテンツ自体へのアクセスを得るのに必要なデジタル放送システムの受信機を制御する。【0014】放送システムでは、クライアントは送信装置において必要な情報を要求しない。その代わり、受信機で何が放送されるか聴き、所望の情報を抽出する必要がある。一般に、放送信号の構成はいつでも変化する可能性があり、情報オブジェクトへのアクセス時間は、双方向通信に基づく情報システムにおけるよりも大きく変化する可能性がある。これらの要件は、放送システム固有のものである。本発明を適用したAPIによって、これらの詳細事項はアプリケーションプログラマにとって問題とはならず、異なる提供フォーマットでの情報サービスの処理をサポートする。本発明を適用したAPIに接続されたクライアントは、必要な情報を要求することができ、この情報が利用可能になると直ちに要求しているクライアントに提供される。APIのインターフェースは、アプリケーションプログラムとAPIによって制御される放送システムとの高度のシステム始動通信に非常に良く合致する非同期メッセージ通信に基づくものである。【0015】APIは、幾つかのクライアントに対するサポートを同時に提供する。すなわち、2以上のクライアントがAPIのサービスを使用することによって、リソースを共有することができる。【0016】以下の本発明の詳細な説明では、本発明を適用したAPIがAPIの機能に関して非常に記述的であるC/C++言語ソリューションで実現されるようなDAB受信機を用いて説明を行う。勿論、本発明は、他の放送システムに適用することもでき、例えばAPIのハードウェアソリューション等の他のソリューションを有することもできる。【0017】例におけるデジタル放送システムの受信機の制御の機能的分解は、以下のようになる。すなわち、放送ソースの選択、サービス情報チャンネルへのアクセス、サービスの選択、サービスコンテンツへのアクセス、受信状態の監視である。【0018】デジタル放送システムの受信機の制御は、通信がサービスプロバイダからサービス消費者への一方向のみであることを示す。受信機は、何が放送されるか常に聴き、所望の情報を抽出しなければならない。放送データに変更があれば、放送を聴くことによって検知される。新たなサービスを追加することも、サービスを削除することもできる。あるサービスデータの流れにおけるオブジェクトの追加、削除、更新を行うこともできる。データの流れで放送されるオブジェクトへのアクセス時間は、数ミリ秒〜数分と広範囲で変化する。本発明を適用したAPIでは、これをメッセージベースアプローチによって考える。
【0019】【発明の実施の形態】以下、本発明に係るアプリケーションプログラミングのインターフェース装置及びその使用方法について、図面を参照しながら説明する。図1は、幾つかのアプリケーションプログラムを含む本発明を適用した具体的なモデルを示すブロック図である。【0020】図1に示すように、アプリケーションプログラム4(以下、APIクライアントともいう。)は、API12を用いてユーザに放送情報サービスを提供する。API12自体は、例えばアンテナ14を備えるデジタル放送システム受信機13を介して、受信機制御ブロック18により放送データにアクセスする。API12自体の典型的な構造は以下のようになる。受信機制御ブロック18は、接続されたデジタル放送システム受信機13のローレベル制御を行う。図1では、受信機制御ブロック18とデジタル放送システム受信機13を、何らかの手段で接続された個別のブロックとして示しているが、本発明は、この具体例に限定されるものではない。すなわち、この部分を1つのブロックに統合することもできる。本発明では、受信機制御ブロック18の上方に示されるビルディングブロック5〜11は全て、受信機制御ブロック18によって提供されるサービスに基づくものである。【0021】図1に示す具体例において、API12は、以下のビルディングブロック5〜11を有する。【0022】・クライアント登録ブロック5は、APIクライアントの登録サービスを提供する。API12を使用しようとする各アプリケーションプログラム4は、予めAPIクライアントとして登録する必要がある。登録によって、各APIクライアントは、他のAPIクライアントと識別するために、全ての準逐次コマンド(subsequent command)で使用されるクライアントIDを得る。【0023】・サービスディレクトリブロック6は、1つ以上の放送ソースの利用可能なサービスに関する情報を提供する。【0024】・放送ソース選択ブロック7は、放送ソースを直接選局する、又は放送ソースを検索する手段を提供する。【0025】・サービス選択ブロック8は、サービスを開始又は停止するのに用いられる。【0026】・サービスアクセスブロック9は、サービスのコンテンツにアクセスする手段を提供する。【0027】・受信品質ブロック10は、受信品質を監視する手段を提供する。【0028】・サービススキャンブロック11によって、APIクライアントは、特定の検索領域の全ての利用可能な放送ソースにおける全ての利用可能なサービスを検索することができ、これによって、サービスディレクトリが更新されるとともに、申し込んだ情報に関する変更がAPIクライアントに通知される。【0029】各コマンドは、概して2つ又は3つのメッセージ種類に分類される。要求メッセージ(-)Reqは、APIクライアントによってAPI12に送られ、コマンドの実行が要求される。確認メッセージ(-)Cnfは、API12によってAPIクライアントに送られ、コマンドの実行が確認される。通知メッセージ(-)Ntfは、長期間継続するコマンドの経過について通知するために、又は更新された情報を提供するために、API12によってAPIクライアントに送られる。【0030】各アプリケーションプログラム4は、その必要な情報に関する要求をAPI12の要求サブインターフェース16を介してビルディングブロック5〜11のうちの1つ又は幾つかに送り、ビルディングブロック5〜11のうちの1つ又は幾つかは、それらの情報を確認通知サブインターフェース17を介してアプリケーションプログラム4、すなわちAPIクライアントに提供する。【0031】図2〜図4は、本発明を適用したこれらの3つのメッセージの異なる組合せによって、コマンドが形成されることを示す図である。【0032】図2は、Req-Cnfコマンドのパターンを示す図であり、ステップS1において、要求メッセージがAPI12に送られ、ステップS2において、コマンドが実行され、実行結果を提供する確認メッセージがAPIクライアントに送られる。【0033】図3は、処理に長い時間がかかるコマンドに使用されるReq-Ntf-Cnfコマンドのパターンを示す図である。ステップS3において、要求メッセージがAPI12に送られ、ステップS4〜S6において、コマンドの実行が開始され、この具体例では、経過情報を提供する3つの通知メッセージがAPIクライアントに送られ、ステップS7において、実行結果を提供する確認メッセージがAPIクライアントに送られる。【0034】図4は、申込サービスを提供するコマンドに使用されるReq-Cnf-Ntfコマンドのパターンを示す図である。この場合、ステップS8において、ある情報、例えば受信品質の配信を申し込む要求メッセージがAPI12に送られる。ステップS9において、API12から、申込を確認する確認メッセージが、要求しているAPIクライアントに送られる。ステップS10〜S12において、要求された情報自体が与えられた通知メッセージ、この具体例では3つの通知メッセージが送られる。すなわち、現在の状態を報告する通知メッセージが最初に送られ、申し込んだ情報が変更される毎に、通知メッセージが必ず送られる。この申込サービスは、他のコマンド実行によって取り消されるまで継続される。なお、現在の状態のみを要求し、必要ではないときは更新を要求しないようにしてもよい。この場合、申込サービスは、関連する通知メッセージによって、要求された情報の配信とともに自動的に取り消される。【0035】本明細書で用いるメッセージという用語は、アプリケーションプログラマ又は設計者に全体として利益を与えるコマンド及びコマンドの実行と区別する必要がある。コマンドの実行は、非同期インターフェース手段を得るために、API12とAPIクライアント間で送られる幾つかのメッセージに分割される。これによって、コマンドを同時に実行することができ、APIクライアントは、長期間継続するコマンドを実行するときに阻止されることはない。これは、デジタル放送システム受信機13の上述した特徴に合致する。メッセージという用語を用いることによって、本発明の範囲を、API12とAPIクライアントをメッセージシステムによって接続した具体例に限定するものではない。【0036】図5は、以下、本発明の説明に用いるAPI12とAPIクライアント15をインターフェースさせる適切なモデルを示す図である。インターフェースは、API12によって定義されるが、要求インターフェース16は、API12内に設けられ、確認通知インターフェース17は、APIクライアント15に設けられる。以下の実施例では、機能エントリポイントを有するインターフェースとして各インターフェースを実現している。すなわち、メッセージ毎に1つの機能が設けられ、APIクライアント15によって要求メッセージのために呼び出されるとともに、API12によって確認及び通知メッセージのために呼び出される。【0037】以下のAPIの説明は、記述的C/C++プログラム言語(descriptive c/c++ program language)で表記するが、これは、本発明の範囲を限定するものではない。上述のように、Java、パスカル、ベーシック等の他のプログラミング言語や、ハードウェアソリューションを用いることもできる。【0038】説明では、以下に示すAPI表記(convention)を適用する。【0039】接尾辞としての大文字Eは、列挙型(enumeration type)を表す。列挙型によって、異なる定数値についての幾つかのシンボル名(symbolic name)を定義することができる。【0040】接尾辞としての大文字Tは、データタイプを表す。データタイプ(data type)は、変数の値のみを記憶する手段を有するタイプ、又はある処理を行う機能をさらに含むタイプである。【0041】接尾辞としての大文字PTは、データタイプについてのポインタを表す。【0042】あるデータタイプの変数は、そのデータタイプを示すために接頭辞を有している。小文字eは、列挙型の変数を表す。小文字bは、タイプブール(type bool)の変数を表す。本発明のドメイン(domain)に関して定義される他のデータタイプを、小文字tで表す。機能シグネチャ(function signature)における形式パラメータ(formal parameter)として用いられる変数は、下線が付された第1文字(first character)を有する。【0043】以下の基本データ構造は、APIを介して用いられるものである。【0044】ResultE:コマンド実行状態が報告されるときに必ず使用される。この種類のマッピングは、API12が用いられる基本システムによって異なる。概して、列挙型として用いられ、異なる定数値について幾つかのシンボル名を定義することができる。各値は、別のコマンド実行状態を表す。共通の値のセットを以下のように定義する。【0045】resOK:コマンドの実行は成功した。【0046】resInvalidParameter:無効パラメータのためにコマンドは実行できなかった。【0047】resNonApplicableFunction:現在の状態ではコマンドは実行できない。【0048】これらは、単に基本的なエラーコードのセットの具体例である。放送情報システムでは、このセットを、何ら発明的技術を用いずに、システムの能力に応じてより詳細なエラーコードによって、容易に拡張することができる。【0049】ClientIdT:APIクライアント15のIDのデータタイプとして使用される。このデータタイプの内部構造は、実際の実現方法に依存する。このデータタイプは、API12の基本システムによって定義される。各APIクライアント15は、API12と接続するときにこのデータタイプのIDを取得して、全ての準逐次コマンドに対して異なるAPIクライアント15を識別するのに用いられる。【0050】ServiceIdT:放送情報サービスのIDのデータタイプとして使用される。このデータタイプの内部構造は、実際の実現方法に依存する。このデータタイプは、API12の基本システムによって定義される。サービスは、サービスディレクトリブロック6によって提供されるサービスディレクトリによって、サービスID及び他の属性とともに報告される。APIクライアント15は、サービスIDを用いてサービスに対する情報を得て、サービスの開始又は停止を行う。【0051】ObjectIdT:例えば、ハイパーテキストページ、イメージ等の情報オブジェクトのIDのデータタイプとして使用される。このデータタイプの内部構造は、実際の実現方法に依存する。このデータタイプは、API12の基本システムによって定義される。オブジェクトIDは、APIクライアント15によってオブジェクトの提供を要求したり、提供されたオブジェクトを識別するのに使用される。【0052】ObjectT:ある情報オブジェクトのコンテンツや、ある画像の有効期限又はテキスト記述等のオブジェクトに関する追加的な属性にアクセスするデータタイプとして使用される。このデータタイプの内部構造は、実際の実現方法に依存する。このデータタイプは、API12の基本システムによって定義される。各オブジェクトはオブジェクトIDによって識別される。【0053】bool:値を真及び偽とすることができる演算データタイプ(boolean data type)。【0054】以下の機能シグネチャにおけるパラメータの中には、イタリック体で記述されるものがある。これらのパラメータは、API12の基本システムと強い関連がある。すなわち、これらのデータタイプの詳細な定義は、基本システムに強く依存し、この記述では定義できない。ある放送システムがビットエラーレートを監視する手段を提供し、他のシステムが同期状態を監視する手段を提供し、さらに他のシステムがこれらの組合せ又は他のパラメータを監視する手段を提供することがある。システム専用の要件をマップする適切な方法は、1又は2以上のパラメータを使用することである。このような場合、正確なデータタイプの定義を付ける必要性があることを示すために、あるパラメータをイタリック体で記述する。当該技術分野の技術者にとっては、本発明の主旨を逸脱しない範囲でコマンドメッセージの定義を変更してもよいことは明らかである。【0055】以下の具体例は、要求インターフェース16と確認インターフェース17のインターフェースの定義を示すものでる。【0056】【表1】【0057】【表2】【0058】【表3】【0059】【表4】【0060】【表5】【0061】【表6】【0062】【表7】【0063】APIクライアント15とAPI12の2つのインスタンス(instance)は、これらのインターフェースを介して接続される。すなわち、API12は、要求インターフェース16を実現し、APIクライアント15は、この要求インターフェース16用い、要求インターフェース16のインターフェース機能を呼び出すことによってAPI12に要求メッセージを送る。APIクライアント15は、確認インターフェース17を実現し、API12は、確認インターフェース17を用い、確認通知インターフェース17のインターフェース機能を呼び出すことによってAPIクライアント15に確認及び通知メッセージを送る。【0064】以下、全てのコマンド及びメッセージの機能について詳細に説明する。コマンドとメッセージを使用する典型的な例を、メッセージシーケンスチャートに示す。なお、これらのチャートは、誤動作を考慮していない単純なシナリオを示すものである。記述したコンテキストにおいて重要なパラメータのみを列挙する。【0065】クライアント登録API12を使用しようとするアプリケーションプログラムはいずれも、図6に示すように、他のコマンドを実行する前にAPIクライアント15としてAPI12に接続する必要があり、また、APIコマンドの使用が終わると切断する必要がある。このような登録及び切断は、クライアント登録ブロック5を介して行われる。Openコマンドは、APIクライアント15を登録し、必要な全てのリソースを割り当て、全ての準逐次コマンドに使用されるクライアントIDを与える。IDは、2つ以上のAPIクライアント15が同時にAPI12を用いる場合に必要である。Openコマンドは、OpenReq及びOpenCnfメッセージによって構成される。Closeコマンドは、動作している全てのサービスを停止し、呼出を行っているAPIクライアント15のために取得されたリソースを解放し、APIクライアント15とAPI12を切り離す。また、APIコマンドを実行するためには、Openコマンドを予め実行する必要がある。Closeコマンドは、CloseReq及びCloseCnfメッセージによって構成される。APIクライアント15は、OpenコマンドとCloseコマンドの間に、API12を介してデジタル放送システム受信機13の制御を行うか、あるいは単に提供されるサービスを「聴く」、すなわちコマンドを実行することができる。【0066】Open及びCloseコマンドメッセージ機能のインターフェースは、以下のように定義される。【0067】【表8】【0068】まず、接続を開くために、ステップS40において、APIクライアント15は、OpenReqメッセージをAPI12に送り、APIクライアント15の確認通知インターフェース17に対するポインタ(_ptInterface)が与えられる。API12は、APIクライアント15とAPI12間の通信で発生する全ての確認及び通知メッセージを、この確認通知インターフェース17に送る。【0069】その後、ステップS41において、API12は、Openコマンドの処理を報告するOpenCnfメッセージをAPIクライアント15に送る。パラメータ_eResultは、接続を確立することができたか否かを示す。値がresOKであるときは、接続が確立され、パラメータ_tClientIdによって、全ての準逐次コマンドに使用される有効IDが与えられる。パラメータ_eResultによって報告される値が他の値であるときは、常にOpenコマンドは失敗し、接続は確立されない。この場合、パラメータ_tClientIdは、有効な値を有しない。【0070】そして、コマンドが実行された後、APIクライアント15がAPIコマンドの使用を終了すると、ステップS42において、APIクライアント15は、CloseReqメッセージをAPI12に送って、接続を閉じる。このメッセージの唯一のパラメータは、呼出を行っているAPIクライアント15を識別するためのクライアントIDである。そして、ステップS43において、API12は、CloseCnfメッセージをAPIクライアント15に送ることによって、Closeコマンドの処理を報告する。パラメータ_tClientIdは、送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKであるときは接続が閉じられ、そうでないときはエラーが発生している。【0071】放送ソースの選択デジタル放送システム受信機13によって提供されるコンテンツにアクセスするために、APIクライアント15は、放送ソース選択ブロック7を介して放送ソースを選択する。概して、放送ソースは直接選択することができるか、あるいはデジタル放送システム受信機13が放送ソースを自動的に検索する何らかの手段を有している。したがって、2つのコマンドが設けられている。【0072】Tuneコマンドは、放送ソースを直接選択するためのものである。APIクライアント15は、どこに放送ソースが位置するか知っており、必要なパラメータは、全てAPIクライアント15によって与えられるものとする。Tuneコマンドは、図7に示すように、TuneReq及びTuneCnfメッセージ機能によって構成される。【0073】Searchコマンドは、放送ソースを検索するためのものである。検索方法は、例えば周波数範囲、周波数ステップ、方向等であり、APIクライアント15によって特定することができ、あるいはAPI12によって自動的に行われる。検索は長時間かかるものと考えられる。したがって、検索が継続している限り経過情報が提供される。Searchコマンドは、図8に示すように、SearchReq、SearchNtf、SearchCnfメッセージ機能によって構成される。【0074】Tune及びSearchコマンドメッセージ機能のインターフェースは、以下のように定義される。【0075】【表9】【0076】図7に示すように、ステップS50において、APIクライアント15は、Tuneコマンドを開始するために、TuneReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。放送ソースは、1又は幾つかのパラメータ(BroadcastSource)によって特定される。API12によるメッセージの受信後、特定された放送ソースへの同調(選局)が開始される。選局が行われた後、現在の受信品質が検出される。そして、ステップS51において、API12からAPIクライアント15へのTuneCnfメッセージによって、コマンドの処理結果が報告される。これは、送信先のクライアント(_tClientId)を識別し、処理結果(_eResult)を示す。処理が成功したときは、パラメータ_eResultはresOKという値を示すが、そうでないときはエラーが発生している。処理結果とは独立して、現在選択されている放送ソース(CurrentBroadcastSource)及び現在の受信品質(ReceptionQuality)が報告される。【0077】図8に示すように、ステップS60において、APIクライアント15は、Searchコマンドを開始するため、SearchReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。検索方法は。1つ以上のパラメータ(SearchMethod)によって特定される。検索には長時間がかかるので、APIクライアント15検索動作中に経過情報を要求することもある。このため、パラメータNotificationsによって、例えば各周波数ステップ等の所望の通知の種類を特定することができるようになっている。【0078】その後、ステップS61〜S63において、API12は、SearchNtfメッセージを用いて、経過情報をAPIクライアント15に供給する。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。経過情報は、1つ以上のパラメータ(ProgressInfo)として供給される。ステップS61において、最初に供給される通知は、検索が開始されたことを示している。通知される他のイベントは、API12の基本システムによって異なる。【0079】そして、ステップS64において、API12は、SearchCnfメッセージをAPIクライアント15に送ることによって、検索コマンド処理の完了を報告する。パラメータ_tClientIdは、送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合、コマンドが成功し、放送ソースが見つかっている。そうでない場合は、エラーが発生している。いずれの場合も、現在選択されている放送ソース(CurrentBroadcastSource)及び現在の受信品質(ReceptionQuality)が報告される。【0080】放送ソースの選択とともに、APIクライアント15は、この放送ソースに属する全ての情報サービスにアクセスする。別の放送ソースの情報サービスにアクセスするには、他の放送ソースを予め選択していなければならない。【0081】受信状態の監視受信状態を監視しようとするAPIクライアント15は、受信品質ブロック10内で実現されるSelectReceptionInfoコマンドを使用する。SelectReceptionInfoコマンドは、図9に示すように、SelectReceptionInfoReq、SelectReceptionInfoCnf、ReceptionInfoNtfメッセージによって構成される。SelectReceptionInfoコマンドは、受信状態に関する状態変化の申込サービスを提供する。すなわち、SelectReceptionInfoReq及びSelectReceptionInfoCnfメッセージを用いてこのサービスを申し込むAPIクライアント15は、APIクライアント15によって申込が取り消されるまで、受信状態が変化するたびに通知メッセージReceptionInfNtfを受ける。なお、現在の受信状態の報告を一回だけ要求することも可能である。【0082】SelectReceptionInfoコマンドメッセージ機能のインターフェースは、以下のように定義される。【0083】【表10】【0084】先ず、受信品質の通知を申し込むために、ステップS70において、APIクライアント15は、SelectReceptionInfoコマンドを開始するためにSelectReceptionInfoReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。監視される情報の種類は、例えば同期状態、ビットエラーレート、その他の基本システムのための適切なパラメータのセット等であり、パラメータReceptionInfoSelectionによって特定される。監視するために、与えられた全てのパラメータあるいは1つのサブセットのみを選択することも、何も選択しないことも可能である。パラメータ_bNoSubscriptionは、情報がAPIクライアント15に一回だけ供給されるか否か、又は選択されたパラメータのうちの1つにおける各状態変化が報告される申込サービスが開始されるか否かを特定する。申込サービスは、初めて監視する幾つかのパラメータを選択することによって開始される。また、申込サービスは、与えられたパラメータのうちの1つも選択しないことによって停止される。監視するパラメータのセットを変更することも可能である。【0085】その後、ステップS71において、API12は、SelectReceptionInfoCnfメッセージをAPIクライアント15に送ることによって要求を確認する。パラメータ_tClientIdは、送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKであるときは、コマンドは成功であり、そうでないときはエラーが発生している。受信状態を監視するための現在の選択は、パラメータCurrentReceptionInfoSelectionによって報告される。監視を行うために、与えられたパラメータの幾つかを選択するとき、要求された情報が1つのReceptionInfoNtfメッセージとして続く。パラメータ_bNoSubscriptionを真に設定することによって情報を一回だけ要求したときは、その後には他のReceptionInfoNtfメッセージは続かない。パラメータ_bNoSubscriptionを偽に設定することによって申込サービスを開始したとき、選択されたパラメータのうちのいずれか1つの状態変化がReceptionInfoNtfメッセージによって報告される。【0086】以下、ステップS72及びS73において、APIクライアント15に受信品質の変化を知らせ続けるために、API12によってReceptionInfoNtfメッセージがAPIクライアント15に送られる。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。ReceptionInfoNtfメッセージは、先に監視するために選択したパラメータのうちの1つ以上のパラメータの状態変化について報告する。パラメータReceptionInfoSelectorは、どのパラメータが更新されているのかを示す。更新された値自体は、パラメータReceptionInfoによって与えられる。申込サービスの場合、選択された全てのパラメータの初期状態が、最初のReceptionInfoNtfメッセージによって送られる。それ以降の全てのReceptionInfoメッセージは、選択されたパラメータの状態変化についての情報を提供する。一回のみの要求の場合、選択された全てのパラメータの現在の状態が、最初のReceptionInfoNtfメッセージのみで送られる。【0087】そして、申込を停止するために、ステップS74において、APIクライアント15は、SelectReceptionInfoReqメッセージをAPI12に送り、ステップS75において、このSelectReceptionInfoReqメッセージは、SelectReceptionInfoCnfメッセージをAPIクライアント15に送ることによって確認される。これら両メッセージのパラメータは、上述のようにステップS70及びS71における場合と同様に定義される。【0088】サービスディレクトリへのアクセスサービスディレクトリブロック6によって提供されるサービスディレクトリは、現在の又は他の放送ソースに属する全ての既知のサービスについての情報を提供するためのものである。この情報がどの程度信頼性があるかは、基本システムの方針(strategy)によって異なる。利用可能なサービスについての情報は放送ソース信号で送信されるが、一時的な受信障害やオフライン作業により、サービスディレクトリブロック6によって提供されるサービスディレクトリが常に最新なものとは限らない。しかし、デジタル放送システム受信機13が接続されると直ちに、情報が更新され、接続された各クライアント4に変更が通知される。また、放送ソース受信機が1つである基本システムでは、他の放送ソースで発生する変化を監視することはできない。この情報が次に更新されるのは、この放送ソースにアクセスしたとき、又はScanコマンドを実行したときである。サービスディレクトリブロック6によって提供されるサービスディレクトリへのアクセスは、サービスディレクトリの動的性質に合うように離散的に行われる。これは、情報が通知メッセージとしてばらばらにAPIクライアント15に供給されるSelectServiceInfoコマンドの使用による申込サービスとして設計されている。例えば、新たなサービスが利用可能である場合、そのサービスの存在及び属性がAPIクライアント15に報告される。スタートアップの直後、サービスディレクトリブロック6によって提供されるサービスディレクトリのコンテンツが、上述の通知メッセージ上にマップされ、その後の変更については同様に報告される。SelectServiceInfoコマンドは、図10に示すように、SelectServiceInfoReqメッセージ、SelectServiceInfoCnfメッセージ、ServiceInfoNtfメッセージによって構成される。【0089】SelectServiceInfoコマンドメッセージ機能のインターフェースは、以下のように定義される。【0090】【表11】【0091】サービスディレクトリ情報を申し込むために、ステップS80において、APIクライアント15はSelectServiceInfoコマンドを開始するためのSelectServiceInfoReqメッセージをAPI12に送る。SelectServiceInfoコマンドは、サービスディレクトリブロック6によって提供されるサービスディレクトリにおける変化に対して、申込サービスの開始、停止、変更を行う。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。サービスディレクトリブロック6によって提供されるサービスディレクトリは、例えばオーディオストリームアプリケーションを有するサービスや、スライドショー等のデータサービスを有するサービス等であり、異なるカテゴリーの情報を提供することもできる。したがって、APIクライアント15は、パラメータServiceInfoSelectionを用いて、関心のある情報の種類をカスタマイズすることができる。サポートしなければならない最小セットのイベントは、dscServiceElementAdded、dscServiceElementRemoved、dscServiceElementChangedである。dscServiceElementAddedの値は、新たなサービスエレメントが利用可能であることを示す。dscServiceElementRemovedの値は、サービスエレメントが除去されているので利用不可能であることを示す。dscServiceElementChangedの値は、サービスエレメントの属性が変化したこと、例えば、あるサービスを記述するテキスト情報、又は、あるサービスによって提供される現在のコンテンツの種類を記述する情報が、コンテンツとともに変更されていることを示す。後者の場合、ServiceInfoNtfメッセージのパラメータServiceUpdateが、その変更についてより詳細に通知する。パラメータServiceInfoSelectionによってどのイベントが特定されるかに応じて、API12は、これらのイベントに関連するServiceInfoNtfメッセージを送る。最後のパラメータ_bAutoDeliveryは、サービスディレクトリブロック6によって提供されるサービスディレクトリにおける変化が、APIクライアント15に通知されているか(偽に設定)、あるいは、変更された情報自体も変更通知とともに供給されているか(真に設定)を特定する。【0092】その後、ステップS81において、API12は、SelectServiceInfoコマンドの処理を確認するために、SelectServiceInfoCnfメッセージをAPIクライアント15に送る。パラメータ_tClientIdは送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合はコマンドが成功し、そうでない場合はエラーが発生している。パラメータCurrentServiceInfoSelectionは、サービスディレクトリにおける変化に対する現在の申込レベルを示す。パラメータ_bAutoDeliveryは、サービスディレクトリのあるエレメントに対する変化が報告されているか(偽に設定)、あるいは、変更された情報自体も供給されているか(真に設定)を示す。申込サービスが開始されると、サービスディレクトリブロック6によって提供されるサービスディレクトリに知られている全ての情報が、ServiceInfoNtfメッセージとして供給される。【0093】利用可能なサービスをAPIクライアント15に通知し続けるため、ステップS82〜S87において、API12によってServiceInfoNtfメッセージがAPIクライアント15に送られる。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。申込サービスの開始直後、APIクライアント15による選択と一致するサービスディレクトリの完全なコンテンツがServiceInfoNtfメッセージ上にマップされ、APIクライアント15に供給される。その後、ServiceInfoNtfメッセージを送ることによって、サービスディレクトリに対する変更のみが報告される。パラメータ_tServiceIdは、サービスディレクトリブロック6によって提供される変更されたサービスディレクトリのサービスエレメントを識別するためのものである。パラメータServiceInfoSelectorは、この通知の理由となるイベントを特定する。サポートされるイベントセットは、API12の基本システムによって異なるが、少なくとも上述のイベントdscServiceElementAdded、dscServiceElementRemoved、dscServiceElementChangedをサポートする必要がある。パラメータServiceUpdateは、dscServiceElementAddedのイベントの場合、サービスエレメントのうちのどのオプショナル部分について知られているかを示し、dscServiceElementChangedのイベントの場合、サービスエレメントのうちのどの部分が変化したかを示す。パラメータServiceInfoObjectは、変更された情報オブジェクト自体を有する。これは、SelectServiceInfoReqメッセージにおけるパラメータ_bAutoDeliveryを特定することによって申込サービスがこのモードで設定されている場合のみ、供給される。そうでない場合、情報オブジェクトを取得するために追加コマンドを実行しなければならない。【0094】このため、コマンドGetServiceInfoが設けられている。これは、GetServiceInfoReqメッセージとGetServiceInfoCnfメッセージによって構成される。【0095】GetServiceInfoコマンドメッセージ機能のインターフェースは、以下のように定義される。【0096】【表12】【0097】APIクライアント15は、GetServiceInfoコマンドを開始するためにGetServiceInfoReqメッセージをAPI12に送る。GetServiceInfoコマンドは、特定されたサービスエレメントについての情報の提供を要求する。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。サービスエレメントは、パラメータ_tServiceIdによって識別される。【0098】API12は、GetServiceInfoCnfメッセージをAPIクライアント15に送ることによって要求を確認する。パラメータ_tClientIdは送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合、コマンドは成功であり、そうでない場合はエラーが発生している。パラメータServiceInfoObjectは、要求された、サービスエレメントを表す情報オブジェクトを有する。このオブジェクトの完全な定義は、API12を介してアクセスされる基本システムによって異なる。【0099】そして、申込を停止するため、ステップS88において、APIクライアント15は、SelectServiceInfoReqメッセージをAPI12に送り、これが、ステップS89において、API12からSelectServiceInfoCnfメッセージをAPIクライアント15に送ることによって、確認される。これら両メッセージのパラメータは、上述のように、ステップS80及びS81における場合と同様に定義される。【0100】サービスの選択サービスのコンテンツにアクセスするには、予めサービスを開始しておく必要がある。API12の基本システムのサービス選択ブロック8は、必要とされるリソースを割り当て、このサービスで何が放送されるのか聴取を開始する。要求されたオブジェクトのAPIクライアント15によるアクセス時間を改善するため、放送オブジェクトをメモリに記憶するキャッシュ技術を用いてもよい。【0101】APIクライアント15は、SelectServiceコマンドを用いてサービスの開始又は停止を行う。SelectServiceコマンドは、図11に示すように、SelectServiceReqメッセージ、SelectServiceCnfメッセージ、ServiceInfoNtfメッセージによって構成される。各サービスは、そのサービスIDによって識別される。APIクライアント15は、サービスディレクトリブロック6によって提供されるサービスディレクトリにアクセスすることによって、サービスについて知る。サービスの開始及び停止に加えて、1コマンドで現在動作している全てのサービスを停止させるとともに新たなサービスを開始することもサポートされる。放送システムでは、サービスを終了することは常に可能である。これは、ServiceInfoNtfメッセージによってAPIクライアント15に知らされる。すなわち、サービスの終了が報告され、サービスが現在選択されている場合、関連するServiceInfoNtfメッセージの供給とともに自動的に停止する。【0102】SelectServiceコマンドメッセージ機能のインターフェースは、以下のように定義される。【0103】【表13】【0104】サービスを開始するのに、ステップS90において、APIクライアント15は、SelectServiceコマンドを開始するためにSelectServiceReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。サービスは、パラメータ_tServiceIdによって識別される。パラメータ_eSelectionModeは、特定されたサービスの選択モードを特定する。以下のモードがサポートされる。dscReplaceの値は、現在動作している全てのサービスを停止させ、パラメータ_tServiceIdによって特定されるサービスを開始する。dscAddの値は、パラメータ_tServiceIdによって特定されるサービスを開始し、現在開始されている全てのサービスについてはそのままにしておく。dscRemoveの値は、パラメータ_tServiceIdによって特定されるサービスのみを停止させる。dscRemoveAllの値は、開始された全てのサービスを停止させる。この最後の場合、パラメータ_tServiceIdは意味を持たない。【0105】そして、ステップS91において、API12は、SelectServiceCnfメッセージを送ることによってコマンドの処理を確認する。パラメータ_tClientIdは送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合、コマンドは成功であり、そうでない場合はエラーが発生している。パラメータ_tServiceIdは、パラメータ_eSelectionModeによって特定される選択モードに従って選択されたサービスを識別するためのものである。パラメータ_eSelectionModeの意味は、SelectServiceReqメッセージで使用するのと同じである。【0106】サービスのアクセス中、開始したサービスを放送から除去する場合、図10に示すステップS82〜S87に関して説明したように、API12からAPIクライアント15にServiceInfoNtfメッセージを送ることによって、この変更がAPIクライアント15に通知される。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。パラメータServiceInfoSelectorは、この場合、dscServiceElementRemovedイベントを示す。サービスエレメントは、パラメータ_tServiceIdによって識別される。dscServiceElementRemovedエレメントが通知されたときは、パラメータServiceInfoObjectは意味を持たない。【0107】そして、サービスを停止するため、ステップS92において、APIクライアント15はSelectServiceInfoReqメッセージをAPI12に送り、これが、ステップS93において、API12からAPIクライアント15にSelectServiceInfoCnfメッセージを送ることによって、確認される。これら両メッセージのパラメータは、上述のステップS90及びS91における場合と同様に定義される。【0108】サービスへのアクセス放送サービスは、幾つかの方法で情報を提供することができる。以下、それら異なる方法について、アプリケーション種類の点から説明する。【0109】ローカルインタラクティブアプリケーション:ローカルインタラクティブアプリケーションは、情報をばらばらに供給する。例えば、ハイパーテキストアプリケーションのユーザは、現在提供されている情報を読み、更なる情報に対するハイパーリンクを追跡することによって、与えられた情報をナビゲートする。各ハイパーテキストページには、テキスト情報、異なるフォーマットのイメージ等の埋込オブジェクト、他のハイパーテキストページや他のフォーマットのオブジェクトへのリンクが含まれている。放送システムでは、これらの情報オブジェクトが周期的に送信される。現在どの情報オブジェクトが必要かは、ユーザインタラクションによって異なる。【0110】オブジェクトの明示的要求を必要とする全てのアプリケーションについて、API12は、サービスアクセスブロック9を用いて、特定された情報オブジェクトの供給を要求するSelectObjectコマンドを与える。これは、SelectServiceコマンドを使用することによって関連するサービスを開始した後に、使用することができる。SelectObjectコマンドは、図13に示すように、SelectObjectReqメッセージ、SelectObjectCnfメッセージ、ObjectNtfメッセージによって構成され、申込サービスを提供する。一回のみの供給を要求することも可能であり、また、更新供給のためにオブジェクトを選択することも可能である。すなわち、オブジェクトは、それがはじめて利用可能となった後に供給され、そのオブジェクトの更新は全て、選択が取り消されるまで追加的に報告される。オブジェクトの選択及び解放に加えて、1コマンドで現在の全ての選択を除去するとともに別の選択を行うことも可能である。別のパラメータによって、完全に受信されたオブジェクトのみが供給されるか、あるいは、部分的に供給されてもよいのかを特定することができる。後者の場合、開始から完全なオブジェクトの既に受信されたデータが全て供給される。最初の供給の後、何回か供給が行われる。供給毎に、供給されるオブジェクトが少しずつ完全になる。別のパラメータは、この情報オブジェクトがアプリケーションにとってどの程度重要かを示す、アプリケーションによるヒントである。【0111】スライドショーアプリケーション:スライドショーアプリケーションは、アプリケーション自体によって予め定義された方法で情報を提供する。例えば、ピクチャスライドショーは、提示時刻が予め決定している一連の画像を提供する。ピクチャスライドショーを実現する簡単な方法は、画像を提示すべき時に放送することである。この場合、追加信号送信は必要ない。より複雑な方法としては、送信エラーに備えるため、提示時刻以前に画像を数回放送する。これによって、提示時刻になる前に提示オブジェクトを適切に受信する可能性が高くなる。【0112】提示時刻が予め決定している全てのアプリケーションについて、API12は、適切な提示時刻においてオブジェクトの復号化、記憶、提示の呼出を行う。上述のアプリケーションを有するサービスが開始した後、提示時刻になると、図12に示すように、提示される各オブジェクトがObjectNtfメッセージとしてAPI12によってAPIクライアント15に供給される。さらに、現在提示されているオブジェクトが提示用として有効でなくなったことを示すため、ObjectNtfメッセージが使用される。【0113】ストリーミングアプリケーション:ストリーミングアプリケーションは、例えばオーディオ又はビデオストリーム等のアプリケーションプログラムによって準備されているデコーダに永続的に供給される連続データストリームである。このアプリケーションを有するサービスが開始された後、時間通りにデータを供給することが重要である。これは、遅れたデータは役に立たないからである。API12は、図12に示すように、ストリーミングアプリケーションに対してスライドショーアプリケーションと同様のアプリケーション処理サポートを提供する。ストリーミングアプリケーションを有するサービスが開始されると、連続データストリームからのデータを包含するバッファを有するObjectNtfメッセージが送られる。このデータは、アプリケーションプログラムのデコーダに供給されなければならない。供給におけるジッタを補償するため、アプリケーションは、ObjectNtfメッセージを記憶するのにファーストインファーストアウトキューを用いてもよい。このキューが所定のメッセージ数まで満たされてはじめて、アプリケーションデコーダが開始する。アプリケーションデコーダは、1メッセージのデータを処理した後、次のメッセージが入る。API12によって供給されるその後のメッセージはいずれも、ファーストインファーストアウトキューに追加される。【0114】アプリケーションのビルトイン処理実際の放送システムでは、あるアプリケーション種類用のビルトイン処理/プロセッサが得られることがある。例えば、ビルトインオーディオデコーダは、連続するオーディオストリームアプリケーションを処理する。このアプリケーションのビルトイン処理は、サービスの処理の開始又は停止を行うSelectServiceコマンドを用いて制御される。この場合、SelectObjectコマンドによるサポートは不要である。サービスアクセスブロック9に含まれるSelectObjectコマンドメッセージ機能のインターフェースは、以下のように定義される。【0115】【表14】【0116】【表15】【0117】図13では、図11で説明したように行われるステップS110及びS111の、APIクライアント15からAPI12へのSelectServiceReqメッセージを有するサービスの開始、及び、SelectServiceCnfメッセージを送ることによるAPI12のコマンドの確認の後、SelectObjectコマンドを開始することができる。【0118】その後、ステップS112において、SelectObjectコマンドを開始するため、APIクライアント15はSelectObjectReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。選択されるオブジェクトは、パラメータ_tObjectIdによって識別される。オブジェクトが属しているサービスは、パラメータ_tServiceIdによって識別される。パラメータ_eObjectSelectionModeは、特定されたオブジェクトの選択モードを特定する。以下のモードがサポートされる。dscOnceの値は、特定されたオブジェクトの一回のみの供給を要求する。dscUpdateの値は、選択が取り消されるまで、特定のオブジェクトの供給及びオブジェクトの各更新の供給を要求する。dscOffの値は、現存のオブジェクト選択を取り消す。dscCacheHintの値は、このオブジェクトがAPIクライアント15にとってどの程度重要であるかを示すヒントをAPI12に供給するためのみに、SelectObjectコマンドが使用されることを示す。この場合、オブジェクトは供給用に選択されない。重要性は、パラメータCacheHintによって特定される。ハイパーテキストアプリケーション等の幾つかのアプリケーションでは、1コマンドで新たなオブジェクトを選択するとともに同じサービスに属する現存の全ての選択を取り消すことが好都合である。これは、パラメータ_bReplaceSelectionsを使用することによってサポートされる。このパラメータが真に設定された場合、パラメータ_tServiceIdによって特定されるサービスに属する現存の全ての選択が取り消される。このパラメータが偽に設定された場合、現存の全ての選択が変更されるわけではない。dscCompleteに対して設定されたパラメータ_eDeliveryModeは、選択されたオブジェクトがオブジェクトの完全な受信後に供給されることを示す。dscPartialに対して設定されたパラメータ_eDeliveryModeは、選択されたオブジェクトを部分的に供給してもよいことを示す。すなわち、インデックス1〜nの範囲のバイトシーケンスからなるオブジェクトについて、最初の供給では、インデックス1〜m(mはn以下)の範囲のバイトシーケンスからなる部分的に受信されたオブジェクトが得られる。次の供給では、1〜l(lはmより大でn以下)のシーケンスが得られ、同様に続く。これは、1〜nの範囲の全てのデータが供給されてオブジェクトが供給されると、終了する。【0119】パラメータCacheHintは、API12への、キャッシュを行うためのAPIクライアント15によるヒントを特定する。キャッシュでは、放送オブジェクトのコピーを記憶するため高速ローカルメモリを使用する。これによって、要求されたオブジェクトが既にキャッシュメモリに記憶されている場合、オブジェクトのアクセス時間が改善する。パラメータCacheHintは、キャッシュを行うオブジェクトを選択するためのヒントを与える。このパラメータの正確な定義は、基本システムによって異なる。一例としては、APIクライアント15にとっての重要性が最も低い0から重要性が最も高い100までの範囲で優先パラメータを使用することである。キャッシュのためのヒントは、各オブジェクトモードdscOff、sdcOnce、dscUpdate、dscCacheについて有効である。【0120】そして、ステップS113において、API12は、SelectObjectCnfメッセージをAPIクライアント15に送ることによってコマンドの処理を確認する。パラメータ_tClientIdは送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合、コマンドは成功であり、そうでない場合はエラーが発生している。パラメータ_tServiceIdは、選択されたオブジェクトが属しているサービスを識別するためのものである。パラメータ_tObjectIdは、選択されたオブジェクトを識別するためのものである。特定されたオブジェクトの現在の選択モードは、パラメータ_eObjectSelectionModeによって与えられる。パラメータAccessTimeは、選択されたオブジェクト自体がObjectNtfメッセージの使用によって与えられるまでの予想される遅延を示す、オブジェクトのアクセス時間を与える。【0121】オブジェクト及び更新を供給するため、ステップS114及びS115に示すように、ObjectNtfメッセージを送ることによって、ローカルインタラクティブアプリケーション等の選択されたオブジェクト、又は、スライドショーアプリケーション等の提示されるオブジェクト、又は、ストリーミングアプリケーション等の連続データストリームの1セグメントを有するオブジェクトがAPI12からAPIクライアント15に供給される。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。パラメータ_tServiceIdは、オブジェクトが属しているサービスを識別するためのものである。パラメータ_tObjectIdは、オブジェクトを識別するためのものである。パラメータ_eSelectionStateは、オブジェクトの現在の選択状態を報告するものであり、ローカルインタラクティブアプリケーションのみで使用される。以下の状態がサポートされる。dscSelectionOKの値は、オブジェクトがこのメッセージとともに供給されることを示し、パラメータ_ptObjectによってアクセスすることができる。dscDelayedの値は、関連するSelectObjectCnfメッセージによって示された場合と比較して、オブジェクトの供給が遅延していることを示す。この場合、パラメータ_ptObjectは意味を持たない。【0122】dscTerminatedの値は、オブジェクトが放送されなくなり、供給することができないことを示す。この場合、パラメータ_ptObjectは意味を持たず、この選択は排除される。パラメータ_bCompleteObjectは、オブジェクトがこのメッセージとともに完全に供給されるか部分的に供給されるかを示す。このパラメータが真に設定された場合、完全なオブジェクトが供給される。このパラメータが偽に設定された場合、上述のようにオブジェクトは部分的に供給される。パラメータ_bObjectInvalidは、提示のためにアプリケーションに以前供給されたスライドショーオブジェクトの提示を停止しなければならないか否かを示す。このパラメータが真に設定された場合、オブジェクトの提示を停止しなければならない。例えば、画像をディスプレイから除去しなければならない。この場合、パラメータ_eSelectionState,_bCompleteObject,_ptObjectは意味を持たない。パラメータが偽に設定された場合、他のパラメータの意味によってメッセージの意味が決まる。【0123】オブジェクトの選択を停止するために、ステップ116において、APIクライアント15はSelectObjectReqメッセージをAPI12に送り、これが、ステップS117において、SelectObjectCnfをAPIクライアント15に送ることによってAPI12から確認される。これら両メッセージのパラメータは、上述のステップS112及びS113における場合と同様に定義される。【0124】そして、サービスを停止するために、ステップS118において、APIクライアント15は、SelectServiceReqメッセージをAPI12に送り、ステップS119において、APIクライアント15にSelectServiceCnfメッセージを送ることによってAPI12から確認される。これら両メッセージのパラメータは、上述のステップS110及びS111における場合と同様に定義される。【0125】図12では、SelectObjectコマンドを使用せずに図11において説明したように行われるステップS100及びS101の、APIクライアント15からAPI12へのSelectServiceReqメッセージを有するサービスの開始、及び、APIクライアント15にSelectServiceCnfメッセージを送ることによるAPI12のコマンドの確認の直後、スライドショーオブジェクトを供給することもできる。この場合、ステップS114及びS115について説明したように定義されるステップS102〜S104に示すように、ObjectNtfメッセージを送ることによってAPI12からAPIクライアント15に情報が供給される。その後、サービスを停止させるため、ステップS105において、APIクライアント15がSelectServiceReqメッセージをAPI12に送り、これが、ステップS106において、APIクライアント15にSelectServiceCnfメッセージを送ることによってAPI12から確認される。これら両メッセージのパラメータは、上述のステップS100及びS101における場合と同様に定義される。【0126】利用可能な全放送ソースにおけるサービスのスキャン放送環境における利用可能な全てのサービスの概要を得るために、Scanコマンドが設けられている。要求インターフェース16を介したサービススキャンブロック11へのScanコマンドの要求後、利用可能な全ての放送ソースの検索を開始し、各放送ソースでどのサービスが利用可能なのかを知るために放送ソースを1つずつ選択する。その結果は、サービスディレクトリブロック6によって供給されるサービスディレクトリに記憶され、APIクライアント15がアクセスすることができる。コマンドの処理中は、他のサービスにはアクセスできないことがある。これは、接続された放送受信機13によって異なる。放送受信機が一時に1つの放送ソースへのアクセスしか行わない場合、他のアクセスは不可能である。【0127】検索方法は、例えば周波数範囲、周波数ステップ、方向等であり、APIクライアント15によって特定することができ、あるいはAPI12によって自動的に行われる。このため、スキャンが継続している限り経過情報が与えられる。Scanコマンドは、図14に示すように、ScanReqメッセージ、ScanNtfメッセージ、ScanCnfメッセージ機能によって構成される。Scanコマンドが実行され、APIクライアント15がサービスディレクトリからの通知を申し込んだ場合、サービスディレクトリにおける変更を通知するため、ServiceInfoNtfメッセージがAPI12からAPIクライアント15に送られる。【0128】Scanコマンドメッセージ機能のインターフェースは、以下のように定義される。【0129】【表16】【0130】まず、ステップS121において、APIクライアント15はScanコマンドを開始するためにScanReqメッセージをAPI12に送る。パラメータ_tClientIdは、APIクライアント15を識別するためのものである。検索方法は、1以上のパラメータ(SearchMethod)によって特定される。スキャンに長時間かかることがあるので、APIクライアント15はスキャン動作中に経過情報を要求してもよい。このため、パラメータNotificationsによって、例えば、各周波数ステップ後に所望の通知種類を特定することができる。【0131】その後、ステップS122〜S124に示すように、API12はAPIクライアント15に経過情報を供給するためにScanNtfメッセージを使用する。パラメータ_tClientIdは、送信先のAPIクライアント15を識別するためのものである。経過情報は、1以上のパラメータ(ProgressInfo)として供給される。【0132】そして、ステップS125において、API12は、APIクライアント15にScanCnfメッセージを送ることによって、Scanコマンドの処理の完了を報告する。パラメータ_tClientIdは送信先のAPIクライアント15を識別し、パラメータ_eResultは処理結果を示す。値がresOKである場合、コマンドは成功であり、放送ソースが見つかっている。そうでない場合はエラーが発生している。いずれの場合も、現在選択されている放送ソース(CurrentBroadcastSource)及び現在の受信品質(ReceptionQuality)が報告される。【0133】放送ソースの選択によって、APIクライアント15は、この放送ソースに属する全ての情報サービスにアクセスを有する。他の放送ソースの情報サービスにアクセスするには、他の放送ソースを予め選択しておく必要があるが、サービスディレクトリブロック6が供給するサービスディレクトリによって、全放送ソースからの全サービスについての情報を得ることができる。これによって、ユーザに全サービスのリストを供給するアプリケーションプログラムを形成することができる。ユーザが、現在選択されているソースからあるサービスを選択する場合、SelectServiceコマンドのみ実行する必要がある。ユーザが、他の放送ソースからサービスを選択する場合、2つの選択肢が与えられる。APIクライアント15は、まずTuneコマンドを使用することによって放送ソースを選択し、次にSelectServiceコマンドを使用することによってサービスを選択する。あるいは、SelectServiceコマンドが他の放送ソースからのサービスについて実行される場合、APIクライアント15は、予めTuneコマンドを自動的に実行する。【0134】本発明を、C/C++言語で実現される一実施例を用いて説明したが、これは限定ではなく、本発明を適用したAPI12の機能を明確に説明するために用いたものであることは明らかである。他のプログラミング言語での実現やハードウェアによる実現も可能であり、同様の機能を示す。API12及び/又はAPIクライアント15については、1つの放送受信機内で又は別々の装置として実現することができる。これらをソフトウェアとして実現する場合、放送受信機内に又はそれぞれの装置内に配置することができる。あるいは、放送システムのチャンネルから、又は、放送受信機又はそれぞれの装置によってアクセスすることができる他のサーバからダウンロードすることができる。【0135】以下、本発明を適用した放送APIの典型的な使用について、幾つかの現存の放送システムを用いて説明する。【0136】RDS(ラジオデータシステム)を持たない標準FMラジオは、ユーザインターフェースが1つである。すなわち、FMラジオへのアクセスをユーザに与えるため、クライアントのみが放送APIを同時に用いている。FMラジオでは、通常、幾つかの放送ソースにアクセスする(周波数範囲88〜108MHz)。各放送ソースは、オーディオサービスを1つだけ提供する。オーディオサービスの処理はビルトインで行われる。すなわち、APIによるサービスアクセスサポートは不要である。放送ソースを選択すると、自動的に1つのオーディオサービスのみが開始するとともに(サービス選択)、自動的にオーディオデータの処理が開始する(サービスアクセス)。移動環境では、受信品質は大きく変化する。しかし、非常に安価なものから高価なものまで広範囲のラジオが存在する。受信品質の監視は得られるときもあり、得られないときもある。【0137】オーディオサービスは、ID、ラベル、プログラム種類等の属性を有しない。したがって、FM信号からサービスディレクトリを作成することは不可能である。【0138】RDSを有するFMラジオは、上述のシステムと同じであるが、オーディオサービスについての更なる情報を与えるためにFM信号とともに送られる追加データを有する。追加情報は、ID(Oxd999)、ラベル("SWF3")、プログラム種類("POP")、アナウンスメントサポート及びスイッチング(スポークントラフィックメッセージ)、ラジオテキスト(追加テキスト情報)からなる。これによって、幾つかの放送ソースを属性とともに有するサービスディレクトリを形成することができる。これは、あるプログラム種類("Pop")に合うサービスを選択するため、あるいは、ラベル("SWF3"、"Antenne1")に基づく1以上のリストからサービスを選択するのに使用することができる。一時に1つのオーディオサービスしか動作しないが、ラジオテキストスライドショーを付加的に行うことができる。【0139】通常のテレビジョン受像機は、クライアントが1つである。幾つかの利用可能な放送ソースから1つの放送ソース(チャンネル)を選択することができる。放送ソース毎に1ビデオストリームサービスが得られる。ラベル、タイム、ProgramInfo等の追加情報は、ビデオテキストによって示される。ビデオテキストは、テキスト情報を有するローカルインタラクティブサービスを提供する。ビデオ処理はビルトインで行われ、ビデオテキストデコーダもサポートされるならば得られる。しかし、ページへのアクセスにはサービスアクセスブロック9が必要である。サービスアクセスブロック9によって、ビデオテキストページをナビゲートすることができ、スライドショー効果はメインページ及びサブページに使用されることが多い。【0140】固定型の動作及び/又はケーブルネットワークであるため、受信状態が障害を受けることは稀である。【0141】チャンネルを選択するのに放送ソース選択が必要である。これによって、自動的にビデオサービスが開始する。ビデオテキストアクセスは、クライアントによる要求で開始する(サービス選択)。ビデオテキスト復号化は、より高速なアクセスを行うために予め開始されている。【0142】サービススキャンでは、全てのサービス(ビデオストリーム及びビデオテキスト)の検索を行い、それらを所定のボタンで自動的に記憶する。これらのサービスをサービスディレクトリに記憶し、現在使用されているチャンネル番号の代わりにチャンネル名リストを与えることも可能である。【0143】例えば、いかなる種類の金融情報にもアクセスする受信機等、特殊な受信機は、DAB等の標準放送システムに基づくこともできるが、特定情報へのアクセスしか得られない。【0144】放送システムの構成として幾つかの構成が可能である。例えば、サーバPCに接続された1ハードウェア受信機と、PCワークステーション上で動作する幾つかのクライアントアプリケーションとを有し、ローカルネットワークを介して情報にアクセスする構成がある。以下に示す構成が可能である。【0145】・1又は幾つかのクライアント。【0146】・1又は幾つかの放送ソース。【0147】・金融情報、ニューステキスト、ニュースティッカ、ハイパーテキスト、ニューススライドショー、株データ等を有する幾つかのサービス。【0148】・1放送ソースでは放送ソース選択は不要だが、2以上では必要。【0149】・2以上のサービスで異なる種類(ハイパーテキスト、ニュースティッカ)の場合、サービス選択が必要。【0150】・サービスマルチプレクスは変更してもよい。【0151】・サービスディレクトリによって柔軟なサービスマルチプレクスが可能である。【0152】・1放送ソースではサービススキャンは行わない。【0153】・例えば、株価を提供する場合、受信品質の監視は重要である。【0154】フルDAB及び/又はDVBシステムには、本発明の好ましい実施例で説明したビルディングブロックの全機能が含まれている。【0155】一般に、放送APIのビルディングブロックには必須のものと任意のものとがあるが、これは、この分野のサポートがクライアント(アプリケーション)にとって必要/有用であるか否かに常に関連している。例えば、1放送ソースにしかアクセスしないシステムの場合、放送ソース選択は不要である。これは、放送ソースを全く選択しなくてよいということではない。1放送ソースしか選択できず、APIの基本システムによって自動的に選択が行われる、ということである。【0156】フルシステムにおいては、全てのビルディングブロックが必要であることは明らかである。実際のシステムの制限によって、サブセットのみが必要である。幾つかの簡単なシステムでは、除去することができるブロックもあり、合体することができるブロックもあるが、これは機能についてのみ有効である。ビルディングブロックのインターフェースを変更することが必要なときもある。その結果、新たなビルディングブロックが定義される。【0157】一般に、機能とそれに対応するビルディングブロックが必須であるか任意であるかの決定は容易になる。【0158】・2以上の放送ソースが利用可能であるときは必ず放送ソース選択が必要であり、選択されたいずれの放送ソースからも全サービスがわかるわけではない。他の全ての放送ソースにおける全サービスについての情報がわかる場合、システムは、スタートアップ後に1放送システムを選択し、利用可能な全てのサービスについて情報を得る。この場合、サービス選択を行うことで、サービスにアクセスするのに十分である。【0159】・提供されたサービスが予めわかっていないとき、また、提供されたサービスのセットを変更することができるとき、サービスディレクトリが必要である。幾つかの放送ソースがあり、選択された放送ソースにおけるサービスが限定的にしか示されていない場合、サービスディレクトリによって、再チューニングを行わずに利用可能な全サービスのリストを得ることができる。クライアントは、動的変更についての情報を得ることができる。【0160】・1放送ソースにおいて2以上のサービスが利用可能であるとき、また、2以上のサービスを同時に動作させるため、サービス選択が必要である。【0161】・更なる処理を行うためにデータをアプリケーションに供給する必要があるとき、サービスアクセスが必要である。【0162】・受信品質が動作中に変化する可能性があるとき、受信品質が必要である。【0163】・サービススキャンによって、サービス選択が容易になり、良好なユーザインターフェースを形成することができる。【0164】・2以上のクライアントがAPIを用いているとき及び/又はインターフェーシングが必要なとき、クライアント登録が必要である。【0165】本発明を適用した放送APIの他の適用例として、APIクライアント15に限定的なアクセスのみを提供する。すなわち、例えば、JavaAppletは完全なDAB受信機の一部賭して動作している。DABへのアクセスは、DAB受信機の適応部分によって制御されるが、JavaAppletは、例えば、DABを介してダウンロードされ、あるデータサービスを提示する。したがって、サービスアクセスブロック9にアクセスする必要があり、他のブロックへのアクセスはできない。
特願2000-137169
