モデルのコンパイルシミュレーションの最初の段階の処理は、システムのモデルを開いて、モデルのシミュレーションを実行したときに行われます。Simulink® エディターで、[シミュレーション] 、 [実行] を選択します。シミュレーションを実行すると、Simulink エンジンによってモデル コンパイラが呼び出されます。モデル コンパイラはコンパイルと呼ばれるプロセスでモデルを実行可能形式に変換します。特にコンパイラは以下を行います。モデルのブロック パラメーター式を評価し、値を決定します。モデルによって明示的に指定されていない信号の属性 (たとえば、名前、データ型、数値型、サイズ) を決定し、各ブロックが、入力に接続されている出力を受け取ることができることをチェックします。属性の伝播と呼ばれるプロセスを使って、指定されていない属性を決定します。このプロセスは、ソース信号から接続しているブロックの入力への属性の伝播を伴います。ブロックを減らす最適化を実行します。バーチャル サブシステムをその構成ブロックで置き換えることにより、モデルの階層をフラットにします (ソルバーを参照)。ブロックの並べ替え順序の決定 (詳細は、オンライン ドキュメンテーションの「「並べ替え順序の制御と表示」」を参照)。サンプル時間が明示的に指定されていないモデル内のすべてのブロックのサンプル時間を決定します (「伝播が継承サンプル時間に影響を与える方法」を参照)。これらのイベントはブロック線図の更新時に発生するイベントと、基本的に同じです (「ブロック線図の更新」)。違いは、Simulink ソフトウェアがモデル シミュレーションの一部としてモデルのコンパイルを開始することです。コンパイルが開始されると、リンク フェーズに記載されているように、リンク フェーズに直接移行します。一方、モデルの更新は、モデルに対するスタンドアロン操作としてユーザーが明示的に開始します。
リンク フェーズこのフェーズでは、Simulink エンジンは、ブロック線図の実行のために、作業領域 (信号、状態、ランタイム パラメーター) 用に必要なメモリを割り当てます。また、各ブロックの実行時情報を格納するデータ構造体用のメモリを割り当て、初期化します。組み込みブロックに対しては、ブロックの主たる実行時データ構造体は、SimBlock と呼ばれます。これは、ブロックの入出力バッファー、状態、作業ベクトルを指すポインターを格納します。メソッド実行リストリンク フェーズでは、Simulink エンジンは、メソッド実行のリストも作成します。これらのリストは、出力を計算するために、モデルのブロック メソッドを実行するための最適な順番を示します。モデルのコンパイル フェーズ中に生成され並べ替えられたリストを使ってメソッド実行リストを作成します。ブロック優先順位ブロックの処理順序には優先順位を付けることが可能です (「ブロックの優先順位の割り当て」を参照)。優先順位が低いブロックの前に優先順位が高いブロックの出力メソッドが実行されます。ただし、その優先順位がブロックの並べ替えルールに従っている場合にのみ、その順序が守られます。
シミュレーション ループ フェーズリンク フェーズが完了すると、シミュレーションはシミュレーション ループ フェーズに入ります。このフェーズでは、Simulink は、引き続きモデルが提供する情報を使って、シミュレーション開始時間から終了時間までの区間でシステムの状態と出力を計算します。状態と出力が計算される連続する時間点は、タイム ステップと呼ばれます。ステップ間の時間の長さは、ステップ サイズと呼ばれます。ステップ サイズは、システムの連続状態の計算に使うソルバーのタイプ (ソルバーを参照)、システムの基本サンプル時間 (「システム内のサンプル時間」を参照)、システムの連続状態が不連続性をもつかどうかに依存します (ゼロクロッシング検出を参照)。シミュレーション ループ フェーズには、ループ初期化フェーズとループ反復フェーズの 2 つのサブフェーズがあります。初期化フェーズは、ループの開始時に 1 回発生します。反復フェーズは、シミュレーション開始時間から終了時間まで 1 ステップごとに 1 回繰り返されます。シミュレーションの開始時に、モデルは、シミュレートするシステムの初期状態と初期出力を指定します。各ステップで、システムの入力、状態、出力が計算され、計算値を反映するようにモデルが更新されます。シミュレーションの終了時に、モデルはシステムの入力、状態、出力の最終値を反映させます。Simulink ソフトウェアは、データの表示とログを行うブロックを提供しています。モデルにこれらのブロックを含めることにより、中間結果を表示またはログできます。ループ反復各タイム ステップで Simulink エンジンは次のことをします。モデルの出力を計算します。 Simulink エンジンは、Simulink モデルの Outputs メソッドを呼び出すことによってこのステップを開始します。モデルの Outputs メソッドは、モデルシステムの Outputs メソッドを呼び出し、これは、シミュレーションのリンク フェーズで生成されたリストによって指定された順番でモデルが含むブロックの Outputs メソッドを呼び出します(ソルバーを参照)。システムの Outputs メソッドは、引数として、ブロックのデータ構造体とその SimBlock 構造体を指すポインターを各ブロックの Outputs メソッドに渡します。SimBlock データ構造体は、入出力バッファーの位置を含む、ブロックの出力を計算するのに必要な情報を示します。モデルの状態を計算します。 Simulink エンジンは、ソルバーを呼び出すことによってモデルの状態を計算します。どのソルバーを呼び込むかは、モデルが状態をもたないか、離散状態のみか、連続状態のみか、連続と離散の両方をもつかによって決まります。モデルが離散状態のみをもつ場合は、Simulink エンジンは、ユーザーが選択した離散ソルバーを起動します。ソルバーは、モデルのサンプル時間をヒットするのに必要なタイム ステップのサイズを計算します。その後で、モデルの Update メソッドを呼び込みます。モデルの Update メソッドは、システムの Updateメソッドを呼び込み、これは、リンク フェーズで生成された Update メソッドのリストで指定された順番でシステムが含むブロックの各々の Update メソッドを呼び込みます。 モデルが連続状態のみをもつ場合は、Simulink エンジンはモデルによって指定された連続ソルバーを起動します。ソルバーにより、モデルの Derivatives メソッドを 1 回呼び出すか、あるいは、メジャー タイム ステップ内の連続する間隔でモデルの出力と導関数を計算する Output メソッドと Derivative メソッドをソルバーが繰り返し呼び出すマイナー タイム ステップのサブサイクルを入力します。これは、状態の計算の精度を上げるために行われます。モデルの Outputs メソッドと Derivatives メソッドは、リンク フェーズで生成される Output および Derivative メソッドの実行リストで指定される順番で、Outputs および Derivatives ブロックを呼び出す対応するシステム メソッドを起動します。オプションでブロックの連続状態の不連続性をチェックします。連続状態の不連続検出には、ゼロクロッシング検出と呼ばれる手法が使用されます。詳細は、ゼロクロッシング検出を参照してください。 次のタイム ステップに対する時間を計算します。シミュレーションの停止時間になるまでステップ 1 ～ 4 を繰り返します。
ソルバー動的システムのシミュレーションは、モデル情報から指定された時間の間、連続タイム ステップで状態量を計算して行われます。システムの状態量をモデルから計算するプロセスは、モデルの解を求めることとして知られています。モデルを解く方法はどのシステムについても 1 つではありません。したがって、ソルバーというプログラム群が用意されており、各プログラムにはモデルを解くための特別なアプローチが組み込まれています。[コンフィギュレーション パラメーター] ダイアログ ボックスを使えば、モデルに最適なソルバーを選択することができます (「ソルバー タイプの選択」を参照)。固定ステップ ソルバーと可変ステップ ソルバー Simulink ソフトウェアのソルバーは、固定ステップと可変ステップという 2 つのタイプに分けられます。固定ステップ ソルバーでは、シミュレーションの開始から終了まで一定の時間間隔でモデルを解きます。時間間隔のサイズは、ステップ サイズとも呼ばれ、ユーザーが自分で選択することもソルバーに選択させることもできます。一般に、ステップ サイズを小さくするとシステムのシミュレーションに要する時間が長くなりますが、結果の精度は向上します。可変ステップ ソルバーでは、シミュレーション実行中にステップ サイズが変化します。モデルの状態量が急激に変動しているときは精度を上げるためにステップ サイズが小さくなり、モデルの状態の変動が緩慢なときは不必要なタイム ステップを取ることを回避するためにステップ サイズが大きくなります。ステップ サイズの計算は、各ステップで計算のオーバーヘッドを加えますが、ステップの総数は減らすことが可能なため、急激に変化あるいは区分的に連続状態をもつモデルの指定したレベルの精度を保持するために必要なシミュレーション時間が増加します。連続ソルバーと離散ソルバーSimulink 製品では、連続ソルバーと離散ソルバーの両方が用意してあります。連続ソルバーは、数値積分を使って前のタイム ステップにおける状態と状態導関数から現在のタイム ステップにおけるモデルの状態量を計算します。連続ソルバーは、個々のブロックに基づいて各タイム ステップにおけるモデルの離散状態量の値を計算します。動的システムの連続状態を表す常微分方程式 (ODE) を解くためのさまざまな数値積分技法が数学者によって開発されています。それぞれ特定の ODE 解法を実装する各種の固定ステップ連続ソルバーおよび可変ステップ連続ソルバー群が用意されています (「ソルバー タイプの選択」を参照)。離散ソルバーは主に、純粋な離散モデルを解くためのものです。モデルについて次のシミュレーション タイム ステップを計算し、それ以外のことは行いません。これらの計算では、モデルの各ブロックに基づいて個々の離散状態量を更新します。連続状態の計算は行いません。 
提供されている 2 つの離散ソルバーは、固定ステップ離散ソルバーと可変ステップ離散ソルバーです。固定ステップ離散ソルバーは既定の場合、モデルの最速ブロックにおける状態量の変化の速度に合わせてステップ サイズ (したがって、シミュレーション速度) を選択します。可変ステップ離散ソルバーは、モデルにおける実際の離散状態量の変化速度に合わせてシミュレーションのステップ サイズを調整します。これにより不必要なステップを取ることが回避されるため、マルチレート モデルのシミュレーション時間が短縮されます (詳細は、「システム内のサンプル時間」を参照)。マイナー タイム ステップソルバーの中には、シミュレーション時間をメジャー タイム ステップとマイナー タイム ステップに細かく分けるものがあります。マイナー タイム ステップは、メジャー タイム ステップの下位区分を表します。ソルバーは、各メジャー タイム ステップでの結果を生成します。マイナー タイム ステップでの結果を使ってメジャー タイム ステップでの結果の精度を向上させます。形状の保存通常、積分ステップ サイズは現在のステップ サイズと現在の積分誤差に関連しています。ただし、微分が迅速に変化する信号の場合、各タイム ステップに微分入力情報を含めることによって、より精度の高い積分結果を得ることができます。そのためには、[モデル コンフィギュレーション パラメーター] 、 [ソルバー] 、 [形状の保存] オプションを有効にします。
ゼロクロッシング検出可変ステップ ソルバーは、変数がゆっくり変化するときにはタイム ステップ サイズを増加させ、急速に変化するときには減少させて、タイム ステップ サイズを動的に調整します。不連続の周辺では変数が急速に変化するため、ソルバーはこの周辺で多くの小さいステップを取ります。このため精度は向上しますが、シミュレーション時間が余分にかかることがあります。Simulink ソフトウェアはゼロクロッシング検出という技法を使用することで、小さいタイム ステップを過度に取ることなく正確に不連続を特定します。この技法を使うとシミュレーション実行時間は短縮されますが、意図した完了時間前に一部のシミュレーションが停止することがあります。Simulink ソフトウェアでは、非適応アルゴリズムと適応アルゴリズムの 2 つのアルゴリズムが提供されています。これらの技法の詳細は、ゼロクロッシング アルゴリズムを参照してください。過度のゼロクロッシング検出の影響を示すデモSimulink ソフトウェアには、ゼロクロッシングの動作を紹介する 3 つのモデル、sldemo_bounce_two_integrators、sldemo_doublebounce、sldemo_bounce が付いています。sldemo_bounce_two_integrators モデルでは、適応アルゴリズムを使用しないと、過度のゼロクロッシングによって意図した完了時間前にシミュレーションが停止する場合を見ることができます。sldemo_bounce モデルでは、sldemo_bounce_two_integrators より優れたモデル設計を使用しています。 sldemo_doublebounce モデルでは、適応アルゴリズムが 2 つの異なるゼロクロッシング条件を使用して複雑なシステムを正しく解く様子を見ることができます。2 つの Integrator ブロックを使用する跳ね返りモデル-  
MATLAB® コマンド プロンプトで、sldemo_bounce_two_integratorssldemo_bounce_two_integrators と入力して例を読み込みます。ブロック線図が表示されたら、[モデル コンフィギュレーション パラメーター] 、 [ソルバー] 、 [アルゴリズム] パラメーターを [非適応] に設定します。また、[ソルバー] ペインの [終了時間] パラメーターを 20 秒に設定します。モデルを実行します。Simulink エディターで、[シミュレーション] 、 [実行] を選択します。シミュレーションの完了後、Scope ブロック ウィンドウをクリックすると結果が表示されます。結果全体を表示するには [オートスケール] をクリックする必要があるかもしれません。
スコープ ズーム コントロールを使用して、シミュレーションの最後の部分を調べます。最後の時間ポイントのゼロのすぐ上で速度が停止していることがわかります。
Simulink エディター ツール バーのシミュレーションの [終了時間] エディット ボックスを 25 秒に変更して、再度シミュレーションを実行します。今度は 20 秒の時間ポイントのシミュレーションを過ぎた直後にエラーが発生してシミュレーションが停止します。ボールが繰り返しゼロ速度に近づくにつれ、過度のチャタリングにより、シミュレーションが許可されている連続ゼロクロッシングの既定の 1,000 回を超えました。この制限は [モデル コンフィギュレーション パラメーター] 、 [ソルバー] 、 [連続的なゼロクロッシングの数] パラメーターを調整することによって増やすことができます。この場合は増やしても 25 秒間シミュレーションを実行することはできません。また、[ソルバー] ペインの [アルゴリズム] プルダウン メニューから [適応] アルゴリズムを選択します。シミュレーションを再び実行します。今度は適応アルゴリズムによって過度のゼロクロッシング回数の発生が回避されたため、シミュレーションは最後まで実行されます。
2 次積分器を使用した跳ね返りモデル-  
Double-Bounce モデル-  
MATLAB コマンド プロンプトで、「sldemo_doublebouncesldemo_doublebounce」と入力して例を読み込みます。モデルとアニメーション ウィンドウが開きます。アニメーション ウィンドウには、2 つのボールが 2 つの台の上に置かれています。アニメーション ウィンドウで、[Nonadaptive] ボタンをクリックして、非適応アルゴリズムで例を実行します。これは Simulink ソフトウェアがすべてのモデルに使用する既定の設定です。右側のボールに大きな初期速度が与えられ、その結果 2 つのボールは別々の時間に地面に当たって跳ね返ります。シミュレーションは左側のボールがゼロクロッシングの制限回数を超えたため、14 秒後に停止します。右側のボールは空中に浮いたままです。エラー メッセージのダイアログが表示されます。[OK] をクリックして、ダイアログ ボックスを閉じます。[Adaptive] ボタンをクリックして、適応アルゴリズムでシミュレーションを実行します。今度は左側のボールの下の地面が 20 秒後に移動しますが、シミュレーションは最後まで実行されます。シミュレーターがゼロクロッシング イベントを見落とす場合bounce モデルと double-bounce モデルから、不連続に関する高周波変動 (「チャタリング」) があると、シミュレーションが途中で停止する可能性があることがわかります。また、ソルバーの許容誤差が大きすぎる場合もソルバーがゼロクロッシングを完全に見落とすことがあります。これは、ゼロクロッシング検出技法では、信号の値によって符号が変更されたかどうかがメジャー タイム ステップの後にチェックされることが原因です。符号変更はゼロクロッシングが発生したことを示し、ゼロクロッシング アルゴリズムはその後に正確なクロッシングの時間を探します。しかし、ゼロクロッシングがある 1 つのタイム ステップの開始時と終了時で値の符号変化がない場合を想定してみましょう。このような場合、ソルバーがゼロクロッシング部を検出できずに、その位置を横切ってしまいます。次の図は、ゼロを横切る信号を示しています。最初の例では、タイム ステップ間で符号が変わっていないため、積分はこのイベントを飛び越えてしまいます。2 番目の例では、ソルバーが符号変更を検出するため、ゼロクロッシング イベントが検出されます。
過度のゼロクロッシングの回避次の表を使用して、モデルで過度のゼロクロッシング エラーを防ぎます。
動的システムのシミュレーション - MATLAB & Simulink
