解説
初心者が忘れがちなのがこの高速化だと思います。
現に自分もそうでした。
自分の場合はゲームができたと思って有頂天にしまいました。
そのため、ついそのままにしていたというのが現状でした。
せっかくできたゲームを他のパソコンで動かしてみたら重くてカクカクといったことを経験した人も多いでしょう。
自分ができるからといってそのままに放置していてはだめです。
できるだけ多くの人ができるようにしましょう。
ゲームを高速化しようと思ったらいくらでも高速化できます。
今までゲームの処理の20%を占めていたのがたった0.1%というのも可能です。
高速化というのは非常に大切です。
オペレータ・オーバーロードは使うな
オペレータ・オーバーロードって何?という人も多いでしょう。
ですが、名前だけ知らなくても使ったことがある人は多いでしょう。
どういったものかといいますと、例えば以下のようなプログラムです。
void Test()
{
D3DXVECTOR3 a(0,1,2),b(1,-1,2),c(0,2,3),d;
d = a + b - c;
}
この足し算をしているところがオペレータ・オーバーロードです。
よく考えてください。
普通の構造体、クラスで足し算ができるのでしょうか?できませんよね。
それをできるようにしてくれるのがオペレータ・オーバーロードです。
さて先ほどのプログラムを計算する順序に括弧をつけてみましょう。
void Test()
{
D3DXVECTOR3 a(0,1,2),b(1,-1,2),c(0,2,3),d;
d = ((a + b) - c);
}
上のように括弧二つが繰り返されますね。
実はオペレータ・オーバーロードは演算結果を新しいオブジェクトとして返しています。
以下のコードはD3DXVECTOR3のオペレータ・オーバーロードの中身を表した例です。
D3DXVECTOR3 D3DXVECTOR3::operator + (D3DXVECTOR3 &vec)
{
D3DXVECTOR3 vec2;
vec2.x = x + vec.x;
vec2.x = y + vec.x;
vec2.x = z + vec.x;
return vec;
}
上のプログラムの通りvec2という新しいオブジェクトを作っています。
そのため 2 項演算をするたびに新しいオブジェクトを作っては破棄を連続しています。
Test()の例ですと無駄なオブジェクトは 4 個作られています。
まずa + bの結果を出すためにオペレータ・オーバーロード内で一個です。
次にその返ってきた値をコピーします。これで 2 個目です。
さらに帰ってきた値と C を演算するためにオペレータ・オーバーロード内で 3 個目が作られます。
最後に帰ってきた値のコピーを作ります。これで計 4 個です。
int型などと違い、クラスの場合はコンストラクタ、デストラクタがあります。
関数というのは重い処理となっています。
そのため無駄なオブジェクトが多いということは、それだけコンストラクタやデストラクタが呼ばれるということです。
その分実行速度が遅くなるということです。
それでは無駄を防ぐためにはどうすればいいのでしょうか?
それは関数を使うということです。
まずは加算をする関数のプログラムを実装してみましょう。
void MyAdd(D3DXVECTOR3 *out,D3DXVECTOR3 *in1,D3DXVECTOR3 *in2)
{
//==================================================================
//本当はポインタよりも参照のほうがいいです
//でもDirectXではポインタを使っていますので自分もポインタを使います。
//==================================================================
out->x = in1->x + in2->x;
out->y = in1->y + in2->y;
out->z = in1->z + in2->z;
}
このように出力を直接引数にもってくれば、先ほどの無駄なオブジェクトを作る必要もありません。
わざわざこんな関数を一から作るのはめんどくさいです。
そこで、DirectXには関数がすでに用意されています。
OpenGLは知りません。多分あると思いますが。
それではコードを見てみましょう。
加算(足し算)   D3DXVec3Add(D3DXVECTOR3 *出力,D3DXVECTOR3 *入力1,D3DXVECTOR3 *入力2);
減算 (引き算)   D3DXVec3Subtract(D3DXVECTOR3 *出力,D3DXVECTOR3 *入力1,D3DXVECTOR3 *入力2);
スケーリング    D3DXVec3Scale(D3DXVECTOR3 *出力、D3DXVECTOR3 *入力1,float 掛ける値);
以上のような関数を使うことで実装できます。ここで一つの疑問が生まれます。
割り算がないということですね。
割り算というのは掛け算の掛ける値の逆数を取れば簡単にできます。
こんな関数を使うなんてめんどくさいという人も多いでしょう。
そこでこういう使い方をしてる人がいるかもしれません。
乗算(掛け算)   入出力 *= 掛ける値
除算 (割り算)   入出力 /= 割る値
加算 (足し算)   入出力 += 足すベクトル
減算 (引き算)   入出力 -= 引くベクトル
別にこういうやり方でもかまいませんよ。でもこの場合だと入力と出力を分けることができないので注意です。
分けることができないということは入力した値が変化するということです。
気をつけましょう。
それでは先ほどのTest()のプログラムを関数を使った方法で実装してみましょうか。
void Test()
{
D3DXVECTOR3 a(0,1,2),b(1,-1,2),c(0,2,3),d;
D3DXVec3Add(&d,&a,&b);
D3DXVec3Sub(&d,&d,&c);
//d = a + b - c
}
なんか少し見にくくなりましたね。どんな演算をしているのかいまいちわかりません。
そこで上のプログラムのようにコメントで書くと何をしているのかがわかりやすくなりますよ。
尚、この方法だと無駄なオブジェクトは一つも発生しません。
構造体、クラスの値返しはやめよう
先ほどのオペレータ・オーバーロードを使うなと似ているところが結構今回あります。
関数は値返しというものがありますね。例えば以下のようです。
int hoge()
{
return 10;
}
これはエラーが出ないですよね。でも以下の場合はエラーが出ます。
int *hoge()
{
int tmp = 1;
reutrn &tmp;
}
int main()
{
int *tmp;  
tmp = hoge();
*tmp = 5;//ERROR
}
変数には二つ種類があります。
一つは自動変数、もう一つが静的変数です。
我々が普段使ってる変数は自動変数というものでautoという識別子が実は略されています。
この自動変数はスコープ外に出ると自動的に開放されるようになっています。
静的変数の場合はスコープ外に出ても開放はされません。
先ほどのプログラムはint型のポインタを返すhogeの返り値は、スコープ外に出てしまったためにメモリが開放されてしまいます。
値を代入しようとしてもメモリが確保されてないのでエラーが出ます。
それを防ぐためにnewやdeleteを使う方法があります。先ほどのプログラムを改変してみましょう。
int *hoge()
{
int *tmp = new int;
*tmp = 1;
reutrn tmp;
}
int main()
{
int *tmp;  
tmp = hoge;
*tmp = 5;
delete tmp;
return 0;
}
これで先ほどの問題が解決できました。
動的に確保した変数というものはスコープ外にでてもdeleteされるまではずっとメモリが残っています。
それで先ほどの問題が解決できたというわけですね。
しかしこの方法だと問題があります。
それはいちいちdeleteを呼ばないといけないことと、new やdeleteは重い処理であるということです。
こんなのやってられません。
それに開放し忘れたら最悪です。
今度は普通に、値返しをした場合を考えて見ましょう。
普通に値を返す場合だと先ほどの問題が解決されます。
ですが、値返しの場合は返された値を直接データに入れるのではなくて、実は関数の値のコピーをデータに入れます。
関数の中のオブジェクトとコピーのオブジェクトの計 2 個分無駄なことをします。
以下プログラム参照。
D3DXVECTOR3 hoge()
{
return D3DXVECTOR3(10.0f,1.0f,10.0f);  //ここで一個無駄
}
int main()
{
a = hoge();             //ここのhoge()の返り値のコピーでもう一個無駄
return 0;
}
以上の理由でこの方法も使えません。
重すぎます。
そこでどうすればいいのかといいますと、値を返さなければいいのです。
そんな馬鹿なと思うかもしれませんが実はできます。
CやC++では戻り値を使わなくても値を取得できます。
それは引数です。
早速実装例です。
void hoge(D3DXVECTOR3 &ioVec)
{
ioVec.x = 10.0f;
ioVec.y = 2.0f;
ioVec.z = 5.0f;
}
このように引数から直接データをもってくれば先ほどの無駄なオブジェクトが一切発生しません。
これからはこの方法を使いましょう。
ただし例外があります。それは以下のときです。
class Character
{
D3DXVECTOR3 m_pos;
public:
const D3DXVECTOR3 &GetPos(){return m_pos;}
}
メンバー変数はインスタンスを削除するまでメンバー変数の中身はありますから参照で直接値を返すといったことが可能です。
この場合は無駄なインスタンスが作られないので問題無しです。
処理の重い条件は後置もしくは入れ子で
処理の重い条件式ってありますよね。
たとえば当たり判定とかです。
例えば自機と敵との当たり判定は以下のようにしますよね。
void Run()
{
if(自機と敵の当たり判定 == 1 && 敵のフラグ == 1)
{
敵のフラグ = 0;
}
}
このときフラグが 0 の時でも当たり判定をされてしまいます。
これだとかなりの無駄な処理となります。
その対策として当たり判定を後ろに書きます。
void Run()
{
if(フラグ == 1 && 当たり判定 == 1)
{
フラグ = 0;
}
}
コンパイラにもよると思いますが、条件式が満たさないと判断すると途中で条件式の解釈をやめてしまいます。
このことを利用して当たり判定を後ろに書きます。
これで無駄な演算が減ります。
ですが見やすいプログラムに書いた通りなのですが複数条件で A , B と置く方法がありました。
その場合は以下のように書くと思います。
void Run()
{
bool A = 敵のフラグ == 1;
bool B = 敵と自機との当たり判定 == 1;//フラグが0のときにも実行されちゃう。
if(A && B)
{
敵のフラグ = 0;
}
}
前もって B という変数に当たり判定の演算結果を代入しました。
その時、フラグが 0 のときにも当たり判定をして、無駄が生じてしまいます。
何とかしてA , B で置き換えてかつ処理を省きたいです。
ということで以下のように入れ子のようにすれば解決します。
void Run()
{
bool A = フラグ == 1;
if(A)
{
bool B = 当たり判定 == 1;
if(B)
{
フラグ = 0;
}
}
}
上のように入れ子にしました。
A,Bという変数に代入したい場合はこのように処理の重いのは入れ子の形としていけばいいです。
これは処理の重い条件式だけにしてくださいよ。入れ子にしすぎるとプログラムが複雑になっちゃいますからね。
重い処理は分割せよ
ゲームの中の処理で、必ず毎フレーム呼ぶ必要がない処理というのがあります。
遅いシューティングの弾の当たり判定や AI のアップデートなどです。
たとえば処理の中の 20 %を占める処理があるとします。
これを 5 回に 1 回呼ぶとしますと20 / 5で1フレームの平均はわずか 4 %になってしまいました。
この処理をうまく使うとかなりの高速化が見込めます。
span class="emphasis">ですが
この場合だと重い処理と軽い処理のフレームが出てしまってフレームが安定しません。
ということで弾がたとえば 40 個あった場合だと 8 個ずつ当たり判定をしていきます。
void Run()
{
static int startpoint = 0;
int endpoint = startpoint + 弾の数 / 5;
for(int i = startpoint; < endpoint; i++)
{
当たり判定
}
if(endpoint == 弾の数)
{
startpoint=0;   
}
}
これで大抵の処理はうまくいきます。
ただしこの処理は弱点があるのはすぐに気づくでしょう。
弾が当たり判定をしてないときにキャラクタを通過したりといったことも起きてしまいます。
ですので、移動が遅い弾もしくは毎フレーム呼ばなくてもいいと思う所に適用するといいでしょう。
うまく使えばかなり有効な手段です。
標準数学関数は使わない
標準ライブラリの中に数学関数と言ったものがあるのはご存知だと思います。
例えばcosやsinといった関数です。
これらの関数はゲームの中では大変使う回数も多いです。
ですが、この数学関数はかなり重いです。
そこで対策としてはルックアップテーブルを使うといった方法もあります。
ですが、この場合はメモリも膨れますし、それにめんどくさいです。
そこでテイラー展開をつかってcos,sinを置き換えます。
それではcos,sinを置き換えたものをみてみましょう。
mysin(x) = x - x^3 / 6;//xは弧度法(PIを使った角度)です。
mycos(x) = 1 - x^2 / 2;
mylog(x)= x - x^2 / 2;
myarctan(x) = x - x^3 / 3;
以上のように置き換えることができます。tanはフーリエ級数展開はできませんので標準関数を使うしかないです。
注意しないといけないのはこの関数は正確な値ではないということです。ですが、範囲内は誤差はそれほど大きいものではありません。
これらの関数は-PI/2からPI/2の範囲が誤差がすくなくなります。範囲から出てしまった場合は
クランプする必要があります。
クランプとは値が範囲外であれば範囲内に矯正をするといったことです。
たとえば、PI * 3/2の場合は円で書けばわかるとおり-PI/2となります。
以下の図参照。
それではcosのクランプのプログラムを実装しましょう。
cosのクランプはy軸に対して対称であるために -PI / 2 から PI / 2 に簡単にクランプできます。
const float PI = 3.141592f;
void Cramp(float *x)
{
if(*x < -PI / 2)
{
int i = (int)( *x * -1 / (PI / 2));
*x += (PI / 2) / (i + 1);
}
else if(*x > PI / 2)
{
int i = (int)(*x / PI);
*x -= (PI / 2) / (i + 1);
}
}
このクランプ関数をMycosやMysinをする前に使ってください。PIというのは
正確には180.0f * PI / 180.0fを計算した値です。後はMyyCos?にクランプを適用します。
float MyCos(float x)
{
Cramp(&x);
return 1 -x * x / 2;   
}
これよりももっと高速な方法がGame Programing Gems1にあります。
Game Programing Gems様様ですね。
今までsin,cosの高速化について触れました。
ですが、最近は CPU 速度も上がって普通にcos,sinを使っても問題はないそうです。
なんだかねぇ。
高速化 - ゲームプログラミングWiki
