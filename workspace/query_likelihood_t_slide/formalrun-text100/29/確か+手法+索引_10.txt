
使い方はQUEとして使用します。 STATUS=0(待ち)の中から、PRIORITY,QUE_IDでソートした一番上の1つを取得したいと思い、以下のようなSQL文を書いています。 SELECT QUE_ID FROM    (SELECT QUE_ID FROM QUE_TBL WHERE STATUS=0       ORDER BY PRIORITY, QUE_ID) WHERE ROWNUM=1 40万件のレコード数でも、それなりの検索スピードを出したいのですが、どういったSQL文、どういったインデックスなどが有効でしょうか? DBはOracle9 Standard CPU XEON3.06GHz x 4のHYPER THREAD MEM 4GB 以下のようなテーブルを作成しています。 オプティマイズはしていません。 デフォルト設定で特にインストール時などにカスタマイズしていません。 QUE_TBL---------- QUE_ID         VARCHAR2(20) (プライマリーキー) REGISTER_DATE  DATETIME STATUS         NUMBER(4) PRIORITY       NUMBER(4) 以下にインデックスを張っています。(逆などの指定はありません) REGISTER_DATE / STATUS / PRIORITY / PRIORITY, QUE_ID QUE_ID   20桁の文字列でIDがついています STATUS   状態が入っています  0:待ち  1:実行中  2:済み  -1:エラー PRIORITY 優先度が入ってます  3:優先  5:通常  7:低い
> 使い方はQUEとして使用します。> STATUS=0(待ち)の中から、PRIORITY,QUE_IDでソートした一番上の>1つを取得したいと思い、以下のようなSQL文を書いています。> SELECT QUE_ID FROM>    (SELECT QUE_ID FROM QUE_TBL WHERE STATUS=0>       ORDER BY PRIORITY, QUE_ID) WHERE ROWNUM=1> 40万件のレコード数でも、それなりの検索スピードを出したいのですが、>どういったSQL文、どういったインデックスなどが有効でしょうか?>>> DBはOracle9 Standard> CPU XEON3.06GHz x 4のHYPER THREAD> MEM 4GB>> 以下のようなテーブルを作成しています。> オプティマイズはしていません。> デフォルト設定で特にインストール時などにカスタマイズしていません。> QUE_TBL----------> QUE_ID         VARCHAR2(20) (プライマリーキー)> REGISTER_DATE  DATETIME> STATUS         NUMBER(4)> PRIORITY       NUMBER(4)>> 以下にインデックスを張っています。(逆などの指定はありません)> REGISTER_DATE / STATUS / PRIORITY / PRIORITY, QUE_ID>> QUE_ID   20桁の文字列でIDがついています> STATUS   状態が入っています>  0:待ち>  1:実行中>  2:済み>  -1:エラー> PRIORITY 優先度が入ってます>  3:優先>  5:通常>  7:低い40万件って最大件数ですか?STATUSが済みでも存在しているのですか?実行計画を確認するのがいいのではないでしょうか。PRIORITY / PRIORITY, QUE_IDはPRIORITY, QUE_IDだけでいいんじゃないでしょうか。挿入時の性能は索引が多ければマイナスになりますよ---deanna
Oracle Technology Network (OTN) Japan - 掲示板 : インデックスの張り方?(高速化手法) ...
