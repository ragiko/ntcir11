
再帰ドリル(11):二分探索木(探索と挿入)
今回は、二分木を探索木として使う方法を考える。
二分木
二分木の定義としては、以下の一般的な定義を使うことにする。
この定義は以下のような意味を持つ。
葉(Leaf)は値を格納しない
節(Node)は、左の木、値、および、右の木を格納する
このように木は再帰的な構造を持つので、再帰的な処理が適している。
節を、葉をで表現し、いくつかの木を図示してみよう。
左から右へ、それぞれ要素数(木の大きさ)が0から4の木の例である。要素が1個以上の場合、葉を書くのは冗長であるから、これ以降不要な場合は描かない。
二分木とリスト
8章で調べたリストの定義と二分木の定義を比べてみよう。
List と Tree の定義はほとんど同じで、自分自身を1つ格納するか、2つ格納するかの違いしかないことが分かる。
実際、二分木も一方向にだけ伸びれば、リストと変わらなくなる。
このような木は、実用上好ましくない。木を使うのは、あらゆる節へ少ない手間で到達したいからである。そのためには、葉の深さをなるべく同じに揃える必要がある。ある基準において、すべての葉の深さが「同じぐらい」と見なせるとき、木は平衡(バランス)しているという。
探索木
探索木とは、要素がソートされて格納されている木のことである。二分探索木の場合を考えてみよう。ある節には、左の木、要素、右の木が含まれている。二分探索木となるには、次の条件を満たす必要がある。
左の木に含まれるすべての要素が「この要素」より小さい
右の木に含まれるすべての要素が「この要素」よりも大きい
この条件は、ある節で満たされればよい訳ではなく、すべての節で満たされる必要がある。以下に例を示す。
他の種類の木と同様、探索木も平衡を保つことが肝要である。平衡を保つ機構を持った二分探索木は、平衡二分探索木と呼ばれる。有名な例に、赤黒木、AVL、および、重み平衡木がある。
今回扱うのは単なる二分探索木であって、平衡二分探索木ではない。
表示
Haskell で data を使いデータ型を定義すると、それがそのままリテラルとして入力に使える。すなわち、パーサが自動的に生成される。また、deriving Show を付けると、リテラルが出力に表示されるようになる。(すなわち、パーサの逆関数であるプリティプリンタが自動的に生成される。)
実は、最初の図に描いた5つの木は、二分探索木である。これらをリテラルで表現してみよう。空の木は Leaf である。以下を ghci で入力して欲しい。
> Leaf
Leaf
要素数が1つの木は、次のように表現できる。
> Node Leaf 5 Leaf
Node Leaf 5 Leaf
要素数が 5 つの木まで入力してみよう。
> Node (Node Leaf 3 Leaf) 5 Leaf
Node (Node Leaf 3 Leaf) 5 Leaf
> Node (Node Leaf 3 Leaf) 5 (Node Leaf 8 Leaf)
Node (Node Leaf 3 Leaf) 5 (Node Leaf 8 Leaf)
> Node (Node Leaf 3 (Node Leaf 4 Leaf)) 5 (Node Leaf 8 Leaf)
Node (Node Leaf 3 (Node Leaf 4 Leaf)) 5 (Node Leaf 8 Leaf)
入れ子が深くなると見にくくなるので、以下のような可視化関数を用意しておく。
recursion-drill/11.md at master 揃 kazu-yamamoto/recursion-drill 揃 GitHub
