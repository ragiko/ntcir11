
ソートと探索(ヒープソート1)
木構造による探索
以前、データ構造を学習した際に「木構造」を取り上げました。
「木」は、もともと枝分かれしたものを表現するのに適したデータ構造です。
節にデータを置くことにすれば根から葉に向かってたどる経路が探索のプロセスを表していると考えることができます。
ですから、節に置いたデータと探索キーを比較しながら、根から葉に向かってたどっていけば、探索が実現できるはずです。
木構造を利用した探索アルゴリズムには、二分探索木
、AVL木、B木など数多くありますが、ここでは最も基本となる二分探索木について勉強しましょう。
二分探索木とは
木構造の一種として、二分木というものがありましたが、これをもとにして探索を行うのが
二分探索木(binary search tree)です。
二分探索木とは、二分木の各節に要素(データ)を持たせたもので、任意の節xについて、左部分木に含まれる要素は節xよりも小さく、右部分木に含まれる要素は節xよりも大きい
という関係が成り立っています。二分探索木とはどのようなものかを実際に見てみましょう。
右の図(a)と(b)は、いずれも7つの要素2,5,6,7,13,15,21を持った二分探索木です。
一般に、あるデータの集合を表現する二分探索木はいくつも存在します。
二分探索木の形は、要素を挿入する順番によって決定されます。
二分探索木の操作
二分探索木を利用した探索の手順は次のようになります。
まず最初に、根の要素xと探し出したいキーの値kとを比較します。
もし、k=xなら探し出したい要素は根に存在していて、探索は成功したことになります。
kxならば、値kを持つ要素が存在するとしたら、二分探索木の性質からその要素は左部分木に含まれているはずです。
また、k>xであるならば、値kを持つ要素は(存在するとすれば)右部分木に含まれるはずです。
つまり、kxなら左の子へ、k>xなら右の子へ進みます。
また、進むべき子が存在しない&mdash;&mdash;つまり「行き止まり」に突き当たった&mdash;&mdash;のなら、キーの値を持つ要素は存在しない(探索が失敗した)ことになるので、この時点で処理を打ち切ります。
この手順を、キーの値を持つ要素が見つかるか、「行き止まり」に突き当たるまで繰り返します。
では、このアルゴリズムに従って、上の図(a)と(b)それぞれにおいて、キーが7のデータを探索してみましょう。
(a)の場合、
13  5  7
とたどるのに対し、
(b)の場合は
6  21  15  13  7
とたどり、ともに探索に成功しましたね。このように、二分探索木の性質さえ満足していれば、その木がどんな形をしていても、探索が行えます。
このアルゴリズムでは、木の節をたどりながらキーとデータの大小を判定して探索を行います。
ですから、その計算量は探索が成功(または失敗)するまでに立ち寄った節の数で表現されると考えられます。
つまり、二分探索木を利用した探索アルゴリズムでは、計算量はその「枝ぶり」に依存する
ことになります。
二分探索木の性質
二分探索木の特徴について考察してみましょう。
二分探索木では、探索、挿入、削除の3つのどの操作についても、根から始めて木をたどって、しかるべき位置を探し出します。
つまり、挿入、削除を行うにも、まず探索をして挿入する位置、削除の対象を決めなければなりません。
ですから、二分探索木の処理の計算量は、探索の計算量に帰結されると考えてよいでしょう。先ほども考察したように、探索の計算量は木の枝ぶりによって大きく変化します。
直感的に考えて、木が低くて枝分かれしている方が探索は高速になります。
下の図(a)と(b)、2つの二分探索木を比較してみましょう。
(a)のように、根から最も遠い葉までの経路の長さと、根から最も近い葉までの経路の長さの差が1以下である二分木を完全二分木といいます。
n個の要素をもつ完全二分木は、根から節への経路の長さはlog2
n+1以内に収まります。
また、このとき根から節への経路の平均長はO(logn
)となるますから、探索もO(logn)で行えることになります。
これに対して(b)も同じ集合を表す二分探索木ですが、要素が1列に並んでいるので、この木を探索することは線形探索を行うことと同じです。
平均するとn/2個の節をたどる必要がりますから、探索の計算量はO
(n)になってしまいます。
この欠点を解消するには、挿入と削除を行うときに、木の形をなるべく完全二分木に近くなるようにします。
このような木を一般に平衡木(baranced tree)と呼びます。探索木の整列への応用
これまでに取り上げたバブルソート、選択ソート、挿入ソート、シェルソート、クイックソート、マージソートは、いずれもデータの並びに注目して整列処理を行うアルゴリズムです。
これらのアルゴリズムは、データを配列や連結リストの形式で保持しながら整列処理を行います。
ここで、データが一列に並んでいることを忘れて、別の方向からアプローチしてみましょう。
具体的には、探索木を利用して整列を行うことを考えてみます。
アルゴリズムはこのようになります。
sort(int a[], int n)
{
int i;
/* すべての要素を探索木に挿入する */
for ( i = 0; i ここで、関数sortは、2つのパラメータaとnを受け取ります。
パラメータaは、整列すべき配列(の先頭要素)へのポインタ、nはその配列に含まれる要素の個数です。
この関数sortは、
要素を挿入する(insert)
最小のキーをもつデータを取り出す(delete_min)
という2つの操作を行っています。
まず最初にinsertによってすべての要素を登録します。
次にdelete_minを使ってキーの小さい順に要素を順に取り出して配列に戻していきます。
delete_minは、その時点でキーが最小の要素を削除して、それを返すという操作です。
delete_minを繰り返し行えば、キーの昇順に要素を得ることができます。このアルゴリズムは、n回実行される2つのループを含んでいます。
探索木では、操作insertとdelete_minをO(logn)で実行することができます。
もちろん、単なる二分探索木では運が悪いとO(n)になってしまうので、平衡木を用いる必要があります。
例えば、AVL木やB木のような平衡木を使えば、insertとdelete_minを常にO
(logn)で実行することができます。
したがって、平衡木を利用すれば常にO(nlogn
)で整列が可能なことになります。
これは、平均的にはO(nlogn)でも最悪の場合にはO
(n2)になるクイックソートと比べると大きな利点だといえます。
半順序木
平衡木を使えば整列を行うことができるのは勿論ですが、実はこれはもったいない
やり方と言えます。
なぜなら、整列に必要な操作はinsertとdelete_minだけで、探索木の本来の目的である「キーを指定して要素を探索する」機能は必要ないからです。
つまり、平衡木を使うのでは、いくら計算量がO(nlogn
)で収まるといっても、ムダが多い(=定数係数が大きい)のです。そこで、半順序木
というデータ構造を用います。
半順序木とは、すべての節に関して「親の値は子の値より大きくない(つまり、親は子より小さいか、等しい)」
という条件が満たされている二分木です(一般的な多分木でもかまいませんが、ここでは二分木に限って話を進めます)。
半順序木では、子ども同士の間に大小関係が規定されていないので、その分、処理の手間が省けます。
実際に半順序木の例を見てみましょう。
右の図(a)に注目してください。
効率よく処理するために、半順序木では、できるだけ木をバランスが取れた状態に保つようにします。
具体的には、根から最も離れた葉と最も近い葉への経路の長さの差が1以下になるようにします。
また、最下段の葉は左寄りに詰めておきます。
このようにすれば、n個の要素を持つ半順序木の高さはlog2
n程度に収まります。
ではまず、操作delete_minについて考えましょう。
最小の要素を見つけるのはとても簡単で、「親の値は子の値より大きくない」という条件から、根が最小になるのは明らかです。
右の図(a)では、5が最小の要素になります。
むしろ、どのようにして条件を満たしつつ、根の要素を取り除くかが問題です。
まず、根の要素を取り除き、その代わりに最下段の一番右の要素を根に移します。
図の(a)の状態から根の要素5を取り除き、その代わりに要素20を根に移すと、(b)のようになります。
しかし、このままでは「親の値は子の値より大きくない」という条件が満たされなくなります。
そこで、根の要素をその2つの子のうち小さい方の子と交換します。
(b)では、根の2つの子はそれぞれ9,15なので、このうち小さい方の9と根の20を入れ換えて、(c)のようになります。
この状態でも、要素20は子12,13よりも大きいので、要素20と12を交換して(d)になります。
ここでも要素20は一方の子17より大きいので、要素20と17を入れ換えて、最終的に(e)の状態になります。
(e)は再び半順序木の条件を満たしています。このように、「親のほうが子よりも大きいなら、子の小さいほうと親を交換する」という手順を繰り返すことによって、半順序木の条件を保つことができます。
この例では、要素20は葉に到達するまで沈みましたが、もし途中の段階で「親の値は子の値より大きくない」という条件が満たされれば、そこで処理を打ち切ります。
操作delete_minでは、根から葉に向かって要素を交換していきます。
先ほど触れたように、木の高さはだいたいlog2n
程度ですから、平均すると約log2n/2回くらい交換が行われることになります。したがって、操作delete_minの1回あたりの計算量は
O(logn)になります。
ソートと探索(ヒープソート1)
