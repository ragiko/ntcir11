
【PARTHENON解説書の目次に戻る】
4. 回路接続とセル・ライブラリの記述言語
4.1 ネットリスト記述言語−NLD言語
4.2 セル記述言語−PCD言語
4.3 セルライブラリの作り方
4.4 論理セルの一覧
【SFL】
SFL言語には,マシン・サイクルという概念を除くとハードウェアのにおいがありません.実際の論理回路の設計で問題となる「論理の簡単化による回路の削減」や「クリティカル・パスの遅延時間短縮による高速化」,それに「クロックのハザードやスキュー」,「ゲートのドライブ能力」,「レジスタのセットアップ時間やホールド時間」といった問題は,いったいどうなっているのでしょうか.
じつは,PARTHENONのシステムでは,実際の論理回路設計の大部分を占めていた「こうした根気のいる作業のための情報」は,SFL言語とは別の言語(NLD言語とPCD言語)の中に閉じこめているのです.つまり,SFL言語は,人間の高度な(抽象度の高い)思考を表現することにのみ使用するように作られています.
では,SFLとは別に用意された二つの言語は,
NLD言語:実回路の接続構造
PCD言語:構成要素の負荷容量,遅延時間などの物理的特性
をそれぞれ表現する役割をもっています.これらの言語と回路最適化プログラムOPT_MAPにより,特定の製造メーカのセル・ライブラリに合わせた実回路情報を生成することができます.
本章ではまず,NLD言語とPCD言語を説明し,次にこれらによって特定の製造メーカのセル・ライブラリを表現する方法を述べます.
4.1  ネットリスト記述言語  NLD
NLDと等電位表現
NLD (Net  List  Description) は,PARTHENONのネットリスト記述言語です.ネットリストとは,「何と何が接続されているか(ネット)の一覧表(リスト)」ということです.
NLDでは,「接続されている端子をすべて並べて表す」形式を採用しています.これを等電位表現といいます.例を見てみましょう.図4.1 に示した回路をNLDで表現すると,
1:  (def-module test
2:      (def-pin abc type input)
3:      (def-pin def type input)
4:      (def-pin xyz type output)
5:      (def-pin uvw type output)
6:      (def-comp and--2 and-1)
7:      (def-net abc and-1.in1)
8:      (def-net def and-1.in2)
9:      (def-net uvw xyz and-1.out)
10:  )
となります.
<図4.1>  簡単な回路例
6行目の (def-comp and--2 and-1) は, and--2 というモジュール(部品種)名の部品を構成要素として,and-1 というサブモジュール(固有)名で使うことを表します.
モジュール,サブモジュールの概念は SFL の場合と同じです.
9行目の(def-net  uvw  xyz  and-1.out)は,外部端子の uvw と xyz そして and-1 の out という端子がすべて接続されていることを表しています.
以下は BNF形式による NLD言語の定義です.
全体の構成
全体の構成は,
NLD記述 ::=
(def-module モジュール名
{外部端子の定義}
{構成要素の定義}
{ネットの定義}
)
のようになります.
NLD記述 に現れる各種の名前には,文字として'a'-'z','A'-'Z','0'-'9','_','-','[',']'しか使えません(先頭の 1文字は 'a'-'z','A'-'Z' にかぎる).注意すべきことは,モジュール名 とNLD記述 を格納するファイル名(モジュール名.nld)との対応がとれなければならないということです.たとえば,(def-module test ....) では,ファイル名は test.nld でなければなりません.一つのファイルに一つのモジュールしか記述することはできません.
なお,NLD記述 のコメントは,; 以降行の終わりまでです.
外部端子
モジュールの外部端子は,以下のように定義します.
外部端子の定義 ::= (def-pin 外部端子名 [type 端子タイプ])
端子タイプ ::=
input
| input-connected
| output
| output-connected
| bidirect
| bidirect-connected
| tristate
| tristate-connected
| global
| unused
| unused-connected
この端子タイプ は,人間やPARTHENON外部のプログラムに情報を提供するためのものです.
端子タイプの表し方には,
端子タイプ生成方式
端子タイプ保存方式
の二つがあります.
端子タイプ生成方式
端子タイプ生成方式となるのは,OPT_MAPから writeコマンド,lastコマンドによりNLDファイルを出力した場合で,global を除くすべての端子タイプは,回路の構造から表4.1 のように生成されます.
<表4.1>  回路構造から生成される端子タイプ
端子タイプで  -connected は,その外部端子が他の外部端子に接続されていることを示します.たとえば,unused-connected は,内部では使われていない二つ以上の外部端子がたんに接続されているだけの場合です.端子タイプが global である外部端子は VDD と VSS のみです.
端子タイプ生成方式の場合には,SFLで記述した input や output が ....-connected となってしまうことがあります.たとえば,
module test {
input abc ;
output xyz;
xyz = abc;
}
を論理合成する際に,OPT_MAPの writeコマンドや lastコマンドを用いると,最後は abc,xyz ともに unused-connected となってしまい,入力と出力の区別はなくなってしまいます.「何か変だ」と思われるかもしれませんが,これは等電位表現の宿命です.この例では,abc と xyz は等電位で方向はありません.
端子タイプ保存方式
一方,OPT_MAPから, write_org_typeコマンドあるいは last_org_typeコマンドでNLDファイルを出力した場合には,端子タイプ保存方式となり,トップ・モジュールの外部端子に対しては,OPT_MAPが読み込んだ時点の端子タイプがそのまま保存されます.ただし VDD と VSS が追加されることがあります.
内部のモジュールに対しては,論理圧縮により回路の構造が変わってしまうので,端子タイプは保存できず,回路の構造から端子タイプが生成されます.
なお,SFLEXP (正確にはHSL_NLD)が出力するNLDでは,SFLでの端子タイプが保存されます.このNLDでは端子タイプは次のように定義されます.unused,tristate,global,-connected は使われず,SFLでの input端子は input に,output端子は output に,bidirect端子は bidirect になります.
autoコマンドで,celldemoライブラリを用いて出力される論理合成の結果は,端子タイプ保存方式となっています.
構成要素
構成要素は,
構成要素の定義 ::= (def-comp モジュール名 {サブモジュール名})
のように定義します.構成要素を定義せずにネットの中で使うことはできません.
ネット
何と何が接続されているかを示すネットは,
ネットの定義 ::= (def-net {接続端子})
接続端子 ::= 外部端子名
| サブモジュール名.端子名
のように定義します.一つの等電位は「1個のネット文」で表現されなければなりません.たとえば,
(def-net a b)
(def-net b c)
はエラーとなります.このような場合は,
(def-net a b c)
としてください.
4.2  セル表現言語  PCD
PCD (Physical  Characteristic  Description) 言語は,論理回路の最下位要素(セル)を表現するための言語です.まず簡単な例を見てみましょう.リスト4.1 は 2入力の nandゲートの PCD記述です.外部端子のタイプ (type) や負荷容量 (load),シンボルの形や,セルの機能,そして遅延やドライブ能力が定義さているのがわかります.
<リスト4.1>  2入力nandのPCD記述
(def-module nand--2 power 4 area 1.10592 gates 1
(def-pin  in1  type input  load 0.10)
(def-pin  in2  type input  load 0.10)
(def-pin  nout type output load 0.09)
(def-symbol  NAND in1 in2 nout)
(def-function  ^nout (and in1 in2))
(def-delay  /in1 /nout (+ 0.5 (* 4.1 ~nout)))
(def-delay  /in2 /nout (+ 0.5 (* 4.1 ~nout)))
(def-delay  %in1 %nout (+ 0.5 (* 4.1 ~nout)))
(def-delay  %in2 %nout (+ 0.5 (* 4.1 ~nout)))
(def-constraint  drive (- 0 ~nout) type max)
)
全体の構成
全体の構成は,次のようになります.
PCD記述 ::=
(def-module モジュール名 {属性}
{各種の定義}
)
各種の定義 ::=	  外部端子の定義
| シンボルの定義
| 機能の定義
| 遅延の定義
| 制約の定義
| ...
属性 ::=	  power 値
| area 値
| gates 値
| cell_name セル名
値 ::=	 +12.333|0.23|.12|2|2e5|2E3|+.1e3|etc.
モジュール名 はPARTHENONでの部品種名です.ほとんどの場合,LSI製造メーカが提供するセルの名前をモジュール名 としますが,異なる名前にしなければならない場合もあります.詳細はセル名 の項を見て下さい.
NLD言語と同様,モジュール名 とPCD記述を格納するファイル名(モジュール名.pcd)との対応がとれている必要があります.PCD記述 に現れる各種の名前は,文字として 'a'-'z','A'-'Z','0'-'9','_','-','[',']' しか使えません(先頭の 1文字は 'a'-'z','A'-'Z' に限る).
属性 の power,area,gates は,セルの消費電力,面積,換算ゲート数です.OPT_MAPは,これらの値を集計したり,値の大きさでセルをソートして表示するためだけに使用します.単位は必要とされません.ライブラリを作成するときに単位を統一しておけば十分です.celldemoライブラリのセルに記述された,power,area,gates の単位は,それぞれμW/MHz,1000μm2,ゲートです.回路の変換時にはこれらの値は使われませんので,どのような値でも結果の回路に影響しません.省略時これらの属性 の値は 0 とみなされます.
値 は負であってはなりません.値 における 0 は 0.00 などとせず,たんに 0 としてください.
なお,PCD記述 のコメントは,; 以降行の終わりまでです.
セル名
セル名 は,同一のセルに対して,PARTHENONとしての部品種(モジュール) を複数定義する場合に使用します.
たとえば,同じラッチをマスタ・ラッチとスレーブ・ラッチとに使い分ける場合,クロックの波形にもよりますが,一般にマスタ・ラッチの出力はクロック・パルスの後縁で安定すると考えるのに対し,スレーブ・ラッチの出力はクロックパルスの前縁から安定すると考えます.このような場合,遅延式も制約式も表現が異なるので,別のモジュールとしておかなければなりません.そして,この二つのモジュールのセル名 を,本来のラッチを示す同一のセル名 にします.この区別はOPT_MAPを終了するまではずっと維持されなければなりません.
OPT_MAPから,lastコマンドあるいは last_org_typeコマンドでネットリスト(NLDファイル)を出力すると,ネットリストの構成要素の定義 におけるモジュール名 には,PCD記述 のセル名 で定義された名前が使用され,先の区別はなくなってしまいます.このNLDファイルを再びOPT_MAPに読み込んで回路の操作を行ってはなりません.このような理由でlast (最後) というコマンド名になっています.
一方,writeコマンドあるいは write_org_typeコマンドでNLDファイルを出力すると,ネットリストの構成要素の定義 におけるモジュール名 には,PCD記述 のモジュール名 で定義された名前が使われます.この場合は,先の区別が残りますので,再度 OPT_MAPに読み込んで回路の操作を行うことができます.
cell_name の指定を省略した場合,セル名 はモジュール名 と同じとみなされます.
各種の定義
各種の定義 は,
(キーワード .....)
という形式をしています.PCDファイルを読み込む各プログラムは,必要のないキーワードの定義を読みとばすように作られています.現在,各種の定義 で使われているキーワードと,それを利用するプログラムとの関係を,表4.2 に示します.
<表4.2>  各種の定義とその利用プログラム
注:表中の,TPGはワークステーション版のPARTHENONに含まれるプログラムであり,またsymbol-mapとdef-logicについては本書では説明していない.
外部端子
外部端子の定義 は,以下のとおりです.
外部端子の定義 ::= (def-pin 外部端子名 {端子の属性})
端子の属性 ::=	  load 負荷式
| type 端子タイプ
| note 注
負荷式 ::=  (+ {負荷式1})
| 負荷式1
負荷式1 ::= (* 値 [負荷式2])
| 負荷式2
負荷式2 ::= 値|変数
変数 ::= ?名前
端子タイプ ::=	  input
| output
| bidirect
| tristate
| unused
注 ::=	  clock
| scan_in
| scan_enb
| scan_out
load は,この端子単独の負荷容量 (キャパシタンス) で,省略時は 0 とされます.
type は省略できません.note は省略時,未定義とされます.load は,power,area,gates と同様,単位は必要とされませんが,ライブラリを作成するときには単位を統一しておく必要があります.
celldemoライブラリのセルに記述された load の単位は pF です.
変数 は,あとから値が設定される外部変数を意味します.たとえば ?temperature で温度を表す変数を導入し,端子の負荷容量を温度依存にすることができます.?temperature の値は,OPT_MAPで回路を操作する時点で設定します.
端子タイプ の unused は,端子としては存在するが,使われないことを示します.bidirect は,3ステート出力であるだけでなく信号の方向が双方向であることを表します.端子タイプ は,端子の電気的特性と信号の向きを表しています.
note による clock属性の指定は,「ハザードが発生しないこと,または発生してはいけないこと」を示します.たとえば,レジスタのクロック入力など,タイミングを決める信号を入力する端子には clock属性を必ず指定しなくてはなりません.clock属性は入力端子に対してのみ意味を持ちます.
OPT_MAPでは,クロック・パルスが 1個到達する条件である,
「不定イベントが到達せず,立ち上がりイベントと立ち下がりイベントへがそれぞれ一個到達するネットワークの構造であること」
によって,clock属性の条件が満足されているかをチェックします.この条件が満足されていなければ,OPT_MAPによる回路の操作はできません.
注: scan_in,scan_enb,scan_out の属性は,ワークステーション版PARTHENONに含まれるテスト・パターン生成プログラムが使用する.本書では説明しない.
シンボル
シンボルの定義 は,以下のように行われます.
シンボルの定義 ::= (def-symbol シンボル 端子リスト)
シンボル ::= AND|NAND|OR|NOR|EXOR|NEXOR|INVERTER|BUFFER
|TRI_STATE|TRI_STATE1|TRI_STATE2|TRI_STATE3|REGISTER
|AOI21|AOI211|AOI22|AOI221|AOI222|AOI31|AOI32|AOI33
|OAI21|OAI211|OAI22|OAI221|OAI222|OAI31|OAI32 |OAI33
端子リスト ::= {入力端子名} {出力端子名}
シンボルの定義 は,NLD_PSによって回路図を作成する場合にのみ用いられ,回路合成には影響しません.
シンボル は,回路図上のモジュール(部品種) の形を示すものです.このうち,TRI_STATE1,TRI_STATE2,TRI_STATE3 は,それぞれ反転出力,制御反転入力(制御入力が 0 のとき駆動状態),出力制御入力とも反転の 3ステートを意味します.AOIは and-or-inv の複合ゲート,OAIは or-and-inv の複合ゲートです.複合ゲートの名前の意味は,
AOI32:	(INV (OR (AND in1 in2 in3) (AND in4 in5)))
AOI211:	(INV (OR (AND in1 in2) in3 in4))
から類推できると思います.
端子リスト は,名前とタイプが外部端子の定義と整合している必要があります.回路図上は,シンボルの左側に入力端子が,右側に出力端子が配置されます.また,入力端子,出力端子共に,端子リストに並べられた順に図形の上方から配置されます.なお.bidirect,tristate は出力端子の扱いとなります.
機能
OPT_MAPはSFLEXPが出力する論理セルのみによって構成された回路を,種々の物理的制約違反を解決することで,実セルのみによって構成され物理的に正しく動作する回路へと変換していきます.この時,OPT_MAPは機能の定義 によってセルの論理的な機能を知り,論理的な意味を変更しないよう回路を変更します.機能の定義 は以下のとおりです.
機能の定義 ::= (def-function 出力 機能式)
出力 ::=  出力端子名
| ^出力端子名
機能式 ::=  (演算子 {機能式})
| 入力
演算子 ::= 名前
入力 ::=  入力端子名
| ^入力端子名
^ は not を表します.^ と以下の演算子 は予約語であり,その意味がOPT_MAPに組み込まれています.
(and f1 f2 ...)
(or f1  f2 ...)
(eor f1 f2 ...)
(buffer f1)
(clock_buf f1)
(true)
これらについては,文字どおり意味を知って,すなわち場合によっては論理圧縮を行いながら(ただし,clock_buf は論理圧縮の対象とはならない)回路を変更していきます.true は恒真ということで "1" や "0" の定数を表現するために使います.
OPT_MAPは,意味が組み込まれていない演算子 であっても,機能式の形が同じで端子の対応関係が同一であれば論理的に等価であるものと判断して,物理的条件から必要であれば交換します.これをパターン・マッチングによる交換とよびます.
予約されていない演算子 と機能式 は,セットアップ時間,ホールド時間の定義の仕方や遅延の伝搬パスなど,そのモジュールの定性的な特性を代表するものでなければなりません.
同じセルに対し複数の使い方がある場合は,それぞれ別のモジュールとすることは前に述べましたが,使い方の違いは演算子 と機能式 に集約されていなければなりません.
モジュール名 は,セル名 とその使い方を指定した名前ということができます.もし全てのセルに 2通りの使い方があれば,モジュール名 の数はセル名 の数の 2倍となります.
OPT_MAPのつくりから現在,次の制約があります.複数の機能表現が可能なときは,いずれかの表現で統一してください.予約されていない演算子 では機能式 がネスティングしないように記述してください.
遅延
遅延の定義 はモジュールの入力端子から出力端子へどのようにイベント(変化)が伝わるかを定義するものです.OPT_MAPはこの情報とモジュールの接続関係によりタイミング上の問題がないかを判定します.その形式は以下の通りです.
遅延の定義 ::= (def-delay スタート エンド 遅延式)
スタート ::= イベント
エンド ::= イベント
イベント ::=  /端子名		/* 注:立ち上がりのイベントの場合 */
| \端子名		/* 注:立ち下がりのイベントの場合 */
| %端子名		/* 注:不定(ハイ・インピーダンス)になるイベントの場合 */
遅延式 ::=  (+ {遅延式1})
| 遅延式1
遅延式1 ::= (* 値 [遅延式2])
| 遅延式2
遅延式2 ::= 端子の負荷
| 変数
| 値
端子の負荷 ::= ~端子名
この形式ではスタートからエンドまでの遅延が遅延式 で表される内容であることを示します.遅延式 の値 は負であってはなりません.
立ち上がり,立ち下がりはハイ・インピーダンスから "H" レベルあるいは "L" レベルなる場合を含みます.また,立ち上がり,立ち下がりは機能の定義 とは無関係に,その端子の電位の変化を意味します.機能の定義 との矛盾はチェックされません.
遅延式 の + は和を表します.たとえば,(+ 2 3 4) は 9 です.(+ ) のように足すべき要素がない場合は, 0 とされます.遅延式1 の * は積を表します.たとえば,(* 2 4 3) は 24 です.(* 3.0) のように掛ける要素が 1個の場合は 0 とされます.
端子の負荷 (すなわち ~端子名) は,その端子につながった負荷の合計値 (その端子自身の負荷を含む) を意味します.したがって,その値は,ネットリストを読み込むまでは決定できません.
前に説明したように,clock属性をもつ端子では,
「不定イベントが到達せず,立ち上がりイベントと立ち下がりイベントへがそれぞれ 1個到達するネットワークの構造である」
ので,その値は,
"H"から"L"になってまた"H"になるか,
"L"から"H"になってまた"L"になるか,
という変化しかしません.したがって遅延を知れば波形を知ることができます.
一方,clock属性をもたない端子には,
"H"から"L"になる遅延のパス(経路)が複数個ある
"L"から"H"になる遅延のパスが複数個ある
ある時点以降不定になることがある
わけですから,その値は"H"と"L"の間を何回か振動する可能性をもつことになり,遅延を知っても波形を知ることはできません.わかるのは,十分に時間がたったあとで,その値が"H"か"L"かどちらかに安定し,場合によっては,さらに,そのあと不定になるということだけです.このことが clock属性をもつかもたないかの違いです.
一般に,レジスタなどのクロック端子ではその波形が問題とされ,データ端子ではクロック投入時の値が問題とされますので,クロック端子では clock属性を指定し,データ端子では clock属性を指定しないようにします.
また,clock属性をもつ遅延のパスでは,各端子での立ち上がりと立ち下がりを明確に区別する必要がありますが,clock属性をもたない遅延のパスでは,立ち上がりと立ち下がりを明確に区別する必要はありません.そこで,精度は落ちますが,遅延評価の速度を上げるため,または,セル・ライブラリの作成を簡単にするために,clock属性をもたない遅延のパスに対しては,立ち上がりイベントで,立ち上がりイベントと立ち下がりイベントの両方を代表させることもできます.
celldemoライブラリのセルに記述された遅延の単位は ns です.
このライブラリの遅延の定義 の例を示します.
(def-delay /a1 /zn (+ 0.5 (* 4.1 ~zn)))
は,「入力端子 a1 に信号の立ち上がり変化が入力されてからその影響が出力端子 zn に信号の立ち上がり変化として現れるまでの時間が,固定分 0.5 (ns) と出力端子 zn に接続されるネットの負荷容量に比例する値の和で表わされ,その比例定数が 4.1 (ns/pF) である」という意味です
制約
制約の定義 では,満足されるべき条件を示します.OPT_MAPはこの情報により回路が物理的に正しいかを知り,制約違反がある場合は必要な変更を行います.OPT_MAPでは仮想セルも実セルも全て同様に扱われます.仮想セルが実セルに変換されるのは,仮想セルには満たすことのできない制約条件が記述されているからです.
制約の定義 は,以下の形式で行います.
制約の定義 ::= (def-constraint 制約名 制約式 [type 制約タイプ])
制約式 ::=  (- {制約式1})
| 制約式1
制約式1 ::= (+ {制約式2})
| 制約式2
制約式2 ::= (* 値 [制約式3])
| 制約式3
制約式3 ::= 端子の負荷
| イベント
| 変数
| 値
制約タイプ ::= 制約タイプ名
制約式 の値が最悪の場合でも負でないことを要求するというのが制約の内容です.制約名 はユーザが定義する任意の名前で,OPT_MAPからの状況表示に使われます.ただし端子名と同一の名前であってはなりません.
制約式 の - は差を表します.
(- a b c ...)
では,最初の要素の値から 2番目以降の要素の値を引きます.たとえば,(- 10 2 3) は 10−2−3 で 5,(- 5) は 5−0 で 5,(-) は 0−0 で 0 です.
制約式3 のイベントはそのイベントの値 (時刻) を意味します.もちろんその値はこの制約が記述されたPCDモジュールが回路のどこにあるかによって変わってきます.clock属性を持たない端子へのイベントは一般には複数個到達すると考えられますが,OPT_MAPはその中でもっとも早いものと遅いものに着目しています.制約の評価では式の値をより小さくする方を選びます.
OPT_MAPは,特定の制約タイプ に対して,表4.3 に示すような回路の変更を行います.
<表4.3>  制約タイプと回路変更の方向
制約タイプ が指定されていない場合は,制約違反の報告のみを行い回路の改良は行いません.
制約の定義例
制約の定義 の例として,エッジ・トリガ・タイプのレジスタのセットアップ時間とホールド時間をPCD言語で表現してみましょう.
<図4.2>  レジスタのセットアップ時間,ホールド時間制約
図4.2 に示すように,レジスタA の内容を組み合わせ回路C で処理して結果をレジスタB へ書き込むものとします.
(1)のクロック信号により,レジスタA の出力が更新されます.この変化は,組み合わせ回路C を伝播して行き,レジスタB の入力まで到達します.この伝播のなかで,もっとも遅いものがレジスタB へ到達してから (4)のクロック信号までの時間が,セットアップ時間より長ければセットアップ時間の要件は満たされます.
一方,(2)のクロック信号により,レジスタA の出力はさらに更新されるので,この変化も組み合わせ回路C 内を伝播し,レジスタB の入力へ到達します.この伝播のなかで,もっとも速いものが (4)のクロック信号からホールド時間以内に到達すると,ホールド時間の要件が満たされずレジスタB への書き込みが正しく行われません.ホールド時間の要件は,(2)から(4) ではなく(1)から(3) を考えても同様です.
(1)と(2) あるいは (3)と(4) のイベントは,レジスタA あるいはレジスタB のクロック端子 clk への立ち上がりイベントなので,どちらも /clk となり区別できません.そこで周期性をもつイベントは,いずれか一方のみを /clk で表すことにします.ここでは,(1)あるいは(3) を /clk とします.周期を表す外部変数 ?cycle (名前は任意,この変数が周期を表すものであると認識しているのは,PCDの記述を行う人) を導入すると,(2)あるいは(4) の時刻は, /clk + ?cycle となります.+ ?cycle で「次の...」を表すわけです.
この議論は,クロック信号がすべてのレジスタにせいぜいバッファを介する程度で共通に分配されており,「今のクロックから出発したイベント」と「次のクロックから出発したイベント」は必ず区別できるということが前提となっています.
そうすると (4) の時刻でのセットアップ時間の要件は,
(def-constraint setup (- (+ /clk ?cycle) /in 4) type setup)
となります.ここで 4 はセットアップ時間です.時間の単位は任意ですが,統一しておく必要があります.この表現は,
(/clk + ?cycle) - /in > 4
ということなので,「in に対する最後のイベントの到着時刻よりも次のクロック信号の到着時刻は 4 だけ大きい」,時間の単位が ns ならば「in に対するイベントは次のクロック信号に対し,少なくとも 4 ns 先に到着する」ということです.ここで最後のイベントの到着時刻が評価されるのは前に述べたように制約式の値をより小さくするイベントが選ばれるからです.
一方,(3)でのホールド時間の要件は,
(def-constraint hold (- /in /clk 2) type hold)
となります.ここで 2 はホールド時間です.この表現は,
/in - /clk > 2
ということなので,「in に対する最初のイベントの到着時刻は,クロック信号の到着時刻よりも 2 大きい」,時間の単位が ns ならば「in に対するイベントは,今のクロック信号に対し,少なくとも 2 ns 後に到着する」ということです.
4.3  セル・ライブラリの作り方
セル・ライブラリの種別
SFLで記述されたハードウェアの動作は,最終的な実セルによる回路情報へ変換される前に,論理セルとダミー・セルによる回路情報に変換され,操作されます.
実セル
実セルは,実在の(製造可能な)構成要素ということで,セルの名称や端子名,機能などは製造メーカや製品系列で指定されているものとなります.
仮想セル
(1) 論理セル
論理セルは,セルの名称,端子名,機能など(端子の負荷容量やドライブ能力,遅延時間などの物理的情報を除く)がPARTHENONで規定されていて,SFLEXP や RINV,ONSET の各プログラムは,その存在や意味を前提として回路を扱います.
(2) ダミー・セル
ダミー・セルは,論理セルと実セルとの対応を仲介するためのもので,セルの名称や端子名,機能などはセル・ライブラリの作成時に実セルへの変換が正しく行われるように決定します.
論理セルとダミー・セルそして後述する過渡的なノン・インバータを合わせて仮想セルと呼びます.仮想セルと実セルの関係を図4.3 にまとめます.
<図4.3>  セル・ライブラリの種別と相互の関係
PCDセルとNLDセル
上記のセル区分とは別に,記述する言語からセルを区分することができます.PCD言語,NLD言語で定義されたセルをそれぞれ PCDセル,NLDセルと呼びます.
実セルは PCDセル
論理セルは PCDセルまたは NLDセル
ダミー・セルは PCDセル
として定義されます.ある論理セルをNLDセルとしたとき,その構成要素は他の論理セルかダミー・セルとなります.
たとえば,ある論理セルに対応する実セルが存在しないとき,実セルの適当なものを選びこれと同一機能のダミー・セルを設けます.このダミーセルと,すでに実セルへの対応が存在する論理セルにより,実セルへの対応が存在しない論理セルをNLDセルとして定義します.
なお,レジスタを構成するフリップフロップ自身をゲートの接続で構成してはいけません.
実セル・マッピングまでの処理過程との関係
実セル・マッピングまでの手順
本来は,圧縮された結果に対して,できるだけ高機能な実セルをマッピングすべきですが,現状では,
フェーズ1 :論理セルによる圧縮
フェーズ2 :論理セルによる高機能セル(複合セル)のくくりだし
フェーズ3 :実セルへのマッピング
が,この順で別々に実行されます.また圧縮,高機能セルのくくりだしは,and,or,not,eor で定義される組み合わせ回路部分に限られ,仮想セルから実セルへのマッピングは,まったく同じ機能定義をもつPCDセル相互でのみ行われます.
実セル・マッピングのメカニズム
セル・ライブラリを正しく作成するには,各フェーズの意味をきちんと理解している必要があります.図4.4を見ながらもう少し詳しく説明しましょう.結果として,機能がand,or,not,eor によって定義されているPCDセルで構成された回路部分 (組み合わせ論理回路部分) が左側のパスとなります.レジスタを表すPCDセルやクロック・ゲート (クロックを通すか通さないかを決定する and回路) は必ず右側 (制御回路部分ほか) のパスとします.
図のフェーズ1,フェーズ2 によって右側部分は,明らかに不要な部分が削除される以外にまったく変更を受けません.左側は回路が圧縮されるとともに,できるだけ高機能な論理セルによる回路へ変更されます.フェーズ3 では,まったく同じ機能定義をもつPCDセル相互で論理セルまたはダミー・セルから実セルへの変換が行われます.
<図4.4>  実セル・マッピングのメカニズム
フェーズ3 のメカニズムから,「実セルと対応しないPCDセルの論理セルまたはダミー・セルはライブラリに含めてはいけない」ことがわかります.
マッピング可能なセルとは
次に,どこまで高機能な実セルまでマッピング可能かについては,左側についてはフェーズ2でくくり出すことができる論理セルまで,右側については初期回路の論理セルまでとなります.ただし右側の経路では論理圧縮が行われませんので,そのデメリットをさし引いても効果があるほど高機能なセルに限定しなければなりません.初期回路の論理セルとフェーズ2 でくくり出すことができる論理セルを本章末の表4.4 に示します.
これを見ながら例を考えてみます.
たとえば,論理セルの一つである「4ビット2入力のセレクタ」に対応する実セルが存在するとき,これを左右のどちらで処理すべきかは次のように考えます.まずそのようなセレクタが表4.4 の中に sl4-2 という名前で存在することを確認します.しかし sl4-2 は,フェーズ2 でくくり出すことのできる論理セルではないので,もしこの論理セルを左側で処理すると,4ビット2入力のセレクタの実セルは,結局,使われないままとなります.一方,右側で処理すると,最終結果に使われます.ただし,回路の圧縮は行われませんので,どちらが良いかは場合によります.
できるだけ左側を使うという方針でもとくに問題はありません.いずれにしても,SFLEXPが出力する初期回路に含まれる論理セルは,すべて右側または左側の経路を経て実セルへ変換されるようにセル・ライブラリを作成しなければなりません.
セル・ライブラリ作成上のその他の注意事項
二つのNANDゲート
論理セルの bgate--2 と nand--2 は,物理的には同一の 2入力のnandゲートですが,PARTHENONの論理合成過程では区別されなければなりません.つまり,
nand--2	:たんなる組み合わせ回路用
bgate--2	:クロック・パルスのゲート用
となっています.このため,bgate--2 には出力にハザードが発生しないための制約条件が定義されなければなりません.また,図4.4 でいうと bgate--2 は右側で,nand--2 は左側で処理されるようにします.実セルの変換は同一機能の PCDセル相互でのみ行われますので,これらの論理セルに対応する実セルとして,組み合わせ回路を表すものとクロックパルスのゲートを表すものが必要です.また同一の実体を表すこれらの二つの実セルの cell_name には,本来の名前を定義します.
また,図4.4 のフェーズ3 では,制約充足メカニズムによって論理セル,ダミー・セルを実セルへと変換していきますので,論理セル,ダミー・セルと実セルの端子容量や遅延時間などの物理的情報 (負荷のドライブ能力を除く) は,できるだけ近いほうが良い結果が得られます.
PCDセルの論理セルあるいはダミー・セルは,実セルに取り替えられてしまうように,出力端子のドライブ能力を 0 にして下さい.
ノン・インバータ,バッファ,クロック・バッファの扱い
ところで,フェーズ1 の処理で,
(def-function out in)
で機能定義されるノン・インバータが過渡的に必要となります.これは仮想セルの扱いです.
実セルには,論理セルとの対応がないものがあります.それはバッファとクロック・バッファです.これらはそれぞれ,
(def-function out (buffer in))
(def-function out (clock_buf in))
と機能定義されていなければなりません.ノン・インバータ,バッファ,クロック・バッファのそれぞれを,物理的に区別する製品系列と区別しない製品系列があります.区別しない製品系列であっても,PARTHENONの論理合成過程では,これらをそれぞれ異なる実セルとしなければなりません.この場合 cell_name には本来の名前を定義します.
autoコマンドを使う場合
autoコマンドを使う場合,
仮想セル	:startディレクトリ
実セル	:cellディレクトリ
に格納します.さらに,autoコマンドが存在を前提としている start_eディレクトリとcell_eディレクトリは,SFLの機能回路に対応するセルを格納するために使います.機能回路を特定の実回路で記述するのではなく,いったん論理的な回路として記述し,フェーズ3 のメカニズムにより実回路へ変換します.
どのようなダミー・セルが必要となるか,あるいは,論理セルをどう表現するかは,実セルの特性に依存するため,仮想セルは実セルごとに用意する必要があります.
新しいセル・ライブラリを作成するときには,celldemo ディレクトリにあるセル・ライブラリの例を理解してください.
4.4  論理セルの一覧
論理セルのまとめ
表4.4 に論理セルをまとめます.論理セルには,すでに述べた初期回路で使われるもの,高機能セルのくくりだしで使われるものがあります.
表には論理セルではありませんが,フェーズ1 の論理圧縮の過程で過渡的に使われるノン・インバータや,フェーズ3 での制約充足で使われるバッファとクロック・バッファを含めました.
また,初期回路の論理セルには,他の論理セル間のネットリストへ分解できるものとそうでないものとがあります.表では,分解できるものをで示しました.この分解の指定はSFLEXPの起動時に -nld のオプション(デフォルトは分解する)をつけることで行われます.
<表4.4>  論理セル一覧
(注)	 レジスタのclk_enb信号は,クロックを制御するように構成することも,フリーラン・クロック(常時クロックを投入すること)として,データを制御するように構成することもできる
Mはファン・イン数あるいはセレクト数
Nはビット幅
a<N-1:0> はNLDでは a[N-1],a[N-2],...,a[1],a[0]
NLD and PCD MANUAL
