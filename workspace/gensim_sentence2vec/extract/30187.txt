
PER
PERは 「可能な限り単純な符号化規則を使って最も簡潔な符号を得る」ものです。
BERのタグ・長さ・値のTLV3項組みの代わりに、
PERはプリアンブル(複数又は省略される場合あり)、
長さ(省略される場合あり)、値(省略される場合あり)のPLVからなります。 
オクテット列ではなく原則ビット列です。 各要素は次の種類があります。
非整列ビットフィールド(bit-field)。
オクテット整列しません。
整列ビットフィールド(octet-aligned bit-field)。
下記の整列形式の場合にオクテット整列します。
フィールドリスト(field-list)。
非整列ビットフィールドや整列ビットフィールドを含みます。
BERでは個別メッセージのASN.1仕様を知らなくてもタグと長さを使ってある程度の復号が可能ですが、
PERは長さや値のフィールドがオプション(必要な場合にのみ指定)で、
ASN.1仕様で指定された各種制限に依存して符号化するため、
符号化と復号化にはASN.1仕様の参照が必要です。
BERでは、タグで区別することで、容易にCHOICEやSETやSEQUENCEに要素を追加する拡張が可能でしたが、
PERはタグがないので拡張性は事前に計画しておく必要があります。
拡張が指定されている場合、プリアンブルに拡張の有無を示すビットが設定されます。
長さはASN.1仕様のSIZE制約で固定長になっていいる場合、一部例外を除き、符号化されません。
SEQUENCEやSETの値の符号化は、オプション要素(OPTIONALやDEFAULT)の存在や非存在を示すプリアンブルで始まります。
CHOICEは選択肢を示すインデックスから始まります。
一般に、PERで符号化は初期処理が大きいがエンコードとデコードは静的でBERより早く、
BERよりサイズが小さいのでネットワーク転送が早くなります。
1. 符号化の4つの形式
PERは2つ形式があります:
基本形式(BASIC-PER)と正規化形式(CANONICAL-PER)です。
そしてそれぞれ整列(ALIGNED)と非整列(UNALIGNED)があります。
正規化形式は基本形式に制限を加えたものです。
この形式はリレーシステムやディジタル署名に適用されます。
基本形式で、値はいくつもの符号化形式をもつかもしれません。
他方、検査は限定されるので、基本形式コーダは正規化コーダより速いでしょう。
整列形式はオクテット境界にそろえるために必要なら、0のビットが挿入されます。
非整列形式でオクテット境界はなく、すべてのビットが使われます。
非整列形式はコンパクトですが、符号化と復号化により時間がかかる処理を必要とします。
整列と非整列は互換性が無く、整列形式デコーダは非整列形式をデコードできません。
2. 整数の符号化
2.1. 有限範囲の整数
符号化する整数をnとします。
整数の範囲に制限がある場合、つまり最小値MINと最大値MAXが決まっている場合、値(n-MIN)を符号化します。
特にMIN=MAXの場合は、値が明らかなので符号化しません(=省略)。
なお、以下の2進形式は、第iビットが2^iを示す一般的な符号なし2進形式です。
非整列形式の場合:
(n-MIN)を必要最小限のビット数(=log2(MAX-MIN+1)、小数点以下切上げ)で、
2進法形式で、非整列ビットフィールド に符号化します。
整列形式の場合:範囲range = MAX-MIN+1によって符号化が変わります。
range≦255:
(n-MIN)を必要最小限のビット数(=log2(range)、小数点以下切上げ)で、
2進法形式で、非整列ビットフィールドに符号化します。オクテット整列をしません。
range=256:
(n-MIN)を1オクテットの、2進法の形式で、整列ビットフィールドに符号化します。
オクテット整列をします。
257≦range≦65536:
(n-MIN)を2オクテットの、2進法の形式で、整列ビットフィールドに符号化します。
オクテット整列をします。
range≧65537:
可変長扱いになります。
(n-MIN)の符号化に必要最小なオクテット数L(=log256(n-MIN)、小数点以下切上げ)を符号化し、
この後にLオクテットの、2進法の形式で符号化した整列ビットフィールドが続きます。
Lのフォーマットは後記の通りです。
2.2. 通常小さい非負整数
SEQUENCEやSETの拡張ビットマップの大きさやCHOICEのインデックスは整数で、
一般に小さいが制限がない事も多いので、「通常小さい非負整数形式」が使われます。
符号化する整数をnとします。
a) n≦63:
1ビット値の0を非整列ビットフィールドに符号化し、
続けて6ビットで符号なし2進形式でnを非整列ビットフィールドに符号化します。
b) n≧64:
1ビット値の1を非整列ビットフィールドに符号化し、
続けてnを下記の部分制限整数(MIN=0とする)で符号化します。
2.3. 部分制限整数
整数nの下限MINは有限であるが上限が+&infin;の場合の符号化です。
可変長扱いになります。
(n-MIN)の符号化に必要最小なオクテット数L(=log256(n-MIN)、小数点以下切上げ)を符号化し、
この後にLオクテットの符号なし2進法の形式で符号化したフィールドが続きます。
非整列形式ではフィールドはオクテット整列をしない非整列ビットフィールドで、
整列形式ではフィールドはオクテット整列をする整列ビットフィールドになります。
Lのフォーマットは後記の通りです。
2.4. 制限なしの整数
整数の範囲に制限がない場合は、符号付き整数でnを符号化します。
可変長扱いになります。
符号化に必要最小なオクテット数Lを符号化し、
この後にLオクテットの符号付き2進法の形式(2の補数表現)で符号化したフィールドが続きます。
非整列形式ではフィールドはオクテット整列をしない非整列ビットフィールドで、
整列形式ではフィールドはオクテット整列をする整列ビットフィールドになります。
Lのフォーマットは後記の通りです。
2.5. 長さLの符号化
BERでは長さフィールドは常に存在し、オクテット単位でしたが、
PERでは長さフィールドは必要な場合にだけ存在します。
BERでは長さはオクテット単位でしたが、PERではビット列ではビット単位、
オクテット列(OCTET STRINGやオープン型)ではオクテット単位、文字列は文字数、
SEQUENCE OFやSET OFでは要素数を表します。
ASN.1仕様によって、長さlenの下限(0以上)と上限(&infin;かもしれない)が存在し、
これによって長さlenの符号化は影響を受けます。
長さlenの上限が65535以下の特定の固定した長さの場合、
長さlenの符号化をしません(=長さLフィールドは省略)。
SETやSEQUENCEのプリアンブルのビットマップの長さの場合、
(長さ-1)を上記の「通常小さい非負整数」で符号化します。
整列形式の場合:
lenの上限値が65535以下の場合:「有限範囲の整数」で符号化します。
lenの上限値が65536以上か、上限が&infin;の場合:
len≦127の場合:
lenを、1オクテットの2進法の形式で、符号化します。
整列形式ではオクテット整列をします。
オクテットの最上位ビットは常に0になります。
128≦len≦16383:
lenを、2オクテットの2進法の形式で、整列ビットフィールドに符号化します。
整列形式ではオクテット整列をします。
第1オクテットの最上位ビットは常に1、次のビットは常に0になります。
len≧16384:
長さの対象となる要素Vを分割して、LVLVといった符号化をします。
詳細は省略します。
非整列形式の場合:
lenの上限値が65535以下の場合:
(上限=下限)の場合は符号化しません。
それ以外の場合、(len-下限)を必要最小限のビット数(=log2(上限-下限+1)、小数点以下切上げ)で、
2進法形式で符号化します。
その他の場合:オクテット整列をしない事を除き、整列形式と同じ符号化をします。
2.6. オープン型
オープン型は、ASN.1の符号化あるいはその他の方法で符号化された後、
長さに制限がないオクテット列の様に扱われ、長さL(単位はオクテット)と、
それに続くオクテット列として符号化されます。
整列形式ではオクテット整列が行われます。
3. 型毎の符号化
3.1. 論理型(BOOL)
1ビットの非整列ビットフィールドで符号化します。
TRUEの値は1で、FALSEの値は0です。
長さLは使いません。
3.2. 整数型(INTEGER)
以下の制約を考慮し、整数の上限下限を決定します。
単一値:特定の値に制限したものです。
例:Two ::= INTEGER (2)
値域:とりうる値の最大値、最小値を制限。
最大値や最小値が無限の場合は、MAXやMINのキーワードを使います。
例:From3to15 ::= INTEGER (3..15)
例:PositiveOrZeroNumber ::= Number (0..MAX)
包含:既存の制約を組み合わせた制約です。
制約条件の組合せ:集合和、集合積、排他、除外などの演算で制約条件を組み合わせです。
整数型の符号化は以下の通りです。
①もし、拡張マークが指定されるなら、プリアンブルとして1ビットの非整列ビットフィールドを符号化します。
値が、元々定義された範囲であれば非整列ビットフィールドの値は0で、範囲外(拡張された値)であれば値は1です。
値が0の場合は②へ、拡張した値の場合は⑤へ進みます。
なお、整数型の符号化では整数の上限と下限だけを考えているため、
拡張した値であっても元の上限と下限の範囲内にあれば、拡張されていない値と扱います。
②もし、制約条件が値を1つに制限するなら、値を符号化せず(=長さLや値Vは省略)、手順を終了します。
③もし、制約条件が値の範囲を制限するなら、有限範囲の整数として符号化し、手順を終了します。
④もし、制約条件が値の下限を示すなら、部分制限整数として符号化し、手順を終了します。
⑤値を制限なしの整数で符号化し、手順を終了します。
PER
