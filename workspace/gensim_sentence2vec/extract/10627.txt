
4.2.1 正規表現の構文
正規表現(またはRE)はそれにマッチする文字列の集合を指定します。つまり、
このモジュール内の関数を使って、ある文字列が与えられた正規表現にマッチするかどうかをチェックすることができます。(あるいは与えられた正規表現が特定の文字列にマッチするかどうか−−要するに同じことになりますが−−をチェックできます。)
正規表現は新しい正規表現を作るために連結することができます。つまり、
AとBが共に正規表現であれば、ABもまた正規表現です。
文字列pがAにマッチし別の文字列qがBにマッチすれば、文字列pq
はABにマッチします。従って、複合した表現をここで説明したように単純な基本的表現から容易に構築することができます。
正規表現の理論と実装の詳細については以下のFriedl本やコンパイラ作成に関する教科書を参考にして下さい。
正規表現のフォーマットの簡潔な説明を以下に示します。
正規表現は特殊文字と通常文字を両方含むことができます。
"A", "a", "0"のような大抵の通常文字は最も単純な正規表現です。つまりそれらはそれ自身にマッチします。
通常文字を連結することができるので、lastは文字列'last'にマッチします。(この節の残りでは、正規表現は通常クオート無しでthis special styleのように記述し、マッチングされる文字列は'in single quotes'のようにシングルクオートで記述します。)
"|"または"("のような文字は特別です。
特殊文字は通常文字のクラスを表すか、そのまわりにある正規表現がどう解釈されるかに影響を与えます。
特殊文字には以下のものがあります。
"."
(Dot.)  デフォルトモードでは、これはニューライン以外のどの文字にもマッチします。DOTALLフラグが指定されていれば、れはニューラインを含むどの文字にもマッチします。
"^"
(Caret.)  文字列の先頭にマッチします。MULTILINEモードでは各ニューラインの直後にもマッチします。
"$"
文字列の最後にマッチします。MULTILINEモードではニューラインの直前にもマッチします。fooは'foo'と'foobar'にマッチしますが、正規表現foo$は'foo'のみにマッチします。
"*"
先行するREの0回以上で可能な限り多くの繰り返しにマッチさせます。
ab*は'a','ab'または任意個の'b'を後ろに従えた'a'にマッチします。
"+"
先行するREの1回以上の繰り返しにマッチさせます。
ab+は'b'を1つ以上従えたaにマッチします。単なる'a'にはマッチしません。
"?"
先行するREの0または1回の繰り返しにマッチさせます。
ab?は'a'か'ab'にマッチします。
*?, +?, ??
"*", "+", "?"修飾はすべて欲張りです。
つまりそれらはできるだけ多くのテキストにマッチします。時にはこの動作は望ましくないことがあります。正規表現<.*>を'<H1>title</H1>'に対してマッチさせると全文字列にマッチし、'<H1>'だけにはマッチしません。
修飾語の後ろに"?"を追加すると、欲張りでないまたは最小の
仕方でマッチングが実行されます。つまりできるだけ少ない文字にマッチします。前の表現で.*?を使うと'<H1>'のみにマッチします。
{m,n}
できるだけ多くの繰り返しにマッチするようにしながら、先行するREのmからn回の繰り返しにマッチさせます。例えば、a{3,5}は3から5個の"a"文字にマッチします。mを省略すると下限に0を指定したのと同じです。
nを省略すると無限大の上限を指定することになります。
{m,n}?
できるだけ少ない繰り返しにマッチするようにしながら、先行するREのmからn回の繰り返しにマッチさせます。これは前の修飾語の欲張りでないバージョンです。例えば、6文字の文字列'aaaaaa'について、a{3,5}は5個の
"a"文字にマッチしますがa{3,5}?は3文字のみにマッチします。
"\"
エスケープ特殊文字("*", "?"等の文字にマッチできるようにします)または特別なシーケンスであることを知らせます。特別なシーケンスは後で説明します。
パターンを表現するためになまの文字列を使っていない場合には、パイソンは文字列リテラルではエスケープシーケンスとしてもバックスラッシュを使っていることを覚えておいて下さい。もしエスケープシーケンスがパイソンのパーサで認識されなければバックスラッシュと後続文字は結果の文字列内に含まれます。しかし、パイソンが結果のシーケンスを認識すればバックスラッシュが2度繰り返されます。これは複雑で理解しにくいことなので最も単純な表現を除くすべての表現にはなまの文字列を使うことを強くお勧めします。
[]
文字集合を示すために使われます。文字は個別に記載してもよいし、文字の範囲を2つの文字とそれを分ける"-"で示すこともできます。
特殊文字は集合内ではアクティブではありません。例えば、[akm$]は
"a", "k", "m", "$"のどの文字にもマッチします。[a-z]は任意の小文字にマッチし、[a-zA-Z0-9]は文字または数字にマッチします。\wや\S(後述)も許されます。
集合内に"]"または"-"を含ませたいときは、バックスラッシュをその前につけるかそれを最初の文字にするかです。例えば、パターン[]]は
']'にマッチします。
補集合によって範囲内にない文字にマッチさせることができます。
これは集合の先頭文字として"^"が含まれることで示されます。
その他の場所では"^"は"^"文字に単純にマッチします。
例えば、[^5]は"5"以外の任意の文字にマッチします。
"|"
AとBが任意の正規表現の場合、A|BはAまたはBにマッチする正規表現を生成します。これはグループ(後述)内でも使うことができます。
リテラル"|"にマッチさせるためには\|を使うか[|]のように文字クラスの中に入れます。
(...)
これは括弧内のいかなる正規表現にもマッチし、そのグループの開始と終了位置を示します。
つまりグループの内容はマッチングが実行された後で取り出すことができ、後述するように\numberという特別なシーケンスを使って後で文字列内でマッチングさせることが可能です。リテラル"(" または "')"にマッチさせるためには\( または \)を使うか、それらを文字クラス[(] [)]に封じ込めます。
(?...)
これは拡張表現です("("の後の"?"は他では意味がありません)。"?"の後の最初の文字はその意味とその後の構文構成を決定します。
拡張表現は通常新しいグループを生成しません。
(?P<name>...)はこの規則の唯一の例外です。
以下が現在サポートされている拡張表現です。
(?iLmsx)
(集合"i","L", "m", "s", "x"から1つ以上の文字)グループは空文字にマッチします。
文字は正規表現全体に対し対応するフラグ(re.I, re.L, re.M, re.S, re.X)をセットします。
これはcompile()関数にflag引数を渡すかわりに正規表現の一部としてそのフラグを含ませたい場合に役立ちます。
(?:...)
通例の括弧のグループ化なしのバージョンです。
括弧内のいかなる正規表現にもマッチしますが、そのグループはマッチングを実行した後取り出すことや後でそのパターン内で参照することは出来ません。
(?P<name>...)
通例の括弧に似ていますが、そのグループでマッチングされた部分文字列はシンボリックグループ名nameでアクセスできます。
グループ名は有効なパイソンの識別子でなければなりません。そのグループが名前を付けられていなくても、シンボリックグループは番号付けされたグループでもあります。
従って例の'id'という名前のグループは番号1のグループとしても参照可能です。
例えば、パターンが(?P<id>[a-zA-Z_]\w*)の場合、そのグループはm.group('id')またはm.end('id')のようにマッチオブジェクトのメソッドの引数にその名前を指定することで参照できますし、パターンテキスト(例えば(?P=id))および置換テキスト(例えば\g<id>)内で名前で参照できます。
(?P=name)
nameという名前を付けられたグループにマッチするどんなテキストにもマッチします。
(?#...)
コメントです。つまり括弧内の内容は単純に無視されます。
(?=...)
...がその次にマッチすればマッチしますが、文字列を消費することはありません。これは先読みの断言と呼ばれます。例えば、Isaac (?=Asimov)は、'Asimov'がそれに続く場合のみ'Isaac 'にマッチします。
(?!...)
...がその次にマッチしなければマッチします。これは先読みの断言の否定です。例えば、Isaac (?!Asimov)は、'Asimov'がそれに続かない場合のみ'Isaac 'にマッチします。
特殊シーケンスは"\"と以下の文字一覧の文字から構成されます。
一覧にない通常文字の場合、その結果の正規表現は2番目の文字にマッチします。
例えば、\$は"$"にマッチします。
\number
同じ番号のグループの内容にマッチします。グループ番号は1から始まります。
例えば、(.+) \1は'the the'または'55 55'にマッチしますが、'the end'にはマッチしません(グループの後のスペースに注意)。
この特殊シーケンスは最初の99グループの一つにマッチさせるためにのみ使用できます。numberの最初の数字が0またはnumberが3つの8進数のときは、グループマッチとして解釈されず、その文字列は8進数値numberとして解釈されます。
文字クラス"[" and "]"の内側では、すべての数値エスケープは文字として扱われます。
\A
文字列の最初のみにマッチします。
\b
単語の最初か最後においてのみ空文字列にマッチします。
単語は英数文字のシーケンスとして定義されているので、単語の最後はホワイトスペースまたは非英数文字によって示されます。文字としては\bはパイソンの文字列リテラルとの互換性のためバックスペースを表します。
\B
単語の最初や最後にない空文字列にマッチします。
\d
任意の10進数文字にマッチします。つまりこれは文字集合[0-9]と同じです。
\D
任意の非数字文字にマッチします。つまりこれは文字集合[^0-9]と同じです。
\s
任意のホワイトスペース文字にマッチします。つまりこれは文字集合
[ \t\n\r\f\v]と同じです。
\S
任意の非ホワイトスペース文字にマッチします。つまりこれは文字集合
[^ \t\n\r\f\v]と同じです。
\w
LOCALEフラグが指定されていなければ、任意の英数文字にマッチします。
つまりこれは文字集合[a-zA-Z0-9_]と同じです。
LOCALEが指定されていれば、文字集合[0-9_]と現在のロケールで文字として定義されているどの文字にもマッチします。
\W
LOCALEフラグが指定されていなければ、任意の非英数文字にマッチします。つまりこれは文字集合[^a-zA-Z0-9_]と同じです。
LOCALEが指定されていれば、文字集合[0-9_]と現在のロケールで文字として定義されていないどの文字にもマッチします。
\Z
文字列の最後にのみマッチします。
\\
バックスラッシュ文字にマッチします。
4.2.1 正規表現の構文
