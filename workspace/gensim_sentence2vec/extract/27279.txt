1本のルールで可算個のルールを記述する仕組みとして、
型付きプロセス文脈と呼ばれる構文を導入する。
データ型
ルール中の型付きプロセス文脈は、プロセスの(可算)集合である
データ型の各要素(とα同値なプロセス)に置換される。
プロセス集合に対する名前の局所化
任意のリンク名 X_1,…,X_n に対して -∃X_1,…,X_n は、
プロセスの集合を入力として、
各要素の X_1,…,X_n 以外のリンク名を任意に付け替えて得られるプロセスの
全体集合を返す演算子とする。
例
-∃X{yes(X),no(X),c} = {yes(X),no(X),c}
-∃X{p(X,Y),a(Z)} = { p(X,Y) | Yは任意のリンク名 }∪{ a(Z) | Zは任意のリンク名 }
単項データ型
リンク名からプロセスの集合への写像 T は、
任意のリンク名 X に対して
T(X) の各要素は X を自由リンクとして持つ
T(X) = -∃X ( T(X) )
を満たすときそのときに限り単項データ型構成子(unary datatype constructor)と呼ばれる。
そのような T(X) を単項データ型という。
特に、T(X) の各要素が必ず X を唯一の自由リンクとして持つ場合、
T は基底単項データ型構成子と呼ばれる。
例
Nat(X)    := -∃X{X=0,X=s(0),X=s(s(0)),…} は基底単項データ型。
Bool(X)   := {yes(X),no(X)} は基底単項データ型。
Ground(X) := -∃X{X=a,X=f(a),X=g(a,a),X=g(a,f(a)),…} は基底単項データ型。
-∃X{f(X,Y),{f(X,Y,Y)}} は単項データ型であるが、基底単項データ型ではない。
-∃X{p(X),a} や -∃X{p(X),(p(X),p(X))} は単項データ型ではない。
データ型
異なる n 個のリンク名からプロセスの集合への写像 D のうち、
T_1,…,T_n を単項データ型構成子として
D(X_1,…,X_n) ⊆ { (P_1,(P_2,(…,P_n))) | ∀i( P_i∈T_i(X_i)) }
D(X_1,…,X_n) = -∃X_1,…,X_n ( D(X_1,…,X_n) )
を満たすものをデータ型構成子と呼ぶ。
そのような D(X_1,…,X_n) をデータ型という。
単項データ型構成子はデータ型構成子となる。
例
(X 
実際には不等号は、自然数だけでなく
最低でも整数の比較ができるように定義すべきであろう。
言語仕様の拡張
構文要素の追加
Rule    R ::= (T :- G | T)
Guard   G ::= 0 | G,G | \+($p1=T1,…,$pn=Tn) | D($q1,…,$qn)
ただし D はデータ型構成子とする。
また、その引数の $q1,…,$qn は互いに異なるプロセス文脈名とする。
(この条件は後述の略記法(2)を使って除去される)
新たに追加された構文要素 D($q1,…,$qn) を型制約(type constraint)と呼ぶ。
ガードの型制約に出現するプロセス文脈名 $q およびその名前をもつプロセス文脈は、
そのルールにおいて型付き(typed)であると呼ばれる。
型付きプロセス文脈名 $q を含む構文に対して、
以下のように制限を設ける。
ガードで $q に関する否定条件を指定することはできない。
それぞれの $q は、ヘッドに高々1回までしか出現できない。
(この条件は後述の略記法(2)を使って除去される)
$q の明示的な自由リンク引数の長さは1でなければならない。
$q がヘッドに $q[X|*A] の形で出現する場合は、
$q はボディにちょうど1回出現しなければならず、
しかもその出現の剰余引数は *A でなければならない。
(したがって現状では、
型付きプロセス文脈 $q[X|*A] に対して、
cp(*A,*B,*C) は書けないことになる)
ヘッドの $q[X|…] は
(それが出現する膜(またはトップレベル)における)
プロセス文脈の出現回数としてカウントされない。
型付きプロセス文脈の意味
型制約を含むルールは、以下の条件を満たす任意の置換を用いて、
型制約以外の部分に対して型付きプロセス文脈をプロセスに置き換えて得られる
可算個のルールを表すと考える。
ルール中の型制約 D($q1,…,$qn) に対して、
ある (P1,(…,Pn))∈D(X1,…,Xn) が存在して、
このルール中のプロセス文脈 $qi[X|…] は Pi{X/Xi} とα同値なプロセスで置換される。
(Pi を $qi の具体値という)
ここで (P1,(…,Pn)) に出現する局所リンク名および Xi は、
置換前のルール中に出現しないものとする。
$q[X] の形の型付きプロセス文脈は、
基底単項データ型の要素で置換されなければならない。
例
p(X),$i[X] :- $i 
型付きプロセス文脈の略記法
略記法(1) - 引数化
ガードの f(s1,…,sm),g(t1,…,tn) は、
si と tn が
このルールで他に出現しない同一のプロセス文脈名ならば
f(s1,…,si-1,g(t1,…,tn-1),si+1,…,sm)
と略記してよい。
ヘッドおよびボディの p(…,X,…),$q[X] は
p(…,$q,…)
と略記してよい。
ヘッドの p(…,X,…),$q[X|*A] および
ボディの r(…,Y,…),$q[Y|*A] は、
それぞれ一斉に p(…,$q,…) および
r(…,$q,…) と略記してよい。
(前項と区別できない場合があるが問題はないか)
例
p($i) :- $i 
略記法(2) - 構造比較・構造代入・基底項
ガードで $p==$q または $p=$q の形の型制約を持つプロセス文脈名 $p と $q は、同じプロセス文脈名を使用してよい。
この結果、これらの型制約はしばしば省略可能となる。
ボディでの出現がちょうど1回でない $q に対して、
ガードの型制約 ground($q) は省略してよい。
例
p($a),q($a) :- p($a).
は
p($a),q($b) :- $a==$b | p($a).
の略記。
p($a) :- $a*$a == 36 | q($a).
は
p($a) :- $n=$a, $a*$n == 36 | q($a).
の略記。
略記法(3) - リンク化
型付きプロセス文脈名 $p は、
そのルールのヘッドおよびボディでの出現がすべて文脈名単独での
略記出現(略記法(1)の結果)であって、
かつガードで型制約されているならば、
$p を一斉にルールに出現しないリンク名で置換してよい。
ただし略記法(2)の結果ヘッドに複数回出現している $p に対しては、
この略記法の適用を認めない方がよいかもしれない。
例
p(N) :- N 
型制約名の入出力モード
ルールは、与えられたプロセスとマッチングするときに、
全ての型付きプロセス文脈名の具体値を(α同値を除いて)
一意的に決定することが困難ならば、
コンパイルエラーとしてよい。
例
p(A) :- A 
一意的に決定できるかどうかを推論するために、
それぞれの型制約名(=データ型構成子)
が持つ入出力モード情報を使用することができる。
具体値の一意化手続き
型制約名はその各引数に対して、
入力を表す + または出力を表す - を割り当てる。
1つの型制約名が複数の割り当て方(入出力モード)を持っていてもよい。
入出力モードが与えられた型制約は、
入力引数の具体値が一意的に決定すると、
出力引数の具体値が(α同値を除いて)一意的に決定しなければならない。
ヘッドに出現するプロセス文脈名の具体値は一意的に決定できる。
(一意的に決定できないようなデータ型(例:{f(X),(f(X),c)})は、
型制約としての使用を認めない)
全ての型付きプロセス文脈名の具体値を一意的に決定することができない場合、
コンパイルエラーとしてよい。
組み込み型制約名の入出力モード情報
'*'(+A,+B,-Res)
+A = -B および -A = +B
+A 
プログラム例
ループ
loop(I,N) :- 0 
構造の比較
Res=equal($p,$p) :- Res=yes.
は次の略記である。
Res=equal($p,$q) :- $p==$q | Res=yes.
これはさらに次の略記である。
equal(P,Q,Res),$p[P],$q[Q] :- $p==$q | Res=yes.
これは意味的には
equal(P,Q,Res),P=a,        Q=a         :- Res=yes.
equal(P,Q,Res),P=f(a),     Q=f(a)      :- Res=yes.
equal(P,Q,Res),P=g(a,a),   Q=g(a,a)    :- Res=yes.
equal(P,Q,Res),P=g(a,f(a)),Q=g(a,f(a)) :- Res=yes.
などの集まりであると解釈される。
名前の比較
Res=eqfunc($p,$q) :- functor($p,$f,$n),functor($q,$f,$n) | Res=yes($p,$q).
は次の略記である。
eqfunc(P,Q,Res),$p[P|*A],$q[Q|*B] :- functor($p,$f,$n), functor($q,$f,$n) |
$p[R|*A],$q[S|*B], yes(R,S,Res).
これは意味的には
eqfunc(P,Q,Res),P=a,     Q=a      :- yes(R,S,Res),R=a,     S=a.
eqfunc(P,Q,Res),P=f(A),  Q=f(B)   :- yes(R,S,Res),R=f(A),  S=f(B).
eqfunc(P,Q,Res),P=g(A,a),Q=g(B,a) :- yes(R,S,Res),R=g(A,a),S=g(B,a).
などの集まりであると解釈される。
型付きプロセス文脈に関する議論
データ型のモジュール性
例えば自然数の表現が
X=n
X=s^n(0)
{X=s^n(0)}
{'+'(X),a,a,…,a}  (aはn個)
{res(X),0,1,…,n-1}
などのどれであっても、
型付きプロセス文脈を使ったプログラムを変更する必要は無い。
組み込みのコピー機能
データ型に属するプロセスは、
非線形のプロセス文脈を利用した「組み込みのコピー機能」によって複製できる。
ただしそのためには、
複製するプロセスをルールのヘッドまたはガードで型付きプロセス文脈として
受け取らなければならないため、
ルールの書き方には構文的な制限が存在している。
例えば
p($a) :- int($a), $b=$a+1 | q($b),q($b).
は書けるが
p($a) :- int($a) | $b=$a+1, q($b),q($b).
は構文エラーとなる。
同様に
p(A) :- int(A), B=A+1 | q(B),q(B).
は書けるが
p(A) :- int(A) | B=A+1, q(B),q(B).
は構文エラーとなる。
なお
p(A) :- int(A), B=A+1 | q(B).
と
p(A) :- int(A) | B=A+1, q(B).
はどちらも書けるが、振舞いが異なることに注意する。
最終更新日: 2003/10/7  作成者: 加藤
修正部分は赤色です。
今後に向けて改善すべき部分は藤色です。
戻る
型付きプロセス文脈
