 自動的に作成されるインデックス（主キー制約と UNIQUE 制約）  クラスター化がある場合の非クラスター化インデックスの内部構造  カバリング インデックス（複合インデックス）  付加列インデックス（Include オプション）  自動的に作成されるインデックス（主キー制約と UNIQUE 制約） PRIMARY KEY（主キー）制約または UNIQUE 制約を設定している場合は、自動的にインデックスが作成されます。デフォルトでは、PRIMARY KEY制約の場合には「クラスター化インデックス」、UNIQUE制約の場合には「非クラスター化インデックス」が作成されて、インデックスの名前は制約の名前と同じになります。どちらの制約もデータを一意に保つためのものなので、この列を検索条件に指定した場合は、必ず 1件の検索結果が返ります。インデックスは、大量のデータの中から数件のデータを取り出すときに最も効果を発揮するので、一意な値を持つ列に対して作成されたインデックスは、最も効果があります。また、主キーは検索条件としても頻繁に使用されるものなので、インデックスが自動的に作成されることはうれしいことです。 Let's Try  クエリ エディターへ次のように入力して、「社員番号」列を主キーとする「社員2」という名前のテーブルを作成します。   
作成後、オブジェクト エクスプローラーで、「社員2」テーブルの［インデックス］フォルダーを展開して、「PK_社員2_～（クラスター化）」というインデックスが作成されていることを確認してみましょう。 クラスター化がある場合の非クラスター化インデックスの内部構造 ここでは、クラスター化インデックスと非クラスター化インデックスの両方が存在する場合について説明します。クラスター化インデックスを作成すると、非クラスター化インデックスの構造が変更され、リーフレベルへ格納されるポインターが「行識別子」から「クラスター化インデックスの値」へ変更されます。たとえば、社員テーブルの「社員番号」列へクラスター化インデックスを作成し、「姓」列に、非クラスター化インデックスを作成している場合は、次の図のようなインデックス構造になります。  このような構造になるメリットは、「姓」と「社員番号」列のみを取得する検索を非常に高速に取得できるようになる点です。 Let's Try  まずは、「姓」列へ作成していたクラスター化インデックスを削除します。   
SQLServer: ◆インデックスの構造と内部動作2
