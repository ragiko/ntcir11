
ヘッダーをスキップ
Oracle Database SQLリファレンス10g リリース2(10.2)B19201-02
目次
索引
11 SQL文: ALTER MATERIALIZED VIEW〜ALTER SYSTEM
この章では、次のSQL文について説明します。
ALTER MATERIALIZED VIEW
ALTER MATERIALIZED VIEW LOG
ALTER OPERATOR
ALTER OUTLINE
ALTER PACKAGE
ALTER PROCEDURE
ALTER PROFILE
ALTER RESOURCE COST
ALTER ROLE
ALTER ROLLBACK SEGMENT
ALTER SEQUENCE
ALTER SESSION
ALTER SYSTEM
ALTER MATERIALIZED VIEW 
用途
マテリアライズド・ビューは、問合せ結果を含むデータベース・オブジェクトです。問合せのFROM句には、表、ビューおよびその他のマテリアライズド・ビューを指定できます。これらをあわせて、マスター表(レプリケーション用語)またはディテール表(データ・ウェアハウス用語)といいます。このマニュアルでは、マスター表という用語を使用します。マスター表が格納されているデータベースをマスター・データベースといいます。
ALTER MATERIALIZED VIEW文を使用すると、既存のマテリアライズド・ビューを次の方法で変更できます。
記憶特性を変更します。
リフレッシュ方法、モードまたは時間を変更します。
別のタイプのマテリアライズド・ビューになるように構造を変更します。
クエリー・リライトを使用可能または使用禁止にします。
注意:
下位互換性を保つために、MATERIALIZED VIEWのかわりにキーワードSNAPSHOTもサポートされています。 
参照:
マテリアライズド・ビューの作成の詳細は、「CREATE MATERIALIZED VIEW」を参照してください。
レプリケーション環境でのマテリアライズド・ビューの詳細は、『Oracle Databaseアドバンスト・レプリケーション』を参照してください。
データ・ウェアハウス環境でのマテリアライズド・ビューの詳細は、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
前提条件
マテリアライズド・ビューを変更するために必要な権限は、次のように直接付与される必要があります。
マテリアライズド・ビューが自分のスキーマ内にある必要があります。自分のスキーマ内にない場合は、ALTER ANY MATERIALIZED VIEWシステム権限が必要です。
クエリー・リライトでマテリアライズド・ビューを使用可能にする場合、次の条件が必要です。
マテリアライズド・ビュー内のすべてのマスター表が自分のスキーマ内にある場合、QUERY REWRITE権限が必要です。
いずれかのマスター表が別のスキーマ内にある場合、GLOBAL QUERY REWRITE権限が必要です。
マテリアライズド・ビューが別のユーザーのスキーマ内にある場合、ユーザーおよびそのスキーマ所有者の両方に、前述の適切なQUERY REWRITE権限が必要です。また、マテリアライズド・ビューの所有者は、マテリアライズド・ビュー所有者が所有しないすべてのマスター表へのSELECT権限を持っている必要があります。
構文
alter_materialized_view::=
画像の説明
(「ALTER TABLE」の項にあるphysical_attributes_clause::=、table_compression::=、LOB_storage_clause::=、modify_LOB_storage_clause::=、alter_table_partitioning::=、parallel_clause::=、logging_clause::=、allocate_extent_clause::=、alter_iot_clauses::=、scoped_table_ref_constraint::=、alter_mv_refresh::=を参照)
physical_attributes_clause::=
画像の説明
(storage_clause::=を参照)
table_compression::=
画像の説明
LOB_storage_clause::= 
画像の説明
LOB_parameters::=
画像の説明
(storage_clause::=、logging_clause::=を参照)
modify_LOB_storage_clause::=
画像の説明
(modify_LOB_parameters::=を参照)
modify_LOB_parameters::=
画像の説明
(storage_clause::=、logging_clause::=、allocate_extent_clause::=、shrink_clause::=、deallocate_unused_clause::=を参照)
parallel_clause::=
画像の説明
logging_clause::=
画像の説明
allocate_extent_clause::=
画像の説明
(size_clause::=を参照)
deallocate_unused_clause::=
画像の説明
(size_clause::=を参照)
shrink_clause::=
画像の説明
alter_iot_clauses::=
画像の説明
(index_org_table_clause::=、alter_overflow_clause::=を参照。alter_mapping_table_clausesは、マテリアライズド・ビューではサポートされていません。)
index_org_table_clause::=
画像の説明
(mapping_table_clauseおよびkey_compressionは、マテリアライズド・ビューではサポートされていません。index_org_overflow_clause::=を参照)
index_org_overflow_clause::=
画像の説明
(「ALTER TABLE」の項にあるsegment_attributes_clause::=を参照)
alter_overflow_clause::=
画像の説明
(allocate_extent_clause::=、shrink_clause::=、deallocate_unused_clause::=を参照)
add_overflow_clause::=
画像の説明
(「ALTER TABLE」の項にあるsegment_attributes_clause::=を参照)
scoped_table_ref_constraint::=
画像の説明
alter_mv_refresh::=
画像の説明
セマンティクス 
schema
マテリアライズド・ビューが含まれているスキーマを指定します。schemaを指定しない場合、マテリアライズド・ビューは自分のスキーマ内にあるとみなされます。
materialized_view
変更するマテリアライズド・ビューの名前を指定します。
physical_attributes_clause
PCTFREE、PCTUSED、INITRANSパラメータの値(USING INDEX句で使用する場合は、INITRANSパラメータ値のみ)、およびマテリアライズド・ビューの記憶特性を指定します。PCTFREE、PCTUSEDおよびINITRANSパラメータの詳細は、「ALTER TABLE」を参照してください。記憶特性の詳細は、「storage_clause」を参照してください。
table_compression
table_compression句を使用すると、ディスクおよびメモリーの使用量を削減するために、データ・セグメントを圧縮するかどうかを指定できます。COMPRESSキーワードを指定すると、表の圧縮が使用可能になります。NOCOMPRESSキーワードを指定すると、表の圧縮が使用禁止になります。表の圧縮の詳細は、「CREATE TABLE」の「table_compression」を参照してください。
LOB_storage_clause
LOB_storage_clauseを使用すると、新しいLOBの記憶特性を指定できます。マテリアライズド・ビューのLOB記憶域は、表の場合と同様に動作します。LOB記憶域パラメータの詳細は、「CREATE TABLE」の「LOB_storage_clause」を参照してください。
modify_LOB_storage_clause
modify_LOB_storage_clauseを使用すると、LOB属性lob_itemの物理属性またはLOBオブジェクト属性を変更できます。マテリアライズド・ビューのLOB記憶域の変更は、表の場合と同様に動作します。
参照:
変更可能なLOB記憶域パラメータの詳細は、「ALTER TABLE」の「modify_LOB_storage_clause」を参照してください。 
alter_table_partitioning
マテリアライズド・ビューのalter_table_partitioningの構文および一般的な機能は、パーティション表と同じです。「ALTER TABLE」の「alter_table_partitioning」を参照してください。
マテリアライズド・ビューのパーティション変更の制限事項: 
partitioning_clausesでは、LOB_storage_clauseまたはmodify_LOB_storage_clauseを指定できません。
注意:
マテリアライズド・ビューの内容をマスター表の内容と同期させて保持するには、表パーティションを削除または切り捨てた後、表に依存しているすべてのマテリアライズド・ビューを手動で完全リフレッシュすることをお薦めします。 
MODIFY PARTITION UNUSABLE LOCAL INDEXES
この句を使用すると、partitionに関連付けられたすべてのローカル索引パーティションに、UNUSABLEのマークが付きます。
MODIFY PARTITION REBUILD UNUSABLE LOCAL INDEXES
この句を使用すると、partitionに関連付けられた、使用禁止のローカル索引パーティションを再構築できます。
parallel_clause
parallel_clauseを使用すると、マテリアライズド・ビューのデフォルトの並列度を変更できます。
この句の詳細は、「CREATE TABLE」の「parallel_clause」を参照してください。
logging_clause
この句を使用すると、マテリアライズド・ビューのロギング特性を指定または変更できます。この句の詳細は、「logging_clause」を参照してください。
allocate_extent_clause
allocate_extent_clauseを使用すると、マテリアライズド・ビューの新しいエクステントを明示的に割り当てることができます。この句の詳細は、「allocate_extent_clause」を参照してください。
shrink_clause
この句を使用すると、マテリアライズド・ビューのセグメントを縮小化できます。この句の詳細は、「CREATE TABLE」の「shrink_clause」を参照してください。
CACHE | NOCACHE
アクセス頻度の高いデータについて、CACHEは、全表スキャンの実行時にこの表に対して取り出された各ブロックを、バッファ・キャッシュのLRUリストの最高使用頻度側に入れることを指定します。この属性は、小規模な参照表で有効です。NOCACHEは、ブロックをLRUリストの最低使用頻度側に入れることを指定します。この句の詳細は、「CREATE TABLE」の「CACHE | NOCACHE | CACHE READS」を参照してください。
alter_iot_clauses
alter_iot_clausesを使用すると、索引構成マテリアライズド・ビューの特性を変更できます。alter_iot_clausesコンポーネントのキーワードおよびパラメータは、ALTER TABLEと同じです。また、次の制限事項があります。
索引構成マテリアライズド・ビューの変更の制限事項: 
index_org_table_clauseのmapping_table_clausesまたはkey_compression句は指定できません。
参照:
索引構成マテリアライズド・ビューの作成については、「CREATE MATERIALIZED VIEW」の「index_org_table_clause」を参照してください。 
USING INDEX句
この句を使用すると、マテリアライズド・ビューのデータをメンテナンスするために使用される索引のINITRANSパラメータおよびSTORAGEパラメータの値を変更できます。
USING INDEX句の制限事項: 
この句では、PCTUSEDまたはPCTFREEパラメータは指定できません。
MODIFY scoped_table_ref_constraint
MODIFY scoped_table_ref_constraint句を使用すると、新しい表または新しい列の別名にREF列または属性の有効範囲を再指定できます。
REF列の有効範囲の再指定の制限事項: 
ALTER MATERIALIZED VIEW文では、1つのREF列または属性の有効範囲のみを再指定することができます。この句は、この文以外では使用できません。
alter_mv_refresh
alter_mv_refresh句を使用すると、自動リフレッシュの方法、モードおよび日時のデフォルト値を変更できます。マテリアライズド・ビューのマスター表の内容が変更された場合、マテリアライズド・ビューのデータを更新し、現在マスター表にあるデータを正確に反映させる必要があります。この句によって、自動的にマテリアライズド・ビューをリフレッシュする日時をスケジューリングし、リフレッシュの方法およびモードを指定できます。
注意:
この句では、デフォルトのリフレッシュ・オプションのみを設定します。リフレッシュを実際に実装する手順は、『Oracle Databaseアドバンスト・レプリケーション』および『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。 
FAST句
FASTを指定すると、増分リフレッシュ方法を指定できます。これはマスター表に対して行った変更に従ってリフレッシュを行います。この変更は、マスター表に関連付けられたマテリアライズド・ビュー・ログ(従来型DML変更の場合)またはダイレクト・ローダー・ログ(ダイレクト・パス・インサート操作の場合)に格納されます。
従来型DMLの変更の場合も、ダイレクト・パス・インサート操作の場合も、他の条件によって、高速リフレッシュへのマテリアライズド・ビューの適応性が制限されることがあります。
参照:
レプリケーション環境における高速リフレッシュの制限については、『Oracle Databaseアドバンスト・レプリケーション』を参照してください。
データ・ウェアハウス環境における高速リフレッシュの制限については、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
「自動リフレッシュの例:」
FASTリフレッシュの制限事項:
FASTリフレッシュには、次の制限事項があります。
作成時にFASTリフレッシュを指定した場合、作成するマテリアライズド・ビューは高速リフレッシュに適応することが検証されています。ALTER MATERIALIZED VIEW文でリフレッシュ方法をFASTに変更した場合、これは検証されていません。マテリアライズド・ビューが高速リフレッシュに適応しない場合、このビューをリフレッシュしようとするとエラーが戻されます。
定義する問合せに分析ファンクションが含まれている場合、マテリアライズド・ビューは高速リフレッシュに適応しません。
参照:
「分析ファンクション」 
COMPLETE句
COMPLETEを指定すると、完全リフレッシュ方法を指定できます。これは、マテリアライズド・ビューを定義する問合せを実行することによって実装されます。完全リフレッシュを指定すると、高速リフレッシュが実行可能であっても、完全リフレッシュが実行されます。
参照:
「完全リフレッシュの例:」 
FORCE句
FORCEを指定すると、リフレッシュ時に、高速リフレッシュが可能な場合は高速リフレッシュを実行し、そうでない場合は完全リフレッシュを実行できます。
ON COMMIT句
ON COMMITを指定すると、マテリアライズド・ビューのマスター表に対するトランザクションをコミットするときに必ず高速リフレッシュが実行されます。
ON COMMITの制限事項: 
この句は、マテリアライズド結合ビューおよびマテリアライズド集計ビューにのみサポートされます。
参照:
『Oracle Databaseアドバンスト・レプリケーション』および『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。 
ON DEMAND句
ON DEMANDを指定すると、マテリアライズド・ビューは、3つのDBMS_MVIEWリフレッシュ・プロシージャのいずれかのコールによる要求でリフレッシュされます。ON COMMITおよびON DEMANDのどちらも指定しなかった場合、ON DEMANDがデフォルトになります。
ON COMMITまたはON DEMANDを指定した場合、START WITHまたはNEXTを同時に指定できません。
参照:
これらのプロシージャの詳細は、『Oracle Database PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス』を参照してください。
REFRESH ON DEMANDを指定することによって作成できるマテリアライズド・ビューのタイプについては、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
START WITH句
START WITH dateを指定すると、最初の自動リフレッシュ時間を表す日付を指定できます。
NEXT句
NEXTを指定すると、自動リフレッシュの間隔を計算するための日付式を指定できます。
START WITH値およびNEXT値は、将来の時刻に評価される値です。START WITH値を省略した場合、Oracleデータベースはマテリアライズド・ビューの作成時刻に対してNEXT式を評価することによって、最初の自動リフレッシュ時刻を判断します。START WITH値を指定し、NEXT値を指定しない場合、Oracleデータベースは1回のみマテリアライズド・ビューをリフレッシュします。START WITH値およびNEXT値のどちらも指定しない場合、またはalter_mv_refreshを指定しない場合、Oracleデータベースはマテリアライズド・ビューを自動リフレッシュしません。
WITH PRIMARY KEY句
WITH PRIMARY KEYを指定すると、ROWIDマテリアライズド・ビューを主キー・マテリアライズド・ビューに変更できます。主キー・マテリアライズド・ビューを使用すると、高速リフレッシュを継続できるマテリアライズド・ビューの機能に影響せずに、マテリアライズド・ビュー・マスター表を再編成できます。
この句を指定するには、マスター表に、使用可能な主キー制約が定義され、この制約に基づき、主キー情報を記録するマテリアライズド・ビュー・ログが定義されている必要があります。
参照:
主キー・マテリアライズド・ビューの詳細は、『Oracle Databaseアドバンスト・レプリケーション』を参照してください。
「主キー・マテリアライズド・ビューの例:」
USING ROLLBACK SEGMENT句
自動UNDOモードでは、ロールバック・セグメントではなくUNDO表領域が使用されるため、データベースが自動UNDOモードの場合、この句は無効です。自動UNDOモードを使用することをお薦めします。この句は、ロールバック・セグメントが使用される以前のバージョンのOracleデータベースが含まれるレプリケーション環境との下位互換性のためにサポートされています。
この句の詳細は、「CREATE MATERIALIZED VIEW」の「USING ROLLBACK SEGMENT句」を参照してください。
USING ...CONSTRAINTS句
この句のセマンティクスは、CREATE MATERIALIZED VIEWおよびALTER MATERIALIZED VIEW文で同じです。この句の詳細は、「CREATE MATERIALIZED VIEW」の「USING ...CONSTRAINTS句」を参照してください。
QUERY REWRITE句
この句を使用すると、マテリアライズド・ビューをクエリー・リライトで使用できるかどうかを指定できます。
ENABLE句
ENABLEを指定すると、クエリー・リライトでマテリアライズド・ビューを使用可能にできます。
参照:
「クエリー・リライトを使用可能にする例:」 
マテリアライズド・ビューを使用可能にする場合の制限事項: 
マテリアライズド・ビューを使用可能にする処理には、次の制限事項があります。
マテリアライズド・ビューが無効または使用禁止の場合、ENABLEモードでもクエリー・リライトに適応しません。
マテリアライズド・ビューの全体または一部がビューから作成されている場合、クエリー・リライトを使用可能にできません。
マテリアライズド・ビューのすべてのユーザー定義ファンクションがDETERMINISTICである場合のみ、クエリー・リライトを使用可能にできます。
参照:
「CREATE FUNCTION」 
文内の式が反復可能な場合のみ、クエリー・リライトを使用可能にできます。たとえば、CURRENT_TIMEまたはUSERを含めることはできません。
参照:
クエリー・リライトの詳細は、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。 
DISABLE句
DISABLEを指定すると、クエリー・リライトでマテリアライズド・ビューを使用禁止にできます。マテリアライズド・ビューが無効な場合、使用禁止であるかどうかにかかわらず、クエリー・リライトの使用には適応しません。ただし、使用禁止にされたマテリアライズド・ビューをリフレッシュすることはできます。
COMPILE
COMPILEを指定すると、マテリアライズド・ビューを明示的に再検証できます。マテリアライズド・ビューが依存するオブジェクトを削除または変更した場合、マテリアライズド・ビューはアクセス可能のままですが、クエリー・リライトに対しては無効です。再度、明示的にマテリアライズド・ビューの妥当性チェックを行い、クエリー・リライトの使用に適応させるには、この句を使用します。
マテリアライズド・ビューの再妥当性チェックに失敗すると、リフレッシュできなくなるか、またはクエリー・リライトに使用できなくなります。
参照:
「マテリアライズド・ビューのコンパイル例:」 
CONSIDER FRESH
この句を使用すると、マスター表が変更された後のマテリアライズド・ビューの失効状態を管理することができます。CONSIDER FRESHは、マテリアライズド・ビューが最新であり、TRUSTEDまたはSTALE_TOLERATEDモードでのクエリー・リライトに適応するとみなされるように指定します。Oracleデータベースは、マテリアライズド・ビューが最新であるかどうかを保証できないため、ENFORCEDモードでのクエリー・リライトはサポートしません。また、この句はマテリアライズド・ビューの失効状態をUNKNOWNに設定します。失効状態は、ALL_MVIEWS、DBA_MVIEWSおよびUSER_MVIEWSの各データ・ディクショナリ・ビューのSTALENESS列に表示されます。
いずれかのマスター表の内容が変更された場合、マテリアライズド・ビューは失効します。この句は、Oracleデータベースに対して、マテリアライズド・ビューが最新で、変更されていないものと仮定するように指示します。そのため、リフレッシュが保留されているこれらの表に対する実際の更新内容は、マテリアライズド・ビューから削除されます。
参照:
クエリー・リライトの詳細、およびマスター表へのパーティション・メンテナンス操作の影響については、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
「CONSIDER FRESHの例:」
例
自動リフレッシュの例:
次の文は、マテリアライズド・ビューsales_by_month_by_state(「マテリアライズド集計ビューの作成例:」で作成)のリフレッシュ方法のデフォルトをFASTに変更します。
ALTER MATERIALIZED VIEW sales_by_month_by_state
REFRESH FAST; 
これ以降のマテリアライズド・ビューの自動リフレッシュは、高速リフレッシュになります。これは、単純なマテリアライズド・ビューであり、そのマスター表には、マテリアライズド・ビューの作成前または最後のリフレッシュ前に作成されたマテリアライズド・ビュー・ログがあります。
REFRESH句にSTART WITHまたはNEXTの値が指定されていないため、マテリアライズド・ビューsales_by_month_by_stateを作成したとき、または最後に変更したときにREFRESH句で設定されたリフレッシュ間隔がそのまま使用されます。
次の文は、マテリアライズド・ビューsales_by_month_by_stateの新しい自動リフレッシュ間隔を設定します。
ALTER MATERIALIZED VIEW sales_by_month_by_state
REFRESH NEXT SYSDATE+7;
REFRESH句にSTART WITHの値が指定されていないため、マテリアライズド・ビューsales_by_month_by_stateが作成されたとき、または最後に変更されたときに、START WITHとNEXTの値によって設定された日時に次の自動リフレッシュが行われます。
このマテリアライズド・ビューは、次に自動リフレッシュが行われる際に、リフレッシュされます。次に自動リフレッシュが行われる日時は、NEXTに設定した式SYSDATE+7が計算されて決まります。その後は、週に1回リフレッシュが自動的に行われます。REFRESH句にリフレッシュ方法が明示的に指定されていないため、CREATE MATERIALIZED VIEW文または直前のALTER MATERIALIZED VIEW文のREFRESH句で指定されたリフレッシュ方法が引き続き使用されます。
CONSIDER FRESHの例:
次の文は、Oracleデータベースがマテリアライズド・ビューsales_by_month_by_stateを最新であるとみなすように指定します。この文を使用すると、sales_by_month_by_stateのマスター表に対してパーティション・メンテナンス操作を実行した後でも、sales_by_month_by_stateに対してTRUSTEDモードでのクエリー・リライトが可能です。
ALTER MATERIALIZED VIEW sales_by_month_by_state CONSIDER FRESH;
参照:
このALTER MATERIALIZED VIEWの例を必要とするパーティション・メンテナンスの例は、「表のパーティションの分割例:」を参照してください。 
完全リフレッシュの例:
次の文は、マテリアライズド・ビューemp_data(「マテリアライズド・ビューの定期的リフレッシュ例:」で作成)の新しいリフレッシュ方法、NEXTで示す新しいリフレッシュ日時および新しい自動リフレッシュ間隔を指定します。
ALTER MATERIALIZED VIEW emp_data
REFRESH COMPLETE   
START WITH TRUNC(SYSDATE+1) + 9/24  
NEXT SYSDATE+7;
START WITH句に指定した値によって、このマテリアライズド・ビューの次の自動リフレッシュは翌日の午前9時に発生するように設定されます。この日時にマテリアライズド・ビューの完全リフレッシュが実行され、NEXTに設定した式が計算されます。その後は、このマテリアライズド・ビューは毎週リフレッシュされます。
クエリー・リライトを使用可能にする例:
次の文は、マテリアライズド・ビューemp_dataのクエリー・リライトを使用可能にし、暗黙的に再妥当性チェックを行います。
ALTER MATERIALIZED VIEW emp_data
ENABLE QUERY REWRITE;
主キー・マテリアライズド・ビューの例:
次の文は、ROWIDマテリアライズド・ビューorder_data(「ROWIDマテリアライズド・ビューの作成例:」で作成)を主キー・マテリアライズド・ビューに変更します。この例では、order_dataに主キーを持つマテリアライズド・ビュー・ログを定義していることが必要です。
ALTER MATERIALIZED VIEW order_data 
REFRESH WITH PRIMARY KEY; 
マテリアライズド・ビューのコンパイル例:
次の文は、マテリアライズド・ビューstore_mvを再検証します。
ALTER MATERIALIZED VIEW order_data COMPILE;
ALTER MATERIALIZED VIEW LOG 
用途
マテリアライズド・ビュー・ログとは、マテリアライズド・ビューのマスター表に関連付けられる表です。ALTER MATERIALIZED VIEW LOG文を使用すると、既存のマテリアライズド・ビュー・ログの記憶特性またはタイプを変更できます。
注意:
下位互換性を保つために、MATERIALIZED VIEWのかわりにキーワードSNAPSHOTもサポートされています。 
参照:
マテリアライズド・ビュー・ログの作成については、「CREATE MATERIALIZED VIEW LOG」を参照してください。
マテリアライズド・ビューのリフレッシュ方法など、マテリアライズド・ビューの詳細は、「ALTER MATERIALIZED VIEW」を参照してください。
マテリアライズド・ビューの様々なタイプの詳細は、「CREATE MATERIALIZED VIEW」を参照してください。
前提条件
マスター表の所有者であるか、またはマスター表に対するSELECT権限およびマテリアライズド・ビュー・ログに対するALTER権限が必要です。
参照:
ALTER MATERIALIZED VIEW LOGの前提条件の詳細は、『Oracle Databaseアドバンスト・レプリケーション』を参照してください。 
構文
alter_materialized_view_log::=
画像の説明
(physical_attributes_clause::=、「ALTER TABLE」の項にあるalter_table_partitioning::=、parallel_clause::=、logging_clause::=、allocate_extent_clause::=、new_values_clause::=を参照)
new_values_clause::=
画像の説明
physical_attributes_clause::=
画像の説明
(storage_clause::=を参照)
allocate_extent_clause::=
画像の説明
(size_clause::=を参照)
shrink_clause::=
画像の説明
parallel_clause::=
画像の説明
セマンティクス
FORCE
FORCEを指定すると、ADD句で指定したいずれかの項目がすでにマテリアライズド・ビュー・ログに指定されている場合、エラーは戻されませんが、既存の要素は無視され、マテリアライズド・ビュー・ログに存在しないすべての項目が追加されます。同様に、INCLUDING NEW VALUESを指定すると、この属性がすでにマテリアライズド・ビュー・ログに指定されている場合、冗長は無視され、エラーも戻されません。
schema
マスター表が定義されているスキーマを指定します。schemaを指定しない場合、マテリアライズド・ビュー・ログは自分のスキーマ内にあるとみなされます。
table
変更するマテリアライズド・ビュー・ログに関連付けられたマスター表の名前を指定します。
physical_attributes_clause
physical_attributes_clauseを使用すると、PCTFREE、PCTUSEDおよびINITRANSの各パラメータの値、マテリアライズド・ビュー・ログ、パーティションおよびオーバーフロー・データ・セグメントの記憶特性、またはパーティション・マテリアライズド・ビュー・ログのデフォルト特性を変更できます。
マテリアライズド・ビュー・ログの物理属性の制限事項: 
マテリアライズド・ビュー・ログがローカル管理表領域に存在する場合は、storage_clauseを使用して、エクステント・パラメータを変更することはできません。このパラメータについては、「CREATE TABLE」を参照してください。
alter_table_partitioning
alter_table_partitioningの構文および一般的な機能は、ALTER TABLE文の場合と同じです。「ALTER TABLE」の「alter_table_partitioning」を参照してください。
マテリアライズド・ビュー・ログのパーティション変更の制限事項: 
マテリアライズド・ビュー・ログのパーティションの変更には、次の制限事項があります。
マテリアライズド・ビュー・ログのパーティションを変更する場合、LOB_storage_clauseまたはmodify_LOB_storage_clauseは使用できません。
マテリアライズド・ビュー・ログのパーティションを削除、切捨てまたは交換しようとすると、Oracleデータベースはエラーを戻します。
parallel_clause
parallel_clauseを使用すると、マテリアライズド・ビュー・ログへのパラレル操作がサポートされているかどうかを指定できます。
この句の詳細は、「CREATE TABLE」の「parallel_clause」を参照してください。
logging_clause
マテリアライズド・ビュー・ログに対するロギング属性を指定します。この句の詳細は、「logging_clause」を参照してください。
allocate_extent_clause
allocate_extent_clauseを使用すると、マテリアライズド・ビュー・ログの新しいエクステントを明示的に割り当てることができます。この句の詳細は、「allocate_extent_clause」を参照してください。
shrink_clause
この句を使用すると、マテリアライズド・ビュー・ログのセグメントを縮小化できます。この句の詳細は、「CREATE TABLE」の「shrink_clause」を参照してください。
CACHE | NOCACHE句
アクセス頻度が高いデータについて、CACHEは、全表スキャンの実行時にこのログ用に取り出された各ブロックを、バッファ・キャッシュ内のLRUリストの最高使用頻度側に入れることを指定します。この属性は、小規模な参照表で有効です。NOCACHEは、ブロックをLRUリストの最低使用頻度側に入れることを指定します。この句の詳細は、「CREATE TABLE」の「CACHE | NOCACHE | CACHE READS」を参照してください。
ADD句
ADD句を使用すると、マテリアライズド・ビュー・マスター表内の行が変更される際に、主キー値、ROWID値、オブジェクトID値または順序も記録できるようにマテリアライズド・ビュー・ログを拡張できます。また、この句は、新しく列を記録するためにも使用できます。
これらの情報の記録を停止する場合は、マテリアライズド・ビュー・ログを削除してから、再作成する必要があります。マテリアライズド・ビュー・ログを削除した後再作成した場合、マスター表に依存するすべての既存マテリアライズド・ビューが、次回のリフレッシュ時に強制的に完全リフレッシュされます。
マテリアライズド・ビュー・ログの拡張の制限事項: 
各マテリアライズド・ビュー・ログに指定できるのは、PRIMARY KEY、ROWID、OBJECT ID、SEQUENCEおよび列リストの列を1つずつです。このALTER文にPRIMARY KEY、ROWID、OBJECT ID、SEQUENCEおよび列リストを指定できるのはそれぞれ1回のみです。また、FORCEオプションを指定しないかぎり、これらの値のいずれかが作成時に(暗黙的または明示的に)指定された場合、このALTER文にはそれらの値を指定できません。
OBJECT ID
OBJECT IDを指定すると、更新されるすべての行の適切なオブジェクト識別子をマテリアライズド・ビュー・ログに記録できます。
OBJECT ID句の制限事項: 
OBJECT IDは、オブジェクト表のログ用のみに指定でき、記憶表用には指定できません。
PRIMARY KEY
PRIMARY KEYを指定すると、更新されるすべての行の主キーをマテリアライズド・ビュー・ログに記録できます。
ROWID
ROWIDを指定すると、更新されるすべての行のROWID値をマテリアライズド・ビュー・ログに記録できます。
SEQUENCE
SEQUENCEを指定すると、追加の順序情報を提供する順序値をマテリアライズド・ビュー・ログに記録できます。
column
更新されるすべての行に対して、マテリアライズド・ビュー・ログに記録する値を持つ新しい列を指定します。通常、フィルタ列(副問合せマテリアライズド・ビューが参照する主キー以外の列)および結合列(副問合せのWHERE句で結合を定義する主キー以外の列)を指定します。
参照:
マテリアライズド・ビュー・ログに値を明示的および暗黙的に含める方法については、「CREATE MATERIALIZED VIEW」を参照してください。
フィルタ列および結合列については、『Oracle Databaseアドバンスト・レプリケーション』を参照してください。
「ROWIDマテリアライズド・ビュー・ログの例:」
NEW VALUES句
NEW VALUES句を使用すると、更新DML操作で、古い値と新しい値の両方をマテリアライズド・ビュー・ログに保存するかどうかを指定できます。ALTER MATERIALIZED VIEW LOG文で追加した列のみでなく、ログのすべての列にこの句で設定した値を適用します。
INCLUDING
INCLUDINGを指定すると、古い値と新しい値の両方を保存できます。このログが単一表マテリアライズド集計ビューの表用で、マテリアライズド・ビューに高速リフレッシュを実行する場合、INCLUDINGを指定してください。
EXCLUDING
EXCLUDINGを指定すると、ログに新しい値が記録されなくなります。この句を使用すると、新しい値の記録によるオーバーヘッドを回避できます。
マテリアライズド・ビューのリフレッシュ・モードをFAST以外のモードに変更した場合を除き、高速リフレッシュが可能な単一表マテリアライズド集計ビューが定義されている場合は、EXCLUDING NEW VALUESを使用しないでください。
参照:
「マテリアライズド・ビュー・ログEXCLUDING NEW VALUESの例:」 
例
ROWIDマテリアライズド・ビュー・ログの例:
次の文は、ROWID情報も記録するように既存の主キー・マテリアライズド・ビュー・ログを変更します。
ALTER MATERIALIZED VIEW LOG ON order_items ADD ROWID;
マテリアライズド・ビュー・ログEXCLUDING NEW VALUESの例:
次の文は、フィルタ列を追加し、新しい値を除外することで、hr.employeesのマテリアライズド・ビュー・ログを変更します。このログを使用するマテリアライズド集計ビューは、これ以降高速リフレッシュされません。ただし、高速リフレッシュが不要になる場合は、この処理によって新しい値の記録によるオーバーヘッドを回避できます。
ALTER MATERIALIZED VIEW LOG ON employees
ADD (commission_pct)
EXCLUDING NEW VALUES;
ALTER OPERATOR
用途
ALTER OPERATOR文を使用すると、既存の演算子に対するバインドを追加または削除したり、既存の演算子をコンパイルすることができます。
参照:
「CREATE OPERATOR」 
前提条件
事前にCREATE OPERATOR文によって演算子が作成されている必要があります。演算子が自分のスキーマ内にあるか、またはALTER ANY OPERATORシステム権限が必要です。ALTER OPERATOR文で参照される演算子およびファンクションに対するEXECUTEオブジェクト権限が必要です。
構文
alter_operator::=
画像の説明
(add_binding_clause::=、drop_binding_clause::=を参照)
add_binding_clause::=
画像の説明
(implementation_clause::=、using_function_clause::=を参照)
implementation_clause::=
画像の説明
(context_clause::=を参照)
context_clause::=
画像の説明
using_function_clause::=
画像の説明
drop_binding_clause::=
画像の説明
セマンティクス
schema
演算子が含まれているスキーマを指定します。この句を指定しない場合、その演算子は自分のスキーマにあるとみなされます。
operator
変更する演算子の名前を指定します。
add_binding_clause
この句を使用すると、演算子バインドを追加し、パラメータ・データ型および戻り型を指定できます。この演算子の既存のバインドと異なる署名を使用する必要があります。
演算子のバインドが索引タイプに関連付けられており、演算子に別のバインドを追加する場合、Oracleデータベースは新しいバインドと索引タイプの関連付けを自動的に行いません。関連付けを行うには、明示的なALTER INDEXTYPE ...ADD OPERATOR文を発行する必要があります。
implementation_clause
この句のセマンティクスは、CREATE OPERATORおよびALTER OPERATOR文で同じです。この句の詳細は、「CREATE OPERATOR」の「implementation_clause」を参照してください。
context_clause
この句のセマンティクスは、CREATE OPERATORおよびALTER OPERATOR文で同じです。この句の詳細は、「CREATE OPERATOR」の「context_clause」を参照してください。
using_function_clause
この句のセマンティクスは、CREATE OPERATORおよびALTER OPERATOR文で同じです。この句の詳細は、「CREATE OPERATOR」の「using_function_clause」を参照してください。
drop_binding_clause
この句を使用すると、演算子から削除するバインドのパラメータ・データ型のリストを指定できます。バインドに索引タイプや補助演算子バインドなどの依存オブジェクトが含まれる場合、FORCEを指定する必要があります。FORCEを指定すると、そのバインドに依存するすべてのオブジェクトにINVALIDのマークが付きます。依存オブジェクトは、DDL文、DML文または問合せで次に参照された際に再検証されます。
この句を使用して、この演算子に関連付けられた唯一のバインドを削除することはできません。この演算子に関連付けられた唯一のバインドを削除するには、DROP OPERATOR文を使用する必要があります。詳細は、「DROP OPERATOR」を参照してください。
COMPILE
COMPILEを指定すると、演算子を再コンパイルできます。
例
ユーザー定義演算子のコンパイル例:
次の例は、演算子eq_op(「ユーザー定義演算子の作成例:」で作成)をコンパイルします。
ALTER OPERATOR eq_op COMPILE;
ALTER OUTLINE 
用途
ALTER OUTLINE文を使用すると、ストアド・アウトラインの名前を変更したり、ストアド・アウトラインを異なるカテゴリに再度割り当てることができます。また、アウトラインのSQL文をコンパイルし、古いアウトライン・データを現行の条件で作成したアウトラインと置き換えて、ストアド・アウトラインを再生成できます。
参照:
アウトラインの詳細は、「CREATE OUTLINE」および『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
前提条件
アウトラインを変更する場合は、ALTER ANY OUTLINEシステム権限が必要です。
構文
alter_outline::=
画像の説明
セマンティクス
PUBLIC | PRIVATE
PUBLICを指定すると、アウトラインのパブリック・バージョンを変更できます。これはデフォルトです。
PRIVATEを指定すると、現行のセッションに対してプライベートで、現行の解析スキーマにデータが格納されているアウトラインを変更できます。
outline
変更するアウトラインの名前を指定します。
REBUILD
REBUILDを指定すると、現行の条件で、outlineの実行計画が再生成されます。
参照:
「アウトラインの再構築例:」 
RENAME TO句
RENAME TO句を使用すると、outlineの値と置き換えるアウトライン名を指定できます。
CHANGE CATEGORY TO句
CHANGE CATEGORY TO句を使用すると、outlineの移動先となるカテゴリ名を指定できます。
ENABLE | DISABLE
この句を使用すると、このアウトラインを選択的に使用可能または使用禁止にできます。デフォルトでは、アウトラインは使用可能になっています。DISABLEキーワードを使用すると、他のアウトラインの使用に影響を与えずに、1つのアウトラインを使用禁止にできます。
例
アウトラインの再構築例:
次の文は、アウトラインのテキストをコンパイルし、古いアウトライン・データを現行の条件で作成したアウトラインと置き換えて、salariesというストアド・アウトラインを再生成します。
ALTER OUTLINE salaries REBUILD;
ALTER PACKAGE 
用途
ALTER PACKAGE文を使用すると、パッケージ仕様部またはパッケージ本体(あるいはその両方)を明示的に再コンパイルできます。明示的に再コンパイルすることによって、実行時に暗黙的に再コンパイルする必要がなくなり、また、実行時のコンパイル・エラーとパフォーマンス上のオーバーヘッドもなくなります。
パッケージ中のすべてのオブジェクトは、1つの単位として格納されているため、ALTER PACKAGE文によって、すべてのパッケージ・オブジェクトがまとめて再コンパイルされます。ALTER PROCEDURE文またはALTER FUNCTION文を使用して、パッケージ中の一部のプロシージャまたはファンクションを再コンパイルすることはできません。
注意:
この文を使用して、既存のパッケージの宣言や定義を変更することはできません。パッケージを再宣言または再定義する場合は、「CREATE PACKAGE」または「CREATE PACKAGE BODY」にOR REPLACE句を指定します。 
前提条件 
パッケージを変更するには、パッケージが自分のスキーマ内にある必要があります。自分のスキーマ内にない場合は、ALTER ANY PROCEDUREシステム権限が必要です。
構文
alter_package::=
画像の説明
compiler_parameters_clause::=
画像の説明
セマンティクス
schema
パッケージが含まれているスキーマを指定します。schemaを指定しない場合、パッケージは自分のスキーマ内にあるとみなされます。
package
再コンパイルするパッケージの名前を指定します。
COMPILE
COMPILEを指定すると、パッケージ仕様部およびパッケージ本体を再コンパイルできます。COMPILEキーワードは必須です。
再コンパイル中、Oracleデータベースはすべての永続コンパイラのスイッチ設定を削除し、セッションからそれらを再び取得してコンパイルの終了時に格納します。この手順を回避するには、REUSE SETTINGS句を指定します。
パッケージの再コンパイル時にコンパイル・エラーが発生した場合は、エラーが戻り、パッケージ本体は無効のままです。SQL*PlusコマンドSHOW ERRORSを使用して、関連するコンパイラ・エラー・メッセージを表示できます。
参照:
「パッケージの再コンパイル例:」 
SPECIFICATION
SPECIFICATIONを指定すると、無効かどうかにかかわらず、パッケージ仕様部のみを再コンパイルできます。パッケージ仕様部を変更した場合は、コンパイル・エラーの有無を確認するために再コンパイルします。
その結果、そのパッケージ中のプロシージャまたはファンクションをコールするプロシージャなど、再コンパイルされたパッケージ仕様部に依存するローカル・オブジェクトはすべて無効になります。パッケージ本体もそのパッケージ仕様部に依存します。その後、明示的に再コンパイルせずに、これらの依存オブジェクトを参照した場合、Oracleデータベースは実行時にそれらを暗黙的に再コンパイルします。
BODY
BODYを指定すると、無効かどうかにかかわらず、パッケージ本体のみを再コンパイルできます。パッケージ本体は、変更後に再コンパイルしてください。なお、パッケージ本体を再コンパイルしても、そのパッケージ仕様部に基づくオブジェクトは無効になりません。
パッケージ本体を再コンパイルした場合、そのパッケージ本体が依存するオブジェクトが無効の場合は、最初にそのオブジェクトが再コンパイルされます。パッケージ本体の再コンパイルが正常に終了した場合、この本体は有効になります。
PACKAGE
PACKAGEを指定すると、有効か無効かにかかわらず、パッケージ仕様部およびパッケージ本体(存在する場合)の両方を再コンパイルできます。これはデフォルトです。パッケージ仕様部およびパッケージ本体を再コンパイルした場合、前述のSPECIFICATIONおよびBODYで説明するとおり、依存オブジェクトの再妥当性チェックおよび再コンパイルが必要になります。
参照:
リモート・オブジェクトを含むスキーマ・オブジェクト間の依存性をOracleデータベースが管理する方法については、『Oracle Database概要』を参照してください。 
DEBUG
DEBUGを指定すると、PL/SQLコンパイラに対して、PL/SQLデバッガ用のコードを生成および格納するように指示できます。この句を指定すると、compiler_parameters_clauseでPLSQL_DEBUG = TRUEを指定するのと同じ効果が得られます。
参照:
パッケージのデバッグの詳細は、『Oracle Database PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス』を参照してください。 
compiler_parameters_clause
この句のパッケージに対する動作は、ファンクションに対する動作と同じです。詳細は、「ALTER FUNCTION」の「compiler_parameters_clause」を参照してください。
REUSE SETTINGS
この句のパッケージに対する動作は、ファンクションに対する動作と同じです。詳細は、「ALTER FUNCTION」の句「REUSE SETTINGS」を参照してください。
例
パッケージの再コンパイル例:
次の文は、hr.emp_mgmtパッケージの仕様部(「パッケージの作成例:」で作成)および本体を明示的に再コンパイルします。
ALTER PACKAGE emp_mgmt
COMPILE PACKAGE; 
emp_mgmtの仕様部および本体の再コンパイル時に、コンパイル・エラーが発生しなかった場合、emp_mgmtは有効になります。その後、ユーザーhrは、実行時に再コンパイルしなくても、emp_mgmtの仕様部に宣言されたすべてのパッケージ・オブジェクトをコールまたは参照できます。emp_mgmtの再コンパイル時にコンパイル・エラーが発生した場合は、エラーが戻り、emp_mgmtは無効のままです。
また、emp_mgmtに依存しているすべてのオブジェクトが無効になります。その後、明示的に再コンパイルせずに、これらのオブジェクトを参照した場合、Oracleデータベースは、実行時にそれらを暗黙的に再コンパイルします。
次の文は、スキーマhr内のemp_mgmtパッケージの本体を再コンパイルします。
ALTER PACKAGE hr.emp_mgmt 
COMPILE BODY; 
パッケージ本体の再コンパイル時にコンパイル・エラーが発生しなければ、この本体は有効になります。その後、ユーザーhrは、実行時に再コンパイルしなくても、emp_mgmtの仕様部に宣言されたすべてのパッケージ・オブジェクトをコールまたは参照できます。本体の再コンパイル時にコンパイル・エラーが発生した場合は、エラー・メッセージが戻り、パッケージ本体は無効のままです。
この文は、emp_mgmtの仕様部ではなく本体を再コンパイルするため、依存するオブジェクトは無効にはなりません。
ALTER PROCEDURE 
用途
ALTER PROCEDURE文を使用すると、スタンドアロンのストアド・プロシージャを明示的に再コンパイルできます。明示的に再コンパイルすることによって、実行時に暗黙的に再コンパイルする必要がなくなり、また、実行時のコンパイル・エラーとパフォーマンス上のオーバーヘッドもなくなります。
パッケージの一部であるプロシージャを再コンパイルする場合、ALTER PACKAGE文を使用して、そのパッケージ全体を再コンパイルします(「ALTER PACKAGE」を参照)。
注意:
この文を使用して、既存のプロシージャの宣言または定義を変更することはできません。プロシージャを再宣言または再定義する場合は、OR REPLACEを指定してCREATE PROCEDURE文を使用します(「CREATE PROCEDURE」を参照)。 
ALTER PROCEDURE文は、ALTER FUNCTION文と似ています。詳細は、「ALTER FUNCTION」を参照してください。
前提条件
プロシージャは、自分のスキーマ内にある必要があります。自分のスキーマ内にない場合は、ALTER ANY PROCEDUREシステム権限が必要です。
構文
alter_procedure::=
画像の説明
compiler_parameters_clause::=
画像の説明
セマンティクス
schema
プロシージャが含まれているスキーマを指定します。schemaを指定しない場合、プロシージャは自分のスキーマ内にあるとみなされます。
procedure
再コンパイルするプロシージャの名前を指定します。
COMPILE
COMPILEを指定すると、プロシージャを再コンパイルできます。COMPILEキーワードは必須です。プロシージャが有効か無効かにかかわらず、プロシージャは再コンパイルされます。
いずれかのオブジェクトが無効の場合、プロシージャが依存するオブジェクトが最初に再コンパイルされます。
プロシージャに依存するすべてのローカル・オブジェクト(たとえば、再コンパイルしたプロシージャをコールするプロシージャ、再コンパイルしたプロシージャをコールするプロシージャを定義するパッケージ本体など)が無効になります。
プロシージャの再コンパイルが正常に終了すると、このプロシージャは有効になります。プロシージャの再コンパイル時にエラーが発生した場合は、エラーが戻り、プロシージャは無効のままです。SQL*PlusコマンドSHOW ERRORSを使用して、関連するコンパイラ・エラー・メッセージを表示できます。
再コンパイル中、Oracleデータベースはすべての永続コンパイラのスイッチ設定を削除し、セッションからそれらを再び取得してコンパイルの終了時に格納します。この手順を回避するには、REUSE SETTINGS句を指定します。
参照:
リモート・オブジェクトを含むスキーマ・オブジェクト間の依存性をOracleデータベースが管理する方法については、『Oracle Database概要』および「プロシージャの再コンパイル例:」を参照してください。 
DEBUG
DEBUGを指定すると、PL/SQLコンパイラに対して、PL/SQLデバッガ用のコードを生成および格納するように指示できます。この句を指定すると、compiler_parameters_clauseでPLSQL_DEBUG = TRUEを指定するのと同じ効果が得られます。
参照:
これらのプロシージャについては、『Oracle Databaseアプリケーション開発者ガイド-基礎編』を参照してください。 
compiler_parameters_clause
この句のプロシージャに対する動作は、ファンクションに対する動作と同じです。詳細は、「ALTER FUNCTION」の「compiler_parameters_clause」を参照してください。
REUSE SETTINGS
この句のプロシージャに対する動作は、ファンクションに対する動作と同じです。詳細は、「ALTER FUNCTION」の句「REUSE SETTINGS」を参照してください。
例
プロシージャの再コンパイル例:
次の文は、ユーザーhrが所有するプロシージャremove_empを明示的に再コンパイルします。
ALTER PROCEDURE hr.remove_emp
COMPILE; 
creditの再コンパイル時にエラーが発生しなければ、creditは有効になります。その後、Oracleデータベースは、実行時にそれを再コンパイルしなくても実行できます。creditの再コンパイル時にコンパイル・エラーが発生した場合は、エラーが戻り、creditは無効のままです。
依存するオブジェクトもすべて無効になります。これらのオブジェクトとは、creditをコールするプロシージャ、ファンクション、パッケージ本体などです。その後、明示的に再コンパイルせずに、これらのオブジェクトを参照した場合、Oracleデータベースは、実行時にそれらを暗黙的に再コンパイルします。
ALTER PROFILE 
用途
ALTER PROFILE文を使用すると、プロファイルのリソース制限またはパスワード管理パラメータを追加、変更または削除できます。
ALTER PROFILE文を使用すると、プロファイルに対して行った変更は、このプロファイルの現行のセッションのユーザーには影響しません。後続セッションのユーザーのみに影響します。
参照:
プロファイルの作成の詳細は、「CREATE PROFILE」を参照してください。 
前提条件
プロファイルのリソース制限を変更する場合は、ALTER PROFILEシステム権限が必要です。パスワード制限および保護を変更する場合は、ALTER PROFILEおよびALTER USERシステム権限が必要です。
構文
alter_profile::=
画像の説明
(resource_parameters::=、password_parameters::=を参照)
resource_parameters::=
画像の説明
(size_clause::=を参照)
password_parameters::=
画像の説明
セマンティクス
ALTER PROFILE文のキーワード、パラメータおよび句の意味は、すべてCREATE PROFILE文のキーワード、パラメータおよび句と同じです。
DEFAULTプロファイルから制限を削除することはできません。
詳細は、「CREATE PROFILE」および次の例を参照してください。
例
パスワードを無効にする例:
次の文は、new_profileプロファイル(「プロファイルの作成例:」で作成)のパスワードを90日間再利用できないようにします。
ALTER PROFILE new_profile 
LIMIT PASSWORD_REUSE_TIME 90 
PASSWORD_REUSE_MAX UNLIMITED;
デフォルトのパスワード値の設定例:
次の文は、app_userプロファイル(「プロファイルのリソース制限の設定の例:」で作成)のPASSWORD_REUSE_TIME値をDEFAULTプロファイルに定義された値にデフォルト設定します。
ALTER PROFILE app_user 
LIMIT PASSWORD_REUSE_TIME DEFAULT
PASSWORD_REUSE_MAX UNLIMITED;
ログインおよびパスワード・ロック時間の制限例:
次の文は、プロファイルapp_userのFAILED_LOGIN_ATTEMPTSを5に、PASSWORD_LOCK_TIMEを1に変更します。
ALTER PROFILE app_user LIMIT
FAILED_LOGIN_ATTEMPTS 5
PASSWORD_LOCK_TIME 1;
この文を使用すると、ログインに5回失敗した場合に、app_userのアカウントは1日ロックされます。
パスワードの有効期限および猶予期間の変更例:
次の文は、プロファイルapp_user2のPASSWORD_LIFE_TIMEを90日に、PASSWORD_GRACE_TIMEを5日に変更します。
ALTER PROFILE app_user2 LIMIT
PASSWORD_LIFE_TIME 90
PASSWORD_GRACE_TIME 5;
同時セッションの制限例:
次の文は、プロファイルapp_userに同時実行セッションの新しい制限5を指定します。
ALTER PROFILE app_user LIMIT SESSIONS_PER_USER 5; 
現在、プロファイルapp_userにSESSIONS_PER_USERの制限が定義されていない場合は、このプロファイルに制限5が追加されます。プロファイルに制限が定義されている場合は、前述の文によってその制限が5に再定義されます。プロファイルapp_userが割り当てられているすべてのユーザーは、同時実行のセッションが5件に制限されます。
プロファイル制限の削除例:
次の文は、プロファイルapp_userのIDLE_TIME制限を削除します。
ALTER PROFILE app_user LIMIT IDLE_TIME DEFAULT;
プロファイルapp_userが割り当てられているユーザーは、以降のセッションからプロファイルDEFAULTに定義されたIDLE_TIME制限に従います。
プロファイル・アイドル時間の制限例:
次の文は、プロファイルDEFAULTにアイドル時間の制限(2分)を定義します。
ALTER PROFILE default LIMIT IDLE_TIME  2; 
IDLE_TIMEの制限は、次のユーザーに適用されます。
プロファイルが明示的に割り当てられていないユーザー
IDLE_TIMEの制限が定義されていないプロファイルが明示的に割り当てられているユーザー 
次の文は、プロファイルapp_user2に無制限のアイドル時間を設定します。
ALTER PROFILE app_user2 LIMIT IDLE_TIME UNLIMITED; 
プロファイルapp_user2が割り当てられているすべてのユーザーは、以降のセッションから無制限のアイドル時間が許可されます。
ALTER RESOURCE COST 
用途
ALTER RESOURCE COST文を使用すると、セッションで使用するリソース・コストの合計を算出するための式を指定または変更できます。
Oracleデータベースは、その他のリソースの使用も監視しますが、セッションに対するリソース・コストの合計は、この構文の4種類のリソースに基づいて算出されます。
この文を使用すると、4種類のリソースに重みを適用できます。Oracleデータベースは、プロファイルに指定されたこれらのリソースの値に重みを適用し、リソース・コストの合計を算出する計算式を設定します。CREATE PROFILE文のCOMPOSITE_LIMITパラメータを使用して、セッションに対するコストを制限できます。セッションのリソース・コストが制限を超えた場合、セッションは異常終了し、エラーが戻ります。各リソースに割り当てた重みを変更するためにALTER RESOURCE COST文を使用した場合、現行のセッション以降のすべてのセッションで、その新しい重みを基にリソース・コストが計算されます。
参照:
すべてのリソースおよびリソース制限の設定については、「CREATE PROFILE」を参照してください。 
前提条件
ALTER RESOURCE COSTシステム権限が必要です。
構文
alter_resource_cost::=
画像の説明
セマンティクス
最初にセッションで使用された各リソースの量にそのリソースの重みを乗算し、次に、4種類のリソースの乗算結果を加算することによって、リソース・コストの合計が計算されます。どのセッションについても、このコストは、ユーザーのプロファイル内のCOMPOSITE_LIMITパラメータの値によって制限されます。乗算結果と総コストは、ともにサービス単位と呼ばれる単位で表されます。
CPU_PER_SESSION
このキーワードを使用すると、CPU_PER_SESSIONリソースに重みを適用できます。
CONNECT_TIME
このキーワードを使用すると、CONNECT_TIMEリソースに重みを適用できます。
LOGICAL_READS_PER_SESSION
この句を使用すると、LOGICAL_READS_PER_SESSIONリソースに重みを適用できます。論理読取りには、メモリーおよびディスクの両方から読み取られたブロックが含まれます。
PRIVATE_SGA
この句を使用すると、PRIVATE_SGAリソースに重みを適用できます。共有サーバー・アーキテクチャを使用して、セッション用としてSGA内でプライベート領域を割り当てている場合のみ、この制限が適用されます。
integer
各リソースの重みを指定します。各リソースに割り当てる重みによって、各リソースがリソース・コストの合計に影響する程度が決定されます。リソースに重みを割り当てない場合は、デフォルト値の0(ゼロ)が適用され、コストへの影響はありません。重みを割り当てた場合は、データベースの次のセッション以降のすべてのセッションで、その重みが適用されます。
例
リソース・コストの変更例:
次の文は、リソースCPU_PER_SESSIONとCONNECT_TIMEに重みを割り当てます。
ALTER RESOURCE COST 
CPU_PER_SESSION 100
CONNECT_TIME      1; 
この重みによって、セッションごとに次のコスト計算式が設定されます。
cost = (100 * CPU_PER_SESSION) + (1 * CONNECT_TIME) 
CPU_PER_SESSIONおよびCONNECT_TIMEの値は、DEFAULTプロファイルまたはセッションのユーザーのプロファイルにある値のいずれかです。
ここでは、リソースLOGICAL_READS_PER_SESSIONおよびPRIVATE_SGAに重みを割り当てていないため、これらのリソースは式に含まれません。
プロファイルでCOMPOSITE_LIMIT値として500を割り当てた場合、costが500を超えると、必ず、セッションはこの制限を超えます。たとえば、CPU時間0.04秒、経過時間101分を使用するセッションは、この制限を超えます。同様に、CPU時間が0.0301秒、経過時間が200分のセッションもこの制限を超えます。
一度割り当てた重みは、次のように、別のALTER RESOURCE文を発行することによって変更できます。
ALTER RESOURCE COST 
LOGICAL_READS_PER_SESSION 2
CONNECT_TIME 0; 
新しく割り当てた重みによって、新しいコスト計算式が設定されます。
cost = (100 * CPU_PER_SESSION) + (2 * LOGICAL_READ_PER_SECOND) 
CPU_PER_SESSIONおよびLOGICAL_READS_PER_SECONDの値は、DEFAULTプロファイルまたはセッションのユーザーのプロファイルにある値のいずれかです。
このALTER RESOURCE COST文によって、式は次のように変更されます。
CPU_PER_SESSIONリソースの重みは指定しません。このリソースにはすでに重みが割り当てられているため、式では先に指定した重みがそのまま使用されます。
LOGICAL_READS_PER_SESSIONリソースに重みを割り当てたため、このリソースが式で使用されます。
CONNECT_TIMEリソースに0(ゼロ)を割り当てたため、このリソースは式に含まれていません。
PRIVATE_SGAリソースの重みは指定しません。このリソースには重みを割り当てていないため、式に含まれていません。
ALTER ROLE 
用途
ALTER ROLE文を使用すると、ロールを使用可能にするために必要な許可を変更できます。
参照:
ロールの作成の詳細は、「CREATE ROLE」を参照してください。
セッションのロールを使用可能または使用禁止にする方法については、「SET ROLE」を参照してください。
前提条件
ロールにADMIN OPTIONが付与されている必要があります。付与されていない場合は、ALTER ANY ROLEシステム権限が必要です。
ロールをIDENTIFIED GLOBALLYに変更する前に、次の作業が必要です。
ロールに対して外部的に識別されたロール権限をすべて取り消します。
すべてのユーザー、ロールおよびPUBLICからロールの付与を取り消します。
この規則の唯一の例外として、現在ロールを変更しているユーザーからはそのロールを取り消さないでください。
構文
alter_role::=
画像の説明
セマンティクス 
ALTER ROLE文のキーワード、パラメータおよび句の意味は、すべてCREATE ROLE文のキーワード、パラメータおよび句と同じです。
ロールの変更の注意事項:
ロールの変更には、次の注意事項があります。
すでに使用可能なロールのユーザー・セッションには影響しません。
パスワードによって識別されるロールをアプリケーション・ロールに変更する場合(USING package句を使用)、ロールに対応付けられたパスワード情報は失われます。次にロールが使用可能になるときから、新しい認証方式が使用されます。
ALTER ANY ROLEシステム権限を持つユーザーが、IDENTIFIED GLOBALLYロールをIDENTIFIED BY password、IDENTIFIED EXTERNALLYまたはNOT IDENTIFIEDに変更すると、非グローバルなロールを作成した場合と同様に、そのユーザーに変更されたロールがADMIN OPTION付きで付与されます。
詳細は、「CREATE ROLE」および次の例を参照してください。
例
ロール識別機能の変更例:
次の文は、ロールwarehouse_user(「ロールの作成例:」で作成)をNOT IDENTIFIEDに変更します。
ALTER ROLE warehouse_user NOT IDENTIFIED;
ロール・パスワードの変更例:
次の文は、ロールdw_manager(「ロールの作成例:」で作成)のパスワードをdataに変更します。
ALTER ROLE dw_manager 
IDENTIFIED BY data; 
パスワードの変更後、ロールdw_managerが付与されているユーザーは、新しいパスワードdataを入力してこのロールを使用可能にする必要があります。
アプリケーション・ロールの例:
次の例は、ロールdw_managerをhr.adminパッケージを使用してアプリケーション・ロールに変更します。
ALTER ROLE dw_manager IDENTIFIED USING hr.admin;
ALTER ROLLBACK SEGMENT 
注意:
ロールバック・セグメントを使用せずに、自動UNDO管理モードでデータベースを実行することを強くお薦めします。ロールバック・セグメントは、以前のバージョンのOracleデータベースとの互換性に必要な場合以外は使用しないでください。自動UNDO管理の詳細は、『Oracle Database管理者ガイド』を参照してください。 
ALTER ROLLBACK SEGMENT文を使用すると、ロールバック・セグメントのオンライン/オフライン切替え、記憶特性の変更、またはロールバック・セグメントの最適サイズまたは指定サイズへの縮小を行うことができます。
ここでは、データベースがロールバックUNDOモードで実行されている(初期化パラメータUNDO_MANAGEMENTにMANUALを設定、またはすべて設定しない)ことを前提としています。データベースが自動UNDOモードで実行されている場合(初期化パラメータUNDO_MANAGEMENTにAUTOを設定)、ユーザー作成のロールバック・セグメントには関連がなくなります。
参照:
ロールバック・セグメントの作成については、「CREATE ROLLBACK SEGMENT」を参照してください。
UNDO_MANAGEMENTパラメータの詳細は、『Oracle Databaseリファレンス』を参照してください。
前提条件
ALTER ROLLBACK SEGMENTシステム権限が必要です。
構文
alter_rollback_segment::=
画像の説明
(storage_clause、size_clause::=を参照)
セマンティクス
rollback_segment
既存のロールバック・セグメントの名前を指定します。
ONLINE
ONLINEを指定すると、ロールバック・セグメントをオンラインにできます。ロールバック・セグメントを作成した場合、最初はオフライン状態になり、トランザクションに使用できなくなります。この句を指定した場合、ロールバック・セグメントはオンラインになり、インスタンスは、トランザクションに対してそのロールバック・セグメントを使用できるようになります。また、初期化パラメータROLLBACK_SEGMENTSを使用すると、インスタンスの起動時にロールバック・セグメントをオンラインにできます。
参照:
「ロールバック・セグメントをオンラインにする例:」 
OFFLINE
OFFLINEを指定すると、ロールバック・セグメントをオフラインにできます。
ロールバック・セグメント内に、アクティブ・トランザクションのロールバックに必要な情報が含まれていない場合は、すぐにオフラインになります。
ロールバック・セグメントにアクティブ・トランザクションについての情報が含まれている場合、このロールバック・セグメントをその後のトランザクションに対して使用できないようにします。また、そのすべてのアクティブ・トランザクションがコミットまたはロールバックされた後、ロールバック・セグメントはオフラインになります。
オフラインになっているロールバック・セグメントは、どのインスタンスからもオンラインにできます。
ロールバック・セグメントがオンラインかオフラインかを確認するには、データ・ディクショナリ・ビューDBA_ROLLBACK_SEGSのSTATUS列を問い合せます。オンライン・ロールバック・セグメントの値はIN_USEです。オフライン・ロールバック・セグメントの値はAVAILABLEです。
ロールバック・セグメントをオフラインにする場合の制限事項: 
SYSTEMロールバック・セグメントをオフラインにすることはできません。
storage_clause
storage_clauseを使用すると、ロールバック・セグメントの記憶特性を変更できます。
ロールバック・セグメントの記憶域の制限事項: 
INITIALパラメータの値は変更できません。ロールバック・セグメントがローカル管理表領域にある場合、変更可能な記憶域パラメータはOPTIMALのみです。ロールバック・セグメントがディクショナリ管理表領域にある場合、変更可能な記憶域パラメータは、NEXT、MINEXTENTS、MAXEXTENTSおよびOPTIMALのみです。
参照:
構文および追加情報については、「storage_clause」を参照してください。 
SHRINK句
SHRINKを指定すると、ロールバック・セグメントを最適サイズまたは指定サイズに縮小できます。縮小されるかどうか、および縮小量は、ロールバック・セグメントの使用可能領域およびアクティブ・トランザクションのロールバック・セグメント内での領域保持状態の状況によって異なります。
TO size_clauseに値を指定しなかった場合、ロールバック・セグメントを作成したCREATE ROLLBACK SEGMENT文のstorage_clauseのOPTIMALで指定した値が、デフォルトのサイズになります。OPTIMAL値を指定しなかった場合、CREATE ROLLBACK SEGMENT文のstorage_clauseのMINEXTENTSで指定した値がデフォルトのサイズになります。
TO size_clauseに値を指定するかどうかにかかわらず、次のことがいえます。
この文の実行時には、ロールバック・セグメントの縮小値が有効です。その後、サイズはCREATE ROLLBACK SEGMENT文のOPTIMAL値に戻ります。
ロールバック・セグメントは、エクステント数2未満には縮小できません。
ロールバック・セグメントを縮小した後でロールバック・セグメントの実際のサイズを確認する場合は、DBA_SEGMENTSビューのBYTES列、BLOCKS列およびEXTENTS列を問い合せます。
ロールバック・セグメントの縮小の制限事項: 
Real Application Clusters環境では、インスタンスに対してオンライン状態のロールバック・セグメントのみを縮小できます。
参照:
この句の詳細は、「size_clause」および「ロールバック・セグメントのサイズの変更例:」を参照してください。 
例
次の例では、ロールバック・セグメントrbs_one(「ロールバック・セグメントの作成例:」で作成)を使用します。
ロールバック・セグメントをオンラインにする例:
次の文は、ロールバック・セグメントrbs_oneをオンラインにします。
ALTER ROLLBACK SEGMENT rbs_one ONLINE; 
ロールバック・セグメントのサイズの変更例:
次の文は、ロールバック・セグメントrbs_oneを縮小します。
ALTER ROLLBACK SEGMENT rbs_one 
SHRINK TO 100 M;
ALTER SEQUENCE 
用途
ALTER SEQUENCE文を使用すると、既存の順序の増分値、最小値および最大値、キャッシュされる数および動作を変更できます。この文は、順序番号に影響します。
参照:
順序の詳細は、「CREATE SEQUENCE」を参照してください。 
前提条件
順序が自分のスキーマ内にある必要があります。自分のスキーマ内にない場合は、順序に対するALTERオブジェクト権限またはALTER ANY SEQUENCEシステム権限が必要です。
構文
alter_sequence::=
画像の説明
セマンティクス 
この文のキーワードおよびパラメータの意味は、順序を作成する場合と同じです。
異なる順序番号で再開する場合、順序を削除して再作成する必要があります。
NEXTVALを最初に呼び出す前に、INCREMENT BYの値を変更する場合、いくつかの順序番号がスキップされます。このため、元のSTART WITHの値を保持するには、順序を削除し、これを元のSTART WITHの値および新しいINCREMENT BYの値を使用して再作成する必要があります。
いくつかの妥当性チェックが行われます。たとえば、MAXVALUEの値に現行の順序番号より小さい値は指定できません。
参照:
順序の作成については、「CREATE SEQUENCE」を参照してください。順序の削除および再作成については、「DROP SEQUENCE」を参照してください。 
例
順序の変更例:
次の文は、customers_seq順序(「順序の作成例:」で作成)に新しい最大値を設定します。
ALTER SEQUENCE customers_seq 
MAXVALUE 1500;
次の文は、customers_seq順序にCYCLEおよびCACHEオプションを指定します。
ALTER SEQUENCE customers_seq 
CYCLE
CACHE 5; 
ALTER SESSION 
用途
ALTER SESSION文を使用すると、データベースへの接続に影響するすべての条件またはパラメータを、設定または変更できます。この文は、データベースとの接続を切断するまで有効です。
前提条件
SQLトレース機能を使用可能または使用禁止にするには、ALTER SESSIONシステム権限が必要です。
再開可能な領域割当てを使用可能または使用禁止にするには、RESUMABLEシステム権限が必要です。
特に指定がないかぎり、これ以外の操作についての権限は必要ありません。
構文
alter_session::=
画像の説明
alter_session_set_clause::=
画像の説明
セマンティクス
ADVISE句
ADVISE句を指定すると、分散トランザクションを強制処理するためのアドバイスをリモート・データベースに送ることができます。リモート・データベース内のDBA_2PC_PENDINGビューのADVICE列に、アドバイスが表示されます(値'C'がCOMMIT、'R'がROLLBACK、'  'がNOTHINGを示します)。トランザクションの状態がインダウトになった場合、データベース管理者は、このアドバイスを使用してトランザクションをコミットするか、ロールバックするかを決定できます。
単一トランザクションにおいて、ADVISE句を指定したALTER SESSION文を複数発行し、リモート・データベースごとに異なるアドバイスを送ることができます。ADVISE句を指定した文はそれぞれ、ADVISE句を指定した別の文が発行されるまで、トランザクション内の後続する文で参照されるデータベースに対してアドバイスを送ります。
参照:
「分散トランザクションを強制的に実行する例:」 
CLOSE DATABASE LINK句
CLOSE DATABASE LINKを指定すると、データベース・リンクdblinkをクローズできます。データベース・リンクを使用するSQL文を発行した場合、Oracleデータベースは、このデータベース・リンクを使用してリモート・データベース上にセッションを作成します。この接続は、セッションの終了またはデータベース・リンクの数が初期化パラメータOPEN_LINKSの値を超えるまでオープンされています。リンクをオープンしたままにしておくことによって発生するネットワークのオーバーヘッドを減らすには、セッションでデータベース・リンクを再度使用しない場合に、この句を使用してデータベース・リンクを明示的にクローズします。
参照:
「データベース・リンクをクローズする例:」 
ENABLE | DISABLE COMMIT IN PROCEDURE
プロシージャおよびストアド・ファンクションはPL/SQLで記述されるため、COMMIT文とROLLBACK文を発行できます。アプリケーション自体が直接発行していないCOMMIT文やROLLBACK文によって、アプリケーションが中断される場合、DISABLE COMMIT IN PROCEDUREを指定して、セッション中にコールされるプロシージャおよびストアド・ファンクションがこれらの文を発行しないように制御します。
その後、ENABLE COMMIT IN PROCEDUREを指定することによって、セッションでプロシージャおよびストアド・ファンクションがCOMMITおよびROLLBACK文を発行できるようになります。
一部のアプリケーションは、自動的にプロシージャおよびストアド・ファンクションでのCOMMIT文やROLLBACK文を禁止します。詳細は、ご使用のアプリケーションのドキュメントを参照してください。
ENABLE | DISABLE GUARD
ALTER DATABASEのsecurity_clauseを使用すると、SYSユーザー以外のユーザーは、プライマリ・データベースまたはスタンバイ・データベース上のデータまたはデータベース・オブジェクトを変更できなくなります。この句を使用すると、現行のセッションの設定を上書きできます。
参照:
GUARDの設定の詳細は、「security_clause」を参照してください。 
PARALLEL DML | DDL | QUERY
PARALLELパラメータを使用すると、そのセッションの後続のDML、DDLまたは問合せ文をパラレル実行するかどうかを指定できます。この句は、現行のセッション中に表自体を変更せずに、表の並列度を上書き可能にします。コミットされていないトランザクションは、DMLに対してこの句を実行する前に、コミットまたはロールバックされる必要があります。
参照:
「パラレルDMLを使用可能にする例:」 
ENABLE句
ENABLEを指定すると、セッション内の後続文をパラレルで実行できます。これは、DDL文および問合せ文のデフォルトです。
DML: パラレル・ヒントまたはパラレル句が指定されている場合に、DML文をパラレル・モードで実行します。
DDL: パラレル句が指定されている場合に、DDL文をパラレル・モードで実行します。
QUERY: パラレル・ヒントまたはパラレル句が指定されている場合に、問合せをパラレル・モードで実行します。
ENABLE句の制限事項: 
オプションのPARALLEL integerにENABLEを指定することはできません。
DISABLE句
DISABLEを指定すると、セッション内の後続文をシリアルで実行できます。これは、DML文のデフォルトです。
DML: DML文をシリアルで実行します。
DDL: DDL文をシリアルで実行します。
QUERY: 問合せをシリアルで実行します。
DISABLE句の制限事項: 
オプションのPARALLEL integerにDISABLEを指定することはできません。
FORCE句
FORCEを使用すると、セッションの後続文を強制的にパラレル実行できます。パラレル句もパラレル・ヒントも指定されていない場合は、デフォルトの並列度が使用されます。この句は、セッションの後続文に指定されたすべてのparallel_clauseを上書きしますが、パラレル・ヒントによって上書きされます。
DML: パラレルDML制限のどれにも違反していない場合、特定の並列度がこの句に指定されていないかぎり、セッションの後続のDML文は、デフォルトの並列度で実行されます。
DDL: 特定の並列度がこの句に指定されていないかぎり、セッションの後続のDDL文は、デフォルトの並列度で実行されます。結果のデータベース・オブジェクトは、通常の並列度に対応します。
FORCE DDLを指定した場合、そのセッションで作成されるすべての表は、自動的にデフォルトの並列度で作成されます。結果は、CREATE TABLE文で(デフォルトの並列度を使用して)parallel_clauseを指定した場合と同じです。
QUERY: 特定の並列度がこの句に指定されていないかぎり、後続の問合せは、デフォルトの並列度で実行されます。
PARALLEL integer
並列度を明示的に指定する整数を指定します。
FORCE DDLでは、並列度は後続のDDL文のパラレル句を上書きします。
FORCE DMLおよびFORCE QUERYでは、並列度は、データ・ディクショナリの表に格納されている現行の並列度を上書きします。
ヒントによって文に指定される並列度は、強制的に実行される並列度を上書きします。
次のDML操作は、この句に関係なくパラレル化されません。
クラスタ化表に対する操作
データベースまたはパッケージの状態を読み書きする埋込みファンクションを使用した操作
起動する可能性のあるトリガーを使用した表に対する操作
オブジェクト型、LONGまたはLOBデータ型が含まれている表またはスキーマ・オブジェクトでの操作
RESUMABLE句
これらの句を使用すると、再開可能な領域割当てを使用可能および使用禁止にできます。この機能によって、領域不足のエラー条件が発生した場合に操作は停止され、エラー条件が修復されたときに中断したところから自動的に再開されます。
注意:
再開可能な領域割当ては、ローカル管理表領域での操作で、完全にサポートされます。ディクショナリ管理表領域を使用する場合は、制限事項があります。制限事項の詳細は、『Oracle Database管理者ガイド』を参照してください。 
ENABLE RESUMABLE
この句を使用すると、セッションに対する再開可能な領域割当てを使用可能にできます。
TIMEOUT
TIMEOUTを使用すると、エラー条件が修復されるまで操作を停止する時間を秒単位で指定できます。エラー条件がTIMEOUTで指定した時間までに修復されない場合は、停止操作は異常終了します。
NAME
NAMEを使用すると、ユーザー定義のテキスト文字列を指定することができ、再開可能モードのセッション中に発行される文の識別に有効です。USER_RESUMABLEデータ・ディクショナリ・ビューおよびDBA_RESUMABLEデータ・ディクショナリ・ビューに、テキスト文字列が挿入されます。NAMEを指定しない場合は、デフォルト文字列「User username(userid), Session sessionid, Instance instanceid」が挿入されます。
参照:
データ・ディクショナリ・ビューの詳細は、『Oracle Databaseリファレンス』を参照してください。 
DISABLE RESUMABLE
この句を使用すると、セッションに対する再開可能な領域割当てを使用禁止にできます。
alter_session_set_clause 
alter_session_set_clauseを使用すると、パラメータの値を設定できます。この句では、2種類のパラメータを設定できます。
ALTER SESSION文の有効範囲内で動的な初期化パラメータ(「初期化パラメータおよびALTER SESSION」を参照)
セッション・パラメータ(「セッション・パラメータおよびALTER SESSION」を参照)
同じalter_session_set_clauseで複数のパラメータに対する値を設定できます。
初期化パラメータおよびALTER SESSION
ALTER SESSIONの有効範囲内で動的な初期化パラメータのリストは、表11-1を参照してください。各パラメータの詳細は、『Oracle Databaseリファレンス』を参照してください。
ALTER SESSIONでこれらのパラメータを設定した場合は、設定した値が現行のセッション以外では継続されません。
ALTER SESSIONで設定可能な一部のパラメータは、初期化パラメータではありません。つまり、初期化パラメータ・ファイルではなく、ALTER SESSIONでのみ設定可能です。これらのセッション・パラメータの詳細は、「セッション・パラメータおよびALTER SESSION」を参照してください。
注意:
初期化パラメータの値を変更する前に、『Oracle Databaseリファレンス』を参照してください。 
表11-1    ALTER SESSIONで設定可能な初期化パラメータ 
パラメータ 
コメント 
ASM_POWER_LIMIT 
COMMIT_WRITE 
CREATE_STORED_OUTLINES  
以前のリリースでは、CREATE_STORED_OUTLINESはセッション・パラメータでした。 
CURSOR_SHARING  
様々な環境での設定の詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
DB_BLOCK_CHECKING  
ALTER SESSION SET DB_BLOCK_CHECKINGによる設定は、後続のALTER SYSTEM SET DB_BLOCK_CHECKING文で上書きされます。 
DB_CREATE_FILE_DEST  
-- 
DB_CREATE_ONLINE_LOG_DEST_n  
-- 
DB_FILE_MULTIBLOCK_READ_COUNT  
-- 
DB_FILE_NAME_CONVERT  
-- 
DDL_WAIT_FOR_LOCKS  
-- 
GLOBAL_NAMES  
グローバル・ネーム解決およびOracleデータベースによる解決方法の詳細は、「リモート・データベース内のオブジェクトの参照」および『Oracle Database Heterogeneous Connectivity管理者ガイド』を参照してください。 
HASH_AREA_SIZE  
-- 
LOG_ARCHIVE_DEST_n  
-- 
LOG_ARCHIVE_DEST_STATE_n  
-- 
LOG_ARCHIVE_MIN_SUCCEED_DEST  
-- 
MAX_DUMP_FILE_SIZE  
-- 
グローバリゼーション・サポート(NLS_)パラメータ 
インスタンスの起動時に、「NLS」で始まる初期化パラメータの値に基づいてグローバリゼーション・サポートが提供されます。動的パフォーマンス表V$NLS_PARAMETERSを問い合せて、セッションの現在のグローバリゼーション属性を参照できます。NLSパラメータの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
NLS_CALENDAR  
-- 
NLS_COMP  
-- 
NLS_CURRENCY  
-- 
NLS_DATE_FORMAT  
有効な日付書式モデルの詳細は、「日時書式モデル」を参照してください。 
NLS_DATE_LANGUAGE  
-- 
NLS_DUAL_CURRENCY  
数値書式要素の詳細は、「数値書式モデル」を参照してください。 
NLS_ISO_CURRENCY 
-- 
NLS_LANGUAGE 
-- 
NLS_LENGTH_SEMANTICS 
-- 
NLS_NCHAR_CONV_EXCP  
-- 
NLS_NUMERIC_CHARACTERS  
-- 
NLS_SORT  
-- 
NLS_TERRITORY  
-- 
NLS_TIMESTAMP_FORMAT  
-- 
NLS_TIMESTAMP_TZ_FORMAT  
-- 
OBJECT_CACHE_MAX_SIZE_PERCENT  
-- 
OBJECT_CACHE_OPTIMAL_SIZE  
-- 
OLAP_PAGE_POOL_SIZE  
-- 
OPTIMIZER_DYNAMIC_SAMPLING  
このパラメータの設定方法は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
OPTIMIZER_FEATURES_ENABLE  
-- 
OPTIMIZER_INDEX_CACHING  
-- 
OPTIMIZER_INDEX_COST_ADJ  
-- 
OPTIMIZER_MODE  
アプリケーションの特性に基づく、コストベース方法に対する目標の決定方法は、『Oracle Database概要』および『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
PARALLEL_INSTANCE_GROUP  
-- 
PARALLEL_MIN_PERCENT 
-- 
PLSQL_CCFLAGS 
PLSQL_CODE_TYPE 
-- 
PLSQL_COMPILER_FLAGS 
-- 
PLSQL_DEBUG  
-- 
PLSQL_OPTIMIZE_LEVEL  
-- 
PLSQL_V2_COMPATIBILITY  
-- 
PLSQL_WARNINGS  
-- 
QUERY_REWRITE_ENABLED  
-- 
QUERY_REWRITE_INTEGRITY  
-- 
RECYCLEBIN  
-- 
REMOTE_DEPENDENCIES_MODE  
-- 
RESUMABLE_TIMEOUT  
-- 
SESSION_CACHED_CURSORS  
-- 
SKIP_UNUSABLE_INDEXES  
-- 
SMTP_OUT_SERVER 
-- 
SORT_AREA_RETAINED_SIZE  
-- 
SORT_AREA_SIZE  
-- 
SQL_TRACE  
-- 
SQLTUNE_CATEGORY 
-- 
STAR_TRANSFORMATION_ENABLED  
-- 
STATISTICS_LEVEL  
-- 
TIMED_OS_STATISTICS  
-- 
TIMED_STATISTICS  
-- 
TRACEFILE_IDENTIFIER  
-- 
WORKAREA_SIZE_POLICY  
-- 
セッション・パラメータおよびALTER SESSION 
次のパラメータは、セッション・パラメータであり、初期化パラメータではありません。
CONSTRAINT[S]
構文: 
CONSTRAINT[S] = { IMMEDIATE | DEFERRED | DEFAULT }
CONSTRAINT[S]は、遅延可能制約によって指定された条件を、いつ適用するかを指定します。
IMMEDIATEを設定すると、遅延可能な制約によって指定される条件は、各DML文の直後にチェックされます。これは、セッションの各トランザクションの開始時に、SET CONSTRAINTS ALL IMMEDIATE文を発行することと同じです。
DEFERREDを設定すると、遅延可能な制約によって指定される条件は、トランザクションのコミット時にチェックされます。これは、セッションの各トランザクションの開始時に、SET CONSTRAINTS ALL DEFERRED文を発行することと同じです。
DEFAULTを設定すると、すべての制約は各トランザクションの開始時に、DEFERREDまたはIMMEDIATEの初期状態にリストアされます。
CREATE_STORED_OUTLINES
以前のリリースでは、CREATE_STORED_OUTLINESはセッション・パラメータでした。今回のリリースでは、初期化パラメータです。『Oracle Databaseリファレンス』のCREATE_STORED_OUTLINESに関する説明を参照してください。
CURRENT_SCHEMA
構文
CURRENT_SCHEMA = schema
CURRENT_SCHEMAは、セッションの現行のスキーマを、指定したスキーマに変更します。セッション中のスキーマ・オブジェクトに対する後続の未修飾の参照は、この指定したスキーマ内でオブジェクトに変換されます。この設定は、現行のセッションの存続期間中、またはALTER SESSION SET CURRENT_SCHEMA文を再発行するまで保持されます。
この設定によって、現行のユーザーのスキーマ以外にあるオブジェクトに対する操作を、オブジェクトをスキーマ名で修飾することなく簡単に行えます。この設定によって、現行のスキーマは変更されますが、このセッションのユーザーまたは現行のユーザーは変更されません。また、セッション・ユーザーには、このセッションに対する追加のシステム権限またはオブジェクト権限は付与されません。
ERROR_ON_OVERLAP_TIME
構文
ERROR_ON_OVERLAP_TIME = {TRUE | FALSE}
ERROR_ON_OVERLAP_TIMEパラメータには、Oracleデータベースが不明瞭な境界日時値(日時が標準か夏時間かが明確でない場合)を処理する方法を指定します。
TRUEを指定すると、不明瞭なオーバラップ・タイムスタンプに対してエラーが戻されます。
FALSEを指定すると、不明瞭なオーバラップ・タイムスタンプは標準時刻のデフォルトになります。これはデフォルトです。
境界日時値の詳細は、「夏時間のサポート」を参照してください。
FLAGGER
構文
FLAGGER = { ENTRY | INTERMEDIATE | FULL | OFF }
FLAGGERパラメータは、FIPSのフラグ付けを指定します。このフラグ付けを使用した場合、ANSI SQL92の拡張要素であるSQL文が発行されたときに、エラー・メッセージが生成されます。FLAGGERは、セッション・パラメータであり、初期化パラメータではありません。
Oracleデータベースでは、ENTRYレベル、INTERMEDIATEレベル、FULLレベルのそれぞれのフラグ付けに違いはありません。セッションでフラグ付けが設定されると、これに続くALTER SESSION SET FLAGGER文は成功しますが、ORA-00097のメッセージが生成されます。このため、セッションを切断しなくてもFIPSのフラグ付けを変更できます。OFFを設定した場合、フラグ付けの使用は停止されます。
参照:
現行のANSI SQL規格に対するOracleの準拠については、付録B「Oracleと標準SQL」を参照してください。 
INSTANCE
構文
INSTANCE = integer
INSTANCEパラメータを設定すると、自分のインスタンスに接続している場合と同様に、別のインスタンスにもアクセスできます。INSTANCEはセッション・パラメータであり、初期化パラメータではありません。Real Application Clusters(RAC)環境では、このパラメータの設定に基づき、各RACインスタンスで、最適なDMLパフォーマンスを実現するようにディスク領域の静的または動的な所有権が保持されます。
ISOLATION_LEVEL
構文
ISOLATION_LEVEL = {SERIALIZABLE | READ COMMITTED} 
ISOLATION_LEVELパラメータは、データベースを変更するトランザクションがどのように処理されるかを指定します。ISOLATION_LEVELはセッション・パラメータであり、初期化パラメータではありません。
SERIALIZABLEを設定すると、セッション内のトランザクションは、SQL92に規定されているとおりシリアル化可能トランザクション分離モードを使用します。シリアル化可能トランザクションが行を更新するDML文を実行する場合、現在の更新対象の行がそのシリアル化可能トランザクションの開始時にコミットされていない別のトランザクションによって更新されていたときは、そのDML文は失敗します。シリアル化可能トランザクションは、同一トランザクション内で行った更新を確認できます。
READ COMMITTEDを設定すると、セッション内のトランザクションは、Oracleデータベース・トランザクションのデフォルトの動作を行います。別のトランザクションでかけられた行ロックを必要とするDMLがトランザクションに含まれていると、DML文は、行ロックが解除されるまで待ち状態になります。
PLSQL_DEBUG
以前のリリースでは、PLSQL_DEBUGはセッション・パラメータでした。今回のリリースでは、初期化パラメータです。『Oracle Databaseリファレンス』のPLSQL_DEBUGに関する説明を参照してください。
SKIP_UNUSABLE_INDEXES
以前のリリースでは、SKIP_UNUSABLE_INDEXESはセッション・パラメータでした。今回のリリースでは、初期化パラメータです。『Oracle Databaseリファレンス』のSKIP_UNUSABLE_INDEXESに関する説明を参照してください。
SQL_TRACE
以前のリリースでは、SQL_TRACEはセッション・パラメータでした。今回のリリースでは、初期化パラメータです。『Oracle Databaseリファレンス』のSQL_TRACEに関する説明を参照してください。
TIME_ZONE
構文
TIME_ZONE =  '[+ | -] hh:mm' 
| LOCAL 
| DBTIMEZONE 
| 'time_zone_region'
TIME_ZONEパラメータには、現行のSQLセッションのデフォルトのローカル・タイムゾーン・オフセットまたは地域名を指定します。TIME_ZONEはセッション・パラメータであり、初期化パラメータではありません。現行のセッションのタイムゾーンを確認するには、組込み関数SESSIONTIMEZONEを問い合せます(「SESSIONTIMEZONE」を参照)。
UTCの前または後の時および分を示す書式マスク('[+|-]hh:mm')を指定します。hh:mmの有効範囲は、-12:00〜+14:00です。
LOCALを指定すると、現行のSQLセッションのデフォルトのローカル・タイムゾーン・オフセットが、現行のSQLセッションを起動したときに構築された、元のデフォルトのローカル・タイムゾーン・オフセットに設定されます。
DBTIMEZONEを指定すると、現行のセッションのタイムゾーンにデータベースのタイムゾーンと一致する値が設定されます。この設定を指定する場合、DBTIMEZONEファンクションは、データベースのタイムゾーンをUTCオフセットまたはタイムゾーン地域として戻します。これはデータベースのタイムゾーンの設定に依存します。
有効なtime_zone_regionを指定します。有効な地域名を表示するには、V$TIMEZONE_NAMES動的パフォーマンス・ビューのTZNAME列を問い合せます。この設定を指定する場合、SESSIONTIMEZONEファンクションは地域の名前を戻します。
注意:
夏時間機能には、タイムゾーン地域名が必要です。地域名は、2つのタイムゾーン・ファイルに格納されます。デフォルトのタイムゾーン・ファイルは、パフォーマンスを最大にするために一般的なタイムゾーンのみの小さなファイルです。タイムゾーンがデフォルトのファイルに存在しない場合は、環境変数ORA_TZFILEを使用して完全な(大きい)ファイルへのパスを指定するまで、夏時間はサポートされません。 
参照:
環境変数ORA_TZFILEの設定の詳細は、『Oracle Database管理者ガイド』を参照してください。
両方のファイルに含まれるすべてのタイムゾーン地域名のリストは、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
注意:
環境変数ORA_SDTZを使用して、クライアント・セッションのデフォルトのタイムゾーンを設定することもできます。この変数の詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
USE_PRIVATE_OUTLINES
構文
USE_PRIVATE_OUTLINES = { TRUE | FALSE | category_name }
USE_PRIVATE_OUTLINESパラメータを使用すると、プライベート・アウトラインの使用を制御することができます。このパラメータが使用可能で、アウトライン化されたSQL文が発行された場合、オプティマイザは、USE_STORED_OUTLINESが使用可能なときに使用されるパブリック領域ではなく、そのセッションのプライベート領域からアウトラインを検索します。そのセッションのプライベート領域にアウトラインが存在しない場合、オプティマイザは、文のコンパイルにアウトラインを使用しません。USE_PRIVATE_OUTLINESは、初期化パラメータではありません。
TRUEに設定すると、要求をコンパイルするときに、オプティマイザはDEFAULTカテゴリのストアド・プライベート・アウトラインを使用します。
FALSEに設定すると、オプティマイザはストアド・プライベート・アウトラインを使用しません。これはデフォルトです。USE_STORED_OUTLINESが使用可能な場合、オプティマイザはストアド・パブリック・アウトラインを使用します。
category_nameに設定すると、要求をコンパイルするときに、オプティマイザはcategory_nameカテゴリのストアド・アウトラインを使用します。
USE_PRIVATE_OUTLINESの制限事項: 
USE_STORED_OUTLINESが使用可能な場合は、このパラメータを使用可能にできません。
USE_STORED_OUTLINES
構文: 
USE_STORED_OUTLINES = { TRUE | FALSE | category_name }
USE_STORED_OUTLINESパラメータは、オプティマイザが実行計画を生成するためにストアド・パブリック・アウトラインを使用するかどうかを決定します。USE_STORED_OUTLINESは、初期化パラメータではありません。
TRUEに設定すると、要求をコンパイルするときに、オプティマイザはDEFAULTカテゴリのストアド・アウトラインを使用します。
FALSEに設定すると、オプティマイザはストアド・アウトラインを使用しません。これはデフォルトです。
category_nameに設定すると、要求をコンパイルするときに、オプティマイザはcategory_nameカテゴリのストアド・アウトラインを使用します。
USED_STORED_OUTLINESの制限事項: 
USE_PRIVATE_OUTLINESが使用可能な場合は、このパラメータを使用可能にできません。
例
パラレルDMLを使用可能にする例:
次の文は、現行のセッションでパラレルDMLモードを使用可能にします。
ALTER SESSION ENABLE PARALLEL DML;
分散トランザクションを強制的に実行する例:
次のトランザクションは、データベース・リンクremoteによって識別されるデータベース上のemployees表に従業員のレコードを挿入し、localによって識別されるデータベース上のemployees表から従業員のレコードを削除します。
ALTER SESSION
ADVISE COMMIT; 
INSERT INTO employees@remote
VALUES (8002, 'Juan', 'Fernandez', 'juanf@hr.com', NULL, 
TO_DATE('04-OCT-1992', 'DD-MON-YYYY'), 'SA_CLERK', 3000, 
NULL, 121, 20); 
ALTER SESSION
ADVISE ROLLBACK; 
DELETE FROM employees@local
WHERE employee_id = 8002; 
COMMIT;  
このトランザクションには、ADVISE句を指定したALTER SESSION文が2つあります。このトランザクションが状態不明(インダウト)になった場合、remoteには、最初に指定したALTER SESSION文によってアドバイス'COMMIT'が送信され、localには、2番目の文によってアドバイス'ROLLBACK'が送信されます。
データベース・リンクをクローズする例:
次の文は、データベース・リンクを使用しているlocalデータベース上のjobs表を更新し、このトランザクションをコミットして、データベース・リンクを明示的にクローズします。
UPDATE jobs@local SET min_salary = 3000
WHERE job_id = 'SH_CLERK';
COMMIT; 
ALTER SESSION
CLOSE DATABASE LINK local;
日付書式の動的な変更例:
次の文は、セッションのデフォルトの日付書式を'YYYY MM DD-HH24:MI:SS'に動的に変更します。
ALTER SESSION 
SET NLS_DATE_FORMAT = 'YYYY MM DD HH24:MI:SS';
変更後は、新しい日付書式が次のように適用されます。
SELECT TO_CHAR(SYSDATE) Today
FROM DUAL; 
TODAY 
------------------- 
2001 04 12 12:30:38
日付言語の動的な変更例:
次の文は、日付書式要素の言語をフランス語に変更します。
ALTER SESSION 
SET NLS_DATE_LANGUAGE = French;
SELECT TO_CHAR(SYSDATE, 'Day DD Month YYYY') Today
FROM DUAL; 
TODAY 
--------------------------- 
Jeudi    12 Avril     2001
ISO通貨の変更例:
次の文は、ISO通貨記号をアメリカ合衆国のISO通貨記号に動的に変更します。
ALTER SESSION
SET NLS_ISO_CURRENCY = America; 
SELECT TO_CHAR( SUM(salary), 'C999G999D99') Total
FROM employees; 
TOTAL
------------------
USD694,900.00
小数点文字と桁区切りの変更例:
次の文は、小数点文字をカンマ(,)に、桁区切りをピリオド(.)に動的に変更します。
ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ',.' ;
これらの数値書式要素を使用した場合、新しい文字が戻ります。
ALTER SESSION SET NLS_CURRENCY = 'FF';
SELECT TO_CHAR( SUM(salary), 'L999G999D99') Total FROM employees;
TOTAL
---------------------
FF694.900,00
NLS通貨の変更例:
次の文は、各国通貨記号を'DM'に動的に変更します。
ALTER SESSION
SET NLS_CURRENCY = 'DM'; 
SELECT TO_CHAR( SUM(salary), 'L999G999D99') Total
FROM employees; 
TOTAL
---------------------
DM694.900,00
NLS言語の変更例:
次の文は、表示されたエラー・メッセージの言語をフランス語に動的に変更します。
ALTER SESSION
SET NLS_LANGUAGE = FRENCH; 
Session modifiee.
SELECT * FROM DMP;
ORA-00942: Table ou vue inexistante
言語のソート順の変更例:
次の文は、言語ソート順序をスペイン語に動的に変更します。
ALTER SESSION
SET NLS_SORT = XSpanish; 
これによって、文字の値はスペイン語のソート順序に基づいてソートされます。
SQLトレースを使用可能にする例:
次の文は、セッションに対してSQLトレース機能を使用可能にします。
ALTER SESSION 
SET SQL_TRACE = TRUE; 
クエリー・リライトを使用可能にする例:
次の文は、明示的に使用禁止にされていないすべてのマテリアライズド・ビューに対する現行のセッションのクエリー・リライトを使用可能にします。
ALTER SESSION SET QUERY_REWRITE_ENABLED = TRUE;
ALTER SYSTEM 
用途
ALTER SYSTEM文を使用すると、Oracleデータベース・インスタンスを動的に変更できます。この設定は、データベースがマウントされているかぎり有効です。
前提条件
ALTER SYSTEMシステム権限が必要です。
構文
alter_system::=
画像の説明
(archive_log_clause::=、checkpoint_clause::=、check_datafiles_clause::=、distributed_recov_clauses::=、end_session_clauses::=、quiesce_clauses::=、alter_system_security_clauses::=、shutdown_dispatcher_clause::=、alter_system_set_clause::=、alter_system_reset_clause::=を参照)
archive_log_clause::=
画像の説明
checkpoint_clause::=
画像の説明
check_datafiles_clause::=
画像の説明
distributed_recov_clauses::=
画像の説明
end_session_clauses::=
画像の説明
quiesce_clauses::=
画像の説明
alter_system_security_clauses::=
画像の説明
shutdown_dispatcher_clause::=
画像の説明
alter_system_set_clause::=
画像の説明
alter_system_reset_clause::=
画像の説明
セマンティクス
archive_log_clause 
archive_log_clauseを使用すると、REDOログ・ファイルを手動でアーカイブしたり、自動アーカイブを使用可能または使用禁止にすることができます。この句を使用する場合、インスタンスでデータベースをマウントする必要があります。特に指定がないかぎり、データベースはオープンまたはクローズできます。
INSTANCE句
OracleデータベースでReal Application Clustersオプションを使用している場合のみ、この句は有効です。REDOログ・ファイル・グループをアーカイブするインスタンスの名前を指定します。インスタンス名は最大80文字の文字列です。指定したインスタンスにマップするスレッドはOracleデータベースによって自動的に決定され、対応するREDOログ・ファイル・グループがアーカイブされます。指定したインスタンスにマップされているスレッドがない場合、エラーが戻されます。
以前のリリースでは、アーカイブするREDOログ・ファイル・グループをスレッドとインスタンスで識別できました。今回のリリースでは、この構文は下位互換性のためにのみサポートされています。同じ目的のためにINSTANCE句を使用でき、使用方法も簡単です。
SEQUENCE句
SEQUENCEを指定すると、指定したスレッド内のログ順序番号integerによって識別されるオンラインREDOログ・ファイル・グループを手動でアーカイブできます。THREADパラメータを指定しなかった場合、インスタンスに割り当てられているスレッドから、指定したグループがアーカイブされます。
CHANGE句
CHANGEを指定すると、オンラインREDOログ・ファイル・グループを、手動でアーカイブできます。このグループには、指定したスレッド内のintegerによって識別されるSCNを持つREDOログ・エントリが含まれます。このSCNが現行のREDOログ・ファイル・グループ内にある場合、ログ・スイッチが実行されます。THREADパラメータを指定しない場合、使用可能な状態にあるすべてのスレッドから、このSCNを含むグループがアーカイブされます。
インスタンスでデータベースをオープンしている場合にのみ、この句を使用できます。
CURRENT句
CURRENTを指定すると、ログ・スイッチを強制的に発生させ、指定したスレッドの現行のREDOログ・ファイル・グループを手動でアーカイブできます。THREADパラメータを指定しない場合、すべての使用可能なスレッドから、現行のログ以前のログも含むすべてのREDOログ・ファイル・グループがアーカイブされます。データベースがオープンしているときのみ、CURRENTを指定できます。
NOSWITCH
NOSWITCHを指定すると、ログ・スイッチの強制実行なしで現行のREDOログ・ファイル・グループを手動でアーカイブできます。この設定は、プライマリ・データベースが停止したときに、データ分岐が発生しないようにするために、主にスタンバイ・データベースで使用されます。データ分岐は、プライマリ・データベースに障害が発生した場合に、データが消失する可能性があることを意味します。
インスタンスでデータベースがマウントされているがオープンされていない場合にのみ、NOSWITCH句を使用できます。データベースがオープンしている場合は、この操作によってデータベースは自動的にクローズされます。再オープンする前にデータベースを手動で停止する必要があります。
GROUP句
GROUPを指定すると、オンラインREDOログ・ファイル・グループを手動でアーカイブできます。このグループには、integerによって識別されるGROUP値が含まれます。REDOログ・ファイル・グループのGROUP値を確認するには、データ・ディクショナリ・ビューDBA_LOG_GROUPSを問い合せます。THREADパラメータとGROUPパラメータの両方を指定する場合は、指定するREDOログ・ファイル・グループが、指定するスレッド内に含まれている必要があります。
LOGFILE句
LOGFILEを指定すると、オンラインREDOログ・ファイル・グループを手動でアーカイブできます。このグループには、'filename'によって識別されるREDOログ・ファイル・メンバーが含まれます。THREADパラメータとLOGFILEパラメータの両方を指定する場合は、指定するREDOログ・ファイル・グループが、指定するスレッド内に含まれている必要があります。
データベースがバックアップ制御ファイルでマウントされている場合は、USING BACKUP CONTROLFILEを指定し、現行のログ・ファイルを含むすべてのオンライン・ログ・ファイルのアーカイブを許可します。
LOGFILE句の制限事項: 
REDOログ・ファイル・グループは、一杯になった順にアーカイブする必要があります。LOGFILEパラメータを使用してREDOログ・ファイル・グループのアーカイブを指定した場合、それ以前のREDOログ・ファイル・グループがアーカイブされていないとエラー・メッセージが戻ります。
NEXT句
NEXTを指定すると、一杯になってもアーカイブされていない次のオンラインREDOログ・ファイルを、指定したスレッドから手動でアーカイブできます。THREADパラメータを指定しない場合、使用可能な任意のスレッド上の、アーカイブされていない最初のREDOログ・ファイル・グループがアーカイブされます。
ALL句
ALLを指定すると、一杯になってもアーカイブされていないすべてのオンラインREDOログ・ファイルを、指定したスレッドから手動でアーカイブできます。THREADパラメータを指定しない場合、使用可能なすべてのスレッドから、一杯でアーカイブされていないすべてのREDOログ・ファイル・グループがアーカイブされます。
START句
以前のリリースでは、この句を使用すると、インスタンスに割り当てられたスレッドについて、REDOログ・ファイル・グループの自動アーカイブが使用可能になります。この句は現在使用されていません。Oracleデータベースは、REDOログ・ファイル・グループの自動アーカイブを自動的に使用可能にします。この句は無効です。この句を指定すると、アラート・ログにメッセージが書き込まれます。
TO location句 
TO 'location'を指定すると、REDOログ・ファイル・グループがアーカイブされる位置を指定できます。このパラメータの値には、オペレーティング・システムの規則に従って、ファイルの位置を完全に指定する必要があります。このパラメータを指定しない場合、REDOログ・ファイル・グループは初期化パラメータLOG_ARCHIVE_DESTまたはLOG_ARCHIVE_DEST_nに指定された場所に格納されます。
STOP句
以前のリリースでは、この句を使用すると、インスタンスに割り当てられたスレッドについて、REDOログ・ファイル・グループの自動アーカイブが使用禁止になります。この句は現在使用されていません。この句は無効です。この句を指定すると、アラート・ログにメッセージが書き込まれます。
checkpoint_clause
CHECKPOINTを指定すると、チェックポイントを明示的に強制処理して、コミット済のトランザクションによる変更をディスク上のデータ・ファイルに書き込むことができます。インスタンスでデータベースがオープンしている場合にのみ、この句を指定できます。チェックポイントが完了するまで、ユーザーに制御は戻りません。
GLOBAL
Real Application Clusters環境で、データベースをオープンしているすべてのインスタンスに対してチェックポイントを実行します。これはデフォルトです。
LOCAL
Real Application Clusters環境で、文を発行するインスタンスのREDOログ・ファイル・グループのスレッドに対してのみチェックポイントを実行します。
参照:
「チェックポイントの発生例:」 
check_datafiles_clause
Real Application Clusters環境などの分散データベース・システムで、データベース制御ファイルからインスタンスのSGAを更新し、すべてのオンライン・データ・ファイルに情報を反映します。
GLOBALを指定すると、データベースをオープンしているすべてのインスタンスに対して、この同期化を実行できます。これはデフォルトです。
LOCALを指定すると、ローカル・インスタンスに対してのみこの同期化を実行できます。
インスタンスでデータベースをオープンしておく必要があります。
end_session_clauses
end_session_clausesを使用すると、現行のセッションを終了することができます。
DISCONNECT SESSION句
DISCONNECT SESSION句を使用すると、専用サーバー・プロセス(共有サーバーによって接続が確立されていた場合は、仮想回路)を破棄することによって、現行のセッションが切断されます。この句を使用する場合、インスタンスでデータベースをオープンする必要があります。次の両方の値をV$SESSIONビューで確認して、このセッションを識別する必要があります。
integer1には、SID列の値を指定します。
integer2には、SERIAL#列の値を指定します。
システム・パラメータを適切に設定した場合、アプリケーション・フェイルオーバーが有効になります。
POST_TRANSACTIONを設定すると、セッションが切断される前に、実行中のトランザクションを完了できます。セッションに実行中のトランザクションがない場合、この句は、後述のKILL SESSIONと同様の効果があります。
IMMEDIATEを設定すると、実行中のトランザクションの完了を待たずにセッションを切断し、すぐにセッション全体の状態をリカバリできます。
POST_TRANSACTIONを指定した場合、セッションに実行中のトランザクションがあれば、IMMEDIATEキーワードは無視されます。
POST_TRANSACTIONを指定しない場合、またはPOST_TRANSACTIONを指定していてもセッションに実行中のトランザクションがない場合、この句は、後述のKILL SESSION IMMEDIATEと同様の効果があります。
参照:
「セッションの切断例:」 
KILL SESSION句
KILL SESSIONを指定すると、セッションに終了済のマークが付き、実行中のトランザクションがロールバックされ、すべてのセッション・ロックが解放され、セッション・リソースが一部リカバリされます。この句を使用するには、インスタンスでデータベースをオープンしている必要があります。また、自セッションおよび終了されるセッションは、同じインスタンスにある必要があります。次の両方の値をV$SESSIONビューで確認して、このセッションを識別する必要があります。
integer1には、SID列の値を指定します。
integer2には、SERIAL#列の値を指定します。
リモート・データベースからの応答を待ったり、トランザクションをロールバックするなど、最後まで完了する必要があるアクティビティをセッションが実行している場合、Oracleデータベースはこのアクティビティが完了するまで待機し、セッションに終了済のマークを付け、その後、ユーザーに制御を戻します。待ち時間が1分以上続く場合は、終了されるセッションにマークが付けられ、マークが付けられたセッションが終了されることを示すメッセージとともにユーザーに制御が戻されます。アクティビティが完了すると、PMONバックグラウンド・プロセスは、セッションに終了済のマークを付けます。
セッションに実行中のトランザクションがあるかどうかにかかわらず、セッション・ユーザーがセッションに要求を発行してセッションが終了されたことを示すメッセージを受け取るまで、Oracleデータベースは、セッション全体の状態をリカバリしません。
参照:
「セッションの終了例:」 
IMMEDIATE
IMMEDIATEを指定すると、実行中のトランザクションをロールバックしてすべてのセッション・ロックを解放し、セッション全体の状態をリカバリしてから、すぐにユーザーに制御を戻すようにOracleデータベースに指示できます。
distributed_recov_clauses
DISTRIBUTED RECOVERY句を使用すると、分散リカバリを使用可能または使用禁止にできます。この句を使用する場合、インスタンスでデータベースをオープンする必要があります。
ENABLE
ENABLEを指定すると、分散リカバリを使用可能にできます。シングルプロセス環境では、分散リカバリを開始する場合にこの句を使用する必要があります。
トランザクションに関係があるリモート・ノードにアクセスできない場合、インダウト・トランザクションをリカバリするには、ENABLE DISTRIBUTED RECOVERY文を複数回発行する必要がある場合もあります。インダウト・トランザクションは、データ・ディクショナリ・ビューDBA_2PC_PENDINGに表示されます。
参照:
「分散リカバリを使用可能にする例:」 
DISABLE
DISABLEを指定すると、分散リカバリを使用禁止にできます。
FLUSH SHARED_POOL句
FLUSH SHARED_POOL句を指定すると、SGAの共有プール上のすべてのデータが消去されます。共有プールは次のものを格納します。
キャッシュされたデータ・ディクショナリ情報
SQL文の共有SQL領域、共有PL/SQL領域、ストアド・プロシージャ、ファンクション、パッケージおよびトリガー 
この文は、現在実行中の項目に対する共有SQL領域および共有PL/SQL領域を消去しません。インスタンスでデータベースがマウントされていてもディスマウントされていても、またはオープン状態でもクローズ状態でも、この句を使用できます。
参照:
「共有プールの消去例:」 
FLUSH BUFFER_CACHE句
FLUSH BUFFER_CACHE句を指定すると、システム・グローバル領域(SGA)のバッファ・キャッシュ上のすべてのデータを消去できます。
注意:
この句は、テスト・データベース上のみで使用します。この句を本番データベース上で使用しないでください。この文を実行すると、後続の問合せで結果が戻らなくなります。 
この句は、リライトされた問合せ、または同一の開始点からの一連の問合せのパフォーマンスを測定する必要がある場合に有効です。
SWITCH LOGFILE句
SWITCH LOGFILE句を指定すると、現行のREDOログ・ファイル・グループのファイルが一杯であるかどうかにかかわらず、新しいREDOログ・ファイル・グループへの書込みを明示的かつ強制的に開始できます。ログ・スイッチを強制的に発生させると、チェックポイントが実行されますが、チェックポイントが完了する前に、すぐに制御が戻されます。この句を使用する場合、インスタンスでデータベースをオープンする必要があります。
参照:
「ログ・スイッチの発生例:」 
SUSPEND | RESUME
SUSPEND句を指定すると、すべてのI/O(データ・ファイル、制御ファイルおよびファイル・ヘッダー)および問合せを停止し、すべてのインスタンスで実行中のトランザクションを処理せずにデータベースのコピーが作成可能になります。
SUSPENDおよびRESUMEの制限事項: 
SUSPENDとRESUMEには、次の制限事項があります。
ホット・バックアップ・モードでデータベースの表領域を確保するまで、この句は使用できません。
ALTER SYSTEM SUSPEND文を発行したセッションは終了しないでください。システムが一時停止しているときに再接続しようとすると、SYSログイン中に実行される再帰的SQLが原因となって接続が失敗することがあります。
システムが停止中に新しいインスタンスを起動する場合、この新しいインスタンスは停止しません。
RESUME句を指定すると、問合せおよびI/Oに対して、再度、データベースが使用可能になります。
quiesce_clauses
QUIESCE RESTRICTED句およびUNQUIESCE句を使用すると、データベースを静止状態にしたり、静止状態から戻すことができます。この状態では、データベース管理者は、トランザクション、問合せまたはPL/SQL操作が同時に存在する状態では安全に実行できない管理操作を実行することができます。
注意:
QUIESCE RESTRICTED句は、データベース・リソース・マネージャがインストールされている場合、およびデータベースをオープンしたインスタンスでデータベースが起動された後、リソース・マネージャが継続的にアクティブになっている場合のみ有効です。 
複数のQUIESCE RESTRICTED文またはUNQUIESCE文が異なるセッションまたはインスタンスで同時に発行された場合、1つを除いた他のすべてのセッションまたはインスタンスにエラーが戻されます。
QUIESCE RESTRICTED
QUIESCE RESTRICTEDを指定すると、データベースを静止状態にできます。この句は、データベースがオープン中のすべてのインスタンスに次の影響を与えます。
Oracleデータベースは、すべてのインスタンスのデータベース・リソース・マネ−ジャに、アクティブでないすべてのセッション(SYSおよびSYSTEM以外)をアクティブにしないように指示します。SYSおよびSYSTEM以外のユーザーは、新しいトランザクション、問合せ、フェッチまたはPL/SQL操作を開始できません。
Oracleデータベースは、SYSまたはSYSTEM以外のユーザーが開始した、すべてのインスタンスの既存のトランザクションが終了するまで(コミットまたは異常終了するまで)待機します。また、Oracleデータベースは、SYSまたはSYSTEM以外のユーザーが開始した、内部トランザクションにない、すべてのインスタンスで実行中のすべての問合せ、フェッチおよびPL/SQLプロシージャが終了するまで待機します。連続する複数のOracle Call Interface(OCI)のフェッチによって問合せが実行される場合、Oracleデータベースはすべてのフェッチが終了するまで待機しません。現行のフェッチが終了するまで待機しますが、次のフェッチは行われません。Oracleデータベースは、エンキューなどの共有リソースを保持するすべてのセッション(SYSおよびSYSTEM以外のセッション)がリソースを解放するまで待機します。すべての操作が完了した後、Oracleデータベースはデータベースを静止状態にし、QUIESCE RESTRICTED文の実行を終了します。
共有サーバー・モードでインスタンスを実行している場合、Oracleデータベースは、SYSまたはSYSTEM以外のユーザーがそのインスタンスにログインすることを阻止するようにデータベース・リソース・マネージャに指示します。非共有サーバー・モードでインスタンスを実行している場合、そのインスタンスへのユーザー・ログインに制限はありません。
静止状態中、すべてのインスタンスにおいてリソース・マネージャのプランは変更できません。
UNQUIESCE
UNQUIESCEを指定すると、データベースを静止状態から戻すことができます。これによって、SYSまたはSYSTEM以外のユーザによって開始された、トランザクション、問合せ、フェッチおよびPL/SQLプロシージャを再開できます。UNQUIESCE文は、QUIESCE RESTRICTED文を発行したセッションと同じセッションで起動する必要はありません。
alter_system_security_clauses
alter_system_security_clausesを使用すると、インスタンスへのアクセスを制御できます。
RESTRICTED SESSION
RESTRICTED SESSION句を指定すると、Oracleデータベースにログインできるユーザーを制限できます。インスタンスでデータベースがマウントされていてもディスマウントされていても、またはオープン状態でもクローズ状態でも、この句を使用できます。
ENABLEを指定すると、RESTRICTED SESSIONシステム権限が付与されているユーザーのみがOracleデータベースにログインできます。既存のセッションは終了しません。
この句は、現行のインスタンスのみに適用されます。そのため、Real Application Clusters環境では、RESTRICTED SESSIONシステム権限を持たない認可済ユーザーも他のインスタンスでデータベースにアクセスできます。
DISABLEを指定すると、ENABLE RESTRICTED SESSION句の効果を無効にできます。つまり、CREATE SESSIONシステム権限が付与されているすべてのユーザーがOracleデータベースにログインできるようになります。これはデフォルトです。
参照:
「セッションを制限する例:」 
SET ENCRYPTION WALLET句
この句を使用すると、サーバー・ウォレット内の情報へのデータベース・アクセスを管理できます。この文は、キーワードALTERで始まりますが、ALTER SYSTEM SET ENCRYPTION WALLET文はDDL句ではありません。ただし、このような文はロールバックすることはできません。
OPEN
この句を指定すると、データベースは指定されたパスワードを使用してサーバー・ウォレット内の情報をメモリーにロードし、インスタンスの存続期間中にデータベース・アクセスができるようになります。この句を使用すると、データベースは、SSOウォレットなしにサーバー・ウォレットからキーを取得できます。サーバー・ウォレットが使用できないか、すでに開いている場合は、データベースからエラーが戻ります。
CLOSE
この句を使用すると、メモリーからサーバー・ウォレットの情報が削除されます。
SET ENCRYPTION KEY句
この句を使用すると、新しい暗号化キーを生成し、現行のデータの透過的暗号化のマスター鍵として設定できます。また、この句はサーバー・ウォレットのデータベース・アクセス情報をメモリーにロードします。certificate_idは、証明書を識別する整数です。これは、基本鍵を使用する場合は不要ですが、PKIベースの鍵を使用する場合は必要になります。この値は、V$WALLET動的パフォーマンス・ビューのCERT_ID列を問い合せて確認できます。passwordには、セキュリティ・モジュールへの接続に使用するパスワードを指定します。指定したcertificate_idまたはパスワードが無効な場合、データベースからエラーが戻ります。
ALTER SYSTEM SET KEY文はDDL文です。この文は、スキーマ内で保留中のトランザクションを自動的にコミットします。
データの透過的暗号化機能を使用するには、暗号化ウォレットと暗号化キーの両方を設定する必要があります。
参照:
サーバー・ウォレットと暗号化キーの使用方法およびデータの透過的暗号化の詳細は、『Oracle Database Advanced Security管理者ガイド』を参照してください。
この機能を利用して表の列を暗号化する方法の詳細は、「CREATE TABLE」の「ENCRYPT encryption_spec」を参照してください。
「ウォレットおよび暗号化キーの確立」
shutdown_dispatcher_clause
SHUTDOWN句は、システムにOracleデータベースの共有サーバー・アーキテクチャを使用している場合のみ有効です。dispatcher_nameで識別されたディスパッチャを停止します。
注意:
この句をSQL*PlusコマンドSHUTDOWN(データベース全体を停止するために使用する)と混同しないでください。 
dispatcher_nameは、'Dxxx'という形式の文字列である必要があります。xxxはディスパッチャの番号です。ディスパッチャ名のリストを取得するには、V$DISPATCHER動的パフォーマンス・ビューのNAME列を問い合せます。
IMMEDIATEを指定した場合、ディスパッチャは新しい接続の受入れをすぐに中止し、そのディスパッチャによる既存の接続はすべて終了されます。すべてのセッションがクリーンアップされてから、ディスパッチャ・プロセスは停止します。
IMMEDIATEを指定しない場合、ディスパッチャは新しい接続の受入れをすぐに中止しますが、すべてのユーザーが切断し、すべてのデータベース・リンクが終了されるのを待ちます。その後、ディスパッチャは停止されます。
REGISTER句
REGISTERを指定すると、PMONバックグラウンド・プロセスによってリスナーにインスタンスがすぐに登録されます。この句を指定しない場合、PMONが次に検出ルーチンを実行するまでインスタンスの登録は行われません。その結果、クライアントは、リスナー起動後最大60秒間サービスにアクセスできない可能性があります。
参照:
PMONバックグラウンド・プロセスおよびリスナーの詳細は、『Oracle Database概要』および『Oracle Database Net Services管理者ガイド』を参照してください。 
alter_system_set_clause
alter_system_set_clauseを使用すると、すべての初期化パラメータ値を設定またはリセットできます。パラメータの詳細は、「初期化パラメータおよびALTER SYSTEM」を参照してください。
初期化パラメータ値を変更する権限は、従来のクライアント側の初期化パラメータ・ファイル(pfile)を使用してデータベースを起動したか、サーバー・パラメータ・ファイル(spfile)を使用してデータベースを起動したかによって異なります。特定のパラメータ値を変更する権限を持っているかどうかを確認するには、V$PARAMETER動的パフォーマンス・ビューの ISSYS_MODIFIABLE列を問い合せます。
パラメータ値を設定するときに、次の設定も行えます。
COMMENT
COMMENT句を使用すると、コメント文字列をパラメータ値の変更に対応付けることができます。SPFILEをあわせて指定すると、パラメータ・ファイルにコメントが表示され、そのパラメータに対する直前の変更がわかります。
DEFERRED
DEFERREDキーワードを指定すると、データベースに接続するその後のセッションに対するパラメータの値を設定または変更できます。現行のセッションでは変更前の値が残ります。
このパラメータのV$PARAMETERのISSYS_MODIFIABLE列の値がDEFERREDの場合は、DEFERREDを指定する必要があります。この列の値がIMMEDIATEの場合、この句のDEFERREDキーワードはオプションです。この列の値がFALSEの場合、このALTER SYSTEM文ではDEFERREDを指定できません。
参照:
V$PARAMETER動的パフォーマンス・ビューの詳細は、『Oracle Databaseリファレンス』を参照してください。 
SCOPE
SCOPE句を使用すると、変更が有効になるタイミングを指定できます。有効範囲は、データベースの起動に使用したファイルがクライアント側のパラメータ・ファイル(pfile)か、サーバー・パラメータ・ファイル(spfile)かによって異なります。
MEMORY
MEMORYを指定すると、変更がメモリーで行われ、すぐに有効になり、データベースが停止するまで持続されます。パラメータ・ファイル(pfile)を使用してデータベースを起動した場合、この有効範囲のみを指定できます。
SPFILE
SPFILEを指定すると、変更がサーバー・パラメータ・ファイルで行われます。新しい設定は、データベースが次に停止し、再起動されたときに有効になります。『Oracle Databaseリファレンス』に変更不可能と示されている静的パラメータ値を変更する場合は、SPFILEを指定する必要があります。
BOTH
BOTHを指定すると、変更がメモリーとサーバー・パラメータ・ファイルの両方で行われます。新しい設定はすぐに有効になり、データベースが停止し、再起動された後も持続します。
データベースの起動でサーバー・パラメータ・ファイルを使用した場合は、BOTHがデフォルトです。データベースの起動でパラメータ・ファイルを使用した場合は、MEMORYがデフォルトで、これ以外の有効範囲は指定できません。
SID
SID句は、Real Application Clusters環境でのみ有効です。この句を使用すると、値を有効にするインスタンスのSIDを指定することができます。
すべてのインスタンスに対してパラメータ値を変更する場合、SID = '*'を指定します。
sidのインスタンスのみでパラメータ値を変更する場合、SID = 'sid'を指定します。この設定は、SID = '*'を指定する前後のALTER SYSTEM SET文より優先されます。
この句を指定しない場合は、次のようになります。
pfile(クライアント側の初期化パラメータ・ファイル)を使用してインスタンスを起動する場合、現行のインスタンスのSIDとみなされます。
spfile(サーバ・パラメータ・ファイル)を使用してインスタンスを起動する場合、SID = '*'を指定したとみなされます。
現行のインスタンス以外のインスタンスを指定すると、そのインスタンスに、メモリーのパラメータ値の変更を通知するメッセージが送信されます。
参照:
V$PARAMETERビューの詳細は、『Oracle Databaseリファレンス』を参照してください。 
alter_system_reset_clause
Real Application Clusters(RAC)環境では、alter_system_reset_clauseを使用すると、サーバー・パラメータ・ファイルですべてのインスタンス用にパラメータが設定されていても、各インスタンスでパラメータを個々に制御することができます。SCOPE句は、alter_system_set_clauseと同様に動作します。
SID
SID句を指定すると、以前、インスタンスに対してALTER SYSTEM SET ...SID = 'sid'文で設定したパラメータを削除できます。(RAC環境以外では、この句にSID = '*'を指定できます。)インスタンスは、パラメータ値を前後のALTER SYSTEM SET ...SID = '*'文で指定されたものとみなします。
参照:
Real Application Clusters環境の各インスタンス用のパラメータ値設定の詳細は、『Oracle Database Oracle ClusterwareおよびOracle Real Application Clusters管理およびデプロイメント・ガイド』を参照してください。 
初期化パラメータおよびALTER SYSTEM
従来のクライアント側のパラメータ・ファイル(PFILE)を使用してデータベースを起動したか、サーバー・パラメータ・ファイル(SPFILE)を使用してデータベースを起動したかに応じて、現行のインスタンスの多くの初期化パラメータ値を変更できます。『Oracle Databaseリファレンス』では、各パラメータの説明で、これらのパラメータが「変更可能」というカテゴリに分類されています。PFILEを使用した場合、変更はインスタンスの存続期間中のみ保持されます。一方、SPFILEを使用してデータベースを起動した場合、SPFILE自体のパラメータの値を変更できるため、後続のインスタンスで新しい値が使用されます。
次に3つのリストを示します。
最初のリストには、基本パラメータを示します。データベース管理者は、すべての基本パラメータについて熟知し、これらのパラメータの設定を考慮する必要があります。
2番目のリストには、機能のカテゴリに分類した初期化パラメータを示します。
3番目のリストには、初期化パラメータをアルファベット順に示します。
これらのパラメータの詳細は、『Oracle Databaseリファレンス』を参照してください。
参照:
ALTER SYSTEM文の使用例は、「ライセンス・パラメータの変更例:」、「クエリー・リライトを使用可能にする例:」、「リソース制限を使用可能にする例:」、「共有サーバーのパラメータ」、「共有サーバーの設定の変更例:」を参照してください。 
基本パラメータ
CLUSTER_DATABASE
COMPATIBLE
CONTROL_FILES
DB_BLOCK_SIZE
DB_CREATE_FILE_DEST
DB_CREATE_ONLINE_LOG_DEST_n
DB_DOMAIN
DB_NAME
DB_RECOVERY_FILE_DEST
DB_RECOVERY_FILE_DEST_SIZE
DB_UNIQUE_NAME
INSTANCE_NUMBER
JOB_QUEUE_PROCESSES
LOG_ARCHIVE_DEST_n
LOG_ARCHIVE_DEST_STATE_n
NLS_LANGUAGE
NLS_TERRITORY
OPEN_CURSORS
PGA_AGGREGATE_TARGET
PROCESSES
REMOTE_LISTENER
REMOTE_LOGIN_PASSWORDFILE
ROLLBACK_SEGMENTS
SESSIONS
SGA_TARGET
SHARED_SERVERS
STAR_TRANSFORMATION_ENABLED
UNDO_MANAGEMENT
UNDO_TABLESPACE
機能のカテゴリに分類したパラメータ
ANSI準拠
BLANK_TRIMMING
バックアップおよびリストア
BACKUP_TAPE_IO_SLAVES
RECYCLEBIN
TAPE_ASYNCH_IO
BFILE
SESSION_MAX_OPEN_FILES
バッファ・キャッシュおよびI/O
DB_nK_CACHE_SIZE
DB_BLOCK_BUFFERS
DB_BLOCK_SIZE
DB_CACHE_ADVICE
DB_CACHE_SIZE
DB_FILE_MULTIBLOCK_READ_COUNT
DB_KEEP_CACHE_SIZE
DB_RECYCLE_CACHE_SIZE
DB_WRITER_PROCESSES
DBWR_IO_SLAVES
DISK_ASYNCH_IO
FILESYSTEMIO_OPTIONS
READ_ONLY_OPEN_DELAYED
USE_INDIRECT_DATA_BUFFERS 
カーソルおよびライブラリ・キャッシュ
CURSOR_SHARING
CURSOR_SPACE_FOR_TIME
OPEN_CURSORS
SESSION_CACHED_CURSORS
データベース/インスタンスの識別
DB_DOMAIN
DB_NAME
INSTANCE_NAME
診断および統計情報
BACKGROUND_CORE_DUMP
BACKGROUND_DUMP_DEST
CORE_DUMP_DEST
DB_BLOCK_CHECKING
DB_BLOCK_CHECKSUM
EVENT
MAX_DUMP_FILE_SIZE
SHADOW_CORE_DUMP
STATISTICS_LEVEL
TIMED_OS_STATISTICS
TIMED_STATISTICS
TRACE_ENABLED
TRACEFILE_IDENTIFIER
USER_DUMP_DEST
分散およびレプリケーション
COMMIT_POINT_STRENGTH
DISTRIBUTED_LOCK_TIMEOUT
GLOBAL_NAMES
HS_AUTOREGISTER
OPEN_LINKS
OPEN_LINKS_PER_INSTANCE
REPLICATION_DEPENDENCY_TRACKING
ファイルの位置、名前およびサイズ
AUDIT_FILE_DEST
BACKGROUND_CORE_DUMP
BACKGROUND_DUMP_DEST
CONTROL_FILES
CORE_DUMP_DEST
DB_CREATE_FILE_DEST
DB_CREATE_ONLINE_LOG_DEST_n
DB_FILES
DB_RECOVERY_FILE_DEST
DB_RECOVERY_FILE_DEST_SIZE
FILE_MAPPING
IFILE
LOG_ARCHIVE_DEST_n
SPFILE
グローバリゼーション
NLS_CALENDAR
NLS_COMP
NLS_CURRENCY
NLS_DATE_FORMAT
NLS_DATE_LANGUAGE
NLS_DUAL_CURRENCY
NLS_ISO_CURRENCY
NLS_LANGUAGE
NLS_LENGTH_SEMANTICS
NLS_NCHAR_CONV_EXCP
NLS_NUMERIC_CHARACTERS
NLS_SORT
NLS_TERRITORY
NLS_TIMESTAMP_FORMAT
NLS_TIMESTAMP_TZ_FORMAT
Java
JAVA_MAX_SESSIONSPACE_SIZE
JAVA_POOL_SIZE
JAVA_SOFT_SESSIONSPACE_LIMIT
ジョブ・キュー
JOB_QUEUE_PROCESSES
ライセンス制限
LICENSE_MAX_SESSIONS
LICENSE_MAX_USERS
LICENSE_SESSIONS_WARNING
メモリー
LARGE_POOL_SIZE
SHARED_POOL_RESERVED_SIZE
SHARED_POOL_SIZE
その他
AQ_TM_PROCESSES
COMPATIBLE
FIXED_DATE
ネットワーク
LOCAL_LISTENER
REMOTE_LISTENER
SERVICE_NAMES
オブジェクトおよびLOB
OBJECT_CACHE_MAX_SIZE_PERCENT
OBJECT_CACHE_OPTIMAL_SIZE
OLAP
OLAP_PAGE_POOL_SIZE
オプティマイザ
OPTIMIZER_DYNAMIC_SAMPLING
OPTIMIZER_FEATURES_ENABLE
OPTIMIZER_INDEX_CACHING
OPTIMIZER_INDEX_COST_ADJ
OPTIMIZER_MODE
OPTIMIZER_SECURE_VIEW_MERGING
QUERY_REWRITE_ENABLED
QUERY_REWRITE_INTEGRITY
STAR_TRANSFORMATION_ENABLED
パラレル実行
PARALLEL_ADAPTIVE_MULTI_USER
PARALLEL_EXECUTION_MESSAGE_SIZE
PARALLEL_MAX_SERVERS
PARALLEL_MIN_PERCENT
PARALLEL_MIN_SERVERS
PARALLEL_THREADS_PER_CPU
PL/SQL
PLSQL_NATIVE_LIBRARY_DIR
PLSQL_NATIVE_LIBRARY_SUBDIR_COUNT
PLSQL_V2_COMPATIBILITY
REMOTE_DEPENDENCIES_MODE
UTL_FILE_DIR
PL/SQLコンパイラ
PLSQL_CC_FLAGS
PLSQL_CODE_TYPE
PLSQL_DEBUG
PLSQL_OPTIMIZE_LEVEL
PLSQL_WARNINGS
NLS_LENGTH_SEMANTICS
SGAメモリー
DB_nK_CACHE_SIZE
DB_CACHE_ADVICE
DB_CACHE_SIZE
HI_SHARED_MEMORY_ADDRESS
JAVA_POOL_SIZE
LOCK_SGA
OLAP_PAGE_POOL_SIZE
PGA_AGGREGATE_TARGET
PRE_PAGE_SGA
SGA_MAX_SIZE
SHARED_MEMORY_ADDRESS
Real Application Clusters
ACTIVE_INSTANCE_COUNT
CLUSTER_DATABASE
CLUSTER_DATABASE_INSTANCES
CLUSTER_INTERCONNECTS
GC_FILES_TO_LOCKS
INSTANCE_GROUPS
INSTANCE_NUMBER
MAX_COMMIT_PROPAGATION_DELAY
PARALLEL_INSTANCE_GROUP
THREAD
REDOログ、アーカイブおよびリカバリ
CONTROL_FILE_RECORD_KEEP_TIME
DB_CREATE_ONLINE_LOG_DEST_n
DB_RECOVERY_FILE_DEST
DB_RECOVERY_FILE_DEST_SIZE
FAST_START_MTTR_TARGET
LOG_BUFFER
LOG_CHECKPOINT_INTERVAL
LOG_CHECKPOINT_TIMEOUT
LOG_CHECKPOINTS_TO_ALERT
LOG_ARCHIVE_CONFIG
LOG_ARCHIVE_DEST_n
LOG_ARCHIVE_DEST_STATE_n
LOG_ARCHIVE_DUPLEX_DEST
LOG_ARCHIVE_FORMAT
LOG_ARCHIVE_MAX_PROCESSES
LOG_ARCHIVE_MIN_SUCCEED_DEST
LOG_ARCHIVE_TRACE
RECOVERY_PARALLELISM
リソース・マネージャ
RESOURCE_LIMIT
RESOURCE_MANAGER_PLAN
セキュリティおよび監査
AUDIT_FILE_DEST
AUDIT_SYS_OPERATIONS
AUDIT_SYSLOG_LEVEL
AUDIT_TRAIL
O7_DICTIONARY_ACCESSIBILITY
OS_AUTHENT_PREFIX
OS_ROLES
RDBMS_SERVER_DN
REMOTE_LOGIN_PASSWORDFILE
REMOTE_OS_AUTHENT
REMOTE_OS_ROLES
SQL92_SECURITY
セッションおよびプロセス
CPU_COUNT
PROCESSES
SESSIONS
共有サーバー・アーキテクチャ
CIRCUITS
DISPATCHERS
MAX_DISPATCHERS
MAX_SHARED_SERVERS
SHARED_SERVER_SESSIONS
SHARED_SERVERS
スタンバイ・データベース
ARCHIVE_LAG_TARGET
DB_FILE_NAME_CONVERT
DB_UNIQUE_NAME
DG_BROKER_CONFIG_FILEn
DG_BROKER_START
FAL_CLIENT
FAL_SERVER
LOG_FILE_NAME_CONVERT
STANDBY_ARCHIVE_DEST
STANDBY_FILE_MANAGEMENT
一時ソート領域
BITMAP_MERGE_AREA_SIZE
CREATE_BITMAP_AREA_SIZE
HASH_AREA_SIZE
PGA_AGGREGATE_TARGET
SORT_AREA_RETAINED_SIZE
SORT_AREA_SIZE
WORKAREA_SIZE_POLICY
トランザクション
COMMIT_WRITE
DML_LOCKS
FAST_START_PARALLEL_ROLLBACK
TRANSACTIONS
UNDO管理
RESUMABLE_TIMEOUT
ROLLBACK_SEGMENTS
TRANSACTIONS_PER_ROLLBACK_SEGMENT
UNDO_MANAGEMENT
UNDO_RETENTION
UNDO_TABLESPACE
すべてのパラメータ(アルファベット順)
ACTIVE_INSTANCE_COUNT
AQ_TM_PROCESSES
ARCHIVE_LAG_TARGET
ASM_DISKGROUPS
ASM_DISKSTRING
ASM_POWER_LIMIT
AUDIT_FILE_DEST
AUDIT_SYS_OPERATIONS
AUDIT_SYSLOG_LEVEL
AUDIT_TRAIL
BACKGROUND_CORE_DUMP
BACKGROUND_DUMP_DEST
BACKUP_TAPE_IO_SLAVES
BITMAP_MERGE_AREA_SIZE
BLANK_TRIMMING
CIRCUITS
CLUSTER_DATABASE
CLUSTER_DATABASE_INSTANCES
CLUSTER_INTERCONNECTS
COMMIT_POINT_STRENGTH
COMMIT_WRITE
COMPATIBLE
CONTROL_FILE_RECORD_KEEP_TIME
CONTROL_FILES
CORE_DUMP_DEST
CPU_COUNT
CREATE_BITMAP_AREA_SIZE
CREATE_STORED_OUTLINES
CURSOR_SHARING
CURSOR_SPACE_FOR_TIME
DB_nK_CACHE_SIZE
DB_BLOCK_BUFFERS
DB_BLOCK_CHECKING
DB_BLOCK_CHECKSUM
DB_BLOCK_SIZE
DB_CACHE_ADVICE
DB_CACHE_SIZE
DB_CREATE_FILE_DEST
DB_CREATE_ONLINE_LOG_DEST_n
DB_DOMAIN
DB_FILE_MULTIBLOCK_READ_COUNT
DB_FILE_NAME_CONVERT
DB_FILES
DB_FLASHBACK_RETENTION_TARGET
DB_KEEP_CACHE_SIZE
DB_NAME
DB_RECOVERY_FILE_DEST
DB_RECOVERY_FILE_DEST_SIZE
DB_RECYCLE_CACHE_SIZE
DB_UNIQUE_NAME
DB_WRITER_PROCESSES
DBWR_IO_SLAVES
DG_BROKER_CONFIG_FILEn
DG_BROKER_START
DISK_ASYNCH_IO
DISPATCHERS
DISTRIBUTED_LOCK_TIMEOUT
DML_LOCKS
EVENT
FAL_CLIENT
FAL_SERVER
FAST_START_MTTR_TARGET
FAST_START_PARALLEL_ROLLBACK
FILE_MAPPING
FILEIO_NETWORK_ADAPTERS
FILESYSTEMIO_OPTIONS
FIXED_DATE
GC_FILES_TO_LOCKS
GCS_SERVER_PROCESSES
GLOBAL_NAMES
HASH_AREA_SIZE
HI_SHARED_MEMORY_ADDRESS
HS_AUTOREGISTER
IFILE
INSTANCE_GROUPS
INSTANCE_NAME
INSTANCE_NUMBER
INSTANCE_TYPE
JAVA_MAX_SESSIONSPACE_SIZE
JAVA_POOL_SIZE
JAVA_SOFT_SESSIONSPACE_LIMIT
JOB_QUEUE_PROCESSES
LARGE_POOL_SIZE
LDAP_DIRECTORY_ACCESS
LICENSE_MAX_SESSIONS
LICENSE_MAX_USERS
LICENSE_SESSIONS_WARNING
LOCAL_LISTENER
LOCK_SGA
LOG_ARCHIVE_CONFIG
LOG_ARCHIVE_DEST
LOG_ARCHIVE_DEST_n
LOG_ARCHIVE_DEST_STATE_n
LOG_ARCHIVE_DUPLEX_DEST
LOG_ARCHIVE_FORMAT
LOG_ARCHIVE_LOCAL_FIRST
LOG_ARCHIVE_MAX_PROCESSES
LOG_ARCHIVE_MIN_SUCCEED_DEST
LOG_ARCHIVE_TRACE
LOG_BUFFER
LOG_CHECKPOINT_INTERVAL
LOG_CHECKPOINT_TIMEOUT
LOG_CHECKPOINTS_TO_ALERT
LOG_FILE_NAME_CONVERT
MAX_COMMIT_PROPAGATION_DELAY
MAX_DISPATCHERS
MAX_DUMP_FILE_SIZE
MAX_SHARED_SERVERS
NLS_CALENDAR
NLS_COMP
NLS_CURRENCY
NLS_DATE_FORMAT
NLS_DATE_LANGUAGE
NLS_DUAL_CURRENCY
NLS_ISO_CURRENCY
NLS_LANGUAGE
NLS_LENGTH_SEMANTICS
NLS_NCHAR_CONV_EXCP
NLS_NUMERIC_CHARACTERS
NLS_SORT
NLS_TERRITORY
NLS_TIMESTAMP_FORMAT
NLS_TIMESTAMP_TZ_FORMAT
O7_DICTIONARY_ACCESSIBILITY
OBJECT_CACHE_MAX_SIZE_PERCENT
OBJECT_CACHE_OPTIMAL_SIZE
OLAP_PAGE_POOL_SIZE
OPEN_CURSORS
OPEN_LINKS
OPEN_LINKS_PER_INSTANCE
OPTIMIZER_DYNAMIC_SAMPLING
OPTIMIZER_FEATURES_ENABLE
OPTIMIZER_INDEX_CACHING
OPTIMIZER_INDEX_COST_ADJ
OPTIMIZER_MODE
OPTIMIZER_SECURE_VIEW_MERGING
OS_AUTHENT_PREFIX
OS_ROLES
PARALLEL_ADAPTIVE_MULTI_USER
PARALLEL_EXECUTION_MESSAGE_SIZE
PARALLEL_INSTANCE_GROUP
PARALLEL_MAX_SERVERS
PARALLEL_MIN_PERCENT
PARALLEL_MIN_SERVERS
PARALLEL_THREADS_PER_CPU
PGA_AGGREGATE_TARGET
PLSQL_CCFLAGS
PLSQL_CODE_TYPE
PLSQL_DEBUG
PLSQL_NATIVE_LIBRARY_DIR
PLSQL_NATIVE_LIBRARY_SUBDIR_COUNT
PLSQL_OPTIMIZE_LEVEL
PLSQL_V2_COMPATIBILITY
PLSQL_WARNINGS
PRE_PAGE_SGA
PROCESSES
QUERY_REWRITE_ENABLED
QUERY_REWRITE_INTEGRITY
RDBMS_SERVER_DN
READ_ONLY_OPEN_DELAYED
RECOVERY_PARALLELISM
RECYCLEBIN
REMOTE_DEPENDENCIES_MODE
REMOTE_LISTENER
REMOTE_LOGIN_PASSWORDFILE
REMOTE_OS_AUTHENT
REMOTE_OS_ROLES
REPLICATION_DEPENDENCY_TRACKING
RESOURCE_LIMIT
RESOURCE_MANAGER_PLAN
RESUMABLE_TIMEOUT
ROLLBACK_SEGMENTS
SERVICE_NAMES
SESSION_CACHED_CURSORS
SESSION_MAX_OPEN_FILES
SESSIONS
SGA_MAX_SIZE
SGA_TARGET
SHADOW_CORE_DUMP
SHARED_MEMORY_ADDRESS
SHARED_POOL_RESERVED_SIZE
SHARED_POOL_SIZE
SHARED_SERVER_SESSIONS
SHARED_SERVERS
SKIP_UNUSABLE_INDEXES
SMTP_OUT_SERVER
SORT_AREA_RETAINED_SIZE
SORT_AREA_SIZE
SPFILE
SQL92_SECURITY
SQLTUNE_CATEGORY
STANDBY_ARCHIVE_DEST
STANDBY_FILE_MANAGEMENT
STAR_TRANSFORMATION_ENABLED
STATISTICS_LEVEL
STREAMS_POOL_SIZE
TAPE_ASYNCH_IO
THREAD
TIMED_OS_STATISTICS
TIMED_STATISTICS
TRACE_ENABLED
TRACEFILE_IDENTIFIER
TRANSACTIONS
TRANSACTIONS_PER_ROLLBACK_SEGMENT
UNDO_MANAGEMENT
UNDO_RETENTION
UNDO_TABLESPACE
USE_INDIRECT_DATA_BUFFERS 
USER_DUMP_DEST
UTL_FILE_DIR
WORKAREA_SIZE_POLICY
システム・パラメータおよびALTER SYSTEM
この項では、システム・パラメータについて説明します。これらのパラメータは初期化パラメータではないため、PFILEおよびSPFILEに設定することはできません。ただし、ALTER SYSTEM文を使用すると、これらのパラメータを設定できます。
USE_STORED_OUTLINES
構文: 
USE_STORED_OUTLINES = { TRUE | FALSE | category_name }
USE_STORED_OUTLINESパラメータは、オプティマイザが実行計画を生成するためにストアド・パブリック・アウトラインを使用するかどうかを決定します。USE_STORED_OUTLINESは、初期化パラメータではありません。
TRUEに設定すると、要求をコンパイルするときに、オプティマイザはDEFAULTカテゴリのストアド・アウトラインを使用します。
FALSEに設定すると、オプティマイザはストアド・アウトラインを使用しません。これはデフォルトです。
category_nameに設定すると、要求をコンパイルするときに、オプティマイザはcategory_nameカテゴリのストアド・アウトラインを使用します。
共有サーバーのパラメータ
インスタンスを起動すると、OracleデータベースはSHARED_SERVERSおよびDISPATCHERS初期化パラメータの値に基づく共有サーバー・アーキテクチャの共有サーバー・プロセスおよびディスパッチャ・プロセスを作成します。ALTER SYSTEM文でSHARED_SERVERSおよびDISPATCHERSパラメータを設定し、インスタンスの実行中に次の操作のいずれかを実行できます。
共有サーバー・プロセスの最小値を増やして、追加の共有サーバー・プロセスを作成します。
現行のコールが処理を終了した後、既存の共有サーバー・プロセスを終了します。
特定のプロトコルに対するディスパッチャ・プロセスをより多く作成します。プロトコル全体で、初期化パラメータMAX_DISPATCHERSによって指定される数まで作成できます。
現行のユーザー・プロセスがインスタンスから切断した後、特定のプロトコルに対する既存のディスパッチャ・プロセスを終了します。
例
REDOログの手動アーカイブの例:
次の文は、SCN 9356083のREDOログ・エントリを含むREDOログ・ファイル・グループを手動でアーカイブします。
ALTER SYSTEM ARCHIVE LOG CHANGE 9356083; 
次の文は、メンバー'diskl:log6.log'を含むREDOログ・ファイル・グループを、'diska:[arch$]'という場所にあるアーカイブREDOログ・ファイルに手動でアーカイブします。
ALTER SYSTEM ARCHIVE LOG 
LOGFILE 'diskl:log6.log' 
TO 'diska:[arch$]'; 
クエリー・リライトを使用可能にする例:
次の文は、クエリー・リライトが明示的に使用禁止にされていないすべてのマテリアライズド・ビューに対するすべてのセッションで、クエリー・リライトを使用可能にします。
ALTER SYSTEM SET QUERY_REWRITE_ENABLED = TRUE;
セッションを制限する例:
たとえば、アプリケーションのメンテナンス中は、RESTRICTED SESSIONシステム権限が付与されているアプリケーション開発者のみがログインできるようにセッションを制限できます。このためには、次の文を発行します。
ALTER SYSTEM
ENABLE RESTRICTED SESSION; 
次に、ALTER SYSTEM文のKILL SESSION句を使用すると、既存のセッションをどれでも終了できます。
アプリケーションのメンテナンスが終了した後で、次の文を発行することによって、CREATE SESSIONシステム権限が付与されているユーザーもログインできるようになります。
ALTER SYSTEM
DISABLE RESTRICTED SESSION; 
ウォレットおよび暗号化キーの確立
次の文を使用すると、サーバー・ウォレットの情報をメモリーにロードして、データの透過的暗号化のマスター鍵を設定できます。
ALTER SYSTEM SET ENCRYPTION WALLET OPEN AUTHENTICATED BY "welcome1";
ALTER SYSTEM SET ENCRYPTION KEY AUTHENTICATED BY "welcome1"; 
これらの文では、セキュリティ・モジュールが初期化済で、パスワードwelcome1を使用してウォレットが作成済であることを前提としています。
共有プールの消去例:
共有プールを消去してから、パフォーマンス分析を開始します。共有プールを消去する場合、次の文を発行します。
ALTER SYSTEM FLUSH SHARED_POOL;
チェックポイントの発生例:
次の文は、チェックポイントを強制的に発生させます。
ALTER SYSTEM CHECKPOINT; 
リソース制限を使用可能にする例:
次のALTER SYSTEM文は、リソース制限を動的に使用可能にします。
ALTER SYSTEM SET RESOURCE_LIMIT = TRUE; 
共有サーバーの設定の変更例:
次の文は、共有サーバー・プロセスの最小数を25に変更します。
ALTER SYSTEM SET SHARED_SERVERS = 25; 
共有サーバー・プロセスの数が25より少ない場合は追加作成されます。共有サーバー・プロセスが25より多く、25あれば負荷を管理できる場合は、現行のコールによる処理が終了した時点で、25を超える分の共有サーバー・プロセスは終了します。
次の文は、TCP/IPプロトコルのディスパッチャ・プロセス数を5に、ipcプロトコルのディスパッチャ・プロセス数を10に動的に変更します。
ALTER SYSTEM 
SET DISPATCHERS = 
'(INDEX=0)(PROTOCOL=TCP)(DISPATCHERS=5)',
'(INDEX=1)(PROTOCOL=ipc)(DISPATCHERS=10)'; 
TCPのディスパッチャ・プロセスの数が5より少ない場合、ディスパッチャ・プロセスが新しく作成されます。5より多い場合は、接続されているユーザーが接続を切断した後に、5を超える分のディスパッチャ・プロセスは終了します。
ipcのディスパッチャ・プロセスの数が10より少ない場合、ディスパッチャ・プロセスが新しく作成されます。10より多い場合は、接続されているユーザーが接続を切断した後に、10を超える分のディスパッチャ・プロセスは終了します。
これ以外のプロトコル用として既存ディスパッチャがある場合、この文は、そのディスパッチャの数に影響しません。
ライセンス・パラメータの変更例:
次の文は、インスタンスにおけるセッションの最大数を64に、セッションの警告しきい値を54に動的に変更します。
ALTER SYSTEM 
SET LICENSE_MAX_SESSIONS = 64 
LICENSE_SESSIONS_WARNING = 54; 
セッション数が54に達した場合、後続の各セッションのALERTファイルに警告メッセージが書き込まれます。RESTRICTED SESSIONシステム権限を持つユーザーも、後続セッションを開始する場合に、警告メッセージを受け取ります。
セッション数が64に達した場合、セッション数が再び64を下回るまでは、RESTRICTED SESSIONシステム権限を持つユーザー以外は新しいセッションを開始できません。
次の文は、インスタンスのセッションの最大数を動的に使用禁止にします。この文の実行後は、インスタンスのセッション数に制限がなくなります。
ALTER SYSTEM SET LICENSE_MAX_SESSIONS = 0; 
次の文は、データベースのユーザー数の制限を200に動的に変更します。この文の実行後は、データベース・ユーザー数が200を超えることはありません。
ALTER SYSTEM SET LICENSE_MAX_USERS = 200; 
ログ・スイッチの発生例:
書込み中のファイルの削除および名前の変更はできません。ただし、ログ・スイッチを強制的に発生させることによって、現行のREDOログ・ファイル・グループまたはそのメンバーの1つを削除したり、その名前を変更できます。強制的に発生したログ・スイッチは、インスタンスのREDOログ・スレッドのみに影響します。次の文は、ログ・スイッチを強制的に発生させます。
ALTER SYSTEM SWITCH LOGFILE; 
分散リカバリを使用可能にする例:
次の文は、分散リカバリを使用可能にします。
ALTER SYSTEM ENABLE DISTRIBUTED RECOVERY;
デモンストレーションまたはテストの目的で、分散リカバリを使用禁止にする場合があります。次の文は、シングルプロセス・モードとマルチプロセス・モードの両方で分散リカバリを使用禁止にします。
ALTER SYSTEM DISABLE DISTRIBUTED RECOVERY; 
デモンストレーションまたはテストが終了した場合、ALTER SYSTEM文にENABLE DISTRIBUTED RECOVERY句を指定して実行すると、分散リカバリを再び使用可能にできます。
セッションの終了例:
あるユーザーのセッションで、他のユーザーが必要とするリソースを使用している場合、そのユーザーのセッションを終了させる場合があります。このユーザーは、セッションが終了したことを示すエラー・メッセージを受け取ります。このユーザーは、新しいセッションを開始しないかぎり、このデータベースをコールできません。次のV$SESSION動的パフォーマンス表のデータについて考えます。ここでは、ユーザーSYSとoeが両方ともセッションを開いているものとします。
SELECT sid, serial#, username
FROM v$session; 
SID    SERIAL# USERNAME
---------- ---------- ------------------------------
29         85 SYS
33          1
35          8
39         23 OE
40          1
. . .
次の文は、V$SESSIONのSID値とSERIAL#値を使用して、ユーザーscottのセッションを終了します。
ALTER SYSTEM KILL SESSION '39, 23';
セッションの切断例:
次の文は、V$SESSIONのSIDとSERIAL#の値を使用して、ユーザーscottのセッションを切断します。
ALTER SYSTEM DISCONNECT SESSION '13, 8' POST_TRANSACTION;
Copyright &copy; 2006 Oracle Corporation. 
All Rights Reserved.
目次
索引
SQL文: ALTER MATERIALIZED VIEW〜ALTER SYSTEM
