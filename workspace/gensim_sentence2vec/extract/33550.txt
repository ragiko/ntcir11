
「a～e」を「X」に置換する
a から e までのいずれかの文字を、といったあいまいな置換対象には正規表現を使用するのが最適だ。
$ echo "abcdefghij" | sed -e 's/[a-e]/X/g'
XXXXXfghij
数字以外を削除する
「～以外」を表す「[^～]」を使用すると簡単に実現できる。
$ echo "I am 20 years old." | sed -e 's/[^0-9]//g'
20
行頭に文字を追加する
行頭に文字列を追加するには、行頭を表す「＾」を追加したい文字列に置換する。
$ echo "Hello World" | sed -e 's/^/>>>/g'
>>>Hello World
行末に文字列を追加する
行末に文字列を追加するには、行末を表す「$」を追加したい文字列に置換する。
$ echo "Hello World" | sed -e 's/$/ !!!/g'
Hello World !!!
連続する複数のスペースを1つにまとめる
連続する複数のスペースは「*」で表される(※「」は半角スペースを表すものとする)。
アスタリスクは直前の文字の 0 ～ n 個の繰り返しなので、「*」だと 0 個のスペースも置換対象とみなされてしまう。
したがって、連続する複数のスペースを表すには「1個のスペース」+「0 ～ n 個のスペース」で「*」となる。
$ echo "hello     world" | sed -e 's/  */ /'
hello world
GNU sed (Linux 上の sed)では「\+」で1個以上の連続するスペースを表現することが可能である。
$ echo "hello     world" | sed -e 's/ \+/ /'
hello world
変数を使用した文字列置換
sed -e "s/$VAR1/置換後パターン/"
sed -e "s/置換対象パターン/$VAR/"
sed -e "s/$VAR1/$VAR2/"
「$」を打ち消さないようにダブルクォートを使用する。
置換に使用されるパターンの指定には、変数の値を使用することも可能である。
変数は値に展開されてから sed コマンドに渡される必要があるため、「'」(シングルクォーテーション)で囲んで「$」をエスケープしてはいけない。
変数を使用する場合は下記の例のように「$」を打ち消さない「"」(ダブルクォーテーション)を使用する。
$ VAR="hoge"
※変数 VAR に "hoge" を設定する。
$ echo "hoge fuga \$VAR" | sed -e "s/$VAR/foo/"
foo fuga $VAR
$ echo "hoge fuga \$VAR" | sed -e "s/fuga/$VAR/"
hoge hoge $VAR
※変数 VAR の値 "hoge" が置換パターンに使用される。
$ echo "hoge fuga \$VAR" | sed -e 's/$VAR/foo/'
hoge fuga foo
※シングルクォートだと変数の値ではなく、文字列 "$VAR" として置換される。
行を指定した置換
sed コマンドはテキスト全体を対象として処理を行うが、
行番号を指定することにより限定された範囲内でのみ処理を行うようにすることが可能である。
# 特定の 1行のみで置換を行う。
sed -e '行番号s/パターン1/パターン2/'
# 開始行～終了行の範囲でのみ置換を行う。
sed -e '開始行,終了行s/パターン1/パターン2/'
「s」の直前に対象とする行番号を指定する。
ある特定の行のみを置換対象としたい、または n 行目から m 行目のみを置換対象としたい、
といった場合には対象とする行の行番号を指定することで、処理が適用される範囲を限定することができる。
$ cat test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 ABC
666 ABC
777 ABC
888 ABC
999 ABC
※使用するテキストファイル。
$ sed -e '5s/ABC/OK OK OK OK OK/' test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 OK OK OK OK OK
666 ABC
777 ABC
888 ABC
999 ABC
※コマンドに5行目を指定したので、5行目でのみ置換されている。
$ sed -e '4,6s/ABC/OK OK OK OK OK/' test.txt
111 ABC
222 ABC
333 ABC
444 OK OK OK OK OK
555 OK OK OK OK OK
666 OK OK OK OK OK
777 ABC
888 ABC
999 ABC
※コマンドに4～6行目を指定したので、4～6行目でのみ置換されている。
特定の行を削除する
n 行目、または n 行目～ m 行目を削除、などのように指定した行を削除して表示する。
sed -e '/パターン/d'
行そのものを削除するには「d」を指定する。
削除対象となる行のパターンと「d」を指定することで、パターンを含む行を削除できる。
置換ではなく削除なので、置換後のパターンを指定する必要はない。
$ cat test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 ABC
※使用するテキストファイル。
$ sed -e '/333/d' test.txt
111 ABC
222 ABC
444 ABC
555 ABC
※「333」を含む行が削除されている。
$ grep -v "333" test.txt
111 ABC
222 ABC
444 ABC
555 ABC
※「grep -v ～」と同じ結果になる。
空行を削除する
空行は行頭と行末の間に何も存在しない行のことなので、正規表現の「^$」で表すことができる。
これを対象パターンに指定することで、空行を削除することが可能である。
$ cat emp.txt
111 ABC
555 ABC
$ sed -e '/^$/d' emp.txt
111 ABC
555 ABC
行中に含まれる文字列に関係なくn行目を削除する
# 単一行の削除
sed -e '行番号d'
# 複数行の削除
sed -e '開始行,終了行d'
「d」に行番号のみを指定する。
対象パターンを指定せずに行番号のみを指定することで、その行自体を削除することができる。
$ cat test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 ABC
$ sed -e '3d' test.txt
111 ABC
222 ABC
444 ABC
555 ABC
※3行目を指定したので、3行目が削除されている。
$ sed -e '2,4d' test.txt
111 ABC
555 ABC
※ 2 と 4 を指定したので、2 ～ 4 行行目が削除されている。
最下行を削除する
最下行を表す正規表現である「$」を、行番号の代わりに指定することも可能。
$ cat test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 ABC
$ sed -e '$d' test.txt
111 ABC
222 ABC
333 ABC
444 ABC
特定の行のみを表示する
n 行目、または n 行目～ m 行目のみを表示、などのように指定した行のみを表示する。
# n行目を表示
sed -n '行番号p'
# n行目～m行目を表示
sed -n '開始行,終了行p'
「-n」オプションと行番号、および print の「p」を指定する。
指定した行を表示するオプションは、「-e」ではなく「-n」となる。
$ cat test.txt
111 ABC
222 ABC
333 ABC
444 ABC
555 ABC
$ sed -n '1p' test.txt
111 ABC
※1を指定して1行目のみを表示。
$ sed -n '2,4p' test.txt
222 ABC
333 ABC
444 ABC
※2 と 4 をして 2行目～ 4行目を表示。
特定の位置の文字列を切り出す
5文字目から 10文字目までを切り出す、"ABC" の後にに続く 3文字を切り出す、
などのように特定の条件に一致する部分的な文字列のみを切り出す。
sed -e 's/パターンA\(切り出し対象パターン\)パターンB/\1/'
文字列を正規表現化し、切り出す部分をエスケープした「()」(小括弧)で囲む。
全体のパターン(パターンA+対象パターン+パターンB)に一致した文字列のうち、
括弧で囲んだ対象パターンに一致する部分を、「\1」を使用することで切り出すことができる。
また、括弧で囲む部分を増やすことで切り出す文字列を複数指定可能で、
1番目の括弧は「\1」、2番目の括弧は「\2」といったように括弧の順番に対応した番号を指定して切り出す。
なお、切り出し対象を指定する括弧は「\(」「\)」のようにエスケープする必要がある。
$ echo "ABC123DEF456" | sed -e 's/...\(...\).*/\1/'
123
$ echo "ABC123DEF456" | sed -e 's/...\(...\)...\(...\)/\1 \2/'
123 456
$ echo "ABC123DEF456" | sed -e 's/...\(...\)/\1 /'
123 DEF456
「.」(ドット)は任意の一文字を表すので「...」は任意の 3文字を表す。
sed コマンドによる文字列の切り出しは、パターンに一致した文字列を括弧の中の文字列で置換するイメージになる。
そのため、上記の 3つめの例のようにパターンに一致しなかった部分はそのまま出力される。
同様に、expr コマンドでも文字列を切り出すことが可能だ。
expr "文字列" : "パターンA\(対象パターン\)パターンB"
文字列を正規表現化し、切り出す部分をエスケープした「()」(小括弧)で囲む。
expr コマンドでは一度に複数の部分を切り出すことはできない。
sed コマンドを用いた場合と同様に括弧はエスケープする必要がある。
また、sed コマンドとは異なり、パターンに一致しなかった部分は出力されない。
$ expr "ABC123DEF456" : "...\(...\)"
123
※パターンに一致しない部分(DEF456)は出力されない。
$ expr "ABC123DEF456" : "...\(...\)...\(...\)"
123
※一度に複数の部分を切り出すことはできない。
置換を行う sed コマンドとは異なるので、パターンに一致しない部分は無視される。
また、複数箇所を括弧で囲んでも、切り出されるのは最初の括弧の部分のみである。
"^M" などの制御文字を削除する
Windows 上でテキストファイルを作成し、改行コードを LF に変換せずに CR+LF のままLinux(Unix) 上へ転送してしまった、といったミスを経験したことがある人は少なからずいるだろう。
改行コードを変換せずに転送されたファイルを、Linux(Unix) 上で vi などを使用して開いてみると、行末に "^M" が表示されていることがある。
これは sed コマンドで削除可能であるが、文字列の指定に少しコツがいる。
削除対象となる "^M" は、通常の文字列ではなく制御文字(制御コード)なので、sed コマンドにそのまま "^M" と指定しても削除することはできない。
制御文字である "^M" を入力するには、 [Ctrl]+[v], [Ctrl]+[M] と連続して入力する。
実際に削除できるか実験してみよう。
まず削除対象となる制御文字の "^M" が含まれたテキストファイルを vi で開いてみる。
$ vi CRLF.txt
This is "^M" ->^M
This is "^M" ->^M
This is "^M" ->^M
This is "^M" ->^M
This is "^M" ->^M
~
~
~
~
~
"CRLF.txt" 6L, 86C
白い色の "^M" は通常の文字列、行末の青い色の "^M" が削除対象となる制御文字。
まず、sed コマンドに "^M" と普通に入力した通常の文字列で置換を実行してみる。
$ sed -e 's/\^M//g' CRLF.txt >LF.txt
※ "^" はエスケープしておくこと。
vi で結果を確認してみる。
$ vi CRLF.txt
This is "" ->^M
This is "" ->^M
This is "" ->^M
This is "" ->^M
This is "" ->^M
~
~
~
~
~
"LF.txt" 6L, 76C
削除されたのは普通の文字列のみで、制御文字は削除されていない。
今度は、[Ctrl]+[v], [Ctrl]+[M] と入力した文字列で置換を実行してみる。
$ sed -e 's/^M//g' CRLF.txt >LF.txt
※ 今回の "^" は制御文字なのでエスケープは不要。
vi で結果を確認してみる。
$ vi LF.txt
This is "^M" ->
This is "^M" ->
This is "^M" ->
This is "^M" ->
This is "^M" ->
~
~
~
~
~
"LF.txt" 6L, 81C
今度はみごとに制御文字が削除された。
参考サイト:
テキストファイルの行末に^Mが表示される
vi で制御コードを入力するには?
フィルタを使用した文字列操作 1 - UNIX & Linux コマンド・シェルスクリプト リファレンス
