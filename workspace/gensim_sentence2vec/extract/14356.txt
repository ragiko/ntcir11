【7行でわかるawkの威力】
1)	http://www.eco.osakafu-u.ac.jp/~kazuhisa/awk.exeからawkをダウンロードしてC:\awkフォルダ作って入れる!
2)	http://www.mkc.zaq.ne.jp/eabeh309/data.txtをダウンロードしてC:\awkフォルダに入れる!
3)	スタートプログラムアクセサリコマンドプロンプトをクリック!
4)	コマンドプロンプトにcd c:\awkと打ち込む!
5)	さらにawk /604/ data.txtと打ち込む!
6)	すると画面上に604とマッチした行だけが出力される!
7)	窓を開けてawk最高と叫ぶ!終了!
と、このように/検索語/と打ち込むだけでマッチした行を出力してくれます。
簡易データベースのように使えますね。
出力方法やマッチ方法も実に多彩。
是非ご活用下さい。
【awkの基本】
awkは基本的に
BEGIN{何らかの処理}
パターン1{何らかの処理}
パターン2{何らかの処理}
・・・
パターンn{何らかの処理}
END{何らかの処理} 
と上から下に処理される。
BEGIN{}やEND{}に何も含めない場合は省略可能。なお、awkでは大文字と小文字を区別するので注意。
指定したファイルの内容を上から1行ずつ読み込み、
通常は半角スペース毎に読み込んだ行を分解して配列変数に渡す。
つまり、$0には1行全体が入っていて、$1は行を区切ったものの先頭、$2は先頭から2つめの区切り・・・以下同となる。
【awkの基本:実例】
例えばディレクトリC:\にawk.exeとdata.txtを置いている場合、
>awk {print} data.txt
と打つとコマンドプロンプト上にdata.txtの内容が表示される。
data.txtの内容が
_________________________________________________
氏名	学年	部屋番号
伊藤	D2	601
田中	D1	602
山本	M2 	502
_________________________________________________
の場合、コマンドプロンプト上で
awk "{print $3}" data.txt
と打つと
_________________________________________________
部屋番号
601
602
502
_________________________________________________
が表示される。
ファイルを1行ずつ読み込み、
読み込んだ各行を半角スペース毎に区切る。
区切ったものを$nという変数に代入する。
特に$0には読み込んだ行全体が代入されている。
そして上のdata.txtの例で言えば、今上から2行目を読み込んでいるところだとすると
$0	=	伊藤	D2	601
$1	=	伊藤
$2	=	D2
$3	=	601
というように各々代入される。
【awkによる出力】
printというコマンドは画面上に表示するだけではなく、ファイルに出力することも可能である。
先ほどと同じawk "{print $3}" data.txtの後ろに、今度は>test.txtをつけ加えてみる。
>awk "{print $3}" data.txt >test.txt
すると今度は画面上には何も出力されない。
そしてC:\を見ると、先ほど存在しなかったtest.txtが生成され、
その内容は
_________________________________________________
部屋番号
601
602
502
_________________________________________________
となっている。
【雑談。そしてawkを学ぶ意義】
先日とある女性が必死にデータを弄っていた。
何をしているのかと聞けば、とあるアンケート調査から、出身地による回答の偏りがあるかどうかを調査したいらしい。
そのために彼女は何時間もかけて(!)回答を出身地ごとにばらしていたのだ。
私は彼女に「awkを学べばそんなもの一瞬で終る」と言いたかったが、
「わざわざプログラミング言語を学ぶなんてゴメンだ」と返されるのが関の山なので言わなかった。
後日、「私がちょちょいとプログラム組んで彼女に渡してあげれば良かったじゃないか!
awkを教えるなんてまだるっこしいことせずとも!」と気づいたが後の祭りであった。
【データの抽出】
次のようなdata.txtがあるとする。
_________________________________________________
氏名	性別	出身地
伊藤	男	東京
坂本	女	大阪
田中	女	東京
高橋	男	東京
山本	男 	大阪
_________________________________________________
ここから出身地別にするにはどうすればいいだろう?
これは実に簡単で、/取り出したい出身地/ と書く。
>awk /東京/ data.txt
と打ち込むと、コマンドプロンプト上で次のように出力される。
_________________________________________________
伊藤	男	東京
田中	女	東京
高橋	男	東京
_________________________________________________
※ちなみに、コマンドプロンプト上で日本語を打ち込むときは
Altキーと半角/全角漢字と書かれたキー(キーボードにもよるが、半角/全角キーの隅に漢字と書かれたキーがあるはず。無ければ探す)の同時押し。
さらに、条件を追加することが出来る。
東京かつ男であるデータだけを抽出したい場合は
>awk "/東京/ && /男/" data.txt
とうち込む。すると
_________________________________________________
伊藤	男	東京
高橋	男	東京
_________________________________________________
と望みの結果が得られる。
集合論で言うところの∪(または)は||、∩(かつ)は&&とタイプする。
もし先ほどの雑談で出てきた彼女が
awkを知っていれば
>awk "/東京/ && /男/" data.txt
とこの一行打ち込むだけで即座に求めるデータを抽出できたはずである。
とても残念だ。
【csvファイルを扱う】
データを扱う場合、Excelなどでcsvファイルを操作することが多いだろう。
csvファイルとはデータをカンマ区切りで並べたものである。
その場合、通常のawkの処理のようにタブではなく,でデータを区切って抽出したい。
そういうときはBEGIN部分を次のように書く。
BEGIN{FS = ","}
すると標準のタブ区切りではなく,でデータを区切ってくれる。
ちなみにFSはフィールド・セパレータの頭文字を取ったものである。
【組み込み変数】
自分で宣言する変数だけではなく、awkがもともと用意している変数がある。
これを「組み込み変数」と言い、awkにはNR,NF,FSなど多数用意されている。全て覚える必要はなく、よく使うものだけ紹介する。
NRは現在の読み込み行、NFは読み込みフィールド(列)、FSは区切り文字が格納される。
awkは通常、読み込んだテキストを先頭から一行一行逐次解釈していく。
さらに、行の中でも先頭のフィールド(列)から読み込んでいき、最終フィールドまで進む。
具体的に見てみよう。
1	3	5
7	9	11
13	15	17
このようなデータがあったとする。
さて問題。1行2列目の数値は?
答えは9です。
NRを利用して、ちょっと便利なコードを書こう。
データに行番号を付与するというものだ。
データは先程も利用したdata.txtを用いる。
_________________________________________________
氏名	性別	出身地
伊藤	男	東京
坂本	女	大阪
田中	女	東京
高橋	男	東京
山本	男 	大阪
_________________________________________________
>awk "{print NR &0}" data.txt
これを打ち込むと出力結果は次のようになる。
_________________________________________________
1	氏名	性別	出身地
2	伊藤	男	東京
3	坂本	女	大阪
4	田中	女	東京
5	高橋	男	東京
6	山本	男 	大阪
_________________________________________________
データを抽出する際、抽出後データは元データの何行目か知りたいことはよくある。
そういう時、実に便利。
これらの組み込み変数はよく利用される。
だがこれらの本当の威力は次に紹介するEND節などと組み合わせて用いるとよりはっきりとするだろう。
【awkを利用した計算】
次のような勤務表データ、kinmu.txtがあったとする。
_________________________________________________
氏名	時間	時給
伊藤	32	970
坂本	25	780
田中	18	750
高橋	50	1200
山本	65 	1350
_________________________________________________
ここで各人のバイト代を求めたいとする。
「時間×時給=バイト代」をコードで表現すると次のようになる。
「バイト代=時間*時給」
×の記号は*(また、割り算は÷ではなく/を用いる。+-はそのまま)、そして代入は右から左へと行われる。
これをawkで実装するには次のようにすればよい。
>awk "{print $1,$2*$3}" kinmu.txt
_________________________________________________
氏名 0
伊藤 31040
坂本 19500
田中 13500
高橋 60000
山本 87750
_________________________________________________
このように簡単に計算が可能である。
慣れればかなり複雑な表計算も可能となる。
【BEGIN,END節】
BEGIN,ENDブロックは共々1度だけ実行される。
文字通り、BEGINは本文を実行する前、ENDは本文実行後である。
これを利用すると、例えば質問項目が20あるアンケートの回答に
18しか列がない、つまり回答に抜けが含まれている行を簡単に割り出すことが出来る。
データの総行数、総列数を求める、最も列が少ない行・多い行を求める、
合計値を求める、平均値を求める、などなど応用は多岐にわたる。
では先程の勤務表データから、各人のバイト代を算出した上、平均給与を求めてみると言うプログラムを書く。
>awk "{Total+=$2*$3} END{print Total/(NR-1)}" kinmu.txt
結果は43258となり、確かに平均値が求められている。
まず、{Total+=$2*$3}部分は、$2*$3をTotalという変数に代入するという意味である。
awkの基本として各行について処理を行うので、結果、給料の合計値が求められるわけである。
END{print Total/(NR-1)}の部分は給料合計を行数-1で割っている。
なぜ-1しているかというと、データの一行目は0なのでそれを省くためだ。
その際気をつけなければならないのがTotal/NR-1ではいけないということ。
これは(Total/NR)-1と判断されてしまう。awkに伝わりやすいようにTotal/(NR-1)と打ち込もう。
さて、最後に実用的なプログラムを書いてみよう。これは意外によく使う。
アンケートデータを解析する際悩まされるのが記入漏れの抽出である。
どの回答者のデータに抜けがあるかを簡単に抜き出せるのが次のプログラムだ。
>awk "NR==1 {i=NF} NFawk "NR==1 {i=NF} NF==i {print}" kinmu.txt >newdata.txt
NF==iの部分は、今読み込んでいる行の列数がiと一致することを示す。
これを実行すると、列数が規定の数を満たした場合のみnewdata.txtに出力される。
さぁ、これでアンケートデータとにらめっこして抜けを探す作業から免れた。
もちろん、Excelなどを用いて同じ作業をすることは十二分に可能だ。
だが、どちらの方が早いか、簡単か、便利か?
awkに習熟すれば回帰分析などのやや複雑な統計処理も簡単に実行できるようになる。
研究のみならず、日常の事務作業も随分楽になるだろう。
この、古くさくて貧弱で低機能なawkという言語を愛する馬鹿な一行野郎どもに幸あれ。
【ついでにコマンドプロンプト簡易利用ガイド】
cmd上の基本操作
Home		カーソルを行の左端に移動
End		カーソルを行に右端に移動
Ctrl+Home	カーソルより左側の文字を全て削除
Ctrl+End	カーソルより右側の文字を全て削除
Insert		挿入モードと上書きモードを切り替える
、F5		前に入力したコマンドを呼び出す
F7		コマンドの履歴を呼び出す。、キーで選択し、Enterで実行
A~Z+F8		コマンド履歴を呼び出し、入力した文字列に一致するコマンドを検索する
Tab		ファイル名やディレクトリ名を補完する
Alt+半角/全角	日本語入力モード
cmd主要コマンド	
Cd
ディレクトリ移動
Dir
カレントディレクトリ内のファイル・ディレクトリ一覧を表示
Dir filename /S
指定したファイルを検索。cvsファイルだけを検索したい場合は *.cvsとワイルドカードを使う
Fc filename1 filename2
テキストファイルの内容を比較する。異なる行とその上下の行を表示する。
つまり、比較したファイルの5行目だけが異なる場合4,6行目も出力される。
Makecab	filename
指定したファイルをCOMPRESS形式で圧縮する。
通常、圧縮されたファイルはカレントディレクトリに保存される。
保存先を任意のdirectryに変更したい場合は
makecab /L directryname filename
と入力する。
Expand filename new_filename
指定したファイルを新しいファイル名で展開(解凍)する。
-Rオプションを使い、元のファイル名のまま展開することも可能。
Find "検索文字列" filename
ファイルから指定した文字列を含む行を出力する。
ワイルドカードを用い、不特定多数のファイルから文字列検索することも可能。
Find "検索文字列" *.txt
これを利用すれば指定した文字列を含むファイルがどれかを検索することが出来て便利。
さらに、/Nオプションを用いれば行番号も出力される。
Findstr	"検索文字列" filename
正規表現を用いてファイルから文字列を検索する。
正規表現は別途記述。
使いこなせばとてつもなく便利。
Replace filename directryname
ファイルを置き換える。
/Uで新しいファイルに置き換える。
より新しいファイルだけが置き換えられるので更新作業として利用できる。
/Aで置き換え先のディレクトリにないファイルだけを追加する。
回復コンソール(WindowsXPのみ)
Windowsが起動しない等の深刻な障害が発生したとき、復旧させるためのツール。
リカバリやクリーンインストールする前に、
以下のコマンドを駆使して出来る限りファイルを救出しよう。
Cd		ディレクトリ移動
Dir		ディレクトリ内のファイル一覧を表示
Copy		指定したファイルをコピーする
Chkdsk		ディスクエラーのチェックと修復を行う
Disable		サービス、デバイスドライバを無効にする。
これが原因で起動しないのかな?と疑いをもつサービスなどがあれば一旦無効にしてみよう
Enable		サービス、デバイスドライバを有効にする
Exit		回復コンソールを終了し再起動する

