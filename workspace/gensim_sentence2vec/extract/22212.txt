
言語[編集]
オブジェクトの扱い[編集]
いずれの言語もオブジェクト指向言語であり、その文法はC++に類似しているが、C++との互換性はない。メモリ再利用の手段として、従来の手動で解放する方法ではなくガベージコレクションを使用する。また、スレッド同期の手段を言語構文に組み込んでいる。
いずれの言語も強い参照と弱い参照の両方をもつ。Javaでは参照がガベージコレクタによって回収された時に通知を受けるリスナーを登録することができる。これはWeakHashMapの性能を考慮したものである。C#にはこれに相当する機能はなく、ファイナライザ(Javaにも存在する)を使用する方法しかない。その一方、C#は指定したオブジェクトのファイナライザ呼び出しをプログラマが抑止することができる。「世代」の概念をもつガベージコレクション(Javaと.NETいずれにも当てはまる)においてファイナライザの呼び出しは性能に大きな影響を与えるため、またファイナライザはプログラマがオブジェクトを破棄しなかった場合のフェイルセーフであるため、これは非常に有効である。ファイナライザをもつオブジェクトは通常余分な世代が与えられ、回収されるまでに長くかかる。
C#は、一部の言語設計者から危険であるとされるポインタを使用した演算が制限つきながら利用できる。C#はポインタを使用するコードブロックあるいはメソッドをunsafeキーワードで修飾することでこの懸念に対応している。これにより、このコードを利用する者はそれが他の部分に比べて危険であるということを知ることができる。また、このようなコードをコンパイルする際にはコンパイラに対して/unsafeスイッチを指定する必要がある。一般に、unsafeコードが使われるのはアンマネージなAPIやシステムコール(これは本来「危険」なものである)との相互運用が必要な時、あるいは性能の向上が必要な時のみである。
データ型[編集]
いずれの言語もプリミティブ型(C#では値型と呼ばれる)の概念をもつ。C#はそのような型をJavaよりも多くもち、符号つき整数だけでなく符号なし整数もサポートされる。さらに、10の累乗の形で指数部を表す浮動小数点数であるdecimal型をサポートする。Javaには符号なし整数が存在しない。文字列はいずれの言語においても不変 (immutable)なオブジェクトとして扱われるが、特殊な構築方法として文字列リテラルを利用することができる。C#ではエスケープ文字を処理しないような文字列リテラル(verbatim文字列)をサポートする。
いずれの言語もプリミティブ型とオブジェクト型の間で変換するためにボックス化とボックス化解除が可能である。これによってプリミティブ型はオブジェクト型のサブセットとみなすことができる。C#においては、これによってプリミティブ型で多態性を利用することが可能である(例えばobject型のToString()メソッドをオーバーライドすることができる)。Javaではこのような用途のためにプリミティブ型をラップするクラスが別に定義される。すなわち、42.ToString()のようなインスタンス呼び出しでなくInteger.toString(42)のような静的呼び出しが必要になる。もう一つの相違点として、Javaではジェネリックスにおいてこのような型を多用するため、暗黙的なボックス化解除が可能になっている(C#ではキャストが必要である)。このような変換はnullポインタ例外を発生する可能性があるが、Javaではそれがコード上で明白ではない。
C#では、structキーワードによって値型を定義することができる。値型にはフィールドやメソッド、プロパティなどの任意のメンバを定義できる。プログラマの視点からは、これは軽量なクラスとみなせる。値型は通常のクラスと異なり、そして組み込みのプリミティブ型と同様、ヒープ領域ではなくスタックに置かれる。また、クラスの一部になる(フィールドとして、あるいはボックス化された状態で)ことも、配列の要素になることも可能である。通常のクラスではメモリ上で間接的に参照される必要があるが、これらはその必要がない。しかし、値型には多数の制限がある。値型は通常nullの値をとることができず、また初期化なしで配列の要素となる必要があることから、常に暗黙のデフォルトコンストラクタが定義される(これはメモリ領域をゼロで初期化する)。プログラマは一つ以上の引数をもつコンストラクタしか定義することができない。また、これは値型は仮想メソッドテーブルを持たないということを意味し、そのため継承関係をもつことができない(インタフェースの実装は可能である)。なお、.NET Framework 2.0でnull許容型が導入され、C#でも擬似的にnull値を取り得る値型が利用可能となった。
C#の列挙型は組み込みの整数型をベースとしている。ベースとなる整数型のどの値も列挙型の値として有効になる(明示的なキャストは必要であるが)。このため、ビットフラグにおいてビットごとのOR演算で列挙型の値を組み合わせることが可能である。一方、Javaの列挙型はオブジェクトである。Javaの列挙型として有効な値は定義においてリストされたものだけである。列挙型の値を組み合わせるためには列挙セットクラスを使用する必要がある。Javaの列挙型では、値によって異なるメソッドの実装が可能である。JavaとC#はいずれも列挙型を文字列に変換することができるが、Javaにおいてはこの変換をカスタマイズすることができる。
配列[編集]
配列やコレクション型は、イテレータによるforeach構文をはじめ、いずれの言語の構文においても重視されている。いずれの言語も配列に相当するArrayクラスをもつ。C#は真の多次元配列をサポートするが、Javaでは「配列の配列」として表現する必要がある(これはC#ではジャグ配列と呼ばれる)。ジャグ配列では参照の展開が次元の分だけ必要なのに対し、多次元配列ではそれが一回で済むため、これは性能向上に寄与する。またジャグ配列では各次元ごとに初期化のために明示的なループが必要なのに対し、多次元配列では一回のnew演算子の使用で領域が確保できる点も性能に影響する。
内部クラス[編集]
いずれの言語も内部クラス(クラスの内部に定義されたクラス)を定義できる。Javaでは、内部クラスからは外側のクラスの静的メンバ、非静的メンバいずれにもアクセスすることができる(内部クラスがstaticとして定義されていた場合は静的メンバのみ)。メソッドの内部にローカルクラスを定義することもでき、ローカル変数には読み込みアクセスのみすることができる。また、匿名ローカルクラスによってそのクラスのメソッドをオーバーライドしたクラスのインスタンスを作成することができる。
C#では、外部クラスの非静的メンバにアクセスするためには外部クラスインスタンスへの明示的な参照が必要になる。ローカルクラスは存在せず、その代わり、ローカル変数やメンバにアクセスすることのできる匿名デリゲートがサポートされる。
ジェネリクス[編集]
Javaではジェネリクスは型消去 (type erasure)によって実装されている。これによってジェネリック型についての情報は実行時には失われ、リフレクションを通してのみ取得できるようになる。.NET 2.0では、ジェネリック型についての情報は完全に保存される。Javaはプリミティブ型に対するジェネリック型は定義できないが、C#では参照型・値型(プリミティブ型を含む)いずれに対してもジェネリック型を定義できる。Javaはその代わりにボックス化した型を使用することができる(List<int>の代わりにList<Integer>など)が、全ての値をヒープに確保し直す必要があるため、パフォーマンスコストが高い。JavaとC#はいずれも、参照型に特殊化されたジェネリック型は、型によらず共通のコードが実行される。しかし、C#において値型に特殊化された場合、CLRは型に最適化されたコードを動的に生成する。.NETにおいては、ジェネリック型に対する型安全性はコンパイル時にチェックされ、CLRにロードされる時に強制される。Javaにおいてはコンパイル時に部分的にチェックされるのみであり、Java VMは実行時にジェネリック型に関する情報を持たないため、キャスト操作を行う必要がある。
表記法と特殊な仕様[編集]
Javaはあるクラスの静的メソッド・静的フィールドを短い名前で使用するためにstatic import構文をもつ(別のクラスのfoo()メソッドを静的インポートしてfoo(bar)と記述できる)。C#は静的クラス(Javaの静的内部クラスとは異なる)の構文をもち、これによってクラスは静的メソッドのみを持つことができるようになる。C# 3.0から、型に静的にメソッドを追加するための拡張メソッドが導入されている(fooについての処理を行うbar()拡張メソッドを追加し、foo.bar()と記述できる)。この機能は、しばしばオブジェクト指向におけるカプセル化の概念を破壊するものとして誤解されるが、ターゲットとなるクラスのプライベートメンバにアクセスすることは出来ないため、そのような事は無い。
キーワード[編集]
キーワード
仕様・使用例
C SharpとJavaの比較 - Wikipedia
