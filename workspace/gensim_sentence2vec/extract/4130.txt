14.1.1 論理構造のチューニング
問合せの最適化は、問合せ実行におけるあまり有効ではない索引の使用を避けるために役立ちますが、SQLエンジンは、表に対して定義されている索引が使用されているかどうかにかかわらず、継続的にすべての索引をメンテナンスします。書込み集中型アプリケーションでは、索引のメンテナンスにCPUとI/Oリソースが大量に必要となる場合があります。したがって、必要がなければ索引を作成しないでください。
最適なパフォーマンスを保つために、アプリケーションで使用していない索引を削除してください。使用されていない索引は、典型的なワークロードがかかる期間にALTER INDEX MONITORING USAGEファンクションを使用することで検出できます。この監視機能は、索引が使用されたかどうかを記録します。使用されていない索引が検出された場合は、削除してください。サンプリングした負荷以外の負荷で使用されている索引を削除しないように、典型的な負荷を監視していることを確認してください。
また、アプリケーション内では、文の実行計画の調査ですぐには明らかにならない索引の使用方法もあります。その例が、共有ロックが子表上に取り出されないようにする親表上の外部キー索引です。
関連項目:
ALTER INDEX MONITORING USAGE文の詳細は、『Oracle Database SQL言語リファレンス』を参照してください。
外部キーの詳細は、『Oracle Databaseアドバンスト・アプリケーション開発者ガイド』を参照してください。
また、新しい索引を作成してSQL文をチューニングするかどうかを決める場合、オプティマイザがアプリケーションの実行時にこれらの索引を使用するかどうかを判断するために、EXPLAIN PLAN文を使用することもできます。新しい索引を作成して現在解析中の文をチューニングする場合は、Oracleはその文を無効にします。
その文が次に解析されるとき、オプティマイザは、新しい索引を使用する可能性のある新しい実行計画を自動的に選択します。新しい索引をリモート・データベース上に作成して分散型の文をチューニングする場合は、その文が次に解析されるとき、オプティマイザがこれらの索引について検討します。
索引を作成してある文をチューニングした場合、他の文の実行計画に対するオプティマイザの選択に影響を及ぼす場合があるので注意してください。たとえば、ある文によって使用される索引を作成した場合、オプティマイザは、アプリケーションの他の文に対しても、その索引の使用を選択する場合があります。このため、最初にチューニング対象と判断した文をチューニングした後、アプリケーションのパフォーマンスおよび実行計画を再検査し、SQLトレース機能を利用します。
14.1.2 SQLアクセス・アドバイザを使用した索引のチューニング
SQLアクセス・アドバイザは、どの索引が必要であるかを手動で判別する作業に対する代替機能です。このアドバイザをOracle Enterprise Managerから起動するか、DBMS_ADVISORパッケージAPIを介して実行すると、索引セットを推奨します。SQLアクセス・アドバイザはワークロードの使用を推奨するか、または指定のスキーマに関する仮定的なワークロードを生成します。SQLキャッシュの現在の内容、ユーザー定義のSQL文セットまたはSQLチューニング・セットなど、様々なワークロード・ソースが使用可能です。SQLアクセス・アドバイザにより指定のワークロードに関して推奨事項のセットを生成され、その中から実装する索引を選択できます。実装スクリプトが用意されており、手動で実行するか、またはOracle Enterprise Managerを介して自動的に実行できます。SQLアクセス・アドバイザの詳細は、「SQLアクセス・アドバイザの概要」を参照してください。
14.1.3 索引を付ける列と式の選択
キーは、索引を付ける列または式です。次のガイドラインに従って、索引を付けるキーを選択します。
WHERE句で頻繁に使用されるキーに索引を付けることを検討します。
SQL文で表を結合するために頻繁に使用されるキーに索引を付けることを検討します。結合の最適化の詳細は、「パフォーマンスを考慮したハッシュ・クラスタの使用方法」を参照してください。
高度な選択性の索引キーを選択します。索引の選択性は、索引を付けるキーについて同じ値を持つ行の表内での割合です。同じ値を持つ行がほとんどない場合、索引の選択性は最適です。
選択性の低い列への索引付けは、データ配分が偏っているために、1つまたは2つの値がその他の値よりはるかに使用頻度が低い場合に便利です。
個別値をほとんど持たないキーまたは式には標準のBツリー索引は使用しません。通常そのようなキーや式は選択性が劣っているので、頻繁に選択されるキー値がその他のキー値に比べて少ない場合を除くと、パフォーマンスは最適化されません。このような場合には、ビットマップ索引を使用すると効果的です。ただし、同時実行性の高いOLTPアプリケーションのように、索引が頻繁に変更される場合には向きません。
頻繁に修正される列には索引を付けません。索引付きの列を修正するUPDATE文および索引付きの表を修正するINSERT文とDELETE文では、索引がない場合よりも、処理に長い時間が必要となります。このようなSQL文は、表のデータのみでなく、索引のデータも修正する必要があります。また、取消しと再実行も追加的に生成されます。
ファンクションや演算子を含むWHERE句のみに指定されるキーには索引を付けません。索引付きのキーにMINやMAX以外のファンクションや演算子を使用するWHERE句は、ファンクション索引を除く索引を使用するアクセス・パスを選択しません。
同時実行の数多くのINSERT文およびUPDATE文、DELETE文が親表と子表をアクセスする場合、参照整合性制約の外部キーに索引を付けることを検討します。このような索引を使用すると、子表を共有ロックせずに親表でUPDATEおよびDELETEを実行できます。
索引を付けるキーを選択するとき、問合せのパフォーマンス向上が、INSERT、UPDATE、DELETEのパフォーマンス損失および索引を格納するために必要となる領域の使用に見合う価値があるかどうか検討してください。SQL文の処理時間を索引の有無によって実際に比較することをお薦めします。SQLトレース機能で処理時間を測定できます。
索引およびクラスタの使用方法
