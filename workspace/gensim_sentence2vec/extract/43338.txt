bash の解説なんて、ネット上には結構あったりするのだが、これをわざわざ公開しようというのは、次の理由による。
某ソフトハウスでのUNIX講座用に書いてしまったから。
ネット上にある bash 解説だと、表面的な構文解説程度であり、きっちりスクリプト言語として使い倒すレベルの解説はあまりない。まあ、プログラミング言語として凝ったサンプルもやってみようじゃないの、というノリで割とディープに解説する。
アクセスを増やすための人気取り(苦笑)。
まあ、そんな不純な目的による bash 解説である。とはいえ、日常的に使い慣れている bash であっても、「え、こんな使い方があったの!?」という発見もあることであろう。苦笑しながらでも読んでくれたまえ。だから、初歩的なリダイレクションなんかは解説しないからそのつもりで。
ちなみに参考書としたのはオライリー・ジャパン刊「入門 bash 第2版」である。この本は bash 2.x 以降のあまり使い倒されてはいない新しい構文をけっこうマジに解説している。読んでいくと「え、こんなスクリプト見たことない...」というサンプルが山のように登場する。とはいえ、本文書での解説は、基本的に筆者が「見たことのある」レベルで新しい機能も説明していこう。
まず、これって常識
シェルの種類
応用:起動スクリプト
変数とその評価
引数の変数
コマンドラインの評価順
リダイレクションの補足
ヒアドキュメント
標準エラー出力の扱い
サブシェルなどとリダイレクション
if文とcase文
実行結果の取得と if 文
test コマンドによる文字列の比較とファイル属性
case 文
for文とwhile文
for文
while文とuntil文
数値計算
関数定義とシグナル
関数の作り方
シグナルのトラップ
その他の bash の機能
Cプログラムからの応用
まず、これって常識
シェルスクリプトとは、シェルによって解釈実行されるスクリプト・プログラムである。MS-DOS にもバッチファイルがあったが、UNIXのシェルの能力はそれと大きくかけ離れ、コマンドラインの便利ツールと言う域を越え、ちょっとしたプログラムを書くことも造作もない。
しかし、このシェルスクリプトが使うのは、UNIXのシェルの機能といくつかの外部プログラムの機能に過ぎない。つまり、UNIX のシェルは本格的なインタプリタであり、さまざまなシェルの内部コマンドと、それを補う実行ファイル形式のツール(よく sh-utils とか textutils と呼ばれる)を使ってさまざまな機能を実現している。
だから、基本的にはコマンドラインで実行する文をそのままファイルに保存すれば、シェルスクリプトになる。しかし、次のことをしておくと、さらに便利に使える。
実行パーミッションを立てて、PATH 環境変数によって検索されるパスに置いておけば、通常のプログラムと同様に使うことができる。「chmod 755 myscript」の要領で実行パーミッションを与えることができるのはすでに触れた。実行パーミッションを与えないのならば、「sh ./myscript」の要領で起動しなくてはならない。
さらに、シェルにはさまざまな種類がある。それを特定するには、スクリプトの最初の行に次の行を入れておく。
#!/bin/sh
こうすると、実行パーミッションが立っている場合、最初に読み込んだ行がこの形ならば、その実行コマンドをスクリプトの実行コマンドとして扱う。つまり、このスクリプトは /bin/sh によって解釈実行される。たとえば、perl で扱うスクリプトの場合には、「#!/usr/bin/perl -Leuc」などとし、「-Leuc」のようにオプション(これはEUCで書かれた2byte文字列を「正しく」扱うオプションである)を与えることもできる。
ちなみに、2バイト日本語コードを含むスクリプトを書いた時、プログラムローダが「間違えて」バイナリファイルだと認識してしまうことがある。一般論として、特に先頭行に「#!」による解釈指定がない場合、/bin/sh によるスクリプトであるとして実行されるが、日本語を含むスクリプトの場合には「#!/bin/sh」がないと誤解するのである... 2バイトコードは差別されてるな!
シェルの種類
さて、シェルにはいろいろな種類がある。これをざっと見てみよう。
bsh あるいは ash
Steve Bourne が書いたものを祖先とする古典的なシェル(Bourne SHell)である。デフォルトのシェルとしてよく扱われ、POSIX 標準でも基本的にこのシェルが標準とされている。つまり、bsh で書いておけば、大概のPOSIX環境で同じように動作する可能性が高い。しかし、古典的な bsh ではヒストリ機能・エリアスを欠くためにコマンドラインでは使いにくく、bsh 以降で採用された機能も多く欠く。だから現在それほど使われてはいないと見てよい。一応 Linux などのディストリビューションでは、ash というパッケージで SysV互換のフリーソフトの bsh が入っている。勿論、コマンドライン編集やヒストリ機能を欠いているためにログインシェルとしては大変使いにくいが、サイズは bash の1/6しなかく、やたらと軽いので使い途がないわけでもないし、互換性が重要なケースでスクリプト用に使ってみても良かろう。一応 /bin/bsh のリンク先は /bin/ash である(A SHell の略だそうだ)。
「エキスパートCプログラミング」(邦訳:アスキー、名著)で van der Linden が Bourne オリジナルの sh をハックした時の裏話を書いていたりするが、malloc(3) も使わずに独自のメモリ管理ストラテジを使っていたりするようなとんでもないプログラムだったようだ.... あと、ちなみに作者の Bourne はもともと Algol68 のプログラマだったようで、「if 〜 fi」とか「case 〜 esac」のように、キーワードのスペルを逆にして適用範囲を示すのは、Algol68 の仕様から来ている。更にオリジナルのソースのトンデモ度は、「マクロを使って Alogol 風制御構造をCの上で実現していた」という程に高いものだそうだ(フツーこんなことを解説しているネット文書はないよな)。
bash
bsh の代わりに使われているのが Bourne Again SHell である。GNUプロジェクトで書かれたフリーソフトであり、古典的 bsh に対してほぼ完全な上位互換にある。というわけで現在では単に「bsh」と呼んだときでさえも、普通にこの「bash」が使われていることが多く、Linux などのフリーUNIXでは単純に /bin/sh が /bin/bash にシンボリックリンクされている。このテキストでは、bsh との互換性を保つ範囲で、この bash をベースに解説をしていく。ちなみに bash 2.0 では大変多くの機能が追加されているが、まだそれほど使われているわけではないので、これらにはそんなに触れない(一応 /bin/bash2 でインストールされるから、開発元でも区別してるわけだし...)。
csh
BSD-UNIX で開発されたシェル(Bill Joy作)である。C言語文法に近い構文を採用しており、bsh 系との間の互換性はほとんどない。コマンドライン用のシェルとして使う人も多いが、セキュリティとリダイレクションにやや問題がないわけではなく、シェルスクリプト言語としてはほとんど使われない。現在普通に使われるのは、やはりフリーソフトの「tcsh」が多い。筆者はシェルスクリプトとして csh で書きたがるプログラマは変態だと思う(たまにいる...)
ksh
ベル研の David Korn によって、bsh, csh, tcsh などのフィーチャーをいろいろと採用して新たに作り直された商用のシェル(Korn SHell)である。それほど多くのユーザは現在ではいないようであるが、当初は先進的なシェルとして評価を集めた。現在 pdksh というパブリックドメイン版の ksh が各種フリーUNIXのディストリビューションに入っている。
zsh
比較的最近使われるようになったシェルである。ベースは ksh だが、結構無節操に bash や csh の機能を採り入れている。for(foreach) 構文だって、bsh 風でもcsh 風でもどっちでも動いたりする! プログラマブルな補完機能や再帰的グロビングなど、親切すぎて使うのが恐いような機能が多い。ネームングは「Z=究極の」シェルだそうだ。
/sbin/sash
これは特殊用途である。何か障害が起きたときに使うために設計されている。だから外部コマンドが起動できないケースに対応するため、組み込みコマンドとして「-ls,-cp,-mkdir,-mount,-sync,-dd」といった最低限必要なコマンド相当のものが用意されている。ダイナミックライブラリは一切リンクせず、すべてスタティックにリンクされているあたりは当然の配慮である。だから /sbin にあるわけだ。ただし、コマンドライン編集などは当然ないし、プログラミング機能はかなり欠いている。
そりゃ、ログインシェルとして /usr/bin/tclsh を使う人(Tcl/Tkインタプリタ)だっていないとは言えないだろうけど、物事には限度と慣習があることは事実だ。まあ、シェルくらい大勢に合わせて bash を使っても「順応主義者!」とは非難されないと思うよ。
応用:起動スクリプト
シェルスクリプトは伝統的に UNIX の起動時の初期化に大活躍をしている。つまり、起動時にカーネルが立ち上がると、さまざまなサービスを行うデーモンを起動していく。このために使われるのが、/etc/rc.d 内にあるシェルスクリプトである。Linux(RedHat系) の場合、次の手順で起動時のセットアップをしている。
まず、/etc/rc.d/rc.sysinit が実行される。これはファイルシステムをマウントし、キーボードを設定し、ネットワーク環境が使えるように準備するなど、基本的なシステムのセットアップを行う。
次に /etc/rc.d/rc を実行し、各種のサーバを起動する。現在の Linux ではこれが二段構えになっており、ランレベルに合わせて /etc/rc[0-6].d ディレクトリがある。このランレベルに応じたディレクトリの中に「S数値」「K数値」で始まるリンクが置いてある。これらはそれぞれそのデーモンの起動/停止などの処理をする /etc/rc.d/init.d 内にあるスクリプトを指している。数値はそれらの実行順を示し、「S」は開始、「K」は停止を示す。だから、/etc/rc.d/rc はランレベルに合わせて /etc/rc[0-6].d ディレクトリのファイル名を検索し、適切なデーモンを適切な順番で起動する。
最後はそのマシンのローカルな設定を記述している /etc/rc.d/rc.local を実行する。
特殊なサービスをする場合には、rc.local に記述できることはいうまでもないが、システム管理者が新しいデーモンを起動しておくことにする場合、次のようにする。
まず、実際のデーモンのプログラムを適当なディレクトリ(/usr/sbinなど)にインストールする。
起動・終了・再起動を引数によって処理するスクリプトを /etc/rc.d/init.d に置く。デーモンについて来る場合もあるし、自分で書いても問題はない。このスクリプトは「スクリプト名 start」でデーモンが開始し、「stop」でデーモンが停止し、「restart」で設定ファイルを読み直して再開する機能が実装されていれば良い。
適切なランレベル(1=single user mode, 2=not networking, 3=full multi user mode, 5=X11, 6=reboot)の /etc/rc.d/rc[0-6].d 内に、/etc/rc.d/init.d 内の起動スクリプトを指すリンクを適切な名前で張る。
だから、新しいサービスを開始する場合でも、rc スクリプトの変更を一切しなくても良いのである。また、シェルスクリプトの書き方を勉強する際には、この /etc/rc.d 内のスクリプトがどういう風に書かれているのかを読むのが一番勉強になる。皆さんも読んでやって欲しい。また、UNIXのコマンドの中には、初期設定をサボるために起動をシェルスクリプトでする応用もある。後で述べる。
変数とその評価
しかし、bsh 文法はかなり異色である。まったく新しい言語を憶えるつもりにならなければ、理解することは難しい。なぜなら、bsh は「テキスト置換マクロ言語」の部類に入る言語だからである。似たような言語としては、bsh 風に使えることを意図して設計された Tcl や、テキストフォーマッタである TeX マクロがある。また、m4 や cpp などのマクロ・プロセッサもそうである。要するに「変数には文字列が格納され、それを評価する時には他の文の中で展開される」というタイプの言語である。次の例を見てみよう。
#!/bin/sh
target=gif
${target}topnm test.gif > test.ppm
代入式「target=gif」は、シェル変数 target に「gif」という文字列をセットする。しかし、それを使う時には「$target」という風に先頭に「$」をつけてやることで、参照の意味になる。この時、その次にある文字列「topnm」と繋げて1つのシンボルにしたいわけで、空白をいれて変数名を区切るわけにはいかないので、「{ }」によって変数名の範囲を明示している。結果として3行目は「giftopnm test.gif > test.ppm」というコマンドになり、これは NetPBM の画像ファイル変換コマンドを呼び出して、GIF画像を PBM画像に変換している。
つまり、シェル言語での変数の内容は「単なる文字列」であり、それが「$」による参照の結果、その内容でコマンドライン行の中にシンボルを置換し、実際に実行すべきコマンドラインを生成する。
それゆえ、シェル言語の変数には「型」はなく、単なる文字列だけがデータ型である。そして、その置き換えによって実際に実行されるコマンドが生成されて、実行される。ちょうどC言語のマクロプロセッサと同じような雰囲気である。つまり、シェル言語は「文字面」しか見ずに、置換を行うだけの言語である。あとの評価機構は単にコマンドインタプリタとしての働きとまったく同じである。
ではこのようなシェル変数といわゆる「環境変数」とはどう違うのだろう。実体にはほとんど違いはないのである。しかし、1つだけ大いに違う点がある。それはシェル変数はサブプロセスに引き継がれないのに対し、環境変数はサブプロセス(サブシェルを含む)に引き継がれる。外部に引き継がれるようにするには、export 内部コマンドによってそれを指示してやれば良い。つまり、
MY_ENV_VAR='use at sub shell'
export MY_ENV_VAR
これだけのことである。環境変数はすべて大文字にする習慣がある。
また、シェル変数はそのシェル内部でしか有効ではないことに注意されたい。これは別スクリプトでシェル変数を定義し、その別スクリプトを実行しても、それはサブシェルで設定されることになり、一切親シェルに反映されることはない。これは困る。だから、現在の Bsh では「source」コマンドが用意されており、これは別スクリプトをあたかも include するように、現在のシェルによって別スクリプトを解釈する。
MY_ENV_VAR='parent'
source sub.sh       # sub.sh 内部で新しくセットした MY_ENV_VAR が
echo $MY_ENV_VAR    # 親シェルにも反映する
さらに bsh には変態的な変数評価がある。次のような書方である。
count=`expr ${count:-0} + 1`
これはシェル変数 count をインクリメントするのだが、最初は当然 count の内容は未定義だから空文字列である。だからこう書くと expr コマンドは困る。
% count=`expr $count + 1`
expr: syntax error
それゆえ、最初空文字の時には値を「0」とする、ということを変数評価の中に畳み込んでしまっているのが上の表現なのである。つまり、次と同様。
if [ "$count" = "" ]; then
tmp=0
else
tmp=$count
fi
count=`expr $tmp + 1`
まあ、こんな「文字列演算子」と呼ばれる機能があったりするが、使うとスクリプトが短くなるな(けど、初心者はとまどうぞ)。
引数の変数
シェルスクリプトもやはり引数を与えて起動できる。この引数は特別なシンボル「$0, $1, $2, ...」で参照できる。つまり、シェル変数「$0」にはその起動されたスクリプト名が入り、「$1」には第1引数が入る。以下同様であるが、沢山の引数を処理するに便利な「shift」コマンドがあり、あまり大きい数の引数変数は使わないことが多い(後述)。引数の個数は「$#」で取得できるし、引数の全体は「$*」で取得できる(ただし、$0は別扱い)。
あと、憶えておくと大変便利なのは、$$ という変数がそのシェルのプロセス番号を保持していることである。これは一時作業ファイルを作成するときにとっても役にたつ。一意なファイル名が欲しい時に、UNIX環境で一番一意なリソースは何か、というとそれはプロセス番号なのである。だから、今のシェルのプロセス番号を付加した作業ファイルに書き出すようにすれば、仮に複数そのスクリプトが起動したとしても、内容がごっちゃにならないわけだ! さあ、憶えたね! (わざわざ強調するのは、当然これが一番探しにくく、「あれ、シェルのプロセス番号ってどうやって取得するんだっけ?」と悩み易いものだからだよ! なんて親切なんだ....)
ちなみにクイズ。次のコマンドの実行結果はどうなるだろう?
#!/bin/sh
echo "parent=$$"
( echo "subshell=$$" )
echo `echo "backquote=$$"`
{ echo "brace=$$" }
知識のある人は、「あれ、(〜) はサブシェルの起動じゃなかったけ? だったら、サブシェルのプロセスIDでこれだけ違うんじゃないのかなあ」とか思うかも知れない。実はこれらの結果はすべて同じ(すべて親シェルのプロセスID)である。その理由は...(See Next!)
コマンドラインの評価順
この評価の順序を先にまとめておく。
1行の入力から、トークンを抜き出す。
最初のトークンが制御用の「キーワード」であるかどうかを判定し、もし1行で終らずに複数の行を前提とするフロー制御の「複合コマンド」であればその準備をする。たとえば、if 文がないのに、then, else が現われたら、ここでエラーになる。サブシェルの起動もここで扱われる。
最初のトークンがエリアスならば置換する。エリアスは「alias ll='ls -l'」というように定義しておくと、「ll」が最初のトークンに現われた時にそれを展開する。csh から採用された機構である。まあ、エリアスは難しい機能じゃないから説明は省略ね。だけど、このように評価が早いから、適当に個人用の .bashrc などにエリアスで個人コマンド定義を書いておくのだ、ということだけは記憶しておいた方がいいな。
ブレース展開をする。これの説明は省略するが、異常に賢いワイルドカード展開のようなものである。
チルダの展開をする。~/test ならば、環境変数 $HOME を見て、それを補うし、~test ならば、/home/test などに展開する。
$ で始まる変数を、その内容に展開する。［答え、変数展開の評価順は早いのだ...］
コマンド置換を行う。これはコマンドライン自体の実行に先だって、一部分だけを先に実行し、その標準出力への出力があたかも最初から書いてあったかのように扱う機構である。このコマンド置換は古典的には ` (バッククォート)で行っていたが、最近の bash では 「$()」で行う。これは入れ子にする時の対策と、読みやすさに関する配慮である。たとえば、
filesize=`cat $file | wc -c`
# あるいは
filesize=$(cat $file | wc -c)
で、filesizeシェル変数に $file で示されるファイルのサイズが入る。
$((4+5)) のような数値演算式を評価する。これは古典的にはサブプログラムの expr で評価していた。つまり、
filesize2=$(($filesize * 2))
filesize3=`expr $filesize \* 2`  # * がワイルドカード展開されるのを防ぐ 
のようにすると、数字文字を数値として扱って計算がなされる。
変数置換、コマンド置換、数値演算式の結果をコマンドラインに戻して、さらに解析を続ける
*,?,[] のワイルドカード文字を展開する。
では先頭の「コマンド」の正体はなんだろうか? 先頭キーワードは次の順で検索されて、対応する実体を探す。
function で定義されるシェルの関数
シェルの内部組み込みコマンド。たとえば、cd など。
環境変数 PATH から検索される外部コマンド
入出力リダイレクションを設定して、コマンドを実行する。
さらに「'〜'」によるクォーテーションをした時には、1から10までのステップをすべて省略する。また、「"〜"」によるクォーテーションをした時には、1〜4、9〜10のステップは実行されない。これによって、コマンドの一部を展開せずに取り扱うことができるのである。
リダイレクションの補足
こんな文書を読む人はリダイレクションなんてきっと知ってるな、だから省略。フツーにコマンドラインで使うリダイレクションはすべてシェルスクリプトで利用できる。しかし、ほぼスクリプト専用と言って良いリダイレクションもあるので、それを説明しよう。
ヒアドキュメント
まず「ヒアドキュメント」である。これは複数の行にわたる入力が必要なとき、いちいち echo 文で外部ファイルに書き出して、さらに読み込むなどという不効率なことをせずに済むために加えられたリダイレクションである。たとえば複数行の内容をメールする場合、
echo "Subject: How are you?" >tmp.$$
echo >>tmp.$$
echo "Hi! This is K. Sugiura." >>tmp.$$
echo "How are you, Mr. $user? " >>tmp.$$
echo "I am fine." >>tmp.$$
/bin/mail $user <tmp.$$
rm tmp.$$
なんて書くのは大変ダサい上に、一時ファイルの管理でトラブる可能性を完全には否定できない(昔の MS-DOS の command.com スクリプトってこんなんばっかだったけど...)。だから、こういうテキストはシェルスクリプトの中で直接管理して、直接リダイレクトできるとうれしい。これが「ヒアドキュメント(今ここにあるドキュメント.. perl なんかにもあるな)」だ。
/bin/mail $user << EOF
Subject: How are you?
Hi! This is K. Sugiura.
How are you, Mr. $user? 
I am fine.
EOF
このとき、複数行にわたる /bin/mail への入力は、EOF で最後を区切って「そこにある」。このヒアドキュメントの中でもやはり変数の置換は行われる。この変数置換を抑制するには、「/bin/mail $user << 'EOF'」のように最後を区切るシンボルをクォートしてやる。
標準エラー出力の扱い
エラー出力が標準出力と分離されているのは、UNIXのパイプライン設計の成功の大きな原因となっているが、しかしスクリプトでは、標準エラー出力を独立して扱うことを考慮してスクリプトを書かなくてはならない場合がある。たとえば、cron ジョブに指定するスクリプトの場合、スクリプトは端末とは切り離されたデーモンのコンテキストで実行されるので、標準エラー出力がメールとして配信されることにもなる。これはいかにもうっとおしいことがある。だから、シェルスクリプトでは標準出力と同時に標準エラー出力もきっちりと処理することが多い。また、「grep」のように一致するパターンがあればそれを表示して戻り値として0を返すが、一致パターンがない時には1を返すプログラムを使うとき、一致パターンの表示には関心がなく、戻り値の結果だけが必要なこともある(ホントは -quiet オプションが使えるが)。このような時に、標準出力も標準エラー出力も /dev/null に捨ててしまうことも、スクリプトではよくなされる。
たとえば次の通り。
if `grep $pat $file >/dev/null 2>/dev/null` ; then
また、標準出力と標準エラー出力を合体させてパイプに送りたい場合もある。これはエラー出力(2) を標準出力(1) へとファイルデスクリプタのレベルで合体させる指定をする。
% find / -name '*.java' 2>&1 | less
この例だとローカルマシンの上にあるすべての「*.java」ファイルを検索するが、パーミッションに関するエラーもすべて見たい(一般ユーザなので)ときにこれを使う。これは実は csh だと実に簡単なのであるが、bsh ではちょっくら複雑な書き方をするために、あまり知られているとは言えなかったりするのだ。
# csh だとこう。
% find / -name '*.java' |& less 
勿論、
% find / -name '*.java' 2| less | less
でうまくいくはずがないことは明白である(less の出力をさらに別の less で受けてしまう)。
サブシェルなどとリダイレクション
シェルスクリプトでは、ちょっとした作業をまとめてそのシェルから起動される、子シェルに実行させることができるのは周知の事実である。このようなサブシェルを使うメリットは、要するに複数のコマンドをまとめてリダイレクションする、ということにある。たとえば、次の通り。
(echo "Subject: Disk is full?"; echo; date; 
echo "現在のディスク利用状況"; df) | mail $user
「;」で複数のコマンドを連結できることなんて、わざわざ説明するまでもないな。これは要するに複数のコマンドの実行結果をまとめてパイプに送り、結果としてメールする、ということをしているのである。この時、「( )」で囲まれた部分は、子プロセスとして起動されたシェルによって実行されているわけだ。だから次のコマンドと等価であり、その略記に過ぎない(-c オプションは引数文字列を実行コマンドとして解釈する)。
/bin/sh -c 'echo "Subject: Disk is full?"; echo; date; \
echo "現在のディスク利用状況"; df' | mail $user
しかし、これは古典的な方法である(勿論だから移植性は良い)。最近の bash などでは、いちいちサブシェルを別プロセスとして起動するのは効率が悪い、という理由で、「複数コマンドをまとめてリダイレクトする」機能が実装されている。勿論、後述する関数によってまとめるのも手ではあるが、「{ }」でまとめると、サブシェルではなくそのシェルによってコマンドをまとめてリダイレクトできるのである。(ちょっとだけ注意... どうやら {の後と、} の前には空白を入れた方が無難のようである...)
{ echo "Subject: Disk is full?"; echo; date; 
echo "現在のディスク利用状況"; df } | mail $user
これを「コマンドブロック」と呼ぶ。一応 bsh でも使えるようだが、あまり見かけないなあ。また、更に凄いことには、if や for, while などの制御構文の最後の部分(要するに fi とか done など)にリダイレクションを書くことさえできる。たとえば次の通り。
while read ip host alias; do
echo "IP: $ip  host: $host  alias: $alias"
done </etc/hosts
これは /etc/hosts が3つの空白で区切られたカラムを持つので、それを分解して標準入力から読み込み(read)、シェル変数(ip, host, alias)にそれぞれセットする。そして整形出力をするわけだ。ちょっと「おいおい」というような機能である。
if文とcase文
さて、シェルスクリプトはプログラムである。ということは制御構造を持つわけであるし、制御構造には変数や関数の評価がつきものである。Cプログラムで void main() ではなくて int main() で宣言するように、と言われるのは、パイプラインでの利用だけではなくて、スクリプトから利用した時の結果(=コマンドの戻り値)を評価して、そのコマンドが成功していれば何かをし、失敗していればそのようにする判断分岐ができるからなのである。
実行結果の取得と if 文
一般にコマンドの戻り値は特殊変数「$?」で参照できる。しかし、この特殊変数を参照するよりも、if 文の中で判定することの方がよくなされる。シェル言語の if 文はかなり特殊で、文法的にも不寛容なところがあるので、正確に理解して欲しい。
if cat $file >/dev/null; then echo here; else echo absent; fi
もし、「cat $file >/dev/null」が成功(戻り値=0:ファイルがある)ならば、「echo here」が実行され、失敗(戻り値≠0:ファイルがない)ならば「echo absent」が実行されるひな型である。これはわざわざ1行で書いた。なぜなら、どこで改行を入れるのかにシェルは神経質である。「;」で示される位置は改行を入れることができる。
if cat $file >/dev/null
then echo here
else echo absent
fi
また、then の後、else の後も入れることができる。
if cat $file >/dev/null
then
echo here
else 
echo absent
fi
つまり、if, then, else, fi がコマンドラインの先頭にキーワードとしてこなければならないのである。これを原則として理解して欲しい。
test コマンドによる文字列の比較とファイル属性
また、コマンド実行の成功/失敗による if 文だけではなく、シェル変数の内容や、ファイルの属性について判断分岐をすることもできる。これには特殊な構文 [ ] を使うが、この判定は内部組み込みコマンド(同内容の外部コマンドも /usr/bin/test にある)「test」の判定と同じである。つまり、
% test "" = ""
% echo $?
0
% test "" = "s"
% echo $?
1
% [ "" = "" ]
% echo $?
0
% /usr/bin/test  "" = "s"
% echo $?
1
の関係にある。[ ] 演算子を使う場合には判定式との間に空白がなくてはならないのが落し穴である。注意されたい。だから、if 文と組み合わせると次のようになる。
if [ "$var1" = 'test' ];
then echo 'string is SAME'
else echo 'string is NOT same'
fi
このとき、変数参照をすべて "〜" で囲むのがコツである。これは変数が未定義のために展開されないと、test コマンドに対する引数が不足してしまうからである。注意されたい。
test コマンドの文字列比較には次のものがある。
表現
Super Technique 講座〜bash 超プログラム術
