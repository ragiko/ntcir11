
C言語(シーげんご)は、1972年にAT&Tベル研究所のデニス・リッチーが主体となって作ったプログラミング言語である。英語圏では単に C と呼んでおり、日本でも文書や文脈によっては同様に C と呼ぶことがある。
UNIXおよびCコンパイラの移植性を高めるために開発してきた経緯から、オペレーティングシステムカーネルおよびコンパイラ向けの低レベル記述ができることを特徴としている。
特徴[編集]
C 言語は手続き型言語であり、コンパイラ言語として設計している。C コンパイラは、自由度、実行速度、コンパイル速度などを追求したが、代わりにコンパイル後のコードの安全性を犠牲にしている。アセンブラのコードと同じことを実現できるようなコンピュータ寄りの言語仕様になっている。
アマチュアからプロのエンジニアまで、非常にプログラマ人口が多い。C 言語は正負の両面含めてコンピュータの世界に大きな影響を及ぼしているが、最大の原因はCPUを出荷するときにC言語を同梱していることと、その結果としてのプログラマの多さがある。
パソコンはもちろんのこと、組込み用マイコンから大型コンピュータまで、C 言語を使用できるハードウェアは多様である。また、仕様規格・派生言語も多い。
採用ソフトウェア分野が広い。言語が拡張可能であるため、あらゆる分野に対してある程度対応可能であり、現実的な選択肢として用いる。発祥元である UNIX の場合、大抵のことがスクリプト言語・マクロプロセッサやフィルタやそれらの組み合わせで処理できるため、うまく分野の棲み分けができていた面があった。幅広い領域への移植の結果、適切でない分野に C 言語が使われている場合もある。
低水準な記述が出来る高級言語とも、高級言語の顔をした低級言語とも言われる。また、コーディング上の自由度が非常に高い。そのため良くも悪くも何でも出来てしまう強力さは多くのプログラマの支持を集める一方で、セキュリティー脆弱性や潜んだバグによる想定外の動作、コンパイラによる最適化の難しさがあり、それゆえにコンパイル速度が遅いなどの欠点の原因ともなっている。自動車分野ではMISRA-CというC言語部分集合(subset)を定義して、C言語の弱点を補っている。
商用・非商用を問わずコンパイラや C 言語向けのエディタが豊富で開発環境が整備しやすい。
C 言語の主な特徴は以下の通りである。歴史的な経緯から BASIC や Pascal と比較することがあったが、現在ではJAVA, C++, C#などのC言語の記法を引き継ぐ言語との比較が重要である。
自由度[編集]
文の区切りを終端記号 セミコロン「;」で表し、改行文字にも空白にもトークンの区切りとしての意味しか持たせない「フリーフォーマット」という形式を採用している。
記述作法について、しばしば議論の対象となり、本も多数出版。
ALGOL の思想を受け継いで構造化に対応している。手順を入れ子構造で示して見通しの良い記述をすることができる。原理的に無条件分岐(goto)を使用する必要はなく、MISRA-Cでは当初goto文を禁止していた。goto文を使わなければ、スパゲティプログラムと呼ばれる読みにくいプログラムになりにくい。
モジュール化がファイルを単位として可能。モジュール内だけで有効な名前を使うことが出来るスコープを持っている。
プログラムを関数(戻り値つきのサブルーチン)に分離できる。関数の中では独立した変数が使用でき、データの流れがブロックごとに完結しデバッグが容易になる。また、多人数での共同開発の際にも変数名の衝突が回避できる。なお C 言語ではUNIXのようなOSを前提としたホスト環境と、UNIXのようなOSを前提としないフリースタンディング環境とがある。ホスト環境では、プログラム開始直後に実行するプログラム要素を main という名前の関数として定義する[1]。プログラム中で再帰的に main 関数を呼ぶことも可能。(C++ では不可能[2][3])フリースタンディング環境では、mainという名前でなくてもよく、引数をどのようにするかを決めることができる。なお再帰呼び出しは、スタックオーバフローの原因となるため、MISRA-Cでは禁止している。
C言語では、main関数とprintf, scanfの3つのグループの関数が引数が可変という特殊な性格の関数である。K&Rでは、この特殊な関数mainとprintfを使った例を最初に示している。C言語理解を困難にする理由の一つは、例外的な関数から教えていることによる。
オペレーティングシステムを記述する言語として設計しているため、高級言語であるがアセンブラ的な低レベルの操作ができる。ポインタ演算、ビットごとの論理演算、シフト演算などの機能を持ち、ハードウェアに密着した処理を効率よく記述できる。これはオペレーティングシステムやドライバなどを記述する上では便利であるが、注意深く利用しないと発見しにくいバグの原因となる。ライブラリ関数は、C言語規格で規定している関数と、OSが規定している関数との間の整合性、棲み分けなどが流動的である。MISRA-Cのようないくつかの制約では、C言語規格で規定している関数の妥当性について指摘し、いくつかの関数を利用しないように規定している。
配列とポインタとでは、宣言の仕方と領域確保の仕組みは異なっているが、配列アクセスそのものは、ポインタ演算および間接参照と同等である。
ポインタを配列表記でアクセスすることや、配列をポインタ表記でアクセスすることができる糖衣構文がある。
MISRA-Cでは、応用ソフトを記述することが目的であるため、ポインタの利用を禁止している。
ソースコードの記述に使う文字集合はANSI-C:1989(ISO/IEC 9899:1990)では ASCII を標準としている。他のISO 646でも書けるように、3文字利用したトライグラフと呼ばれる表記法も存在する。その後, ISO/IEC 9899:1995 AMDなどで多バイト対応の拡張を規定している。さらに、その後トライグラフは複数のコードを利用したシステムでしか利用がないため、より分かり易い2文字によるダイグラフを規定している。
アセンブラとのインターフェース[編集]
多くの処理系がインラインアセンブラを搭載しているほか、アセンブラで出力したオブジェクトとのリンクが容易になっている。これにより速度が要求される部分だけをアセンブリ言語で記述するということが容易に行えることが多い。アセンブラとのインターフェースは#pragma asmなどを用いて局所化を図る努力はあるが、コンパイラごとに定義があり、CPU が同一であっても移植性が低い場合がある。
コンパイラ仕様[編集]
コンパイラの処理が1パスで済む仕様になっている。ANSI-C:1989では宣言のない変数はintを想定することになっていたが、現在では変数はその使用より前に宣言する必要がある。関数の宣言がないと、戻り値や引数をint型とみなす仕様は、プログラミングの視点で好ましくない。後継言語では記述によって先読みが必要になりうる。
マクロ記述やコンパイル条件の指定などが出来る前処理指令が標準化されており、その解釈をするプリプロセッサを持っている。その名の通りコンパイル処理の前に自動的に実行される。コンパイラの機能として、プリプロセッサを通しただけの段階のソースコードを出力可能になっている場合、結果を確認することができる。
処理系の簡素化[編集]
配列参照時の自動的な添字のチェックをしない
これを要因とする代表的なバグがバッファオーバーフロー(固定長のバッファをはみだして上書きが行われてしまう)である。標準ライブラリにはバッファオーバーフローを考慮していない関数があり、かつ多用されがちなため、しばしば脆弱性の原因となる。また、プログラムにより制御する事で可変長配列を可能にしている。
文字列を格納するための特別な型が存在しない
文字列にはchar型の配列を利用する。言語仕様上に特別な扱いはないが、ヌル文字(\0)を終端とする文字列表現を使い、その操作をする標準ライブラリ関数がある。これは実質的にメモリ領域のポインタアクセスそのもので、バッファオーバーランの元凶の1つとなっている。後継言語では文字列処理を特に強化している場合が多い。
自動変数の自動的な初期化をしない
自動変数(静的でないローカル変数)は変数の中でも最も頻繁に用いられる。初期化されていない変数を参照した場合、値は不定となるが、不定な値へのアクセスは未定義の動作(英語版)であるので、コンパイラ最適化の過程で想定しない形に改変することもある[4]。変数宣言・初期化の仕様による制限から、変数宣言の時点で初期化せず後で代入することで初期化に代えることが日常的で、誤って不定の値の変数を読み出すバグを作り込みやすい。なお自動変数の自動とは変数の領域の確保と開放が自動であるという意味であり、自動的に初期化されるという意味ではない。
その他[編集]
文字の大文字・小文字を区別する。
入出力を含め、ほとんどの機能を C 言語自身で書かかれたライブラリによって提供する。このことは、C 言語の機種依存性が低く、入出力関係ライブラリをのぞいた部分は移植性(ポータビリティ)が高いことを意味する[要出典]。さまざまな機種がある UNIX の世界で C 言語が普及した理由のひとつである。
プログラムの実行に必要とするハードウェア資源が、アセンブラよりは多いが他の高級言語より少なくてすむため、現在さまざまな電化製品などの組み込みシステムでも使用している。
組込み向けの場合は、プログラミング言語として、アセンブラ以外では、C 言語、C++ 言語しか用意していないことがある。他の言語処理系は、その処理系にC言語で書かれたものがあれば、コンパイルすることにより生成できるが、メモリ制約などで動作しないことがある。
コード例[編集]
Hello world プログラム
C 言語の Hello world プログラムには、ホスト環境を前提とするか、フリースタンディング環境を前提とするかで、方向性が異なる。入門書によって趣が異なるいくらかの方向性が存在する。ホスト環境を前提とする場合には、入出力の利用により、動作をすぐに確かめることができる。標準Cライブラリ (stdio.h)のprintf関数を利用したものを例示する場合、以下のようなものがある。
歴史[編集]
誕生[編集]
C 言語は、AT&T ベル研究所のケン・トンプソンが開発したB言語を改良することにより誕生した(#外部リンクの「The Development of the C Language」参照)。
1973年、トンプソンとUNIXの開発を行っていたデニス・リッチーは B 言語を改良し、実行可能な機械語を直接生成する C 言語のコンパイラを開発した。UNIX は大部分を C 言語によって書き換え、C 言語のコンパイラ自体も移植性の高い実装の Portable C Compiler に置き換わったこともあり、UNIX上のプログラムはその後にC 言語を広く利用するようになった。
UNIX 環境と C 言語[編集]
アセンブラとの親和性が高いためにハードウェアに密着したコーディングがやりやすかったこと、言語仕様が小さいためコンパイラの開発が楽だったこと、小さな資源で動く実行プログラムを作りやすかったこと、UNIX環境での実績があり、後述の K&R といった解説文書が存在していたことなど、さまざまな要因から C 言語は業務開発や情報処理研究での利用者を増やしていった。特にメーカ間でオペレーティングシステムやCPUなどのアーキテクチャが違う UNIX 環境では再移植の必要性がしばしば生じて、プログラムを C 言語で書いてソースレベル互換[5]を確保することが標準となった。
パソコンと C 言語[編集]
1980年代に普及し始めたパーソナルコンピュータでは当初 8 ビット CPU で ROM-BASIC を搭載していたものも多く BASIC が普及していたが、80年代後半以降 16ビット CPU を採用しメモリも増えた(ROM-BASIC 非搭載の)パソコンが主流になりだすと2万円前後の安価なコンパイラが存在したこともあり、ユーザーが急増した。8 ビットや 8086 系のパソコンへの移植は、ポインタなどに制限や拡張を加えることで解決していた。
現在の C 言語[編集]
1990年代中盤以降は、最初に学ぶプログラミング言語としても主流となった。GUI環境の普及とオブジェクト指向の普及により Java、Objective-C、C++、PHP、Visual Basic、などの言語の利用者も増加したため、広く利用されるプログラミング言語の数は増える傾向にある。現在でも JAVA, C#, C++などC言語の後続言語を含めて、C 言語は比較的移植性に優れた言語であり、業務用開発やフリーソフトウェア開発、C++ などの実装が困難な組み込みなどの小規模のシステムで、幅広く利用されている。
C 言語の規格[編集]
K&R[編集]
1978年に出版された、リッチーとカーニハンの共著である「The C Programming Language」[6]は、その後標準化がなされるまで実質的な C 言語の標準として使用された。しかし、この本の記述にはいくつか曖昧な部分が存在していた。そのため、C 言語が普及するに従い、互換性のない処理系が数多く誕生することとなった。
C89/C90[編集]
そこで、ISOとANSI は協同で C 言語の規格の標準化を進め、1989年12月に ANSI が ANSI X3.159-1989, American National Standard for Information Systems -Programming Language-C を、1990年12月に ISO が INTERNATIONAL STANDARD ISO/IEC 9899 : 1990(E) Programming Languages-C を発行した。ISO 規格のほうが章立てが追加されており、その後 ANSI も ISO 規格にならって章立てを追加した。それぞれ C89(ANSI C89)及び ISO/IEC C90 という通称で呼ばれることがある。
日本では、これを翻訳したものが日本工業規格『JIS X3010-1993 プログラム言語C』として、1993年10月に制定された。
最大の特徴は、C++ と同様の関数プロトタイプ[7]を導入して引数の型チェックを強化したことと、void や enum などの新しい型を導入したことである。一方、処理系に依存するとするに留めた部分も幾つかある(int 型のビット幅、char 型の符号、ビットフィールドのエンディアン、シフト演算の挙動、構造体などへのパディング、等)。
また、型の大きさは厳密に決められてはおらず、バイト数は sizeof 演算子で取得し、最大最小値は limits.h で参照することとされている。もっとも、多くの処理系では char 型は 8 ビット、short 型は16ビットである。ただし、int や long は環境によってまちまちである。また API などの呼び出しには、ヘッダで BYTE や WORD などと typedef で定義した型を使用して回避するのが一般的になっている。char 型以外で符号を明示しない場合は signed (符号付き)になる。
規格上には、BCPL・C++タイプの一行コメント(「//…」)は無いが、オプションでサポートした処理系も多く、gcc や Clang は GNU 拡張 -std=gnu89 でサポートしている。
GNU C コンパイラ や Clang では、-std=c89 (または-ansiもしくは-std=c90)をつけることにより、GNU 拡張を使わない C89 規格に準拠したコンパイルを行うことができる[8]。加えて、-pedantic をつければ診断結果が出る。商用のコンパイラではWatcom Cコンパイラが規格適合の比率が高いと言われていた。
C89には、下記の追加の改訂が行われた。
ISO/IEC 9899/COR1:1994
ISO/IEC 9899/AMD1:1995 - 主として英語圏での利用を想定して制定されたC89に対して、主に国際化のためワイド文字版ライブラリを追加した Amendment1 が1995年に発行された。
ISO/IEC 9899/COR2:1996
C99[編集]
1999年12月1日には、ISO で規格の改定が行われ、C++ の機能のいくつかを取り込むことを含めた機能拡張がなされ ISO/IEC 9899:1999(E) Programming Language--C (Second Edition) が制定された。この版の C 言語の規格を、通称としてC99と呼ぶ。Intel C++ Compiler は C99 に完全準拠していると公称している。GNU C コンパイラ(gcc)は C99 にほとんど対応しているが一部未対応部分も残っている[9]。
日本では、日本工業規格 JIS X 3010:2003「プログラム言語C」がある。
主な追加機能:
変数宣言がブロックの先頭でなくても良くなった。
ブール代数を扱うための _Bool 型が予約語に追加され、標準ライブラリーとして stdbool.h が追加された。
複素数を扱うための _Complex 型や _Imaginary 型が予約語に追加され、標準ライブラリーとして complex.h が追加された。
64 ビット整数値を保持できる long long int 型の追加。
// による1行コメント。
インライン関数(inline キーワード)。
可変長配列(alloca 関数の代替)[10]。
C99は下記の改訂が行われた。
ISO/IEC 9899:1999 Cor. 1:2001(E)
ISO/IEC 9899:1999 Cor. 2:2004(E)
ISO/IEC 9899:1999 Cor. 3:2007(E)
C11[編集]
2011年12月8日に改定されたISO/IEC 9899:2011(通称C11)が現在の最新規格である。gcc や Clang などが部分的に対応している。改定による変更・追加・削除機能の一部を以下に記述する。
C11 は Unicode文字列(UTF-32、UTF-16、UTF-8 の各符号化方式)に標準で対応している。そのほか、type-generic 式、C++ と同様の無名構造体・無名共用体、排他的アクセスによるファイルオープン方法、quick_exitなどのいくつかの標準関数などを追加した。
また、_Noreturn 関数指示子を追加した。_Noreturnは従来各処理系毎に独自に追加していた(たとえば gcc では __attribute__((__noreturn__)))ものを共通化したもので、「呼び出し元に戻ることがない」という特殊な関数についてその特性を示すためにある。「return 文を持たない関数」と誤解する者がいるようだが[要出典]、規格では return 文を持たなくとも、関数の最後の文の実行が終われば制御は呼び出し元に戻る。この指示が意味するものは、当該の関数、ないしその内部から呼び出している関数の実行中に、必ず _exit や execve を実行したり、例外などで終了する、あるいは、longjmp による大域ジャンプで抜け出す[11]、継続渡しスタイル変換されたコードである、などのために、絶対に制御が呼び出し元に戻らない、という関数を指示するためにある。そのような関数は、スタックに戻りアドレスを積む通常の呼び出しではなく、スタックを消費しないジャンプによって実行できる。
アラインメント機能、_Atomic 型や C 言語ネイティブの原始的なスレッド機能などを省略可能な機能として規格に組み込んだ。また、C99 では規格上必須要件とされていた機能のうち、複素数型と可変長配列を省略可能なものに変更した。これらの省略可能な機能は C11 規格合致の必須要件ではないので、仮に完全に規格合致の処理系であっても、対応していないかもしれない。C11 規格では、省略可能な機能のうちコンパイラがどれを提供しているかを判別するために利用できる、テスト用のマクロを用意している。
gets 関数は廃止。
主な C 言語処理系[編集]
現在は C 言語と C++ で兼用となっている処理系がgcc, clang, Visual C++, C++Builderなど利用者の多い処理系で多い。
Linux、Windows、UNIX 用[編集]
C++ Builder
Windows 用の x86 用 C 言語・C++ のコンパイラ。RAD。前身は DOS、Windows 用の Borland C/C++。さらに前身として Turbo C/C++ がある。
clang
LLVM をバックエンドとして用いるオープンソースの C 言語・C++・Objective-C コンパイラ。多数の CPU に対応。
Digital Mars C/C++
Windows・MS-DOS・DOSエクステンダを対象とする x86 用の C 言語・C++ コンパイラ。無料版もある。ウォルター・ブライト作で Datalight C、Zorland C、Zortech C/C++、Symantec C/C++ と変遷している。
GNUコンパイラコレクション (GCC)
C・C++ 以外の言語もサポートし、多数の CPU やオペレーティングシステムに対応、組み込み向けも含む多様な開発に広く使われるオープンソースのコンパイラ。
Intel C++ Compiler
インテル製の x86・x64用の C 言語・C++コンパイラ。Windows・Linux・OS X向けがある。gcc 互換。
Microsoft Visual C++
Windows 系プラットフォーム用の C 言語・C++ コンパイラ。2013 から C99 におおむね対応。x86・x64 が主だが Xbox 360、Windows CE 等向けに PowerPC、ARM、MIPS、Itanium 等に対応した版もある。前身として MS-DOS・Windows 用の Microsoft C Compiler がある。またその廉価版として Quick C があった[12]。
Open Watcom C/C++
Windows・Linux・OS/2・MS-DOS・DOSエクステンダを対象とする x86 用 C 言語・C++ コンパイラ。商用だった Watcom C/C++ がオープンソース化したもの。
Portable C Compiler
gcc が普及する以前の UNIX における標準的 C 言語コンパイラ。現在はオープンソース。
組み込み用、8ビット・16ビット・32ビット・64ビットCPU用(クロスコンパイラ)[編集]
GreenHILS C/C++
組み込み向けの C 言語・C++ コンパイラ。 Windows 用・Solaris 用・Linux 用があり、HP/UX用がver4ではあった。
CodeWarrior C/C++
組み込み向けやゲーム機開発向けの C 言語・C++ コンパイラ。Mac OS 用として発祥、かっては Windows 用・BeOS 用・Palm 用もあった。
ARM C/C++
armCPU用 C 言語・C++ コンパイラ。
IAR C/C++
新旧の組み込み向け CPU 各種を広くカバーする。現在は統合開発環境 EW・SW に移行。armCPU用 C 言語・C++ コンパイラが著名。armをコアにした各社のCPUに対応している。
High C
元は x86 向けでPC/AT互換機用だが 80386 のネイティブモードに対応したため FM TOWNS でも標準開発環境、「High C 386」として使用された。現在は各社RISC向け。
BDS-C
CP/M(8080・Z80)用のサブセット(整数のみ)の K&R 系の C 言語コンパイラ。現在はパブリックドメインソフトウェア。
Hitech-C
Z80、PICなど。
Lattice C
1980年代に、日本で高い普及率を見せたコンパイラ。解説書も多く出版されていた。日本での発売はライフボート。初期版はマイクロソフトCコンパイラ1.0として発売された。商用利用のできない個人向けの「personal」版も販売されており、これの価格は 19,800 円であった[13][14]
LSI C
8080・Z80用の LSI C-80(セルフ版・クロス版。現在はクロス版のみ)と、8086 用の LSI C-86 がある。8086 では機能限定(スモールモデルのプログラムしか開発できず、デバッガがない)の「試食版」がフリーソフトで公開され、広く使われた。
関連するプログラミング言語[編集]
先祖[編集]
ALGOL
ヨーロッパ生まれのアルゴリズム記述言語。Pascal や C 言語などに影響を与えたとされる。
BCPL
MULTICS で作成された高級言語。
B言語
初期の UNIX で作成されたインタプリタ方式の高級言語。BCPLを元に作られ、Cの原型となった。
継承・拡張・部分集合(subset)[編集]
C++
C 言語を拡張してオブジェクト指向化したもの。当初は C 言語のスーパーセットだったが、現在は細かい非互換部分が増えている。
JAVA
JVM上で動作し、ポインタ処理をなくし、アプリ開発をしやすくした言語。
C#
JAVAに対抗して、MicrosoftがC言語およびC++の書式を継承した言語。
Cg
C 言語を GPU でのグラフィック処理用に特化させたもの(シェーダー言語)。NVIDIA によって開発された。
Cyclone
C 言語の上位互換セキュア実装。ポインタの扱いを厳格化して安全面に配慮して拡張したもの。その他リージョンベースメモリー管理システム、正規表現、タグ付共用体などを追加している。
Objective-C
C 言語を拡張してオブジェクト指向化したもの。C 言語に Smalltalk のオブジェクトシステムを取り付けたような設計で、互換性は保たれている。C 言語からの拡張部分が C++ と干渉しないため、C++ と混在した記述が可能。
SystemC
ハードウェア記述言語向けに拡張したもの。書式はC++。EEE 1666-2005。ISO 8866:1991。
Impulse_C
ハードウェア記述言語向けに拡張したもの。書式はC。
Unified Parallel C
並列計算向けに C99 を拡張して作られた言語。
その他にも、OpenGLシェーダー言語であるGLSL、DirectX(Direct3D)シェーダー言語であるHLSL、OpenCLカーネル記述言語であるOpenCL-Cなど、C言語の文法的特徴を取り入れた派生言語やDSLが多数存在する。
参考文献[編集]
2014年現在、初心者向けのイラスト入り入門書やサブルーチンのサンプル集の他、組み込み機器の制御や科学技術計算など目的を特化した専門書なども多数ある。便利な機能の説明はあっても、学習者の水準や目的にあった本を見つけるのは必ずしも容易でない。オープンソースのCコンパイラ、OSも大規模なものがあり、直接読み始めるのは困難になっている。オープンソースのOSの小規模なものから始めるとよい。
プログラミング言語C
ブライアン・カーニハン、デニス・リッチー 共著、石田晴久訳、共立出版。
「K&R」として知られている「The C Programming Language」の邦訳。入門書ではなく、特にプログラミングそのものが初めてという読者には不適である。初版と2版があり、2版が現在も時折増刷している(邦訳では事情により、原書2版を基とした版には旧版と改訂新版がある。旧版は装丁が緑地で新版は白地である)。標準の制定以前は本書初版を言語仕様の参考文献として扱っていたが、現在は規格表を参照すべきであり、本書の記述は参考にとどめるべきである。
Cプログラムの落とし穴
コーニグ、中村明訳、新紀元社
Cプログラミングで嵌まるところを指摘している。MISRA-Cでも参考文献になっている。
Cパズルブック
アラン・R. フューアー、田中和明訳、カットシステム
Cプログラミングの芸当を示し、読み書きを推奨しない例を示している。
脚注[編集]
C言語 - Wikipedia
