
文字列検索(BM法)
Boyer-Mooreのアルゴリズム
BM法の原理
KMP法は『理論的には優れているが,実戦には弱い』
というアルゴリズム でした。
これに対して,BM法は『理論的にも優れていて,実戦にも強い』
と いう頼もしいアルゴリズムです。
実用的には,BM法は最も速い文字列探索ア ルゴリズムだということができます。パターンとテキストを重ね合わせて,末尾から先頭に向かって順番に文字を 比較していき,パターンとテキストの不一致が見つかったら,不一致の原因に なった文字に応じてパターンをずらす分量を決める,というのがBM法の考 え方です。
たとえば,左の図のようにテキストabdefghにパターンabcを重ね合わ せて比較することを考えましょう。
まずパターンの最後の文字をテキストと比 較します(左図(1))。
パターンの最後の文字はcで,対応するテキストは dになっています。
ここで,文字dはパターン中に出現しないことに注目しま しょう。文字dはパターンに含まれないので,もしパターンを1つずらしたとして も,やはり文字dのところで不一致になるのは明らかです(左図(2))。
パ ターンを2つずらしたとしても,やはり文字dのところで不一致になります (左図(3))。
結局,パターンを3つずらせばよいことがわかります(左図(4))。結論としては,パターンに含まれない文字の場合には,パターンを
m文字 分ずらせばよいことになります。
このようにBM法では,文字を1回比較するだけでパターンを最大m
文字 分ずらすことができます。
したがって,うまくいけばO(n/m)程度の計算量で 文字列の探索を行うことが可能です。
パターンを末尾から先頭に向かって逆向 きにチェックするというのがBM法のミソで,種明かしをされてみれば,ご く当然の発想のように思えます。
こんな当たり前のことに,1977年まで誰も 気がつかなかったとは,むしろ意外に感じられるほどです。
BM法の実際
さて,BM法の原理は今説明したとおりなのですが,プログラムを作成する 前に,細かい点を検討しておきましょう。
上の図の例では,不一致になっ た文字がパターンに含まれていなかったので,パターンをその長さ
mだけず らすことができました。
しかし,不一致になった文字が,パターンに含まれて いた場合にはどうすればよいのでしょうか?
たとえば左の図のようにテキス トabaabcdの先頭にパターンabcを重ね合わせることを考えましょう。ここ では,パターンの3文字目のcとテキストの3文字目のaが一致しません (左図(1))。
パターンを1つずらしたとすると(左図(2)),テキストの3文字目のa とパターンの2文字目のbは一致しないことは明らかです。
パターンを2つ ずらしたとすると(左図(3)),今度はパターンの1文字目とテキストの3 文字目がともにaなので,OKです。
そこで結局,パターンを2つずらせばよ いことになります。パターンに含まれる文字で不一致になった場合には,その文字がパターンの 末尾から数えて
x文字目(末尾の文字を0文字目として数えることに注意)に当 たるとすると,パターンをx文字ずらせばよいことになります。
また,今までの例ではパターンの末尾の文字で不一致が見つかる場合だけを 取り上げてきました。
末尾以外の文字で不一致になったときにはどうすればよ いでしょうか?
左図(1)のケースを考えましょう。
ここでは,パターンとテキストを末 尾から先頭に向かって順に比較していって,パターンの3文字目のcとテキス トの3文字目のzが一致しません。
ここで,パターンを5つずらすと左図(2)になりますが,残念ながらこれは正しくありません。
実際に,左図(2)のようにしてしまうと,テキストの4文字目から始まる本来見つかる はずのabcabを見逃してしまいます。
今まで,「パターンをx文字分ずらす」という表現を使っていましたが,こ の表現は正しくありません。
正確にいえば,「テキストの注目点をx文字分ず らして,パターンの末尾の文字から再び比較を始める」必要があります。この 場合には,不一致が見つかったとき,テキストの注目点は(左から)3文字目で した。
したがって,テキストの注目点を8文字目にして,そこにパターンの最 後の文字が重なるようにパターンをずらします(左図(3))。
また,パターン中に同じ文字が2回以上出現する場合もあります(左図)。
この場合には,左図(2)のようにいちばん末尾寄りに現れた文字の位置に よって移動量を決めなければなりません。
さもなければ,左図(3)のよう に本来見つけるべきものを見逃してしまう可能性があります。
BM法のプログラム
さて、こまごまとした話をしてきましたが,具体的に アルゴリズムを考えていきましょう。まずは、パターンをずらす表から検討します。
BM法では,不一致になった文字によって,パターンを何文字ずらすかを決 定します。
このような情報は,探索処理に入る前に,前処理によってテーブル に格納しておくのが適切でしょう。
この表は,不一致になった文字の文字コー ドを添え字として,パターンをずらす量を入れた配列skipとして実現します。
ここで,1バイトの文字は0〜255までの値をとるので,配列の大 きさを256にしておきます。
また,配列skipは文字コードによって添え字付 けします。
char型が符号付きだと,めんどうなことになるので,文字はすべ て符号なしとしておきます。
以下のように定義しておくと便利です。
#define uchar unsigned char
配列skipの内容の計算は,以下の4行になります。
先ほど説明したとおりの方法で値を求めています。
パターンの先頭から末尾へと向かって処 理するので,パターン中に同じ文字が2回以上現れる場合には,最後のものが 優先されるようになっています。
for( i = 0; i 続いて、この表を用いたBM法の本体を考えましょう。
#define max(a,b) ((a)>(b)?a:b)
/* 文字列textから文字列patternを検索する(BM法) */
int bm_search(char text[], char pattern[])
{
int i; /* 注目しているテキストの位置 */
int j; /* 注目しているパターンの位置 */
int text_len, patn_len;
text_len = strlen(text);    /* テキストの長さをセット */
patn_len = strlen(pattern); /* パターンの長さをセット */
iにテキストの最初の注目位置をセット
while( i このプログラムは前回同様,変数iがテキストの注目点を表し,変数jがパターン の注目点を表しています。
また,全体が2重のwhileループによって構成さ れています。
外側のwhileループは,パターンをずらしながらテキストの最 後尾に行き当たるまで繰り返します。
内側のループは,パターンとテキストが 一致するかを(パターンの末尾から先頭に向かって)1文字ずつ比較していきま す。
もし,すべての文字が一致したら(つまり,j==0になったら),探索は成 功です。
パターンとテキストが一致しない場合には,パターンをずらす必要がありま す。
先ほどの説明では,「テキストの注 目点を,不一致になった文字に応じた分量だけずらす」ということだったので,
i = i + skip[text[i]];
だけでもよさそうな気がします。
しかし,配列skipをもとにiを更新すると, パターンが前に戻ってしまうことがあります(左図(2))。
不一致が起った文 字(ここではd)がパターンの注目点よりも末尾寄りにあるときに,このような 現象が発生します。
これを避けるために,このような場合には,パターンを現 在の位置よりも1つだけずらすことにします。
従って、skip[text[i]]とパターンを1つずらすための移動量(patn_len - j),移動量が多い方にテキストの注目点を移動します。
外側のwhileループの実行を終えてその下に到達するのは,パターンが見 つからなかった場合です。
この場合には,パターンが見つからなかったことを 示す-1を返します。
BM法の性質
文字列検索(BM法)
