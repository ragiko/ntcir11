
2.1 繰り返し文内でアドレスを参照した場合の注意事項(SHC-0073)
該当バージョン:
V.9.00 Release 00 〜 V.9.02 Release 00
現象:
繰り返し文のループ本体で配列要素のアドレス、もしくは構造体または共用体のメンバのアドレスを、ポインタ変数を使って参照する場合、ポインタ変数の値が間違っている場合があります。
発生条件:
以下の条件をすべて満たした時に発生することがあります。
(1) optimize=1オプションを使用している。
(2) 仮引数、自動変数、もしくは関数内static変数のいずれかをポインタ変数として使用している。
(3) (2)のポインタ変数のアドレスを参照していない。
(4) (2)のポインタ変数を用いて配列、構造体、または共用体メンバのアドレスを参照している。
(5) (4)でアドレスを参照したメンバの配列、構造体、または共用体の先頭からのオフセット値が1バイト以上127バイト以下になっている。
(6) 繰り返し文が存在する。
(7) (6)の繰り返し文のループ本体に、(2)、(3)、(4)、および(5)全てに該当するアドレス参照が複数個ある。
(8) (7)と同じループ本体で、(7)のアドレス参照の他にも(7)と同じポインタ変数を使用している式がある。
(9) (7)と同じループ本体以外では(7)のアドレス参照と同一のアドレスを参照していない。
(10) (8)で使用しているポインタ変数がR8, R9, R10, R11, R12, R13, またはR14レジスタのいずれかに割りついている。
例:
----------------------------------------------
struct ST {
int mem1;
int mem2;
};
int a,b,*pa,*pb,*pc;
void func(struct ST *pst)       // 発生条件 (2)
{
while (a > 0) {
sub();
a = pst->mem1;          // 発生条件 (8)
. . . . . . . . . . . . . . . . . . . . . . . .
pa = &(pst->mem2);      // 発生条件 (4),(5),(7)
pb = &(pst->mem2);      // 発生条件 (4),(5),(7)
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
if (b > 0) {
pc = &(pst->mem2);  // 発生条件 (4),(5),(7)
}
}
}
----------------------------------------------
コンパイル結果
----------------------------------------------
. . . . . . . . . . . . . . . . . . . . . . . .
MOV         R4,R13       ; 発生条件(10):変数pstがR13に
; 割り付いている。
. . . . . . . . . . . . . . . . . . . . . . . . . .
MOV.L       @(4,R15),R14 ; 値が設定されていないスタック
; 領域からpst->mem2のアドレス値を
; 参照している。
MOV.L       R14,@R9      ; paに代入
MOV.L       R14,@R10     ; pbに代入
. . . . . . . . . . . . . . . . . . . . 
MOV         R13,R14
ADD         #4,R14
MOV.L       R14,@R8      ; pcに代入
. . . . . . . . . . . . . . . . . . . . 
----------------------------------------------
回避策:
以下のいずれかの方法で回避してください。
(1) optimize=1の代わりに、optimize=0またはoptimize=debug_onlyオプションを使用する。
(2) 発生条件に該当するポインタ変数のアドレス参照をおこなう。
例:
----------------------------------------------
. . . . . . . . . . . . . . . . .
void func(struct ST *pst)
{
&pst;                       // 追加
while (a > 0) {
. . . . . . . . . . . . . . . . .
----------------------------------------------
2.2 参照と設定が行われている1ビットのビットフィールドメンバが複数ある場合の注意事項(SHC-0074)
該当バージョン:
V.9.01 Release 00 〜 V.9.02 Release 00
現象:
参照と設定が行われている1ビットのビットフィールドメンバが複数ある場合そのビットフィールドメンバに間違った値が設定される場合があります。
発生条件:
以下の条件をすべて満たした時に発生することがあります。
(1) optimize=1オプションを使用している。
(2) cpu=sh2a、またはcpu=sh2afpuオプションを使用している。
(3) 1ビットのビットフィールドメンバが複数存在する。
(4) (3)の複数のメンバのうち、値の参照と設定をしているメンバが複数ある。
(5) (4)のメンバのうちで、参照と設定が連続していないメンバが存在する。
例:
----------------------------------------------
struct aa {
unsigned char bf1:1;  // 発生条件(3)
unsigned char bf2:1;  // 発生条件(3)
} aaf;
void main()
{
unsigned char getfl1;
unsigned char getfl2;
// 発生条件(4)(5): bf1参照
getfl1 = (*(volatile struct aa *)0x80FFFD00).bf1;
// 発生条件(4)(5): bf2参照
getfl2 = (*(volatile struct aa *)0x80FFFD00).bf2;
// 発生条件(4)(5): bf1設定
(*(volatile struct aa *)0x80FFFD00).bf1 = getfl1;
// 発生条件(4)(5): bf2設定
(*(volatile struct aa *)0x80FFFD00).bf2 = getfl2;
}
----------------------------------------------
コンパイル結果
----------------------------------------------
MOV.L   L11,R5      ; H'80FFFD00
BLD.B   #7,@(0,R5)  ; aaf.bf1をステータスレジスタに設定
MOV.B   @R5,R0      ; aaf
TST     #64,R0      ; ステータスレジスタの値を破壊
MOVRT   R6  
BST.B   #7,@(0,R5)  ; aaf.bf1に、破壊されたステータスレジスタの
; 値をストア
BLD     #0,R6  
BST.B   #6,@(0,R5)	 
RTS/N   	 
----------------------------------------------
回避策:
以下のいずれかの方法で回避してください。
(1) optimize=1の代わりに、optimize=0、またはoptimize=debug_onlyオプションを使用する。
(2) 発生条件(4)の全ての参照について、以下のいずれかを実施する。
(2-1) 参照したメンバの値を変数に代入する場合は、代入先の変数をvolatile修飾する。
(2-2) (2-1)以外の場合は、そのメンバの値を、volatile修飾した自動変数に代入し、メンバの参照をその自動変数の参照で置き換える。
例:
<変更前>
----------------------------------------------
st.b1 &= st.b2;         // b1の参照、設定
----------------------------------------------
<変更後>
----------------------------------------------
// volatile変数vtempに代入して、元の参照をvtempで置換
volatile unsigned char vtemp = st.b1;
st.b1 = vtemp & st.b2;
----------------------------------------------
(3) 発生条件(4)の全てのメンバについて、参照と設定が連続するようにプログラムを変更する。
例: 以下のように変更する。
----------------------------------------------
// 参照の直後に設定: bf1
getfl1 = (*(volatile struct aa *)0x80FFFD00).bf1;
(*(volatile struct aa *)0x80FFFD00).bf1 = getfl1;
// 参照の直後に設定: bf2
getfl2 = (*(volatile struct aa *)0x80FFFD00).bf2;
(*(volatile struct aa *)0x80FFFD00).bf2 = getfl2;
----------------------------------------------
2.3 if文で、変数に0、1、または-1を設定した場合の注意事項(SHC-0075)
該当バージョン:
V.9.01 Release 00 〜 V.9.02 Release 00
現象:
if文のブロック内で変数に0、1、または-1を設定する場合に、正しい値が設定されていないメモリ領域を参照することがあります。
発生条件:
以下の条件をすべて満たした時に発生することがあります。
(1) optimize=1オプションを使用している。
(2) 以下のいずれかを満たすif文が存在する。
(2-1) then節に式文が無い。
(2-2) else節に式文が無い。
(2-3) else節が無い。
(3) (2)のif文において、文が存在する方の節には、1つの代入文だけが存在する。
(4) (3)の代入文で変数に0, 1, または-1のいずれかを代入している。
(5) (2)のif文より前に、(4)と同じ変数に0, 1, または-1のいずれかを代入する文がある。
(6) (4)および(5)において、代入する値の組み合わせは、以下のいずれかである。
(4)の値
(5)の値
SuperH(TM) RISC engine ファミリ用C/C++コンパイラパッケージV.9 ご使用上のお願い
