SQL に関する Q&A: 最適なパフォーマンスを実現するための微調整
重複するインデックス、キャンセルしたロールバック操作、および I/O スパイクは、パフォーマンスの問題の原因になりますが、この問題は回避することが可能です。
Paul S. Randal
重複するインデックス
Q. SQL Server では、同じテーブルに重複するインデックスの作成が許可されているようです。この仕様は、ワークロードのパフォーマンスにどのように役立つのでしょうか。クエリによって、使用されるインデックスが異なっているのでしょうか。
A. SQL Server では、重複するインデックスを作成できますが、残念ながら、得られるメリットは一切ありません。それどころか、重複するインデックスを使用すると、いろいろな意味で悪影響があります。
重複するインデックスは、インデックス キーが他のインデックスとまったく同じである場合 (同じ ASC 仕様または DESC 仕様を使用して、同じ順序で指定されている場合) に作成されます。列が含まれる場合は、含まれる列についても同様です (ただし、順序は自由に指定できます)。
SQL Server でクエリに使用するのは重複するインデックスのうちの 1 つだけですが、挿入操作、更新操作、および削除操作の実行中は、テーブルに作成されている全インデックスを保持する必要があります。したがって、テーブルに対して挿入または削除の操作を行うと、その変更はすべてのインデックスに毎回必ず反映されます。更新された列がインデックスに含まれている場合、更新についても同じことが言えます。
インデックス メンテナンスでは、(事実上意味のないインデックスに対して) 余分なリソースを使用して余分なトランザクション ログ レコードを生成し、重複するインデックスにより、余分なディスクとバックアップの領域が必要になります (インデックス メンテナンスに必要なページによってもメモリ領域が必要以上に消費されます)。
重複するインデックスは断片化しやすいため、定期的にインデックスの断片化を解消するための処理でも余分なリソースが必要になります。インデックス メンテナンスと断片化の解消によって生成される余分なトランザクション ログ レコードは、データベース ミラーリングやトランザクション レプリケーションなど、高可用性 (HA) 機能のパフォーマンスを低下させる原因にもなります。
SQL Server では、重複するインデックスを作成したことに関する警告は通知されません。したがって、重複するインデックスの作成を避ける責任はユーザーにあります。重複するインデックスが存在するかどうかを確認する作業を、軽視しないでください。この作業には、すべてのインデックス定義をスクリプトで出力して、出力内容を手動で比較するか、プログラムによるシステム カタログの広範な解析が必要になります。昨年、Kimberly Tripp が、この問題に対する完全な解決策に関する記事を投稿しています。
ロールバックに注意する
Q. 先日、実行時間の長い更新操作をキャンセルしなければならないことがありました。操作をロールバックした後、最初に作成された日単位のトランザクション ログ バックアップは膨大なサイズになりました。データベースには変更を加えなかったため、バックアップのサイズは、とても小さくなることを想定していたのですが、この異常な状態について説明していただけますか。
A. これは非常によくある誤解です。大規模な操作をロールバックした場合、次に作成される差分バックアップが小さくなるというのは間違いです。
SQL Server でデータベースに変更を加えると、必ず 2 つの処理が実行されます。まず、変更内容を説明するトランザクション ログ レコードが生成されます。次に、変更によって更新された全データ ファイル ページに対して、対応するビットが差分ビットマップに設定されます。この設定は、次の差分バックアップで、これらのページをバックアップする必要があることを表しています。
操作をロールバックすると、SQL Server では、その操作による変更箇所を元に戻す必要があります。つまり、ロールバック前の操作によって生成されたすべてのトランザクション ログ レコードが調べられます。SQL Server では、変更を逆の順序で元に戻す必要があります。各トランザクション ログ レコードには、データベースに対する変更内容が、操作の一環として 1 つずつ示されています。この変更をロールバックするには、元の変更の影響を無効にする新たな変更をデータベースに加える必要があります。たとえば、レコードの挿入操作をロールバックするには、挿入したレコードを削除します。実質的な効果は、挿入したレコードが存在しなくなることです。
ここからが、非常にわかりにくい部分です。ロールバック中に行われた変更はすべて、(特殊な変更ではありますが) データベースへの新たな変更になります。トランザクション ログ レコードは、データベースに対するすべての変更について必ず作成されるため、ロールバック中に加えられた変更も、当然のこととしてログ記録されます。つまり、大規模な操作をロールバックすると、ロールバック前の操作だけでなく、ロールバックに対してもトランザクション ログ レコードが生成されます。トランザクション ログ バックアップでは、これらのトランザクション ログ レコードがすべてバックアップされます。これが、膨大なサイズのトランザクション ログ バックアップが作成された原因です。
ロールバック前の操作で、データベースの一部を変更したことにより差分ビットマップにビットが設定された場合、データベースが変更されているため、差分ビットマップのビットを再度クリアすることはできません。その変更が最終的にロールバックされてても、データ ファイル ページが変更されたことに変わりはありません (実際には、2 回変更されています)。そのため、データ ファイル ページは、差分バックアップによってバックアップが作成される必要があります。
この問題で最も重要な部分は、操作がロールバックされても、データベースが変更されたことに変わりはなく、すべてのバックアップには、この変更を反映させる必要があるということです。
スパイクを探す
Q. ある SQL Server で継続的に I/O スパイクが発生するという問題をトラブルシューティングしています。PerfMon を使用してチェックポイントを絞りましたが、どのデータベースが主な原因になっているのかわかりません。どのようにトラブルシューティングを進めればいいでしょうか。
A. チェックポイントが存在する理由は 2 つあります。1 つ目の理由は、トランザクション ログに書き込まれた内容でデータ ファイル ページを更新できることです。SQL Server では、先書きログというメカニズムを使用します。このメカニズムでは、データベースに対する変更が、データ ファイルに反映される前にトランザクション ログに記録されます。このメカニズムにより、クラッシュした場合に変更が維持されることが保証されます。2 つ目の理由は、変更されたデータ ファイル ページを、(各データ ファイル ページが変更されるたびに出力するのではなく) 一定の間隔で出力することで、常時発生する I/O の負荷を下げられることです。
チェックポイントは、各データベースで個々に発生し、復旧間隔 (SQL Server が、前回のチェックポイントから、約 1 分間 (既定) でクラッシュから回復するのに十分なトランザクション ログが生成されていることを認識する時間) を含むさまざまな要因に基づいてトリガーされます。
この数は、生成された何万件ものトランザクション ログ レコードの数と同じです。トランザクション ログ レコードによって変更されたデータ ファイル ページの数が増えるにつれて、データベースのチェックポイントで発生する I/O の量も増加します。
チェックポイントは、SQL Server の Buffer Manager パフォーマンス オブジェクトに用意されている "Checkpoint pages/sec" カウンターを使用して追跡できます。このカウンターでわかるのは、SQL Server インスタンスの全データベースにおけるチェックポイントの合計数だけです。その時点で "チェックポイントが発生している" データベースを特定するには、トレース フラグを使用する必要があります。
トレース フラグ 3502 (チェックポイント発生時に出力をトレースする)、3504 (チェックポイントに関する出力の詳細をトレースする)、および 3605 (トレースした情報をエラー ログに出力する) を有効にすると、チェックポイントが I/O スパイクの原因となっているデータベースを特定できます。
これらのトレース フラグを有効にするには、次のコマンドを使用します。
SQL に関する Q&A: 最適なパフォーマンスを実現するための微調整
