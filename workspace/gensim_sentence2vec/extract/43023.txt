コンフィギュレーションファイル
μITRON仕様OSを用いたアプリケーション開発では、拡張子.cfgのファイルが必須となります。
このソースに記載した情報が、
前節で解説したコンフィギュレータによる初期化処理時に読み込まれます。
静的OS
静的OSとは、
組込みシステムが専用システムであるという特性を活かしたOS技術のことを指します。
コンフィギュレーションファイル.cfgにタスクなどのOS資源を静的に定義し生成することで、
プログラム実行時に必要なメモリ容量を抑えることができます。
また、システム起動時の初期化処理に掛かる時間を短縮できます。
静的API
組込みシステムはメモリ容量が限られているため、システム動作中にメモリ・オブジェクトのメモリ量が増減するのは好ましくありません*1。そこで、μITRON仕様OSでは、静的APIというものが定義されています。
代表的な静的APIである CRE_TSK を例に説明すると、
タスクの静的な生成
タスクが使うスタック領域のメモリ量
タスクの起動番地
タスクの起動時優先度
などといった情報が、コンフィギュレータによって静的に定められます。
led_onboard.cfg
それでは、前節で実行したプログラムのコンフィギュレーションファイルled_onboard.cfgの中身を見ていきましょう。
13〜18行目
13: /* おまじない */
14: INCLUDE("target_timer.cfg");
15: INCLUDE("syssvc/syslog.cfg");
16: INCLUDE("syssvc/banner.cfg");
17: INCLUDE("syssvc/serial.cfg");
18: INCLUDE("syssvc/logtask.cfg");
この部分はいわゆるおまじない部分です。
アプリケーション開発に役立つ機能を使用するためのものです。
20,21行目
20: /* ファイルのインクルード */
21: #include "led_onboard.h"
これ以降に出現するパラメータが記述されているC言語のヘッダファイルを指定しています。
タスク管理機能:タスクの生成
23〜31行目
23: /* 静的API */
24: /* BLED_TASK1 の生成 */
25: CRE_TSK(BLED_TASK1, { TA_NULL, 1, bled_task1, BLED_TASK1_PRIORITY, STACK_SIZE, NULL });
26:
27: /* 初期化タスクの生成 */
28: CRE_TSK(INI_TASK, { TA_NULL, 1, ini_task, INI_TASK_PRIORITY, STACK_SIZE, NULL });
29:
30: /* メインタスクの生成 */
31: CRE_TSK(MAIN_TASK, { TA_ACT, 0, main_task, MAIN_PRIORITY, STACK_SIZE, NULL });
ここでは、静的API CRE_TSK を用いて、MAIN_TASK および BLED_TASK を静的に生成しています。
CRE_TSK では、システム動作前のコンフィギュレーション時に、静的にタスクの生成と資源の確保を行います。
CRE_TSK に与える引数は、以下の通りです。
CRE_TSK(ID tskid, { ATR tskatr, intptr_t exinf, TASK task, PRI itskpri, SIZE stksz, STK_T *stk })
引数
ID tskid : タスクID番号
シンボル名を入力することでコンフィギュレータにより自動で割り振られる
ATR tskatr : タスクの属性
TA_ACT : 起動状態で生成
TA_NULL : 休止状態で生成
intprt_t exinf : タスクの拡張情報
拡張情報を与えないなら0
TASK task : タスクの先頭番地
タスクに対応する関数名を指定
PRI itskpri : タスクの起動時優先度
1から16の整数で指定する
1が最高優先度で16が最低優先度である
SIZE stksz : スタック領域のサイズ(バイト指定)
STK_T *stk : スタック領域の先頭番地
NULLを入れるとコンフィギュレータにより自動的に設定(通常はNULLでOK)
タスクID番号は、例えば MAIN_TASK といったシンボルを記述すれば、コンフィギュレータが自動解釈して割付けを行うため、数値を指定する必要はありません。
アプリケーションプログラム中でも、MAIN_TASKと指定することでタスクIDを使用することができます。
25,28,31行目のCRE_TSKへ与えている引数のパラメータは、21行目で#includeしたファイルに記述されています。
メインプログラム
メインのプログラムは4つのファイルで構成されています。
led_onboard.c :アプリケーションの本体。タスクの記述がされている
led_onboard.h :アプリケーション用のヘッダファイル
dev_led.c   :LEDのデバイスドライバの本体
dev_led.h   :LEDのデバイスドライバのヘッダファイル
ここでは、led_onboard.c ファイルを解説していきます。
led_onboard.c"
本ソースコードには、ユーザが定義するタスクの動作などを記述してあります。
TOPPERS/ASPはマルチタスクに対応しています。
今回のアプリケーションは3つのタスクから構成されています。
それぞれのタスクの相対的な優先度を高中低で示しています。
ini_task()
アプリケーションの初期化タスク
優先度:高
bled_task1()
LEDの ON <--> OFF 切替えタスク
優先度:中
main_task()
メインタスク
優先度:低
#実際の優先度は、1から16の数値で指定します。説明のために、高中低としています。
上記3つのタスクが本ソースコードに記述されています。
まずは、これらのタスクがどのように動作するかのイメージを図で説明します。
main_task()は最初から実行状態として動作します。
そのほかのタスクは、はじめは休止状態です。
そして、main_task()がini_task()をまず起動します。
すると、ini_taskの優先度は高であり、main_taskの低よりも優先的に動作するため、ini_taskは実行状態となり、LEDの初期化を行います。その間、main_taskは実行可能状態となります。
#実行可能状態とは、動作はできるのですが、優先度が高い他のタスクがいるために実行状態になれない状態です。
そして初期化処理終了後は、他にする処理がないため、ini_taskは休止状態となります。
すると、main_taskが再び実行状態となり、次に優先度中のbled_task1を起動します。main_taskは再び優先度の高いタスクを起動することで実行可能状態になります。起動されたbled_task1は処理を終了すると、待ち状態になります。
すると、main_taskは実行状態となり、その処理の途中で自らを待ち状態にします。その後実行状態になると、bled_task1を起床して、再び自分は実行可能状態となります。
この後の動作は繰り返しです。
今回、起動と起床という言葉を使い分けています。
起動とは、休止状態のタスクを実行可能状態とすることです。
そして、起床とは待ち状態のタスクを実行可能状態とすることです。
以降の解説で起動と起床に対応するサービスコールの解説を行っています。
それでは実際にファイルの先頭から順に解説していきます。
10〜17行目
組込みシステム技術に関するサマースクール(SSEST) - SSEST5/事前実習/ASPを用いたLED点滅
