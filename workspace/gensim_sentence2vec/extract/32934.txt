
Stata, TSP, Eviewsなどの計量経済ソフトやRなどの統計に特化された言語を使っていると、既存の分析パッケージが豊富な一方、まだパッケージ化されていない最先端の分析手法や、他分野の技術からのインスピレーションを自分でコーディングして実装する習慣が身につかない傾向にあります。
PythonでもStatsmodelsという統計分析のパッケージがあり、これに頼りきりになってしまうと同じことかもしれません。しかし、そこは汎用プログラミング言語ですから、自分でコーディングする気になればRなどよりもはるかにスムーズに書くことができます。
今回はその一例として、「粒子フィルター」というアルゴリズムを使って「時変パラメター構造自己回帰多変量モデル(TVP-SVAR)」を推定してみます。
FullCodeはこちら。詳しい仕様でご不明な点はGithubのIssue経由でお知らせ頂ければ幸いです。
経済データとの向き合い方が徐々に変わってきている?
これまでの計量経済分析は、どちらかといえば、「普遍的な経済法則」のような、経済現象に潜む「変わらない構造」や「真理」と呼べるようなものを見出そうとしてきたように思います。そのため、どのようなテクニックを使えば、単なる出来事の記録に過ぎない経済データから、自然科学における管理実験データで行ったのと同じような確証を得たことになるのか、が研究されてきました。
具体的には、経済時系列データは、人々の複雑な、そして、絶え間のない相互作用プロセスの一部が、断片的に記録・集計されたもの。実験データと異なり、一つ一つの観測データが独立に発生した看做すのは極めて困難です。例えば、複数の経済時系列データの関係を考えるとき、相関の高い変数の間には、ほとんどの場合、双方向の因果関係があり得えます。ですから、折れ線グラフを2本並べただけで因果関係を語ることはまず不可能です。
こうした問題に対処し、信頼に足る因果構造を得るために、計量経済学は、逆の因果、潜在変数、質的変化のコントロールなど、実験データに近い環境を作りだすための様々なトリックを開発してきました。しかし、計量経済学的にOKとされた経済モデルのうち、パラメタ—の更新なしで、長期に渡って十分な再現性を持つものを見たことがありません。経済学をやっているとそれは当たり前のことと割り切ってしまいます。ですが、自然科学では、実験データを使ってパラメタ—を決めたモデルが高い再現性を持っているようです。
やはり、計量経済学の手法を駆使しても、経済時系列データを使っている限り、同時の因果(例えば価格と需給の同時決定)や潜在変数(観察できない「期待」などの影響)を完璧にコントロールすることは難しく、仮に、経済現象の中に「普遍の構造」があったとしても、その構造を見つけることは無理があるのでしょう。
そうであれば、経済現象の中の因果関係そのものが時間の流れとともにゆらいでいると考えればよいのではないか。むしろ、そのゆらいだ法則のなかから、どれが現実に成るかを決めるのは、実際、その経済システムの基礎的要素である私たちの思考なのではないか、とも思えます。
であれば、経済データを使った実証分析は、「真の経済法則」に到達するためではなく、経済データに現れ出た、私たちの経済状態や日々の思考の集まりを「追跡」「認識」する道具として利用するのが良いように思います。
そうだとすれば、論理実証主義的な方法論よりも、現象論的またはエンジニアリング的な方法が優先であり、新たな分析技術の方向性が見えてきます。
マクロ経済分析が実用として求められるのは、(1)経済状態の現状認識、(2)政策など意図的操作の効果測定、(3)将来の予測、であることがほとんどです。これらの役に立つなら、従来の線形回帰をベースとした不偏性や頑健性の確保に拘泥するよりも、多様なモデル表現や計算機集約的な技術を許して、経済データの持つ情報を最大限活かすように発展したほうがよいと思われます。
今回は、(1)と(2)に役立つ例として、「時変パラメター構造多変量自己回帰モデル」(TVP-SVAR)を取り上げ、粒子フィルター(Particle Filter)による推定方法を紹介しています。
結果として得られた値の一つが下図です。TVP-SVARで推定されたインフレ率のGDPギャップへの弾性値(フィリップス・カーブの傾き)が時間発展している様子です。人々の「期待」など観察不可能な状態の変化に伴い、インフレ決定則が変化している可能性が示唆されています。
なお、以下では、技術的な点を中心にTVP—SVARの紹介をしています。粒子フィルターによるTVP‐SVAR推定を実際にPythonで実装してみたい方は、bitbucketのプライベートリポジトリにCodeを保管していますので、サインアップの上ご連絡ください。
[!!Wonkish!!]
粒子フィルターのアルゴリズムをモジュール化
PFilterというモジュールを作成しました。これで粒子フィルターのアルゴリズムを簡単に実行できます。
粒子フィルターのアルゴリズムは、状態空間モデルの未知状態を推定するもので、ダイナミクスが非線形なものを含めてかなり一般的なクラスを扱うことができます。
状態空間モデルは時系列モデルをデータの観測式と未知状態の推移式の組み合わせで表現するもので、ごく簡潔には以下のように表します(ラグは1期で表現していますが、ラグ変数を状態変数に含めてしまうことで任意の次数まで拡張できます)。
観測:
推移:
X:状態変数、w:観測ノイズ、Y:観測変数、v:状態推移ノイズ
今回は、実用例として、「可変パラメター構造多変量自己回帰モデル」(Time Varying Parameter Structual Vector AutoRegression、以下TVP-SVAR)の推定をデモします。その状態空間表現は次の通りです。
複数時系列データの観測パターンに線形のダイナミクスを当てはめているわけですが、その遷移を規定するパラメターと確率的ノイズのボラティリティが観察できない未知状態で、それらが時間変化することを想定しています。未知状態のダイナミクスには何らかの想定が必要ですが、ここでは特に事前知識がないことの表れとして、ランダムウォークを仮定しています。
マクロ経済分析におけるSVARの必要性
以上のように、粒子フィルターを使えばTVP-SVARを簡単に推定できるのですが、はたして、これが経済分析にとって何の役に立つのでしょうか?
TVP‐SVARは、パラメターが時間を通じて変化するSVARモデルですから、まずは、基礎となるSVARについて解説しておきます。
SVARはマクロ経済分析でおなじみの手法です。2012年にはクリストファー・シムズが、SVARを使った金融政策分析を確立させた功績でノーベル経済学賞を得ています。SVAR自体は単なる時系列モデルですので、それを経済現象に当てはめたときの解釈に意義がありました。
2つ以上の経済時系列データの関係を調べる際、変数間の相互作用に起因する「フィードバック構造」と「同時性」の問題は避けて通れません。
というのも、マクロ経済分析で扱うデータのほとんどは、複雑に絡み合った1度しかない歴史のダイナミクスを飛び飛びの時点で記録したものに過ぎません。現実の連続な時間の中で、私たち一人ひとりや企業ひとつひとつは常に様々なやり取り(相互作用)をしているでしょう。
ですから、マクロ経済データというものは、双方向に影響し合っている経済活動の一部を観察・記録し、ある集団とある期間について集計したものであり、実験室で得たデータのように、外部環境の変化をコントロールした上で、一つの事象だけ独立に生じて得られたデータではあり得ません。
特に、計測期間をまたいで生じた相互作用は、時系列データの上では「フィードバック構造」として現れますし、計測期間内で起きていた相互作用は「同時性」となります。それらの問題を無視し、経済時系列データが、あたかも、一つ一つ切り離されて(独立に一定の確率分布に従って)生じた事象かのような取り扱いをしてしまえば、機械的な統計処理では否定できない誤った結論にたどり着いてしまう可能性があります。
SVARは、こうした問題を極力コントロール(緩和)するために使われます。例えば、相互に影響し合っている2変数AとBについて、Bとは独立に生じたAの変化によってBがどのように変化するかを測ろうとするものです。
景気と物価の関係をSVARで表現
景気(GDPギャップ)と物価(インフレ率)の関係を例にとれば、景気が良ければ物価が上がる一方で、物価が上がれば景気が冷める関係もあります。こうした関係が十分な時間差を経て繰り返すのなら「フィードバック」として捉えられます。
最も単純には、次式ののような2変数の線形ダイナミクスを想定することで表現できそうです。これを多変量自己回帰モデル(VAR)と呼びます。
しかし、景気と物価の関係は時間をまたいで表現できるものだけではありません。「景気が上がるだろうから価格を上げよう」、または、「物価が上がるだろうからもっと貯金しよう」、のような関係もあります。こうした関係は、同じ観測期間内で「同時的」に起きている可能性が高く、捉えきれなかった「同時点での相互作用」が誤差項に残っている可能性あります。所謂、Correated-Errorの状態です。それを極力(≠完全)コントロールし、誤差項をUncorreatedに近づける工夫が「構造化」であり、次式のようにします。
つまり、変数間の同時点の因果関係を指定する行列(A)を乗じて同時に推定することで、VARの誤差項が各変数に固有の独立なショック(構造ショックと呼ぶ)に分解・還元できると考えるのです。
SVARは目指しているものに届いていない
しかし、Ae=uという連立方程式がAの要素について解け、その値が統計的に推定可能となるためには、Aに含まれる未知パラメターの数が式の本数よりも少ない必要があります。このとき、Aの中で、どの部分を0と置くかは、あくまでも仮定です。マクロ経済学の理論モデルから導かれる関係式などに基づいてAの構造を指定するのが一応のマナーとなっていますが、それでは理論が実証よりも先に成立している状態です。
ですから、構造化SVARで経済変数に潜む「同時性」を克服し、時系列データによるマクロ経済理論の適切な実証を可能にしようと言ってみても、「構造化の仕方」そのものが実証される以前のマクロ経済理論や分析者の暗黙的知見に依存しており、結局は、実験データによって成されるような科学的に正統な意味での「確証」は得られないことになります。
残念ながら、経済時系列データに頼っている以上、構造モデルは、盲目的にデータに出ていることを上手く表現しようと努める現象論的モデルと大差ないのです。
であれば、「いつの時代も通用する経済法則を科学的に実証する」ということはそもそも放棄し、実用的な現状観察用のモデルを求めていくのも次善の策として必要なのではないでしょうか。
というのも、マクロ経済分析の現実的な役割は、(1)経済の現状認識、(2)政策効果の測定、(3)将来の予測、であることがほとんどです。実際的な意味からすれば、これらの役割を担ってくれるモデルであれば、別に、ミクロ経済学の一般均衡の「原理」に裏付けられていなくてもいいはずです。
そのような新しい発想の実証モデルとしては、(1)経済データを最低限可読的な潜在的時系列要因に分解する(ファクターモデル)、(2)構成的モデルのシミュレーションにより特定の経済現象の再現を試みる(データ同化されたエージェントモデル)、(3)非線形な推移式をセミ・パラメトリックな方法で構成する(ニューラル・ネットワーク)、などが有用ではないかと思います。
これらは多かれ少なかれ、コンピューター集約的な技術であり、機械学習的な手法を、経済時系列データにも当てはめるという方向性が適していると思われます。
Googleのチーフエコノミストになったハル・ヴァリアンは、計量経済学と機械学習を融合させることの必要性を説いていました(インタビュー)。このような経済分析技術の変化は思ったよりも早く進んでしまうかもしれません。
TVP-SVARの登場
ここでようやくTVP‐SVARの意義が出てきます。これは上の(1)～(3)の分類で言えば、(1)の潜在ファクターモデルに属します。景気(GDPギャップ)と物価(インフレ率)の関係をTVP-SVARで表現すると以下の通り。
要するにSVARのパラメターとボラティリティが時間変化する未知状態となっています。そして、未知状態のダイナミクスは、現象論的に(何も先験的な法則を仮定せずに)、ランダムウォークとしています。
このモデルの良いところは、現象論的柔軟さと可読性のバランスです。未知状態の時間変化の記述によっては、かなり現象論的なアプローチになるのですが、SVARの各時点での構造化と線形応答の仮定によって最低限の可読性が確保されています。
つまり、それぞれ独立に生じたGDPショックとインフレ・ショックが経済に伝播することによってGDPギャップの水準とインフレ率の水準が変化して行くという経済構造の想定は維持したまま、それらの反応の大きさや起こり得るショックの規模などのパラメターが、「何らかの理由で」時間とともに移ろっていると想定しているのです。
「移ろう理由」について、このモデルは答えてくれませんが、出てきた時変パラメターの動き方にパターンがあったりすれば、考慮していない経済変数の状態変化に連動しているのかもしれませんし、システムの非線形性の表れの可能性もあります。
そんな仮説を考えながら、ランダム・ウォークの代わりに何かの推移法則を入れてみたり、システムに別の変数を加えて見たりと、思考し議論する材料として、従来の固定パラメターの線形モデルよりも格段と豊かな情報を持つようになります。
未知状態のダイナミクスを自由に構成でき、さらに、データへの適合度を尤度情報で比較できたりしますので、データ・オリエンティッドに「今効いている法則」を発見しようとするプロトタイピング的なアプローチに向いているでしょう。その点、(1)経済状態の現状認識という実用目的については、深い洞察を提供できそうです。
また、SVARの構造を残していますので、(2)政策操作の効果測定にも対応できます。シミュレーション期間中の時変パラメターについては、最新値で固定するか、もしくは、パラメターのダイナミクスを想定し、それごと変化させて効果を予想することになるでしょう。
ちなみに、深層学習のような多層ニューラル・ネットワーク(例えばDeep Belief Network)では、データさえ与えておけば、何の先験的な定式化を与えなくても十分な表現性と汎化性を持った非線形モデルを、アルゴリズムが自ら獲得します。しかし、これはあまりに現象論的過ぎて、いったい何が何を説明しているのか人間には理解しきれません。(3)の予測に使うならいいのかもしれませんが(為替予測をした例)、(1)現状認識や(2)政策効果の測定のような、「説明的」な要素を含む実用には使えないと思います。
以下では、いよいよ、Pythonで、このTSV-SVARを実装します。
TSV-SVARのPythonによる実装と粒子フィルターによる推定
繰り返しになりますが、粒子フィルターというアルゴリズムによって、状態空間モデルが簡単に推定できます。TVP‐SVARは状態空間モデルの一種ですので、応用可能です。
粒子フィルターについてはこちらの本が現時点で最も参考になると思います(データ同化入門)。
今回作成したPFilterというモジュールは、1)Pandas‐DataFrame形式のデータ(DD)、2)状態の初期分布(X0)、3)データと最新状態を受けとり観測方程式を通じて誤差を出力する関数(ww)、4)状態のダイナミクスを指定する関数(Dyn)、の4つを必要な引数として、状態空間モデルの未知状態の時間推移を出力します。
以下ではTVP-SVARの実装部分のみのプログラムを紹介します。実際にデータによるモデル推定まで実行してみたい方は、PFilterの使い方を紹介しますのでbitbucke経由でご一報ください。
“””
必要なモジュールをimportしています。TVPというディレクトリの__init__.pyでは必要な外部モジュールと自作した計算を便利にする関数群をimportしています。PFilter.pyは粒子フィルターを実行する関数だけを含んだモジュールです。
“””
from TVP import *
import TVP.PFilter as PF
“””
まずはいつも通り、Pandas.DataFrame形式でデータを読み込みます(ここではExcelから)。サンプル期間数(TT)と扱う変数の数(KK)を記録しておくと後々使いまわせて便利です。
“””
# Config & initialization ###################################################
# /// Data ///
url=r"TVP.xlsx"
EXL=pd.ExcelFile(url)
Data = EXL.parse('Go',index_col="TIME")
DD=Data.copy()
TT,KK=DD.shape
“””
粒子フィルターは、未知の状態変数の分布を離散表現し、データ適合度が高まるように学習的に変形(リサンプリング)していくものです。離散化に用いる粒子の数が多ければ多いほど柔軟に変形できますので、計算時間と適合度とのバランスを見ながら粒子数を決めていきます。
“””
# /// Number of particles ///
NN = 100
“””
状態空間モデルでラグ付きのデータを用いる場合、その分、データのサンプル期間が減りますから、フィルターの計算期間も対応して減らす必要があります。
“””
# /// Time iter Config ///
Lag = 1 # Maximum lag used in Obs or Exo function
start=Lag+1 #TT-1#
t=start
T=TT-Lag
“””
SVARモデルの内生変数(=観測データ)を指定します。また、尤度(適合度)計算に使用する観測データの標本標準偏差も計算しておきます。
“””
# /// Std of Obs Vars to be used to calc loglik
obslist= ['Pi','LR','GAP']
sigw=std(DD[obslist].values,axis=0)
ll=len(obslist)
“””
未知状態としての時変パラメターの初期分布として、固定パラメターモデルの推定値を使用します。そのために、Statsmodelsを使ってSVARを推定しています。詳しくはStatsmodelsのドキュメントを参照。
まずは、構造ショックの識別制約を設定。ここでは最も単純なコレスキー分解(下三角行列A)を採用します。
“””
###########################################################################
#
# Constant params SVAR for initialization
#
# ##########################################################################
# /// SVAR /// #
svar_type="A"
A=tril(ones(ll*ll).reshape(ll,ll)*2).astype('S1')
A[A=='2']="E"; fill_diagonal(A,1)
B=None
model = tsa.SVAR(DD, svar_type=svar_type, A=A,B=B)
rlt= model.fit(maxlags=1,trend="c")
# IRF #
IRF=rlt.irf(12)
##IRF.plot();plt.show()
# /// Ericiting initials for TVP /// #
a_0 = rlt.A[tril_indices(ll,-1)]
gam_0 = rlt.params.flatten()
gam_s = rlt.cov_params.diagonal()
lnh_0=log(diag(linalg.cholesky(rlt.sigma_u,lower=True))**2)
“””
TVP-SVARの行列表記を念頭にパラメター行列の名前を定義し、その個数を記録しておきます。
“””
###########################################################################
#
# TVP Initialization Proc
#
# ##########################################################################
# /// StateSpace construction ///
state_keys = ['a', 'gam', 'lnh', 'sgVa', 'sgVg', 'sgVh']
Nstate = len(state_keys)
“””
それぞれの状態変数の初期分布をNN個サンプリングし、DictionaryのリストXとしてまとめます。
“””
# /// Set parameters of initial dst ///
a_0, a_s = (a_0, 0.05*ones(ll))
gam_0, gam_s = (gam_0, gam_s)
lnh_0, lnh_s = (lnh_0, 0.05*ones(ll))
sgVa_0, sgVa_s = (0.001*ones(ll), 0.01*ones(ll))
sgVg_0, sgVg_s = (0.005*ones(ll**2+ll), 0.05*ones(ll**2+ll))
sgVh_0, sgVh_s = (0.005*ones(ll), 0.05*ones(ll))
# /// Int dst of State Vars ///
init_dst=[]
init_dst.append( array([stats.norm.rvs(a_0[i],a_s[i],NN) for i in range(ll)]).T )
init_dst.append( array([stats.norm.rvs(gam_0[i],gam_s[i],NN) for i in range(ll**2+ll)]).T )
init_dst.append( array([stats.norm.rvs(lnh_0[i],lnh_s[i],NN) for i in range(ll)]).T )
init_dst.append( array([stats.norm.rvs(sgVa_0[i],sgVa_s[i],NN) for i in range(ll)]).T )
init_dst.append( array([stats.norm.rvs(sgVg_0[i],sgVg_s[i],NN) for i in range(ll**2+ll)]).T )
init_dst.append( array([stats.norm.rvs(sgVh_0[i],sgVh_s[i],NN) for i in range(ll)]).T )
X = [
dict(zip(
state_keys,
[init[i] for init in init_dst]
)) for i in range(NN)
]
“””
状態推移式によって1期進められた状態変数のDictionaryと観測データとを受けとり、SVARをフィットさせて観測誤差を出力する関数(ww)を定義します。
“””
###########################################################################
#
# Estimation Proc
#
##########################################################################
# Model Equation #########################################################
# /// fitted observation function ///
def ww(xf,DD,t):
## Endo vars, install
Y = DD[obslist].values[t]
## Exog vars, install
Yp = DD[obslist].values[t-1]
## State vars, install
a = xf['a']
gam = xf['gam']
lnh = xf['lnh']
## Observation equations
sigy = exp(lnh/2.)
iHsqt = linalg.inv(diag(sigy))
A = identity(ll); A[tril_indices(ll,-1)] = a
Ahat = dot(A,iHsqt)
G0 = gam[:ll]
G1 = gam[ll:].reshape(ll,ll)
A0 = dot(Ahat,G0)
A1 = dot(Ahat,G1)
## Observation equations
resid = dot(Ahat,Y) - ( A0 + dot(A1,Yp) ) # This is SVAR model
fitted = G0 + dot(G1,Yp) # Reduced VAR model
## Other variables to return
oth_rlt=fitted
## Output
return resid,oth_rlt
“””
未知状態(=パラメター)のダイナミクスを指定する関数(Dyn)を定義します。現在の状態を引数で受けて、1期先の状態の予測を返します。状態変数の次元が揃っており、Dictionaryのkeyが正確にセットされていることが必要です。
“””
# /// models for system function ///
def Dyn(x,keys=state_keys):
## Prior, install
sgVa = abs(x['sgVa'])
sgVg = abs(x['sgVg'])
sgVh = abs(x['sgVh'])
## System Inovations
Va = array([stats.norm.rvs(0.,sig) for sig in sgVa])
Vg = array([stats.norm.rvs(0.,sig) for sig in sgVg])
Vh = array([stats.norm.rvs(0.,sig) for sig in sgVh])
## System equations
a = x['a'] + Va
gam = x['gam'] + Vg
lnh = x['lnh'] + Vh
## Output
values = [
a,
gam,
lnh,
sgVa,
sgVg,
sgVh
]
xf = dict(zip(keys, values))
return xf
“””
PFilterモジュールを使って、粒子フィルターによって推定した未知状態(=パラメター)の時系列を出力します。引数は上で定義したDD,X,ww,Dynです。
“””
# Execute PFilter ######################################################
X, Xhat, Xstd, resid, othpath, LOGLIK = PF.PFilter_D(DD,X,ww,Dyn, sigw=sigw, start=start)
“””
適宜、結果を可視化するセクションです。
“””
# Output checking ######################################################
fitted=array(othpath)
YY=DD[obslist].values
a_r=array([Xhat[t]['a'] for t in range(TT-start)])
gam_r=array([Xhat[t]['gam'] for t in range(TT-start)])
lnh_r=array([Xhat[t]['lnh'] for t in range(TT-start)])
# col=0;pd.DataFrame(c_[fitted[:,col],YY[start:,col]],columns=['Fit','Act'],index=DD.index[start:]).plot()
# pd.DataFrame(a_r,columns=['JPY<->NKY','JPY<->LR','NKY<->LR'],index=DD.index[start:]).plot()
# pd.DataFrame(lnh_r,index=DD.index[start:]).plot()
Python for Economist バックナンバー
[第5回]: 最先端の時系列分析もPythonで!～粒子フィルターによるTVP−SVARの推定～
[第4回]: チャート画像からデータを取得
[第3回]: Codeするための便利な道具
[第2回]: PandasでExcelの読み書き
[第1回]: Anacondaのインストール
Python For Economist [第5回]: 最先端の時系列分析もPythonで!～粒子フィルターによるTVP−SVARの推定～ | necochan
