攻撃対象として狙われやすい文字列処理
文字列は、プログラムとユーザ、プログラムとプログラム間のインタフェースとして利用されるのをはじめ、XMLなどテキスト形式で表現された情報を処理する際にも利用されます。データのみならず、プログラムの挙動に直接影響する動作パラメタや設定情報など様々な情報がテキスト形式で表現されるにつれ、文字列を処理する機会が増加すると共に、文字列を処理すること自体の重要性が高まっています。
攻撃者にしてみれば、プログラムの挙動を操作しうる文字列処理の不備を突く機会も多く存在することになるため、文字列操作エラーを作り込まないことが求められます。文字列操作に関するプログラミングエラーはいくつかありますが、今回は基本的であるが間違いを犯しやすい文字列のNULL終端エラーについて解説します。
NULL終端エラー
文字列型を持たないC言語において、文字列は文字型の配列で表現されます。この配列には、文字列の最後を示すNULL文字が含まれている必要があります。文字列用に確保された文字型配列内にNULL文字が含まれていなければ、文字列として不完全であり、文字列を取り扱う関数や処理に引き渡した場合、脆弱性の要因となります。以下にNULL終端エラーに関連したいくつかの脆弱性の事例を示します。なお、カッコ内の番号(CVE-2006-1516 など)は、米国政府の支援を受けた非営利団体MITRE社が採番している識別子です。
MySQLのコネクション確立処理において、NULL終端されていないユーザ識別子を渡されることによって、意図しないメモリ領域の内容が読みだされてしまう脆弱性(CVE-2006-1516)
Qualcomm POP3サーバ qpopperにおいて、snprintfに類似したユーザ関数呼び出しの結果、生成される文字列がNULL終端されないことにより、後続処理で発生しうるバッファーオーバーフローを利用した任意のコード実行に繋がる脆弱性(CVE-2003-0143)
OpenBSD 2.5のcronにおいて、NULL終端されていないargv[]を渡されることによって、root権限が取得可能となる脆弱性(CVE-2000-0312)
NULL 終端文字に依存する処理
C標準の文字列処理関数を用いて文字列操作を安全に行うためには、引数として渡す文字列が確実にNULL終端されている必要があります。これは、strcpy()やstrlen()などをはじめとするC標準の文字列処理関数の動作が、NULL終端文字に依存しているためです。例えば、strlen()は、引数として渡された文字列にNULL終端文字が出現するまでの文字数をカウントしますし、strcpy()は、コピー先バッファにNULL終端文字が見つかるまで、コピー元の文字列の内容を書き込みます。
また、C標準の文字列処理関数を利用していない場合でも、以下に示すコード例のように、NULL終端文字の存在に依存したコードを書くこともあるでしょう。
size_t i;
char ntbs[16];
/* 文字型配列 ntbs に値を設定(NULL終端されているかは不明) */
for (i = 0; ntbs[i] != '\0' ; i++) {
/* 文字型配列 ntbs に含まれた英小文字を大文字に変換して配列に書き戻す */
}
このコード例においても、ループの終了条件を満たすためには、処理対象となる文字列がNULL終端されている必要があることが分かります。
もし、strcpy()やstrlen()あるいは上記コード例に対して、NULL終端されていない文字データが渡されたらどうなるでしょうか? こういったケースは、バッファーオーバーフローの発生や、その他の未定義動作につながる恐れがあります。上記のコード例であれば、配列の境界を越えて書き込みが行われ、メモリ内の他のデータを破壊してしまいます。strlen()であれば、想定される文字列の長さよりも、より大きな値が返却され、後続の処理でバッファーオーバーフローが引き起こされることも考えられます。
NULL終端を確実に行う
NULL終端エラーを作りこまないためには、プログラマが責任を持ち、文字列がNULL終端されていることを確認するか、または自らNULL終端した上で、NULL終端文字の存在に依存する処理へ制御を移さなければなりません。前述のコード例であれば、ループに入る前に配列の最後をNULL終端することで、元の配列にNULLが含まれていない場合でも、ループの終了条件を確実に満たすことができます。
文字列はNULL終端させる ——C/C++セキュアコーディング入門(3):CodeZine
