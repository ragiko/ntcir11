
本文章は様々な確率分布に従う乱数を生成するC言語の関数をまとめたものである。このページは近江崇宏によって作られました。コードはご自由にお使いになってかまいませんが、バグ等によって生じた損失に対する責任は負いません。
入門編
C言語のrand関数の使い方
メルセンヌ・ツイスタの使い方
乱数生成の基礎
一様乱数 (Uniform Random Number)
C言語のrand関数
線形合同法 (Linear Congruential Method)
メルセンヌ・ツイスタ (Mersenne Twister)
乱数の質の比較〜特に線形合同法の欠点について
逆変換法 (Inverse Transform Method)
モンテカルロ法
各種の確率分布に従う乱数の生成法
プログラム使用について
指数分布 (Exponential Distribution)
正規分布・ガウス分布 (Gauss Distribution)
カイ二乗分布 (Chi-squared Distribution)
コーシー分布 (Cauchy Distribution)
対数正規分布 (Lognormal Distribution)
逆正規分布 (Inverse Gauss Distribution)
ガンマ分布 (Gamma Distribution)
ソースコード
参考文献
1. 入門編
1.1. C言語のrand関数の使い方
C言語には乱数を生成するrand関数が標準装備されている。この章はこのrand関数を用いてお手軽に乱数を生成する方法を説明する。ただし2章でみるようにrand関数にはいくつかの問題があるために、ここで書かれた方法を研究などに使用することは推奨されないということに注意されたい。あくまでも導入のためのお手軽な方法である。
rand関数は$0$からRAND_MAXの範囲の整数の乱数を出力する。RAND_MAXは次のコードで確認できる。
#include &ltstdio.h>
#include &ltstdlib.h>
int main(void){
printf("RAND_MAX=%d\n",RAND_MAX);
}
次のコードはrand関数を用いて$0$からRAND_MAXの整数の乱数を100個出力するコードである。
#include &ltstdio.h>
#include &ltstdlib.h>
int main(void){
int i;
srand(10);
for(i=0;i
rand関数を使うためにはまず始めにstdlib.hをインクルードしなければならない(2行目)。6行目のsrand(10)は乱数の種(シード)を決めるものである。このコードではsrand関数に10を入力しているが、入力する値が同じであればrand関数は同じ乱数列を出力する。異なる乱数列が欲しいときにはsrand関数に別の値を入力すればいい。また実行毎に自動的にシードをかえたいときには
#include &ltstdio.h>
#include &lttime.h>
#include &ltstdlib.h>
int main(void){
int i;
srand((unsigned)time(NULL));
for(i=0;i
のように、現在時刻をシードとして使えばよい(7行目)。このtime関数を用いるためにはtime.hをインクルードする必要がある(2行目)。
上ではrand関数をそのまま用いていたが、実用上はある範囲の整数の乱数を得ることが多い。例えばさいころをシミュレートするときには1から6の整数の乱数が欲しい。この場合には、
#include &ltstdio.h>
#include &ltstdlib.h>
int main(void){
int i;
srand(10);
for(i=0;i
とすればよい。7行目のrand()%6はrand()を6で割ったあまりを出力する演算子で、rand()%6は0から5の整数の乱数を返す。よってrand()%6+1は1から6の乱数を出力するのである。
より一般的にAからBの整数の乱数が欲しいときには上のコードの7行目を
rand()%(B-A+1)+A;
に返ればよい。
1.2. メルセンヌ・ツイスタの使い方
優れた乱数生成アルゴリズムであるメルセンヌ・ツイスタの使用方法のまとめである。性能の評価については2章(乱数の質の比較〜特に線形合同法の欠点について)を参照のこと。メルセンヌ・ツイスタのCコードは開発者により公開されている(Link)。まず準備としてメルセンヌ・ツイスタの関数のヘッダーファイルMT.hを作る(Cソースをダウンロードし、44行目の#include&ltstdio.h>と174行目以降のint main(void){・・・}を消し、ファイル名をMT.hに変える。これでヘッダーファイルの完成である。後はMT.hをメルセンヌツイスタを使うプログラムがあるフォルダに入れて準備が完了である。
次のコードはメルセンヌ・ツイスタの関数genrand_int32()を用いて整数の乱数を100個出力するコードである。
#include &ltstdio.h>
#include "MT.h"
int main(void){
int i;
init_genrand(10);
for(i=0;i
メルセンヌツイスタの関数を使うためには、まず"MT.h"をインクルードし(2行目)、init_genrand(seed)で乱数の初期化(6行目)を行わなくてなならない。seedの値を変えることで異なる乱数列を得ることができる。ここでメルセンヌ・ツイスタの関数genrand_int32()は$[0,2^{32}-1]$の範囲の整数の乱数を返す(7行目)。またgenrand_int32()の出力は長整数型なのでprintfでの表示には%ldを用いる(7行目)
シードを現在時刻にしたいときには、次のコードのように
#include &ltstdio.h>
#include &lttime.h>
#include "MT.h"
int main(void){
int i;
init_genrand((unsigned)time(NULL));
for(i=0;i
さらにtime.hをインクルードし(2行目)、init_genrand((unsigned)time(NULL))で現在時刻で乱数の初期化を行えばよい(7行目)。これで実行ごとに異なる乱数列を得られる。
AからBの範囲の整数の乱数が欲しいときには
genrand_int32()%(B-A+1)+A;
のような関数を用いればよい。
Mersenne Twisterには乱数の関数として以下のも関数が用意されている。
genrand_int32() //符号なし32ビット長整数
genrand_int31() //符号なし31ビット長整数
genrand_real1() //一様実乱数[0,1] (32ビット精度)
genrand_real2() //一様実乱数[0,1) (32ビット精度)
genrand_real3() //一様実乱数(0,1) (32ビット精度)
genrand_res53() //一様実乱数[0,1) (53ビット精度)
2. 乱数生成の基礎
乱数とはランダムな数である。乱数の厳密な定義はさておき、乱数は過去の乱数から予測できない予測不可能性や、いくら大きな列をとっても非周期であるという非周期性、分布に偏りがない均等性などによって特徴づけられる。このような乱数がシミュレーション、暗号作成、統計推定など様々な分野において重要な役割を果たしている。
我々がコンピューターで乱数を扱う際には、上でも見たように特定のアルゴリズムによって乱数を模した擬似乱数を生成して、これを乱数の代わりに用いる。本来ならば擬似乱数も乱数と同じ性質を持つべきである。しかしながら擬似乱数は決定論的なアルゴリズムから生成されているため、乱数と違い周期性、予測可能性や分布の偏りがどうしても生じてしまう。そのため研究等で精度の高い解析を得るためには、精度の高い生成アルゴリズムを用いることが重要である。簡単のため以下では乱数と言った時には擬似乱数をさすものとする。
この章ではまず一様乱数を例にして、アルゴリズムの精度の違いが乱数の質にどのように現れるかを見ていく。その後、より複雑な確率分布に従う乱数を生成するための一般的な方法論について述べる。
2.1. 一様乱数 (Uniform Random Number)
一様乱数は一様分布
に従う乱数である。次に記述する逆関数法やモンテカルロ法によって、一様乱数からより複雑な乱数を生成することができるという意味で、一様乱数は最も基礎的な乱数の1つである。
C言語を用いて一様乱数を生成する最も簡単な方法は、C言語に標準装備されているrand関数を用いることである。このrand関数は線形合同法という比較的容易な方法に基づいている。しかしながらこれらの方法で生成された乱数列は周期が短いといった問題があるため、研究などでの使用は推奨されない。精度が高い乱数生成法としてはMersenne Twister(メルセンヌ・ツイスタ)がある。その乱数の周期は非常に長く、高度な解析においてはMersenne Twisterを使うことが推奨される。
以下ではまずそれぞれの方法の詳細をみていき、最後にこれらの方法で得られた乱数の質の比較を行う。
2.1.1 C言語のrand関数を用いた方法
C言語の関数rand();は0〜RAND_MAXの擬似乱数(整数)を出力する。(rand()+1)/(RAND_MAX+2)のように規格化することで一様乱数を生成できる。
#include&ltstdlib.h>
double Uniform( void ){
return ((double)rand()+1.0)/((double)RAND_MAX+2.0);
}
注:rand関数の基本的な使用法は1章(C言語のrand関数の使い方)を参照のこと。rand関数の使用にはstdlib.hのインクルードが必要である。乱数の初期化はsrand(unsigned seed)で行う。
2.1.2 線形合同法(Linear Congruential Generator)を用いた方法
線形合同法は定数$a,b,m$に対して、$x_{i+1}=ax_i+b \mod m$の漸化式で$0$から$m-1$の乱数(整数)を生成する。ここで$\mod\ m$は$m$で割った時のあまりを表している。周期は最大で$m$である。$(x+1)/(m+1)$と規格化することで一様乱数が得られる。
double Uniform( void ){
static int x=10;
int a=1103515245,b=12345,c=2147483647;
x = (a*x + b)&c;
return ((double)x+1.0) / ((double)c+2.0);
}
注:このコードは$a=1103515245$,$b=12345$,$m=2^{31}$に対応する。また二行目のxの値を変えることで乱数の初期値(シード)を変えることが出来る。
2.1.3 Mersenne Twisterを用いた方法 [推奨]
Mersenne Twisterではgenrand_real3()が一様乱数を返す。ここでは表記の一貫性からUniform()がgenrand_real3()を返すものとする。
#include "MT.h"
double Uniform( void ){
return genrand_real3();
}
注:Mersenne Twisterの使い方は1章(メルセンヌツイスタの使い方)を参照のこと。Mersenne Twisterの使用にはMT.hのインクルードが必要である。乱数の初期化はinit_genrand(unsigned seed)で行う。
2.1.4. 乱数の質の比較〜特に線形合同法の欠点について
ここでは線形合同法とMersenne Twisterの比較を行う。線形合同法は比較的容易な方法であるが様々な短所があることが知られている。その一方でMersenne Twisterは優れたアルゴリズムとして知られている。アルゴリズムの質を評価するのにはいくつかの指標が考えられるが、ここでは得られた乱数列の周期、予測可能性、及び多次元分布の一様性に着目する。
まず周期であるが
C言語による乱数生成
