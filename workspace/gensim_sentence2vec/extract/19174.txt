7.2. re — 正規表現操作¶
このモジュールでは、 Perl で見られるものと同様な正規表現マッチング操作を提供しています。パターンと検索対象文字列の両方について、 8 ビット文字列と Unicode 文字列を同じように扱えます。
正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さずにその特殊な文字を使えるようにするために、バックスラッシュ文字 ('\') を使います。こうしたバックスラッシュの使い方は、 Python の文字列リテラルにおける同じバックスラッシュ文字と衝突を起こします。例えば、バックスラッシュ自体にマッチさせるには、パターン文字列として '\\\\' と書かなければなりません、というのも、正規表現は \\ でなければならず、さらに正規な Python 文字列リテラルでは各々のバックスラッシュを \\ と表現せねばならないからです。
正規表現パターンに Python の raw string 記法を使えばこの問題を解決できます。
'r' を前置した文字列リテラル内ではバックスラッシュを特別扱いしません。従って、
"\n" が改行一文字の入った文字列になるのに対して、 r"\n" は '\' と 'n' という二つの文字の入った文字列になります。通常、 Python コード中では、パターンをこの raw string
記法を使って表現します。
大抵の正規表現操作がモジュールレベルの関数と、 RegexObject のメソッドとして提供されることに注意して下さい。関数は正規表現オブジェクトのコンパイルを必要としない近道ですが、いくつかのチューニング変数を失います。
7.2.1. 正規表現のシンタクス¶
正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表しています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッチするか
(または指定の正規表現がある文字列にマッチするか、つまりは同じことですが) を検査できます。
正規表現を連結すると新しい正規表現を作れます。 A と B がともに正規表現であれば AB
も正規表現です。一般的に、文字列 p が A とマッチし、別の文字列 q が B とマッチすれば、文字列 pq は AB にマッチします。ただし、この状況が成り立つのは、 A と B
との間に境界条件がある場合や、番号付けされたグループ参照のような、優先度の低い演算を A や B
が含まない場合だけです。かくして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細については上記の Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。
以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報やよりやさしい説明に関しては、 正規表現 HOWTO を参照下さい。
正規表現には、特殊文字と通常文字の両方を含められます。 'A' 、 'a' 、あるいは '0'
のようなほとんどの通常文字は最も簡単な正規表現になります。こうした文字は、単純にその文字自体にマッチします。通常の文字は連結できるので、 last は文字列 'last' とマッチします。
(この節の以降の説明では、正規表現を引用符を使わずに この表示スタイル: special style
で書き、マッチ対象の文字列は、 '引用符で括って' 書きます。)
'|' や '(' といったいくつかの文字は特殊文字です。特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常の文字に対する解釈方法に影響します。正規表現パターン文字列には、 null byte を含めることができませんが、
\number 記法や、 '\x00' などとして指定することができます。
特殊文字を以下に示します:
'.'
(ドット)  デフォルトのモードでは改行以外の任意の文字にマッチします。
DOTALL フラグが指定されていれば改行も含むすべての文字にマッチします。
'^'
(キャレット)  文字列の先頭とマッチします。
MULTILINE モードでは各改行の直後にマッチします。
'$'
文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、 foo は ‘foo’ と ‘foobar’
の両方にマッチします。一方、正規表現 foo$ は ‘foo’ だけとマッチします。興味深いことに、 'foo1\nfoo2\n' を
foo.$ で検索した場合、通常のモードでは ‘foo2’ だけにマッチし、
MULTILINE モードでは ‘foo1’ にもマッチします。
$ だけで 'foo\n' を検索した場合、2箇所 (内容は空) でマッチします: 1つは、改行の直前で、もう1つは、文字列の最後です。
'*'
直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したものにマッチさせるようにします。例えば ab* は
‘a’、’ab’、あるいは ‘a’ に任意個数の’b’ を続けたものにマッチします。
'+'
直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせるようにします。例えば ab+ は ‘a’ に一つ以上の ‘b’
が続いたものにマッチし、 ‘a’ 単体にはマッチしません。
'?'
直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせるようにします。例えば ab? は ‘a’ あるいは ‘ab’
にマッチします。
*?, +?, ??
'*' 、 '+' 、 '?' といった修飾子は、すべて 貪欲 (greedy)
マッチ、すなわちできるだけ多くのテキストにマッチするようになっています。時にはこの動作が望ましくない場合もあります。例えば正規表現 <.*> を '<H1>title</H1>' にマッチさせると、 '<H1>' だけにマッチするのではなく全文字列にマッチしてしまいます。
'?' を修飾子の後に追加すると、 非貪欲 (non-greedy) あるいは
最小一致 (minimal) のマッチになり、できるだけ 少ない 文字数のマッチになります。例えば上の式で .*? を使うと '<H1>' だけにマッチします。
{m}
前にある RE の m 回の正確なコピーとマッチすべきであることを指定します;マッチ回数が少なければ、RE 全体ではマッチしません。例えば、
a{6} は、正確に 6個の 'a' 文字とマッチしますが、 5個ではマッチしません。
{m,n}
結果の RE は、前にある RE を、 m 回から n 回まで繰り返したもので、できるだけ多く繰り返したものとマッチするように、マッチします。例えば、 a{3,5} は、3個から 5個の 'a' 文字とマッチします。 m を省略するとマッチ回数の下限として0を指定した事になり、 n
を省略することは、上限が無限であることを指定します; a{4,}b は aaaab や、千個の
'a' 文字に b が続いたものとマッチしますが、 aaab とはマッチしません。コンマは省略できません、そうでないと修飾子が上で述べた形式と混同されてしまうからです。
{m,n}?
結果の RE は、前にある RE の m 回から n 回まで繰り返したもので、できるだけ 少なく
繰り返したものとマッチするように、マッチします。これは、前の修飾子の控え目バージョンです。例えば、 6文字文字列 'aaaaaa' では、 a{3,5} は、5個の 'a' 文字とマッチしますが、 a{3,5}? は3個の文字とマッチするだけです。
'\'
特殊文字をエスケープする( '*' や '?' 等のような文字とのマッチをできるようにする)
か、あるいは、特殊シーケンスの合図です;
特殊シーケンスは後で議論します。
もしパターンを表現するのに raw string を使用していないのであれば、 Python も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして使っていることを覚えていて下さい;もしエスケープシーケンスを Python の構文解析器が認識して処理しなければ、そのバックスラッシュとそれに続く文字は、結果の文字列にそのまま含まれます。しかし、もし Python が結果のシーケンスを認識するのであれば、バックスラッシュを 2回繰り返さなければいけません。このことは複雑で理解しにくいので、最も簡単な表現以外は、すべて raw string を使うことをぜひ勧めます。
[]
文字の集合を指定するのに使用します。文字は個々にリストするか、文字の範囲を、2つの文字と
'-' でそれらを分離して指定することができます。特殊文字は集合内では有効ではありません。例えば、 [akm$] は、文字 'a' 、 'k' 、 'm' 、あるいは '$' のどれかとマッチします; [a-z] は、任意の小文字と、 [a-zA-Z0-9] は、任意の文字や数字とマッチします。 (以下で定義する) \w や \S のような文字クラスも、範囲に含めることができます。しかしながら、それら文字クラスのマッチは有効になっている LOCALE 、もしくは、
UNICODE のモードに依存します。もし文字集合に ']' や '-' を含めたいのなら、その前にバックスラッシュを付けるか、それを最初の文字として指定します。たとえば、パターン []] は ']' とマッチします。
範囲内にない文字とは、その集合の 補集合をとること でマッチすることができます。これは、集合の最初の文字として '^'
を含めることで表すことができます;他の場所にある '^' は、単純に '^' 文字とマッチするだけです。例えば、 [^5] は、
'5' 以外の任意の文字とマッチし、 [^^] は、 '^' 以外の任意の文字とマッチします。
[] の中では、特殊な形式や特殊文字が、その意味を失い、ここに記述された書式だけが有効であることに注意して下さい。例えば、 +, *, (, ), などは [] の中では文字通りに扱われ、後方参照は [] の中では使用できません。
'|'
A|B は、ここで A と B は任意の RE ですが、 A か B のどちらかとマッチする正規表現を作成します。任意個数の RE を、こういう風に '|' で分離することができます。これはグループ (以下参照) 内部でも同様に使えます。検査対象文字列をスキャンする中で、 '|'
で分離された RE は左から右への順に検査されます。一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。このことは、もし A
がマッチすれば、たとえ B によるマッチが全体としてより長いマッチになったとしても、 B
を決して検査しないことを意味します。言いかえると、 '|' 演算子は決して貪欲 (greedy) ではありません。文字通りの '|'
とマッチするには、 \| を使うか、あるいはそれを [|] のように文字クラス内に入れます。
(...)
丸括弧の中にどのような正規表現があってもマッチし、またグループの先頭と末尾を表します;グループの中身は、マッチが実行された後に検索され、後述する
\number 特殊シーケンス付きの文字列内で、後でマッチされます。文字通りの
'(' や ')' とマッチするには、 \(
あるいは \) を使うか、それらを文字クラス内に入れます: [(] [)] 。
(?...)
これは拡張記法です ('(' に続く '?' は他には意味がありません) 。 '?'
の後の最初の文字が、この構造の意味とこれ以上のシンタクスがどういうものであるかを決定します。拡張記法は普通新しいグループを作成しません;
(?P<name>...) がこの規則の唯一の例外です。以下に現在サポートされている拡張記法を示します。
(?iLmsux)
( 集合 'i', 'L', 'm', 's', 'u', 'x'
から1文字以上) 。グループは空文字列ともマッチします;文字は、正規表現全体の対応するフラグ
(re.I (大文字・小文字を区別しない), re.L (ロケール依存),
re.M (MULTILINEモード), re.S (DOTALLモード),
re.U (Unicode依存), re.X (冗長) ) を設定します。
(フラグについては、 モジュールコンテンツ に記述があります)
これは、もし flag 引数を re.compile() 関数に渡さずに、そのフラグを正規表現の一部として含めたいならば役に立ちます。
(?x) フラグは、式が構文解析される方法を変更することに注意して下さい。これは式文字列内の最初か、あるいは1つ以上の空白文字の後で使うべきです。もしこのフラグの前に非空白文字があると、その結果は未定義です。
(?:...)
正規表現の丸括弧の非グループ化バージョンです。どのような正規表現が丸括弧内にあってもマッチしますが、グループによってマッチされたサブ文字列は、マッチを実行したあと検索されることも、あるいは後でパターンで参照されることも できません 。
(?P<name>...)
正規表現の丸括弧と同様ですが、グループによってマッチされたサブ文字列は、正規表現の残りの部分から name という記号グループ名を利用してアクセスできます。グループ名は、正しい
Python 識別子でなければならず、各グループ名は、正規表現内で一度だけ定義されなければなりません。記号グループは、グループに名前が付けられていない場合のように、番号付けされたグループでもあります。そこで下の例で
id という名前がついたグループは、番号グループ 1 として参照することもできます。
たとえば、もしパターンが (?P<id>[a-zA-Z_]\w*) であれば、このグループは、マッチオブジェクトのメソッドへの引数に、 m.group('id') あるいは m.end('id') のような名前で、また同じ正規表現内 (例えば、 (?P=id)) や置換テキスト内 (\g<id> のように)
で名前で参照することができます。
(?P=name)
前に name と名前付けされたグループにマッチした、いかなるテキストにもマッチします。
(?#...)
コメントです;括弧の内容は単純に無視されます。
(?=...)
もし ... が次に続くものとマッチすればマッチしますが、文字列をまったく消費しません。これは先読みアサーション (lookahead assertion) と呼ばれます。例えば、
Isaac (?=Asimov) は、 'Isaac ' に
'Asimov' が続く場合だけ、 'Isaac ' とマッチします。
(?!...)
もし ... が次に続くものとマッチしなければマッチします。これは否定先読みアサーション
(negative lookahead assertion) です。例えば、
Isaac (?!Asimov) は、 'Isaac ' に
'Asimov' が続か ない 場合のみマッチします。
(?<=...)
もし文字列内の現在位置の前に、現在位置で終わる ... とのマッチがあれば、マッチします。これは 肯定後読みアサーション (positive lookbehind assertion) と呼ばれます。
(?<=abc)def は、 abcdef にマッチを見つけます、というのは後読みが3文字をバックアップして、含まれているパターンとマッチするかどうか検査するからです。含まれるパターンは、固定長の文字列にのみマッチしなければなりません、ということは、 abc や a|b
は許されますが、 a* や a{3,4} は許されないことを意味します。肯定後読みアサーションで始まるパターンは、検索される文字列の先頭とは決してマッチしないことに注意して下さい;多分、 match() 関数よりは
search() 関数を使いたいでしょう:
(?<!...)
もし文字列内の現在位置の前に ... とのマッチがないならば、マッチします。これは 否定後読みアサーション(negative lookbehind assertion) と呼ばれます。肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけにマッチしなければいけません。否定後読みアサーションで始まるパターンは、検索される文字列の先頭とマッチすることができます。
(?(id/name)yes-pattern|no-pattern)
グループに id が与えられている、もしくは name があるとき、 yes-pattern  とマッチします。存在しないときには no-pattern とマッチします。 no-pattern はオプションで省略できます。例えば
(<)?(\w+@\w+(?:\.\w+)+)(?(1)>) はemailアドレスとマッチする最低限のパターンです。これは '<user@host.com>' や 'user@host.com' にはマッチしますが、
'<user@host.com'
にはマッチしません。
バージョン 2.4 で追加.
特殊シーケンスは '\' と以下のリストにある文字から構成されます。もしリストにあるのが通常文字でないならば、結果の RE は2番目の文字とマッチします。例えば、 \$ は文字 '$' とマッチします。
\number
同じ番号のグループの中身とマッチします。グループは1から始まる番号をつけられます。例えば、 (.+) \1 は、 'the the' あるいは '55 55' とマッチしますが、
'the end' とはマッチしません(グループの後のスペースに注意して下さい)。この特殊シーケンスは最初の 99 グループのうちの一つとマッチするのに使うことができるだけです。もし number の最初の桁が 0 である、すなわち number が 3 桁の8進数であれば、それはグループのマッチとは解釈されず、 8進数値 number を持つ文字として解釈されます。文字クラスの '[' と ']' の中の数値エスケープは、文字として扱われます。
\A
文字列の先頭だけにマッチします。
\b
空文字列とマッチしますが、単語の先頭か末尾の時だけです。単語は英数字あるいは下線文字の並んだものとして定義されていますので、単語の末尾は空白あるいは非英数字、非下線文字によって表されます。
\b は、 \w と \W の間の境界として定義されているので、英数字であると見なされる文字の正確な集合は、 UNICODE と LOCALE フラグの値に依存することに注意して下さい。文字の範囲の中では、 \b は、 Python の文字列リテラルと互換性を持たせるために、後退
(backspace)文字を表します。
\B
空文字列とマッチしますが、それが単語の先頭あるいは末尾に ない 時だけです。これは \b のちょうど反対ですので、同じように LOCALE と UNICODE
の設定に影響されます。
\d
UNICODE フラグが指定されていない場合、任意の十進数とマッチします;これは集合
[0-9] と同じ意味です。
UNICODE がある場合、Unicode 文字特性データベースで数字と分類されているものにマッチします。
\D
UNICODE フラグが指定されていない場合、任意の非数字文字とマッチします;これは集合
[^0-9] と同じ意味です。 UNICODE がある場合、これは Unicode 文字特性データベースで数字とマーク付けされている文字以外にマッチします。
\s
LOCALE と UNICODE フラグが指定されていない場合、任意の空白文字とマッチします;これは集合 [\t\n\r\f\v] と同じ意味です。
LOCALE がある場合、これはこの集合に加えて現在のロケールで空白と定義されている全てにマッチします。 UNICODE が設定されると、これは [ \t\n\r\f\v] と Unicode
文字特性データベースで空白と分類されている全てにマッチします。
\S
LOCALE と UNICODE がフラグが指定されていない場合、任意の非空白文字とマッチします;これは集合 [^\t\n\r\f\v] と同じ意味です。 LOCALE がある場合、これはこの集合に無い文字と、現在のロケールで空白と定義されていない文字にマッチします。
UNICODE が設定されていると、 [ \t\n\r\f\v] でない文字と、
Unicode 文字特性データベースで空白とマーク付けされていないものにマッチします。
\w
LOCALE と UNICODE フラグが指定されていない時は、任意の英数文字および下線とマッチします;これは、集合 [a-zA-Z0-9_] と同じ意味です。 LOCALE が設定されていると、集合 [0-9_] プラス現在のロケール用に英数字として定義されている任意の文字とマッチします。もし UNICODE が設定されていれば、文字 [0-9_] プラス Unicode
文字特性データベースで英数字として分類されているものとマッチします。
\W
LOCALE と UNICODE フラグが指定されていない時、任意の非英数文字とマッチします;これは集合 [^a-zA-Z0-9_] と同じ意味です。 LOCALE が指定されていると、集合 [0-9_] になく、現在のロケールで英数字として定義されていない任意の文字とマッチします。もし UNICODE がセットされていれば、これは [0-9_] および Unicode 文字特性データベースで英数字として表されている文字以外のものとマッチします。
\Z
文字列の末尾とのみマッチします。
Python 文字列リテラルによってサポートされている標準エスケープのほとんども、正規表現パーザに認識されます:
7.2. re — 正規表現操作 &mdash; Python 2.6ja2 documentation
