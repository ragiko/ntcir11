 とかく、同期処理のプログラミングに慣れてしまうと、非同期な処理が不安に感じられるものです。ただ、システムの世界は同期処理で全てうまくゆくものではなく、非同期である方がむしろうまくゆく場合もあるのです。食わず嫌いであった、あるいは難しそうで敬遠していた方は是非この機会にJMSのアーキテクチャを学びましょう。
非同期な世界 長い間設計やコーディングをしてきて同期的な処理(要求を出すとこたえがすぐに返ってくる処理)に慣れてしまうと、非同期な処理(要求を出したがこたえをすぐには期待しない処理)は非常に不安なものです。しかし、よく世界を観察すると同期処理で動いているものばかりではないことに気づきます。 よく例として挙げられるのがメールです。紙のメールにせよ、電子メールにせよ、すぐにこたえが返ってくるわけでもなく、そのように望んでいるわけでもありません。これに対し電話は同期処理です。相手が忙しいかどうかに係わりなく通じます。「この忙しい時に!」というのは仕事中よくあることです。 最近では、急ぎではなく事実として残しておきたい用件は、電子メールでやり取りすることが普通となってきました。システムもまた然りです。要求先の忙しさに関係なくコミュニケーションするには非同期な処理が向いています。これをシステム的に言うと同期通信と非同期通信と呼びます。それでも不安は残る システムでも非同期通信向きのものがあることは理解しやすいと思いますが、一方で信頼性に欠けるのではないかという不安が残ります。これについては、電子メールでも返信を求めることができるように非同期通信でも信頼性を保つための仕組みがあります。これは後ほど説明します。JMS(Java Message Service)とは何か JMSというAPIができて非同期通信が実現できたわけではありません。メッセージング指向のミドルウェア(MOM:Message Oriented Middleware)製品が登場し非同期通信が可能になり、それらをJava EE(当時はJ2EEという呼称)に取りこむための仕組みがJMSです。JDBCが特定のデータベース製品を意識しなくて済むように開発されたのと同様、JMSもコーディングするのに特定のMOM製品を意識する必要はありません。プレイヤー JMSを使って非同期通信を行うために必要なプレイヤーは表1の通りです。

