
はじめに
オブジェクトが入力 (または入出力) 項目属性をパラメーターとして受け取る場合、フィルタ条件を一部のグループ (For Each、グリッドなど) に適用できます (詳しくは、「Parm ルール」を参照)。
一部の状況で、上記のルールが考慮されていません。そのため、GeneXus X Evolution 2 では、それを修正するための変更が加えられました。ここでは、エラーとその解決策について説明します。
これまでの動作 (GeneXus X Evolution 1 以前)
次のトランザクションおよびオブジェクトがあるとします:
TRN Category {    CategoryId* }
TRN Customer
{
CustomerId*
CategoryId
}
TRN Invoice
{
InvoiceId*
CustomerId
}
parm( CategoryId)
...
for each
defined by CategoryId, InvoiceId, CustomerId
...
endfor
For Each 節について、Invoice テーブルがそのベーステーブルとして考慮され、そのナビゲーションは、Customer テーブルにアクセスしません。
WWSD パターン用に生成したコードを使用すると、エラーをより明確に特定できます。
上述のデータ構造があるとします。パターンが Category に適用されると、この場合、特定の CategoryId からすべての Customer を表示するために、関連する各テーブルにセクションが作成されます。セクションのコードはパラメーターとして CategoryId を持ち、グリッドは CustomerId を表示します。生成されたコードは、特定の CategoryId の代わりにすべての Customer を表示します。
この動作に対する技術的な理由
CategoryId 項目属性は、パラメーター (この場合、入出力パラメーター) で、インスタンス化されている (値を持つ) として考慮されます。一般的な規則に照らして、フィルタ条件が生成される可能性があるので、これは正しいです。
さらに、それは定数と考えられ、その結果、ナビゲートする必要がなくなります。結果として、ナビゲートする項目属性のリストから除外されます。結果的に、次のようになります:
(CategoryId が属する) Customer テーブルはナビゲートされない。
パラメーターはフィルタを適用しない。
すべての Invoice が処理される。
現在の動作 (GeneXus X Evolution 2 以降)
上記の問題は、新しいバージョンでは修正され、次の基準が追加されます:
通常どおり、Parm ルールで言及されているかどうかに関わらず、グループに属するすべての項目属性を考慮して、グループのベーステーブルが決められる。
さらに、これらの基準は、依然として各パラメーターの項目属性に適用されます:
項目属性が、グループによって決められたテーブルの 1 つに属している場合 (これはすべての拡張テーブルは意味しないことに注意してください)、フィルタが適用される。
上記のテーブルのいずれにも属していない場合で、しかし項目属性による明示的な条件が存在する場合、その条件が適用される (付録の例 2 を参照)。
互換性
以前のバージョンから変換したナレッジベースに関して、この修正に関連する変更を検出するために、ナビゲーションを比較することが重要です。
一般に、次のような状況が起こり得ます:
パラメーターの項目属性も For Each グループの外部のイベントで言及されているので、ナビゲーションが一部のテーブルまたは条件を変更する。たとえば、Start イベントで、これらの項目属性の一部をパラメーターとして渡すプロシージャーを呼び出します。このとき、それらの項目属性がベースおよび拡張テーブルを推論すると考えられるので、オブジェクトナビゲーションは変更されている可能性があります。
さらに、次の SAC が修正されました:
SAC #18904 (スペイン語の情報)  パラメーターとして受け取られた項目属性による、正しくない警告 spc0037
SAC #20460 (スペイン語の情報)  パラメーターの項目属性もグループで言及されていることにより、フィルタが適用されない
SAC #22824 (スペイン語の情報)  Start イベント内の呼び出しコマンドで言及される項目属性によって、オブジェクトナビゲーションに条件が含まれる
付録
例 1
TRN Category
{
CategoryId*
}
TRN Customer
{
CustomerId*
CustmerName
CategoryId
}
特定の Category に属するすべての Customer をリストするための Web パネルが必要だと仮定します。期待されるコードを次に示します:
parm(CategoryId);
...
// 次の項目属性を持つグリッドを挿入します: CustomerId および CustomerName
// ナビゲーションへの参加を強制するために、フォームに非表示のコントロールとして CategoryId を挿入します
ただし、このナビゲーションは条件を含まず、Customer テーブルだけがアクセスされます。
これは、parm(ATT) を parm(&VAR) に変更して条件 ATT = &Var; を追加することで簡単に解決できますが、For Each、グリッド、データプロバイダーなどでのベーステーブルおよび拡張テーブルの推論方法の一般規則が原因で、この動作は、混乱を生じさせる可能性があります。
例 2
TRN A
{
A1*
A2
}
Trn B
{
B1*
B2
}
Proc:
Parm(A1)
For each
Where B1 = A1
Endfor
この場合、期待される動作は、次の条件で B テーブルをナビゲートすることです: B1 = @A1   (この場合は変更なし)
パラメーターとして項目属性を受け取るグループのナビゲーション
