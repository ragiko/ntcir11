
第4回 : 高次の積分公式と一般的な微分方程式    
今週のテーマ  
数値積分の精度を高める  
一般の連立常微分方程式に拡張する。  
キーワード: Leap-Frog 法、 Runge-Kutta 法,,固有値、固有ベクトル、Jordan標準形  
Euler 法の限界     
これまで見てきたように, Euler 法は単純でわかりやすい半面,     
精度があまりよくない. 時間刻み (Δt)を小さくとればある程度精度はあげられるが,     
あまり小さくとりすぎると「丸め誤差」が無視できなくなって,     
かえって精度が悪くなる.     
これを回避するために「倍精度」の実数を使うことも考えられるが,     
Δtを小さくしたために積分回数が増える上, 普通,     
倍精度の演算にはかなりの時間がかかるので,     
計算速度がかなり悪くなる.    
したがって,     
そこそこ大きいΔtでも精度が高い計算方法があれば,     
それを使うのが得策ということになる.    
そもそも, Euler 法がなぜ精度が悪かったかと言えば, Euler 法が1次精度の近似 しかしていないからである.     
たとえば「質点の運動」を記述する微分方程式を Euler法で解く際には,     
現在の「速度(dx/dt)」がそのまま続くと考えて将来の位置を予測するが,     
質点に「加速度(d2x/dt2」が生じると,     
それがそのまま誤差になってしまう. もし,     
「加速度」まで考慮にいれて, 将来を予測すればそれだけ     
精度が上がることになる.    
「加速度」すなわち2階微分まで考慮した公式を     
2次精度の公式と呼ぶが, さらに, 3次精度, 4次精度となれば,     
同じΔtでも精度のよい計算ができる.    
しかも, n次精度の近似をすれば, Δtを小さくしたときに,     
誤差はΔtn に比例して 小さくなる. つまり, Euler     
法では精度を1桁あげようとすれば, Δtを1/10     
にしなければならないが, 4次精度の公式であれば, 1/2     
で十分な精度が得られる.    
Leap-Frog 法    
2次精度の積分公式でよく使われるのが、中点差分に基づく     
Leap-Frog (蛙とび) 法である。中点差分は    
dx
= F として
dt
X(τ+Δ)−X(τ−Δ)
= F(τ)
2Δ
と書ける。これを整理すると、    
X(τ+Δ)= X(τ−Δ)+ 2ΔF(τ)
となる。これがLeap-Frog     
法である。この最大の特徴は、右辺第一項が t=τ-Δ     
の値になっていることである。つまり、最新の情報だけでなく、もうひとつ前の情報を使って、「一つおき」に計算を進める。そのため、初期値として、t=0     
だけでなく t=Δ の値も必要である。Leap Frog     
法を使って、前回の問題を積分したものが   
leap11.f90  
(このプログラムでは、dx/dt などの計算に    
「内部サブルーチン」を使っていることに注意)   
である。Euler 法では、dt=0.01     
ぐらいでも、どんどん外側にずれていった解が、今度は dt=0.2     
でもかなりいい近似になっていることがわかる。1ステップ計算するための手間     
(コスト) は、Euler     
法と変わらず、精度がよいので、よく使われているが、この方法は問題を選ぶ。たとえば、最初の問題    
(dx/dt = -cx) にLeapFrog     
を適用すると、必ず数値不安定になって計算ができなくなる。   
これは、数学的には初期値が1つでよいはずの問題に、2つの初期値が必要なことと関係がある。実は、この解法の「数値的な解」には「本来のモード」と差分化の際に現れてしまった「数値モード」がある。そして、上記の例の場合には、この数値モードが不安定になってしまうのである。   
leap01.f90  
Runge-Kutta 法     
常微分方程式    
dx
-- = f(t, x)              (1)
dt
を考える. 刻み幅を h としたとき, Euler 法は     
k = h f(t, xn)          (2)
xn+1 = xn + k               (3)
とかける. これを整理すると,     
xn+1 = xn + h x'n          (4)
となるので, O(h2) の誤差を含む.     
ここで, 一気に t+h まで計算せずに, 一旦 t+h/2     
で「仮のステップ」をとって, 次のように計算してみよう.     
k1 = h f(t      , xn       )      (5)
k2 = h f(t + h/2, xn + k1/2)      (6)
xn+1 = xn + k2                      (7)
これを整理すると,    
xn+1 = xn + h x'n + h2/2 x''n       (8)
となり, 誤差は O(h3) になることがわかる. これを 2次精度 の Runge-Kutta法 と呼ぶ.     
この方法は一見,     
刻み幅を半分にしただけのように思えるかも知れないが,     
精度が上がっていることに注意してほしい. つまり, Euler 法は h     
を半分にしても誤差が半分にしかならないが, 2次精度の Runge-Kutta     
では 1/4 になる.     
同様にして, もっと高次の公式を作ることができる. 4次の     
Runge-Kutta法の公式は    
k1 = h f(t      , xn       )            (9)
k2 = h f(t + h/2, xn + k1/2)           (10)
k3 = h f(t + h/2, xn + k2/2)           (11)
k4 = h f(t + h  , xn + k3  )           (12)
xn+1 = xn + k1/6 + k2/3 + k3/3 + k4/6     (13)
とかける. この4次の公式は多くの問題で,     
比較的良い結果を得られるので, よく使われる. しかし,     
いつもこの方法がベストであるとは限らない.     
この方法はもともと関数 x     
が少なくとも4階連続微分可能であることを前提にしており,     
この前提が崩れてしまえば, 4次の精度は出ない.     
Runge-Kutta 法による時間積分     
上記の Runge-Kutta の4次公式を使って,     
前回の2元連立方程式の時間積分をして見よう.    
すでに, 時間微分を subroutine     
で計算するように書き直してあるので, Runge-Kutta     
の公式をほとんどそのまま次のように書き下せばよい.    
............省略 ..........
*--------------- time integration ------------------
do i=1, n-1
call drv(x(i)      , y(i)      , dx1, dy1)
call drv(x(i)+dx1/2, y(i)+dy1/2, dx2, dy2)
call drv(x(i)+dx2/2, y(i)+dy2/2, dx3, dy3)
call drv(x(i)+dx3  , y(i)+dy3  , dx4, dy4)
x(i+1) = x(i) + (dx1 + 2*(dx2 + dx3) + dx4) / 6
y(i+1) = y(i) + (dy1 + 2*(dy2 + dy3) + dy4) / 6
end do
............省略 ..........
このプログラムで dt をいろいろ変えて計算してみるとよい.     
r-k11.f90  
Euler 法に比べて,     
かなり精度がよくなっていることがわかるだろう。しかも、この方法は問題をあまり選ばない。   
r-k01.f90  
精度の比較  
euler13.f90  
rk-13.f90  
ここまでの話   
ここまで,   
dx
= ax    (1)
dt
という形と   
dx
= −by    (2a)
dt
dy
=  bx    (2b)
dt
という形の微分方程式を扱ってきた.   
ここで, (2) をもう少し一般化して,     
dx
= ax−by    (3a)
dt
dy
= bx+ay    (3b)
dt
という形の方程式を考えてみよう. この方程式は, b=0 ならば, (1)     
の形, a=0 ならば (2) の形になる. 両方とも 0 でないときには,     
「らせん形」の解を持つ.    
n 元の一般的な微分方程式を考えると,     
これらの方程式は非常に簡単なものに見えるが, 実は,     
一般の線型常微分方程式のほとんどは,     
上記の2つの方程式形に帰着できることを 以下に示す.     
2次元の固有値固有ベクトル問題.    
独立変数 (x,y) をベクトル X で表して, 2次元の微分方程式を     
dX
= AX    (4)
dt
と表す. ここで, A は2x2行列である.     
この行列の 固有値 をλ1, λ2とし,     
それらに対応する 固有ベクトル を e1,     
e2とする. この固有ベクトルの方向にベクトル Xi = x0     
ei を考えて, (4)式に代入すると,     
dxi
= λix   (5)
dt
となる. ここで, 2次元のベクトルの方程式(4)     
がスカラーの方程式になったことに 注意してほしい. つまり,     
2つの独立した固有ベクトルが存在するときには,     
その固有ベクトルを基底にするように座標変換を施せば,    
dX
= AX    (6)
dt
｜λ1,0｜
A=｜    ｜
｜0,λ2｜
となり, それぞれの成分は独立に (1) の形になる.     
したがって, (4)の一般解は,     
X = c1 exp(λ1t) e1 + c2 exp(λ2t) e2
となる. (ci は任意定数)     
上記のことはλが複素数でもなりたつが,     
複素数の場合には2つの固有値は複素共役なので,     
さらに変数変換することにより虚数部を消去して,    
｜a,−b｜
A=｜    ｜
｜b, a｜
λ=a±ib
と書くことができ, 解は,     
X =  exp(at){c1 cos(bt) e1 + c2 sin(bt) e2 }
となる. (ci は任意定数)     
つまり, 独立な固有ベクトルが存在すれば,     
2次元の一般的な微分方程式(4) は変数変換により, (1) と (3)     
に帰着させることができ, 解はその1次結合で表される.     
固有ベクトルが独立でない場合    
2つの固有値が同じで, 固有ベクトルまで同一, つまり,     
2つの独立した固有ベクトルが得られない場合がある. (固有値が同じでも,     
最初から行列 A が対角化されている場合には,     
固有ベクトルは独立に存在する.) そのような場合でも,     
座標変換により,    
｜λ,0｜
A=｜   ｜
｜1,λ｜
という形にかける.    
この場合, 1つの成分に関しては (1) の形になるので,     
他方の成分と無関係に解くことができる. そして, その解に(t+c2)     
(c2 は定数) をかけたものが他方の解になっていることも,     
微分方程式に代入してみればわかる. 結局, この場合の一般解は,     
X =  c1 exp(λt){ e1 + (t-c2) e2}
となる.    
n次元線型常微分方程式    
一般に n次元の問題でも,     
2次元の場合と同様に考えることができる.    
すなわち, 基底ベクトルを適当に選べば,     
｜λ1           ｜
｜ λ2          ｜
｜  λ3      0  ｜
｜   λ4        ｜
｜    ・        ｜
A=｜     ・       ｜
｜      P1     ｜
｜       P2    ｜
｜  0     P3   ｜
｜         ・   ｜
｜          ・  ｜
とかける. ここで, Pi     
は同一固有値に属する成分のブロックで,     
｜λi      ｜
｜1λi   0 ｜
｜ 1λi    ｜
Pi=｜  1λi   ｜
｜   1λi  ｜
｜ 0  1λi ｜
｜     1λi｜
である. 上のAをJordan標準形, その中のPi を Jordan     
細胞と呼ぶ. 同一固有値が n 個ある場合には, Jordan 細胞の大きさは     
n x n で, 2次元の場合と同様 exp(λt) に t, t2, ... tn-1     
を かけたものも独立な解になる.     
これも, Jordan 細胞以外の固有値が複素数の場合には,     
2次元の場合と同様, その部分を     
｜a,−b｜
A=｜    ｜
｜b, a｜
λ=a±ib
と書き直すことで, 実数だけで表現できる. Jordan     
細胞の部分に関しては, 複素固有値に対応する Jordan細胞     
2つ分(複素共役)が    
｜A      ｜
｜IA   0 ｜
｜ IA    ｜
B=｜  IA   ｜
｜   IA  ｜
｜ 0  IA ｜
｜     IA｜
となる. ここで     
｜a,−b｜
A=｜    ｜
｜b, a｜
λ=a±ib
｜1,0｜
I=｜   ｜
｜0,1｜
である. したがって, n 次元の場合も, 一般解は (1) および (3)の形の方程式の解の一次結合,     
および, 同一固有値がある場合は, その数だけ t     
のべき乗をかけたものの一次結合が 解となる.     
一般の線型常微分方程式    
ここまでは n次元の連立方程式の話であったが, ここで, n階の微分方程式     
dnX      dn-1X
+cn-1   ・・・c1X +c0=0
dtn      dtn-1
を考えてみよう.    
dX
X1≡
dt
dX1
X2≡
dt
・・・・
・・・・
と新しい変数を定義すると,    
dXn-1   n-1
+ Σ ci Xi +c0=0
dt      i=1
となり, Xi の定義式とあわせて, n元の1階連立常微分方程式系に帰着する.     
したがって, 線型方程式である限り,     
すべての常微分方程式の解は exp(λt), sin(λt), cos(λt) および,     
多重固有値がある場ある場合には, それらにt     
のべき乗をかけたものの一次結合で表される.    
なぜ数値積分    
このように,     
線型常微分方程式に関しては非常に美しくかつ簡単に扱えるように見える.     
ここまで, わかっているなら, なぜ,     
数値的に積分する必要があるのだろうか. まず,     
上記の方法で実際に,     
与えられた初期値から時刻tの値を求めることを考えてみよう.     
そのためには    
1: 固有値を求める.
2: 固有ベクトルを求める.
3: 固有ベクトルを基底とする座標系に初期値を変換する.
4: 各成分の時刻 t の値を求める.
5: もとの座標に戻す.
という処理が必要である. 上では,     
概念的な説明しかしなかったが,     
実際にこれらの処理をするのはかなり難しい. 特に, 2の固有ベクトルを求めるのは次元が大きくなると非常に難しくなる.     
したがって, 具体的な解が必要な場合には,     
上記の手続きをとらずに,     
素直に数値積分した方が簡単で早い場合が多い.    
だったら, なぜ, ややこしい代数の話をするかといえば,     
固有ベクトルに分解せずに数値積分する場合でも, その過程では,     
Jordan 標準形に直した方程式を積分しているのと     
同じことが起こっているからである. すなわち,     
多次元の常微分方程式形の数値積分をするということは,     
各固有値に対応した解を同時平行で解いているのと同じである.    
前回までの計算では dt     
を固有値の逆数よりもかなり小さくとらないと     
十分な精度で計算できなかったし, 最悪の場合は発散してしまって     
計算がストップしてしまった. n 元連立方程式を解く際には,     
各固有値に対応する解がどれか一つでも発散すると,     
すべての計算ができなくなる. したがって, dt     
は最大固有値の逆数よりも小さくとらなければならない.    
つまり, 数値積分する場合でも, その前に, 1:     
の固有値を求めることは最低限やっておかなければならない.     
もちろん, 厳密にすべての固有値を求める必要はない.     
最大固有値の大体の値がわかればよい. 要するに,     
全くえたいの知れない方程式をなにも考えずに積分するのは     
非常に危険である.    
高次の積分公式と一般的な微分方程式
