はじめに:なぜ Google C++ Testing Frameworkを使うのか¶
Google C++ Testing Framework を上手に活用すれば,より良い C++ のテストを書くことができます.
Linux,Windows,そして Mac,あなたが C++ のコードを書いているこれらの環境に関係なく Google Test を利用できます.
では,優れたテストを書くにはどうすればよいのでしょうか?Google C++ Testing Framework は,どのように役立つのでしょうか?我々は次のように考えています:
テストには, 独立性 と 再現性 が必要です.別のテストの結果に依存して成功したり失敗したりするテスト,をデバッグするのは非常に面倒な作業です.Google C++ Testing Framework は,各テストを異なるオブジェクト上で実行することによって,テストの独立性を保ちます.Google C++ Testing Framework は,これらを独立に実行するので,テストが失敗したときに迅速なデバッグが行えます.
テストは,よく 整理され ,かつテストコードの構造を反映したものであるべきです.Google C++ Testing Framework は,関連するテスト同士を,データとサブルーチンを共有するテストケースとしてグループ化します.これにより,テストを理解しやすくなり,メンテナンスが簡単になります.このような一貫性は,プロジェクトが変わって新たなコードを扱い始める人にとっては,特に役立ちます.
テストは, 移植性 があり再利用できるものであるべきです.オープンソースのコミュニティには,プラットフォームに依存しないコードが多くあり,それらのテストもプラットフォーム非依存であるべきです.Google C++ Testing Framework は,様々な OS やコンパイラ(gcc,MSVC など)上で,例外を使用するかしないかに関係なく動作します.よって,Google C++ Testing Framework のテストでは,様々な動作条件を簡単に試すことができます.(ただし,現在のリリースでは,Linux用のビルドスクリプトのみが付属します.ほかのプラットフォーム用のスクリプトも鋭意開発中です.)
テストが失敗した場合,その問題に関する 情報 をできるだけ多く出力するべきです.Google C++ Testing Framework は,最初にテストが失敗した箇所では停止しません.代わりに,現在のテストを停止して,次のテストに移ります.また,致命的ではない失敗をレポートして,そのまま現在のテストを続けるように設定することもできます.したがって,1回の「実行-編集-コンパイル」サイクルで複数のバグを検出して修正することができます.
Testing Framework は,テストを書くユーザがテスト内容に集中できるようにするものです.つまり,それ以外の雑多な作業をユーザにさせてはいけません.Google C++ Testing Framework は,定義されたすべてのテストを自動的に追跡するので,ユーザがそれらを実行順に並べたりする必要はありません.
テストは 高速 に動作するべきです.Google C++ Testing Framework を使えば,共有リソースを再利用することができ,互いに依存しあうようなテストを作らずに,開始/終了のための処理は1度行うだけで済みます.
Google C++ Testing Framework は,有名な xUnit アーキテクチャに基づいているので,以前に JUnit や PyUnit を使ったことがあれば,すぐに馴染むことができるでしょう.もし使ったことがなくても,10分もあれば基本を学んで使い始めることができるようになります.さぁ,では始めましょう.
注意 : Google C++ Testing Framework を,Google Test と呼ぶ場合もあります.
新しいテストプロジェクトを開始する¶
Google Test を使ったテストプログラムを書くには,Google Test をライブラリとしてコンパイルし,それをテストにリンクする必要があります.有名なビルドシステム用のビルドファイルが用意されています:(Visual Studio 用の msvc/,Mac XCode 用の xcode/,GNU make 用の make/,Borland C++ Builder 用の codegear/,Scons 用の scons/,そして Google Test ルートディレクトリにある autotools スクリプト).あなたのビルドシステムがリストない場合,make/Makefile を見て,Google Test がどのようにコンパイルされるかを調べることができます. (通常,GTEST_ROOT および GTEST_ROOT/include をインクルードパスに入れて,src/gtest-all.cc をコンパイルします.ここで,GTEST_ROOT は Google Test のルートディレクトリです).
Google Test ライブラリをコンパイルできれば,後はプロジェクトを作成したり,テストプログラム用のターゲットをビルドしたりできるでしょう.コンパイル時にコンパイラが “gtest/gtest.h” を見つけられるように,GTEST_ROOT/include がインクルードパスに含まれていることを確認してください.また,Google Test ライブラリをリンクするようにプロジェクトを設定してください(例えば,Visual Studio の場合,gtest.vcproj への依存を追加することで実現できます).
まだ分からないことがあれば,Google Test 自身のテストがどのようにビルドされ,どのように使われているかを調べてみてください.
基本コンセプト¶
Google Test を利用する場合,アサーション,つまり,ある条件が真かどうかを調べる文,を書くところから始まります.アサーションの結果には,成功,致命的ではない失敗,致命的な失敗,があります.致命的な失敗が起きた場合は,現在実行中の関数が中断され,それ以外の場合は,通常通りプログラムが続行されます.
テスト は,アサーションを利用してテスト対象コードの動作を検証します.テストがクラッシュしたり,アサーションが失敗したりした場合,テスト自体が 失敗 となります.それ以外の場合は,テスト成功となります.
1つの テストケース には,1つまたは複数のテストが含まれます.テスト対象コードの構造を反映するように,テストをテストケースとしてグループ化してください.1つのテストケースに複数のテストが含まれており,共通のオブジェクトやサブルーチンを共有する必要がある場合,それをテストフィクスチャクラスに書くことができます.
1つの テストプログラム は,複数のテストケースを含むことができます.
では,個々のアサーションレベルから始めて,テスト,テストケースと段階的に進むことで,テストプログラムの書き方を説明していきます.
アサーション¶
Google Test のアサーションはマクロであり,関数呼び出しと似たようなものです.クラスや関数のテストを行うには,それの動作を調べるアサーションを定義します.アサーションが失敗すると,Google Test は失敗を知らせるメッセージと共に,アサーションのソースファイルと失敗した箇所の行番号を出力します.また,Google Test のメッセージに追加する形で,ユーザ定義の失敗メッセージを出力することもできます.
現在実行中の関数で同じテストを行っても,その挙動が異なるアサーションが存在します.ASSERT_* バージョンが失敗した場合,致命的な失敗となり, 現在実行中の関数を中断します. EXPECT_* バージョンでは,致命的ではない失敗となり,関数を中断することはありません.1度のテストで複数の失敗を報告できるので,通常はEXPECT_* が好まれます.しかし,問題のアサーションが失敗した後にプログラムを続行しても意味がない場合は,ASSERT_* を利用してください.
ASSERT_*が失敗すると,その関数から直ちに戻るので,その後に実行されるはずだった後処理のコードをスキップしてしまう可能性があります.これは,メモリリークの原因になる可能性があります.これを修正する価値があるか否かは,リークの種類に依存します.アサーションエラーに加えてヒープエラーも調べる場合は,このことを覚えておいてください.
ユーザ定義の失敗メッセージを出力するには,単に<<演算子を用いて,そのメッセージをストリームに出力するだけです.以下に例を示します:
入門ガイド &mdash; Google Test ドキュメント日本語訳
