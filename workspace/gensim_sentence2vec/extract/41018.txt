マルチスレッドモデル 
大部分のマルチスレッドモデルは、以下のいずれかの形態で実装されています。
複数対単一
単一対単一
複数対複数 
「複数対単一」のモデル (グリーンスレッド)
「複数対単一」のモデル (1 つのカーネルスレッドに対してユーザースレッドが複数のモデル) では、アプリケーションは、並列に動作できるスレッドをいくつでも作成できます。スレッドのすべての動作はユーザー空間のみに限定されます。カーネルにアクセスできるスレッドは一度に 1 つだけなので、スケジューリング可能な 1 つのエンティティ (実体) だけがオペレーティングシステムに認識されます。このため、「複数対単一」のマルチスレッドモデルでの並列処理は限定されたものになり、マルチプロセッサが有効に利用されることはありません。Solaris システムにおける Java スレッドの初期の実装は、この「複数対単一」のモデルでした。  
図 2-1  「複数対単一」のマルチスレッドモデル「単一対単一」のモデル
「単一対単一」のモデル (1 つのカーネルスレッドに対してユーザースレッドが 1 つのモデル) は、正しいマルチスレッドの初期の実装の 1 つです。「単一対単一」のモデルでは、アプリケーションによって作成されたユーザーレベルのスレッドはそれぞれカーネルによって認識され、すべてのスレッドが同時にカーネルにアクセスできます。「単一対単一」モデルの最大の問題は、スレッドが増えるほどプロセスが重くなるため、開発者はそのことを考慮しながらスレッドをあまり多く使用しないようにする必要があることです。このため、Windows NT や OS/2 のスレッドパッケージなどの「単一対単一」モデルのスレッド実装の多くは、システムでサポートされるスレッド数を制限しています。  
図 2-2  「単一対単一」のマルチスレッドモデル「複数対複数」のモデル (Solaris 上の Java - ネイティブスレッド) 
「複数対複数」のモデル (複数のカーネルスレッドに対してユーザースレッドが複数のモデル) は、「単一対単一」のモデルが持つ制限の多くを解消し、マルチスレッドの応用範囲を広げます。2 レベルモデルとも呼ばれる「複数対複数」のモデルは、各スレッドの負荷を軽減し、プログラミング作業も簡潔になります。「複数対複数」のモデルでは、プログラムは、プロセスを重くしすぎることなく適切な個数のスレッドを持つことができます。ユーザーレベルのスレッドライブラリによって、カーネルスレッドの上位でユーザーレベルのスレッドをスケジューリングすることが可能になります。カーネルが管理する必要があるのは、アクティブになっているスレッドだけです。ユーザーレベルで「複数対複数」のモデルが実装されることにより、アプリケーションで効果的に使用できるスレッド数の制限がなくなるため、プログラミング作業が軽減されます。つまり、標準のインタフェースを持つより簡単なプログラミングモデルが提供され、すべてのプロセスについて最高のパフォーマンスが得られるようになります。Solaris 上の Java オペレーティング環境は、市販製品で初めてマルチスレッドオペレーティングシステムに「複数対複数」モデルの Java が実装された環境です。  
図 2-3  「複数対複数」のマルチスレッドモデル

