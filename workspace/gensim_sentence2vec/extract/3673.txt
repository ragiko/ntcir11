この章ではクラス、インタフェース、パッケージそしてコンパイル単位に焦点をあてる。クラスはオブジェクトがインスタンス化(生成)されるときの雛形(テンプレート)となるもので、フィールドとメソッドの定義から構成される。インタフェースはメソッドとフィールドに関する共通のシグネチャを定義したもので、シグネチャはこれを実装するクラスはかならず提供しなければならない。パッケージは関連あるクラスを集めたもの。コンパイル単位とはクラスやインタフェースが定義されている1つのソースコードファイルである。Javaではコンパイル単位をデータベースに保存してもよいので、個々のコンパイル単位が直接物理的なソースコードファイルでなくてもよい。
6.1  クラス標準
クラスにとって重要な標準は以下に基づく。
可視性
命名規約
ドキュメント規約
宣言規約
public、protectedなインタフェース
6.1.1  クラス可視性
クラスは2つのうち1つの可視性を持つ。すなわちpublicかパッケージ(デフォルト)である。public可視性はキーワードpublicによって示され、パッケージ可視性の場合は何も示さない(キーワードがない)。publicクラスは他のすべてのクラスから見ることができ、パッケージ可視性のクラスは同一パッケージ内のクラスだけが見ることができる。
コンポーネント内部のクラスはパッケージ可視性を使う
パッケージ可視性によってパッケージ内にクラスを隠蔽することができ、コンポーネント内部に効果的にカプセル化する。
コンポーネントのファサードにはpublic可視性を使う
コンポーネントはコンポーネントのインタフェースを実装したクラスとコンポーネント内のクラスへメッセージを配信するファサードクラスによってカプセル化される。
6.1.2  クラス命名
Java標準は正しくフルスペルで、最初の1文字は大文字とし、複数の単語をつなげるときは、続く単語の最初の1文字も大文字とする(Gosling,Joy,Steele,1996;Sandvik,1996;Ambler,1998a)。
Customer
Employee
Order
OrderItem
FileStream
String
6.1.3  クラスドキュメント
以下の情報がクラス定義の直前におかれるドキュメント化コメントに書かれていること。
クラスの目的
開発者がそのクラスの大まかな目的を見て、要求に合致しているかどうか判断できるようにする。また、例えばそのクラスがある設計パターンの一部を担っているとか、クラスを使う上での制限事項について書くように習慣付ける。
既知のバグ(13)
そのクラスについて判明している問題があれば記述し、他の開発者にとってクラスの弱点・障害点が分かるようにする。また、そのバグが修正されていない理由を記述する。ただし、もしバグがある一つのメソッドに特定されるならば、直接メソッドドキュメントの方に記述する。
開発・保守履歴
日付・修正者・変更概要を記した履歴表を付けるのは一般的な習慣である(Lea,1996)。この目的は保守プログラマーに過去にどんな修正が、いつ誰によってなされたのかを知らせることにある。メソッドの時と同様、この情報は構成管理システムに含むべきで、ソースファイル自身に含めるべきではない。
不変条件をドキュメント
不変条件はインスタンスあるいはクラスが定常期間(stable time)の間、満たさねばならない表明の集まりである。定常期間(stable time)とは、該当インスタンスもしくはクラスのメソッドが起動される前からメソッドが起動された直後までと定義される(Meyer,1988)。クラスの不変条件をドキュメントすることによって、他の開発者にクラスがどのように使われるかを示す。
並行性に関する戦略
Runnableインタフェースを記述したクラスは、その並行戦略を完全に記述しなくてはならない。並行プログラミングは多くのプログラマーにとって新しくて複雑な話題であり、特に時間を割いて何を意図しているのか確実に理解できるようにドキュメントを記述すること。また、なぜその他多くの戦略の中からそれを選んだかを書くことが重要である。一般的に並行戦略(Lea,1997)には次の事柄が含まれる:同期オブジェクト、balking objects、番兵オブジェクト、バージョンオブジェクト、並行ポリシー制御、アクセプタ等。
そう、バグを修正するのはよいことだ。しかし、そうする時間を取れなかったり、作業するのがその時は重要でなかったりする。例えば、負の数を渡したときにメソッドが正しく動作しないかもしれないが、正の数では正しく動作することを知っていたとする。アプリケーションでは正の数しか渡さないならば、問題が存在することをドキュメントし、そのバグを生かしたままにできる。
6.1.4  クラスの宣言
6.1.4.1  finalキーワードを注意深く適用する
finalキーワードを継承できないクラスを示すために使う。これは元の設計者の設計上の判断であり、軽く考えるべきではない。
6.1.4.2  メソッドとフィールドの順序
クラスを理解容易にするために、一貫したやり方でクラスを宣言する。Javaにおいて一般的なやり方は、クラスを最も可視性の高いものから最も可視性の少ない順に宣言していき(NPS, 1996)、最も重要な特性であるpublicなものを最初に見つけやすいようにする。Laffra(1997)氏は、コンストラクタとfinalize()を最初に置くことを提唱している。たぶんこれらが他の開発者がクラスをどう使うのか理解するために最初に見るメソッドだからである。さらに、すべてのフィールドはprivateとして宣言するという標準を持っているから、宣言の順番は以下のようになる。
コンストラクタ
finalize()
public メソッド
protected メソッド
private メソッド
private フィールド
メソッドのそれぞれのグループ内での順番は、アルファベット順とする。多くの開発者は静的メソッドを先に、インスタンスメソッドを次に宣言し、この2つのグループ内のメソッドもアルファベット順にならべる方法を取っている。どちらのやり方も妥当であるので、どちらにするか選んだならばそれを固持すること。
6.1.5  PublicとProtectedなインタフェースを最小限にする
オブジェクト指向設計の原則の1つは、クラスの公開インタフェースを最小限にすることである。その理由は以下のとおり。
学習容易性
クラスをどのように使うか習得するには、公開されているインタフェースを理解するだけでよい。公開されているインタフェースを少なくすればクラスを学びやすくなる。
結合度を疎にする
あるクラスのインスタンスが別なクラスのインスタンスや直接そのクラス自身にメッセージを送っているならば、2つのクラス同士は結合していることになる。
公開インタフェースを最小限ににすることで、結合の可能性を低減することにもつながる。
柔軟性を大きくする
結合度と直接関係しているが、公開インタフェースの中の実装されているメソッドを変更(例えば戻り値を変更等)すると、そのメソッドを起動しているすべてのコードを修正しなくてはならない。公開インタフェースが少なければ少ないほどカプセル化が大きくなり、その結果柔軟性が大きくなる。
publicなインタフェースを少なくすることに価値があるのは明らかだが、protectedなインタフェースを少なくすべきかどうかは不透明である。サブクラスの視点でみると、スーパークラスのprotectedなインタフェースはpublicと同じ効果を持つため、protectedなインタフェースのどのメソッドもサブクラスから起動することができる。それゆえ、publicなインタフェースを最小化することと同じ理由でクラスのprotectedなインタフェースを最小化する。
6.2  インタフェース標準
インタフェースにとって重要な標準は以下のとおり。
命名規約
ドキュメント規約
6.2.1  インタフェースの命名
Java言語の規約ではインタフェース名を正しくフルスペルで、最初の1文字は大文字とし、複数の単語をつなげるときは、続く単語の最初の1文字も大文字とする。また、RunnableやCloneableのように副詞が使われることが多い。もちろんSingletonやDataInputのような名詞も一般的に使用される。
6.2.1.1  代替案
インタフェース名に接頭詞'I'を付加する
Coad氏, Mayfield氏ら(1997)が提案している方法でインタフェース名の先頭に'I'を付け加え、例えばISingletonやIRunnableのように命名する。このやり方は、パッケージ名やクラス名とインタフェース名とを一目で区別することができる。この命名則で私がよいと思っているのは、クラス図(オブジェクトモデル)が分かりやすくなるという点である。欠点はRunnableのような既存のインタフェースがこの命名則を使っていない点で、これは今後も変わるとはないことである。それゆえ、私は上述の事実上の標準を選択した。
このインタフェース命名は、MicrosoftのCOM/DCOMアーキテクチャで使われている規約でもある。
インタフェース名に接尾詞'Ifc'を付加する
Lea氏が提案(1996)している方法でインタフェース名の最後に'Ifc'を付け加え、例えばSingletonIfcやRunnableIfcのように命名する。インタフェース名は常にクラス名と同様となる(Lea,1996)。この考え方全般はよいと思っているが、私なら名前の接頭詞に'Interface'とフルスペルを使うだろう。この命名則が持つ問題は前述1.と同じである。
6.2.2  インタフェースのドキュメント
以下の情報がインタフェース定義の直前におかれるドキュメント化コメントに書かれていること。
目的
他の開発者はインタフェースを使用する前に、そのインタフェースがカプセル化しようとしている概念を理解する必要がある。すなわち目的である。インタフェースを定義するべきか否かを判定するよい方法は、その目的が簡潔に記述できるか否かである。簡潔に記述できない場合はインタフェースを使わない。なぜならば、オブジェクト指向の初心者が継承、とりわけ多重継承を乱用しがちであったように、Javaの初心者がインタフェースを乱用する傾向があるためである。
どのように使うか、使わないべきか
インタフェースをどのように使うかということと、どのように使ってはいけないかの両方を知る必要がある(Coad &Mayfield,1997)。
インタフェースでは、メソッドのシグネチャが定義される。個々のメソッドのシグネチャ定義については前の章で述べたメソッドのドキュメント規約に従う。
6.3  パッケージ標準
パッケージにとって重要な標準は以下のとおり。
命名規約
ドキュメント規約
6.3.1  パッケージの命名
パッケージについての命名規約を順番に示すと
識別子の間はピリオドで区切る
パッケージ名を読みやすくするために、Sunはパッケージ名の中で識別子をピリオドで分割することを提唱している。例えばjava.awtは、javaおよびawtの2つの識別子を含む。
SunによるJava標準パッケージは、'java'または'javax'の識別子で始まる
Sunがこの権利を予約しており、開発に使っているJava開発環境に関わらず、標準Javaパッケージは一貫した方法で命名される。
ローカルなパッケージ名は小文字で記述する
ローカルなパッケージとは組織内部で使用され、他の組織へは配布されない。こうしたパッケージの例としては、persistence.mapping.relationalとかinterface.screensとかがある。
グローバルなパッケージ名は組織について割り当てられているインターネットドメイン名にもとづいて命名する
他のいくつかの組織へ配布されるパッケージは、組織のドメイン名で始まる名前を含むものでなくてはならない。トップレベルのドメイン種類は小文字で記述する。例えば前項のパッケージを配布するならば、私はcom.ambysoft.www.persistence.mapping.relationalとcom.ambysoft.www.interface.screensと命名する。接頭辞(.com)は小文字とし、インターネット標準のトップレベルドメイン名(現時点ではcom, edu, gov, mil, net, orgなど)でなくてはならない。
パッケージ名は単数形とする
共通の規約は、パッケージ名にinterface.screensのような複数形ではなく、interface.screenのように単数形の名前を使用する。
6.3.2  パッケージのドキュメント
パッケージの目的を記述した1つ以上の外部文書を記述し保守する必要がある。個々のパッケージ毎に以下のことをドキュメントする。
パッケージの理論的説明
他の開発者が、そのパッケージがいったい何であるかを知り、それが使えるかどうか判断できる必要がある。また、パッケージが共有されるならば、それを改善・拡張してよいかどうか分かる必要がある。
パッケージに存在するクラス
パッケージに含まれるクラス、インタフェースの一覧にそれぞれの簡潔な1行説明を記述し、他の開発者がパッケージ内容を知ることができるようにする。
Lea氏(1996)は、それぞれのパッケージ毎にindex.htmlという名前のHTMLファイルを作成し、パッケージのディレクトリに置くことを提唱している。もっとよいHTMLファイルの名前は、パッケージの完全限定名に.html拡張子をつけたものにすることである。(14)こうすれば、あるパッケージのドキュメントファイルを別なもので上書きしてしまう事故を防ぐことができる。Lea氏の考え方には大枠賛成だが、私の経験上似た名前のファイルは上書きされてしまうので、彼のアプローチに一部修正を加える。
頑健なJavaプログラムの書き方
