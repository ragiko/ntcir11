4.6. パターンマッチング
PostgreSQL にはパターンマッチングを行うに際して二つの異なった手法があります。ひとつは SQL
の LIKE 演算子を使う方法と、もうひとつ 
POSIX 標準の正規表現を使う方法です。 Tip: 
これらの機能以上のパターンマッチングが必要であったり、パターン駆動型の置換や変換を行いたい場合は Perl や Tcl を使ってユーザ定義関数を書くことを試みてください。4.6.1. LIKE を使ったパターンマッチングstring LIKE pattern [ ESCAPE escape-character ]
string NOT LIKE pattern [ ESCAPE escape-character ]
それぞれの pattern は文字列の、ある集合を定義します。 LIKE 式は pattern
によって示される文字列の集合に string が含まれていれば真を返します。(想像されるとおり、NOT LIKE
式は LIKE 式が真を返す場合には偽を返し、その逆もまた同じです。同等の式として NOT
(string LIKE
pattern) とも表現できます。)
pattern がパーセント記号 (%) もしくはアンダースコア (_) を含んでいない場合 pattern は自身の文字列そのものです。この場合 LIKE 式は等号演算子のように振舞います。 pattern の中にあるアンダースコア (_) はすべての一文字とのマッチを意味し、パーセント記号 (%) は 0 文字以上の文字列とのマッチを意味します。
例を幾つか挙げます。'abc' LIKE 'abc'    真
'abc' LIKE 'a%'     真
'abc' LIKE '_b_'    真
'abc' LIKE 'c'      偽
LIKE によるパターンマッチは常に文字列全体に対して行われます。ですから、文字列内のいかなる位置に於いてもパターンマッチさせるにはパーセント記号を始めと終りに附ける必要があります。
リテラルのアンダースコアやパーセント記号を他の文字のマッチングに使用するのではなくそのものをマッチさせたい場合には、
pattern の中のそれぞれのアンダースコアとパーセント記号はエスケープ文字でエスケープされなければなりません。デフォルトのエスケープ文字は逆スラッシュですが、ESCAPE
句で他の文字を指定することがでいます。エスケープ文字そのものをマッチさせるにはエスケープ文字をふたつ書きます。
リテラル文字列において逆スラッシュには始めから特別な意味合いがあるので逆スラッシュを含んだパターン定数を記述するときは問い合わせの中で 2 つの逆スラッシュを記述する必要があることに注意してください。
ESCAPE 句で他のエスケープ文字を選択すればこのような状況を回避でき、逆スラッシュは LIKE 式にとり特殊な文字ではなくなります。(とはいっても、リテラル文字列パーサにとっては依然として特殊文字なので、やはり 2 つは必要です。)
同時に ESCAPE '' と記述することでエスケープ文字を選択しないことも可能です。この場合にはパターン内のアンダースコアとパーセント記号に特別な意味を持たせなくすることはできません。
現在動いているロケールに従って大文字小文字を区別しないマッチを行うのであれば LIKE の替わりに ILIKE キーワードを使うことができます。これは SQL 標準ではありませんが PostgreSQL の拡張です。
~~ 演算子は LIKE 式と等価で、~~* は ILIKE に対応します。また NOT LIKE および NOT
ILIKE を表す !~~ および !~~* 演算子があります。これらすべての演算子は PostgreSQL
固有のものです。4.6.2. POSIX 正規表現Table 4-10. 正規表現マッチ演算子演算子説明例 ~ 正規表現にマッチ、大文字小文字の区別あり'thomas' ~ '.*thomas.*' ~* 正規表現にマッチ、大文字小文字の区別なし'thomas' ~* '.*Thomas.*' !~ 正規表現にマッチしない、大文字小文字の区別あり'thomas' !~ '.*Thomas.*' !~* 正規表現にマッチしない、大文字小文字の区別なし'thomas' !~* '.*vadim.*'
POSIX による正規表現はパターンマッチングという意味合いでは
LIKE 関数よりもさらに有力です。egrep、
sed、あるいは awk のような多くのUnix ツールはここで解説しているのと類似したパターンマッチング言語を使用しています。 
正規表現とは文字列の集合(正規集合)の簡略された定義である文字が連なっているものです。ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。 LIKE 関数を使った時と同じように、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とはいっても正規表現は LIKE
関数が使用するものと異なる特殊文字を使用します。LIKE 関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定 (anchoring) されていない限り文字列内のどの位置でもマッチを行えます。
POSIX 1003.2 の定義によると、正規表現 ("RE")には 2 つの形式があるとされます。最新の (modern) 正規表現(大まかにいって
egrep に代表されるもので  1003.2 では
"拡張 (extended)" ED と呼んでいる)、および使われなくなった正規表現(大まかには ed に代表されるもので 1003.2
では"ベーシック (basic)" 正規表現と呼んでいる)の二つです。
PostgreSQL は最新の形式を実装しています。
最新の正規表現はひとつまたはそれ以上の | で区切られた空でないブランチです。ブランチの一つとでもマッチすればマッチしたことになります。
ブランチはひとつまたはそれ以上の ピース の連結です。最初のピースからその次のピースへのマッチというふうにマッチされます。
ピースとは原子で、*、
+、?、あるいは 
バウンドが後に続く可能性があります。
* が後に続く原子は 0 回以上連続して原子とのマッチを行うマッチです。
+ が後に続く原子は 1 回もしくはそれ以上連続して原子とのマッチを行うマッチです。? が後に続く原子は 0 または 1 回原子とマッチを行います。
バウンドは、{ で始まり、その後に符号無し 10 進数整数が続き、その後にたぶん , が続き、そしてその後にこれもたぶんもう一つ符号無し 10 進数整数が続いて、最後は必ず } で括られます。整数は 0 から
RE_DUP_MAX (255) までの範囲であって、2 つ存在する場合最初の整数は 2 番目の整数より大きくあってはいけません。1 つの整数
i があってコンマを持たないバウンドが続く原子は正確に i 回連続して原子とマッチを行います。1 つの整数 i とコンマが付帯するバウンドが続く原子は i 回以上連続して原子とマッチを行います。2 つの整数 i と j
を持ったバウンドが続く原子は i から
j 回(i と j を含んだ間)連続して原子とマッチを行います。Note: 
反復演算子 (?、*、
+、もしくはバウンド)は他の反復演算子と併用することはできません。反復演算子は式または副式を開始させることや、
^ あるいは | の後に続くことはできません。
原子は(正規表現とマッチするマッチングを実行する)
() で括られた正規表現、(NULL 列とマッチングを実行する)
() の空集合、 括弧式(後述)、(いかなる 1 文字ともマッチングを実行する) .、(入力文字列の先頭にある NULL 文字列とマッチングを実行する) ^、(入力文字列の後尾のヌル文字列とマッチングを実行する) $ 、(本来の文字としてその文字がマッチングされる)文字 ^.[$()|*+?{\
の前に置かれる \、(あたかも \ が存在していなかったかのように、その文字が本来の意味を持つ文字としてマッチングされる)それら以外の文字が次にくる \、もしくは
{ の直後に数字以外の文字が続いたものは通常の文字で、バウンドの開始ではありません。\で正規表現を終了させることは禁じられています。    
逆スラッシュ (\) は元もとリテラル文字列において特別の意味が有ることに注意してください。ですから、逆スラッシュがあるパターン定数を記述するには問い合わせの中でふたつの逆スラッシュを記述しなければなりません。
角括弧内正規表現 (bracket expression) とは
[] で括られた文字のリストです。通常リストの中のいずれの一文字ともマッチを行います(以下も参照)。リストが
^ で始まっている場合はリストに有る残りの文字ではなくどんな一文字ともマッチを行います(以下も参照)。リストの中で二つの文字が - で分割されている場合、その文字を含んだ連鎖している繋がりの文字範囲を示す省略形です。例えば、
ASCII の [0-9] はすべての10 進数とマッチを実行します。a-c-e のように二つの終りの位置の範囲を指定することはできません。範囲はかなり連鎖の順番に依存しますので、移植性が求められるプログラムでは使用を避けてください。
リストにリテラル ] を含める場合は、(^ が存在すればその直後に)最初の文字とします。リストにリテラル - を含めたい場合は、最初の文字か最後の文字、もしくは範囲の終了とします。リテラル
- を範囲の開始としたい場合には照合要素(collating element、下記参照)とするために [. と .] で括ってください。。これらの例外と
[(次の段落を参照)の組み合わせ方の幾つかを除き、
\ を含むすべての特別な意味を持つ文字はその特殊性を角括弧内正規表現内で失います。
角括弧内正規表現内で、[. と .]
で囲まれた照合要素は(あたかも一文字か照合順序名であるかのように照合を行う一文字、または複数の文字列)その照合要素の文字列を意味します。文字列は角括弧内正規表現リストの単一の要素です。ですから、複数文字による照合要素のある角括弧内正規表現は一文字以上とマッチします。例えば、照合順序に照合要素 ch があると正規表現
[[.ch.]]*c は chchcc 文字列の最初の 5 文字とマッチを行います。
角括弧内正規表現内で、[= と =]
で囲まれた照合要素は等価クラスで、それ自身を含め、それと等価なすべての照合要素の文字列を意味します。(等価照合要素がない場合、囲んでいる角括弧の区切り文字は単なる [. と 
.] として扱われます。)例えば、o
と ^ が等価クラスの構成要素の場合、
[[=o=]]、[[=^=]]、および
[o^] はすべて同義です。等価クラスは範囲の終端指定にはできません。
角括弧内正規表現内で、 [: と :] に囲まれている文字クラスの名称はそのクラスに属する文字すべてのリストを意味します。標準文字クラス名には以下のようなものがあります。
alnum、
alpha、 blank、
cntrl、 digit、
graph、 lower、
print、 punct、
space、 upper、
xdigit。
これらは
ctype
で定義されている文字クラスを意味します。ロケールによりこれ以外のものが提供されることもあります。文字クラスは範囲の終端指定にはできません。
角括弧内正規表現には 2 つの特殊事例があります。角括弧内正規表現
[[:<:]] と [[:>:]] はそれぞれ単語の先頭と末尾のヌル文字列にマッチします。単語とはその前後に単語文字が付かない単語文字列と定義されます。単語文字とは( ctype で定義されている)英数字またはアンダスコアです。これは拡張で、互換性を持っていますが
POSIX 1003.2 で指定されていません。他のシステムに移植予定のソフトウェアなどには注意をして使用してください。
正規表現が文字列の中の 1 つ以上の部分文字列とマッチする場合に於いて正規表現は最初にマッチした部分文字列とマッチします。その位置からまた1 つ以上の部分文字列とマッチした際は、正規表現は最も長い部分文字列とマッチします。部分正規表現は、正規表現において先に開始した部分正規表現が後から開始された部分正規表現より優先するため、すべてのマッチは可能な限り長くても良いという制約に従う限りに於いて可能な限り長い部分正規表現ともマッチします。従って、より高いレベルの部分正規表現はより低いレベルの構成要素を有する部分正規表現より優先します。
マッチの長さは照合要素ではなく文字列で測られます。ヌル文字列は全くマッチする要素がない文字列よりも長いと考えられます。例えば、
bb* は abbbc の真中の 3 文字とマッチし、(wee|week)(knights|nights) は
weeknights のすべての 10 文字とマッチし、
abc に対して (.*).* がマッチされると、丸括弧内部分正規表現は 3 つの文字すべてにマッチし、
bc に対して (a*)* がマッチされると、全体の正規表現と丸括弧内正規表現はヌル文字列にマッチします。
もし大文字小文字を区別しないマッチングが指定されると、アルファベット文字の大文字小文字の区別が全くなくなったと同じ効果をあたえます。角括弧内正規表現の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、 例えば、x が 
[xX] となるように大文字小文字ともに角括弧内正規表現に実質的に転換されます。角括弧正規表現の中に現われたときは、(例えば、)
[x] が [xX] となり、また
[^x] が [^xX] となるように、すべての大文字小文字それぞれの対が追加されます。
メモリーによる制限を除けば正規表現の長さに特定の制限はありません。メモリーの使用はほぼ正規表現の大きさに線形比例し、バウンド反復を除いて正規表現の複雑さにはほぼ無関係です。バウンド反復はマクロ拡張で実装されていて、反復回数が多かったり、バウンド反復が入れ子になっていると処理時間とメモリー空間を犠牲にします。例えば、
((((a{1,100}){1,100}){1,100}){1,100}){1,100} のような正規表現は(つまるところ)現存するほとんどのマシンでスワップ領域を使い切ってしまいます。
[1]Notes[1]
ここは 1994 年に書かれたもでです。気になりませんか。数値はたぶん変わっているでしょうが問題は存続しています。PrevHomeNextバイナリ列関数と演算子Upデータ型フォーマッティング関数
パターンマッチング
