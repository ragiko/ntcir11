
自作関数データのファイルへの取り込み  &dagger;
maechan? (2006-06-26 (月) 14:04:44)
ある行列データがありそれを一つのヒストグラムで見ようと思い行列を一列にするプログラムを書きました。それを画面上に表示することはできるのですがファイルに取り込む方法がわかりません。
関数の値をファイルに書き込む方法が知りたいです。
関数は -- maechan? 2006-06-26 (月) 14:06:36
?sink または ?capture.output --  2006-06-26 (月) 14:12:18
ありがとうございました。sinkでファイルに書き込むことができました -- maechan? 2006-06-26 (月) 14:27:15
> 行列を一列にするプログラムを書きました
プログラムを書くって,as.vector(行列オブジェクト)だけでことが済みますよね。
それと,ファイルに取り込むの?書き込むの?「関数の値」って何でしょうか。何を書き込んだり取り込んだりするのか。よくわかりませんでした。 --  2006-06-26 (月) 14:59:11
適当なエディタを開き,画面(コンソール)に表示されたものをコピーしてエディタのウインドウにペーストして,ファイルセーブするのが,一番簡単では?それに,プログラムだろうと,データだろうと,計算結果だろうと,何でもファイルにできますよ。エディタといえば,R だって自前のエディタを持っているんですよ。 --  2006-06-26 (月) 15:07:58
R-2.3.1のインストール手順10のファイルの上書き  &dagger;
初心者? (2006-06-24 (土) 12:03:31)
インストールの手順の最後にRconsole,Rdevga,Rprofile.siteをダウンロードし、同名ファイルに上書きとありますが、これらのファイルはどこからダウンロードしたらよいのでしょうか?
ファイル名のところにリンクが張ってありません?? --  2006-06-24 (土) 12:05:15
インターネットでは(そのほかでも),半角カタカナは使わないようにしましょう。(お節介をして,直しておきました) --  2006-06-24 (土) 12:31:10
ファイル名の所を押しても文字が出てくるだけなのですが? --  2006-06-24 (土) 16:09:24
MIMEタイプの設定がうまくできていないサーバーなんでしょうかね。
このような場合の対処法は,覚えておくと,今後得しますよ。
そのような場合は,うんとね,ういんどーずのようですから,右ボタンクリックで,リンク先の内容を保存する(ブラウザの種類・バージョンで言葉は違うだろうが)を選べばよいのではないかなと。(それにしても,ユーザに追加の処理を要求しないように,「私でも,インストールできます!」というような,ワンタッチ方式にはできないのだろうか?CRANとしてはむりでも,それをミラーリングする日本のサイトで独自のバイナリファイルをおいてもいいんじゃないか?特に,ういんどーず) --  2006-06-24 (土) 21:00:59
関数c()内でのargs[]の使用  &dagger;
チョコボール? (2006-06-23 (金) 07:21:00)
現在、perlでのスクリプトをバッチモードで使用しています。
変数を用いているのですが、c()の中では使用できません。
(こんなかんじ)
Y <- X[c(args[5])]
実行は
# R --vanilla --quiet --args test.pdf 3 5 3 < test.R
とやっています。
他の変数は得られています。
どなたかおしえてください。
あのね。追試できるように,必要なファイルを全て用意して,それらをどのように操作するかが分かるように記述した方が良いですよ。
なにも,あなたが実際にやったときのそのままのファイルを見せて!というんじゃなくて(全部見せられたら余計に困る),問題が再現できる短いファイルということです。
回答してみようかと思う人でも,あなたがどういう風にやったか分からないので,手も足も出せないんじゃないかなと思います。決して,回答は分かっているけど答えないというような,意地悪じゃないと思いますよ。
全体が見通せれば,「そういうことをやりたいのなら,こんな風にすれば良いんですよ」という別解(しかも,エレガントな別解)が提案されるかもしれません。 --  2006-06-24 (土) 21:26:44
すみませんでした。質問のしかたから勉強します。 --  2006-06-24 (土) 22:09:43
関数名を文字列に  &dagger;
ショーン? (2006-06-22 (木) 19:50:20)
以下のように関数オブジェクトを変数に入れて、関数として呼び出すことができると思いますが、
> a = cos
> a
.Primitive("cos")
> a(0)
[1] 1
後でaの元の関数名である、"cos"という文字列を得る方法はありますでしょうか?つまり、
> f2s(a)
[1] "cos"
のf2sようなことはできますでしょうか?
出来ないことは無いですが、まずなぜそんなことが必要なのか一言説明してもらわないと、答える気にはなりませんね。それに、例のようなことは内部関数にたいしてだけ出来ることですが。 --  2006-06-22 (木) 20:08:53
理由がないと教えられないと言うことでもないようには思いますが。
もっとも,私にはわかりませんでした。
変数に関数定義を付値したら,その変数の class は function になるので,元の名前と同じように使えますが,「そのようなことは内部関数に対してだけできること」というのもちょっと私にはわかりませんでした。 --  2006-06-22 (木) 21:16:11
> cubic.root <- function(x) x^(1/3)
> cubic.root(27)
[1] 3
> a <- cubic.root
> a(27)
[1] 3
> a
function(x) x^(1/3)
> class(a)
[1] "function"
答えるにはそれなりの手間がかかりますから、必要性が私には感じられない質問には(私は)たとえ答えを知っていても答える気にはなりませんよ、という意味です。そんなことに拘らず答えてあげようという親切な方はご自由に。また、直前の例では関数 a には元の関数の情報(名前) "cubic.rootが保存されませんから、a から文字列 "cubic.root" を復元することは原理的に不可能ですね。 --  2006-06-22 (木) 21:40:58
勉強の機会を与えてくれて,ありがとうございます。後者の場合に,名前を得る方法(に近いものを)さがしてみました。けど,是では,名無しさんさんが持っている解の方つまり,内部関数に対しては無力です。 --  2006-06-22 (木) 22:25:03
> f2s <- function(arg1, arg2)
+ {
+ 	for (i in arg2) {
+ 		cat(sprintf("ref <- %s?n", i), file="temp")
+ 		source("temp")
+ 		if (identical(ref, arg1)) print(i)
+ 	}
+ }
> cubic.root <- function(x) return(x^(1/3))
> a <- cubic.root
> f2s(a, ls())
[1] "a"
[1] "cubic.root"
> b <- sin
> f2s(b, ls())
[1] "b"
勉強になりました。内部関数の場合でも,たとえば以下のようなものでも,できないことはないですね。
来るか来ないか分からない答えを待つより,何とか考えてみるのもよいもんですね。
> f2s <- function(a)
+ {
+ 	sink("temp")
+ 	print(a)
+ 	sink()
+ 	res <- readLines(con="temp")
+ 	res <- sub("?.Primitive???(???"", "", res)
+ 	res <- sub("???"?)", "", res)
+ 	return(res)
+ }
> a <- sin
> f2s(a)
[1] "sin"
> b <- cos
> f2s(b)
[1] "cos"
うむ、あなたは初級者などでは決してない。何につかうのか秘密のようですが、第二の例は次のようにも出来ます。 --  2006-06-22 (木) 23:33:51
f2a <- function(x) {capture.output(x ,file=(filename <- tempfile())); unlist(strsplit(readLines(filename),"?""))[2]}
私は,原質問者じゃないよ。
だから,原質問者は用途が秘密だとは言っていない。
質問者をもてあそぶヒマはあっても,答えるヒマはないというのが,鼻についただけ。 --  2006-06-22 (木) 23:41:11
暇のある無しの問題ではありません。質問するからには、やはりなぜそんなことを知る必要があるのか(多くの自明な場合は除き)述べる方が、回答を得る可能性が高まりますよ、といいたかっただけ。 -- 某常連回答者? 2006-06-22 (木) 23:55:28
回答ありがとうございます。おかげさまでうまくいきそうです。f2sの使い道ですが、ユーザ次第でいろいろあるとは思いますが、私の場合は、
funcs = c(cos,sin,tan)
のようにして、ループでいろいろな関数のグラフを描こうと思っています。複数のグラフファイルができますが、そのときのファイル名を関数名にするためにf2sを使います。 -- ショーン? 2006-06-23 (金) 10:47:09
2006-06-22 (木) 23:33:51 は,もっと簡単になるでしょう? --  2006-06-23 (金) 10:47:31
f2a <- function(x)
{
unlist(strsplit(capture.output(x),'"'))[2]
}
引数...の長さ  &dagger;
ショーン? (2006-06-22 (木) 12:37:36)
可変長引数...の長さを知りたいのですが、以下のようにうまくいきません。
> func = function(...){print(length(...))}
> func(1,2,3)
以下にエラーprint(length(...)) : 'length' に対する引数の個数が正しくありません
「Rの関数定義の基本」を見るとlength(...)という書き方もあるように思えるのですが、何が間違っているのでしょうか?
次のようにする。nargs() は関数中でつかわれ、実引数の数を与える。 なぜ length(...) が失敗するかというと、今の場合 length(c(1,2,3)) でなく length(1,2,3) を実行しようとしたから。 --  2006-06-22 (木) 13:09:43
func <- function(...) print(nargs())
なるほど。
純粋に ... の個数を知りたい場合には,以下の方がよいのかな? --  2006-06-22 (木) 16:36:19
> func = function(a, ...){print(length(c(...)))}
> func(1,2,3)
[1] 2
【「Rの関数定義の基本」を見るとlength(...)という書き方もあるように思えるのですが】は記述が間違えているというか抽象的に書かれているので,実際にプログラムの中に書く場合には,可変長引数の一番最後の引数の参照は ...[length(c(...))] と書く必要がある。 --  2006-06-22 (木) 16:46:28
ショーンさんはlength(1:3)とlength(c(1,2,3))、length(1,2,3)の区別がついていなかったということですね。 --  2006-06-22 (木) 17:10:19
【「Rの関数定義の基本」を見るとlength(...)という書き方もあるように思えるのですが】は記述が間違えているというか抽象的に書かれている......済みません。ちなみに、... 引数の各項目を取り出すには次のように list(...)[[.]] とすれば良いようです。 -- 参照記事投稿者? 2006-06-22 (木) 17:20:22
> test <- function(i,...) print(list(...)[[i]])
> test(1,1,"abc",list(1:4),matrix(1:4,2,2))
[1] 1
> test(2,1,"abc",list(1:4),matrix(1:4,2,2))
[1] "abc"
> test(3,1,"abc",list(1:4),matrix(1:4,2,2))
[[1]]
[1] 1 2 3 4
> test(4,1,"abc",list(1:4),matrix(1:4,2,2))
[,1] [,2]
[1,]    1    3
[2,]    2    4
つまり、質問に対する汎用的な答えは length(list(...)) でしょうか。
ありがとうございました。よくわかりました。 -- ショーン? 2006-06-22 (木) 19:27:52
データ行列の行をまたぐレコード参照  &dagger;
ginga? (2006-06-21 (水) 15:19:35)
以下のような時系列データがあるとします
time  ID1  ID2   val1      val2
1    1077525908    1    2 35.256    90.188
2    1077529016    1    3 33.664    90.509
3    1077532131    1    3 30.543    68.935
4    1077535240    1    3 36.345   123.351
5    1077538354    1    5 36.408    93.581
6    1077541476    1    5 37.916   106.016
7    1077544589    1    2 35.809    93.094
...    .    .    ...       ...(数十万行)
ここで各行について,以下の処理をしたいというのは,R ではどのように書くのでしょうか?
for を使ってやるしかないでしょうか?
result[i] = (((他の行のtime - i行めのtime)< 10000) であり,
かつ (val1 < 35.0) となるレコードについて
ID2 のラベルが何種類あるか(ID2 が同じものは無視して可))
例えば 4行めだと ID2,3 が該当するので答えは 2 という感じです
(time では一応ソート済なので,処理の際に前後100行のみ,という感じにある程度スコープを絞ることはできますが,それがまたどう書くのか分からないです)
大量のデータ列の行間の関係を洗うような処理について,なにか良い資料というか,例などがあれば有り難いです.
配列の添字に条件をいろいろ書けばできるような話なのか,添字部分に書く書き方を探すというのがそもそも間違いなのか...
R向きの考え方でないのであれば改めて別言語で検討します.
よろしくお願いします
lapplyと比較演算子を組み合わせればできそうに思いますが --  2006-06-21 (水) 15:30:07
例に挙げたデータについての例解が間違えているし。条件の記述も間違えている。(他の行のtime - i行めのtime)< 10000)は引き算の順序が逆?val1<35なのに val1>35 のものを対象にしているし。 --  2006-06-21 (水) 17:36:37
まずは,val1 < 35.0 という条件なら,それを満たさないものは事前に除外した方が探索時間は短くなる。データフレーム名を d とすれば,d <- d[d[,4]<35,] でとりあえず。 --  2006-06-21 (水) 17:38:54
しかしまあ,val1 < 35.0 は,第 i 行に関する条件なのか,比較される他の行に関する条件なのか,それとも両方なのか。曖昧だねぇ。曖昧だとプログラムが書けません。とりあえず,上では,両方ということにしたけど,解釈を間違えていそうだねぇ。 --  2006-06-21 (水) 17:42:30
いろいろ面倒だが,骨格を作ったから直してみて?val1 についてのチェックは,定義が曖昧だから,プログラムに含めていない。定義がどうであろうと,簡単に組み込めるだろう。
たぶん遅いから,R じゃなきゃいけないとか R の機能をふんだんに使っているというのではないのだから,Cなんかで書く方が良いでしょう。 --  2006-06-21 (水) 17:53:05
nr <- nrow(d) # 行数
sapply(1:nr, function(i)
{
ti <- d[i] # i 行目の time
lo <- max(1, i-100) # i 行目の前100行(前か後だけでよいのだろうが)
hi <- min(nr, i+100) # i 行目の後100行(前か後だけでよいのだろうが)
temp <- d[lo:hi,] # とりあえず対象可能性のある行列を取り出す
ok <- abs(temp[,1]-ti) < 10000 # 時間差をチェック(abs は要らないのだろうが,そのときは不等号の向きを確認)
temp <- d[ok, 3] # ID2 の列を取り出して
length(table(temp)) # 度数分布を求めてその長さを見れば,カテゴリーが何種類あったかわかる
})
ありがとうございます.lapply() 調べてみます&ご提示頂いた sapply() を参考に練ってみます.
その他の皆様も,アドバイスありがとうございます(たしかに例が正確ではなかったかも) -- ginga? 2006-06-21 (水) 18:52:15
上のコードと本質的に同じコードで50万行の人工例を(一部実行で)試してみたら、所要時間19時間余りと予測されました(笑)。本当に全部を一度に処理する必要があるかどうか熟考した方がよさそうです。普通そんなことは無いものですが。 --  2006-06-21 (水) 22:46:41
一昼夜コンプータを動かしておけば解が出るなら,安いモンでしょう(^_^) --  2006-06-21 (水) 23:08:33
初級Q&A アーカイブ(5) - RjpWiki
