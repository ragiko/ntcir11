目次
Part1  SQLを最適化するコストベースオプティマイザの基本機能
はじめに
CBOを使用する理由
SQL文の処理におけるオプティマイザの役割
Part2  CBOは何を見てどう判断するのか
CBOのアクセスパス選択方法
ヒストグラム
CBOとバインド変数
バインドピーク(Bind peek)
I/O + CPUコストモデル
CBOとフルスキャン
CBOとキャッシュ効率
CBOとパラメータ
CBOと結合順序
Part3  オプティマイザ統計の管理
自動統計収集
統計履歴の自動保存
動的サンプリング
Part4  実行計画の固定と自動チューニングオプティマイザの活用方法
実行計画を固定する機能
自動チューニングオプティマイザ
CBOを使いこなすためには
Part2 CBOは何を見てどう判断するのか
CBOのアクセスパス選択方法
パート1では、CBOとRBOの違いと、SQL文の処理におけるCBOの役割を見てきました。パート2では、例を示しながらCBOの動作を詳しく見ていきます。 
CBOは、ユーザーが指定した条件に対するヒット件数を予測してアクセスパスを選択します。その際に、テーブルの行数や列値の最小値、最大値、NULL値の数、値の種類といった統計を利用しています(場合によっては値の分布のヒストグラムを利用することも可能です)。 
一般に、ヒット件数が15%以下に絞り込める場合は、フルテーブルスキャンよりもインデックスアクセスのほうが効果的とされています。しかしCBOは、例えばヒット件数の見積もりが1%であったとしても、フルテーブルスキャンを選択することがあります。そしてこれは正しい選択なのです。どういうことなのか、ちょっと考えてみてください。 
トリックを見破れたでしょうか。これを解くには、まずコスト見積もりの際にCBOが利用する統計情報について押さえておく必要があります。 
CBOはヒット件数を予測する際に、先ほど挙げた統計だけでなく、テーブルのHWM(High Water Mark)までのブロック数や索引の深さ、リーフブロック数およびキー値あたりのリーフブロック数といった物理情報も利用しています。このような統計の1つに「クラスタリングファクタ(クラスタ化係数)」があります。 
クラスタリングファクタは、索引の統計情報の1つです。この統計値が大きいほど、索引が付けられている列の値がテーブル全体に満遍なく分布していることを意味します。クラスタリングファクタは、索引内で隣り合ったレコードが異なる表ブロックをポイントしている場合にカウントアップされます。したがって、クラスタリングファクタの最大値はレコード数(索引内の隣り合ったレコードがすべて異なる表ブロックを指しているケース)と等しくなります。つまり極端な例では、ユーザーの指定した値がテーブルのすべてのデータブロックに格納されている場合もあり得るわけです。 
全体の行数から見れば1%であっても、テーブルのすべてのブロックから値を読み込まなければならないケースでは、テーブル全体をマルチブロックリード 注5でスキャンするほうが効率的です。インデックスアクセスの場合、テーブルのブロックを1つずつ読み込みますが、フルテーブルスキャンでは複数ブロックをまとめて1つのI/Oで読み込めるためです。 
このようなケースをRBOで実行すると、必ずインデックスアクセスを行ないます。もちろん最適なアクセスパスではありません。CBOの賢さを実感していただけたでしょうか。
クラスタリングファクタが極端に高い場合
クラスタリングファクタが極端に高い場合はどのような動作になるのかを見てみましょう。 
表TEST1のそれぞれのブロックに、列COL2の値として1～100までの値が格納されているとします。COL2に索引IND_COL2を作成し、この索引を利用してアクセスした場合を考えます。ここで「WHERE COL2=100」という条件句の問い合わせが発行されたとすると、値の種類は100種類ですから、1%(100種類中の1種類)の行がヒットするはずです。ところが100という値はすべての表ブロックに格納されているため、索引にアクセスした後、すべての表ブロックをシングルブロックリードで読み込む必要があることが分かります(図1)。
図1 すべての表をシングルブロックリードで読み込む例
索引を使用した場合の大量のシングルブロックリードと、表フルスキャン時のマルチブロックリードの性能差を見てみましょう。LIST1とLIST2はSQL Traceの出力結果です。 EVENT10046(Tips参照)という方法で取得したため、SQL実行時の待機イベントの情報も出力されています。
LIST1 フルテーブルスキャン実行時
LIST2 インデックスレンジスキャン実行時
両方のケースとも条件句は「COL2=100」で同じ行数がヒットしますが、LIST1のケースではFULLヒントによってフルテーブルスキャンを強制しており、LIST2のケースではINDEXヒントによってインデックスアクセスを強制しています。なお、表領域はALLOCATION_TYPE=SYSTEMのローカル管理表領域を使用しています。 
これらの統計を見ると、同じ結果を返すのにフルテーブルスキャンの場合は3.05秒、インデックスレンジスキャンの場合は5.7秒かかっており、明らかにフルテーブルスキャンのほうが効率が良いことが分かります。 
出力結果からは、ほかにも以下の情報が読み取れます。
マルチブロックリード 
1 I/Oの読み込みブロック数平均:14.9ブロック 
(db_file_multiblock_read_count=16) 
1 I/Oの平均レスポンス:13ミリ秒 
I/O発行回数:151回 
I/O待機時間合計:2.02秒
シングルブロックリード 
1 I/Oの読み込みブロック数平均:1ブロック 
1 I/Oの平均レスポンス:2ミリ秒 
I/O発生回数:2224回 
I/O待機時間合計:5.01秒
表のほとんどのブロックにアクセスする必要がある場合には、小さなI/Oを大量に発行するインデックスアクセスよりも、大きなI/Oでまとめて読み込むフルテーブルスキャンのほうが効率的です。 
オプティマイザは単にヒット行数の見積もりだけでなく、データがどの程度、表内に散らばっているか(その場合、索引アクセスの効率は下がる)も考慮してアクセスパスを選択しています。
通常のSQL Traceに加え、SQL実行時に発生した待機イベントの情報を収集するために使用するテクニックです。従来は公開されていない方法でしたが、10gではマニュアルに記述があります。パフォーマンスチューニング時には非常に重宝します。 次のコマンドを実行した後に当該セッションで発行したSQLは、待機イベントとともにトレースが出力されます。このコマンドによって出力されたトレースファイルも、通常のSQL Traceと同様にtkprofユーティリティを使ってフォーマットできます。
ALTER SESSION SET EVENTS '10046 trace name context forever, level 8';
なお、Oracle 10gではほかにもDBMS_MONITORパッケージで待機イベントを含んだSQL Traceを取得可能です。カレントセッションだけでなく、ほかのセッションに対して外部からトレースを仕掛けることも可能であり、こちらのほうが使いやすいと思います。
ページTOPに戻る
ヒストグラム
次に、CBOが誤った選択をする例を見てみましょう。テーブルTEST1には100万行が格納されています。同テーブルにはNUMBER型の3つの列COL1、COL2、COL3があり、以下のような値が格納されています。
COL1には行番号が格納されている。つまり、1行目から1,2,3,&hellip;&hellip;1000000が格納
COL2は1～100までの値が循環的に格納されている。つまり、1,2,3,&hellip;&hellip;100,1,2,3,&hellip;&hellip;100,1,2,&hellip;&hellip;と格納
COL3は1～100までの値がソートされて格納されている。つまり、1,1,1,&hellip;&hellip;1,2,2,2,&hellip;&hellip;100,100,&hellip;&hellip;100となっている。各値は1万レコードずつ均等に格納
ここで、COL3の1行(50万行目)だけを1000000に更新して、オプティマイザ統計を収集します(LIST3)。
LIST3 COL3の1行だけを1000000に更新
exec dbms_stats.gather_table_stats
(ownname=>'TEST',tabname=>'TEST1', -
estimate_percent=>100,cascade=>true)
TEST1表のCOL3列には索引IND_COL3があります。この状態で次のSELECT文を発行した場合、どんなアクセスパスが適切でしょうか。
SQL1 
select count(col1) from TEST1 
where COL3 <= 10000;
この場合、100万行中の99万9999行(50万行目以外のすべて)がヒットするわけですから、当然フルスキャンが適切です。ところが、オプティマイザは次のような推測を行ないます。 
COL3列の値は最小値1、最大値1000000の間に均等に分布している
COL3列の値の種類(NDV:Number of Distinct Values)は101個である
「COL3 <= 10000」にヒットする行数は以下のようになるはずである 
選択率(Selectivity)
Sel(COL3<=10000) = Sel(COL3<10000)+  Sel(COL3=10000)
=(10000−最小値)/(最大値−最小値)+ 1/NDV
=(10000−1)/(1000000−1)+1/101
= 0.0199
ヒット行数
= 全行数 &times; 選択率
= 1000000 &times; 0.0199
=  
19900
予測された選択率は約2%となります。このヒット行数であれば、クラスタリングファクタを考慮しても索引を使用したほうがコストが低いと見なされ、インデックススキャンが選択されました(LIST4)。 
LIST4 インデックススキャンが選択される
さらに、次のSELECT文を発行してみます。この場合はどんなアクセスパスが適切でしょうか。
SQL2 
select count(col1) from TEST1
where COL3 > 500000;
このSELECT文では100万行中の1行(50万行目)しかヒットしません。したがって当然インデックスアクセスが必要です。 
ところがオプティマイザは全体の50%がヒットすると予測し、これだけヒットするのであればフルスキャンのほうが効率的だろうという結論に至ってしまいます(LIST5)。 
LIST5 フルテーブルスキャンが選択される
Sel(COL3>500000) = (1000000−500000) /
(1000000−1) =0.5
この間違いの原因は、オプティマイザの仮定である「最小値と最大値の間の値の一様分布」および「値の発生頻度は同じ」が、実際のデータ分布と一致していない点にあります。 
こんな間違いをするようではCBOは当てにならないのでしょうか。現実に使用されるデータには、値の種類によって発生頻度が大きく異なったり、最小値と最大値の間にまばらにデータが存在するというケースがよくあります。 
こういった状況に対処するため、CBOは統計情報の1つである列値ヒストグラムを利用して、アクセスパスの選択精度を向上できます。Oracleでは2種類のヒストグラムをサポートしており、最大254のバケット数を指定して列値ヒストグラムを作成できます。
頻度分布(Frequency)ヒストグラム
ヒストグラムには2種類あります。列値の種類が指定されたバケット数以下であれば、「頻度分布(Frequency)」のヒストグラムが作られます。これは、それぞれの値が何行あるかを正確に記録するものです。「頻度分布」ヒストグラムを作成した状態で次の2つのクエリを実行してみましょう。 
列の個別値数(NDV)よりも大きな値をmethod_optに指定することで、頻度分布ヒストグラムは作成可能です。ここでは最大値の254を指定して作成します。
execdbms_stats.gather_table_stats(ownname=>
'TEST',tabname=>'TEST1', -
estimate_percent=>100,method_opt=>
'FOR COLUMNS COL3 SIZE 254',cascade=>true)
COL3列に対してLIST6のような頻度分布ヒストグラムが作成されました。
LIST6 頻度分布ヒストグラム
USER_HISTOGRAMSディクショナリビューを参照すると、ENDPOINT_VALUEが列値を表わし、ENDPOINT_NUMBERが行数の累計を表わしています。したがって1つ前のエントリとの差分がその列値の行数となります。 
値の分布が正しく記録されていますから、オプティマイザの見積もり行数も正確であり、正しいアクセスパスが選択されます。
SQL1 
正しく999K行(Kはキロ、1000倍の意)がヒットすると見積もり、フルスキャンを選択しています。
SQL2 
正しく1行がヒットすると見積もり、インデックススキャンを選択しています。
高さ調整(Height Balanced)ヒストグラム
もう1つのヒストグラムは「高さ調整」ヒストグラムです。頻度分布ほど正確ではありませんが、値の偏りを検出するために使用されます。 
高さ調整ヒストグラムは、指定されたバケット数にソートしたデータを順番に入れていき、それぞれのバケットの最後の値(ENDPOINT_VALUE)を記録していくものです。この時、それぞれのバケットには同じ行数しか入らないので、「高さ調整(Height Balanced)」と呼ばれます。 
連続したバケットのENDPOINT_VALUEが同じであれば、その値がほかの値より多く存在する証拠になります。このような複数のバケットのENDPOINT_VALUEとなる値を「ポピュラー値」と呼びます。Oracleは領域使用率向上のため、ポピュラー値が存在した場合は、最後のバケットの情報のみ格納し、先行するバケットの情報は省略します。バケット0のENDPOINT_VALUEは最小値です。最後のバケットのENDPOINT_VALUEは最大値となります。 
先にも書きましたが、Oracleでは最大254のバケット数までしか指定できないため、256種類以上(バケット0を含めて255種類の値を記録可能)の値を持つ列に対しては「頻度分布」のヒストグラムを作れません。 
バケット数を際限なく増やすと、ヒストグラム生成に要する時間が長くなるだけでなく、ヒストグラム情報を格納するための領域(ディクショナリ表)も大量に消費されてしまいます。ヒストグラムの使用に関しては、統計の正確さとのトレードオフになります。 
高さ調整ヒストグラムは統計の正確さという点では限界がありますが、厳密な統計がなくても、正しい実行計画の選択という目的は達成できます。 
例えば1～1000000までの101種類の値が存在するCOL3列にバケット数10で高さ調整ヒストグラムを作ってみましょう。
exec dbms_stats.gather_table_stats(ownname=>'TEST'
,tabname=>'TEST1', -
estimate_percent=>100,method_opt=>
'FOR COLUMNS COL3 SIZE 10',cascade=>true)
COL3列に対してLIST7のような高さ調整ヒストグラムが作成されています。
LIST7 高さ調整ヒストグラム
ポイントは以下のとおりです。
USER_HISTOGRAMSディクショナリビューの参照結果
ENDPOINT_NUMBERがバケット番号を表わす。列値をソートし、それぞれのバケットに同数の行を入れていったと考える。ポピュラー値が存在する場合はバケット番号に抜け番が発生する(逆に、抜け番の発生からポピュラー値の存在が分かる)
ENDPOINT_VALUEがそのバケットに入れられた最後の列値を表わす。このケースでは100万行に対して10バケットを使用しているため、1つのバケットに10万行が入れられる。したがって、バケット1のENDPOINT_VALUEはソートした10万行目の値、バケット2は20万行目の値、バケット3は&hellip;&hellip;となる
この高さ調整ヒストグラムには ポピュラー値(Tips参照)は存在しません。ポピュラー値は、ある値がほかの値に比べて偏って多く存在する場合に発生します。 
このヒストグラムからは範囲における非一様性(範囲内の値の偏り)が読み取れます。LIST7のバケット9とバケット10を比較してみましょう。2つのバケットに格納されている行数は同じです。バケット9には81～91までの11種類の値が入っていますが、バケット10には91～1000000までの99万9910もの値の種類があります。これだけの種類があるにもかかわらずバケット9と同じだけの行数ということは、91～1000000までの値はまばらに存在していることが分かります。 
このヒストグラムを使用して、先の2つのSQLのヒット行数はどのように計算されるかを見てみましょう。 
以下でSel(COL3>10000)やSel(COL3>500000)を計算している部分がありますが、どちらもヒストグラムのバケット10の範囲(91～1000000)に包含されることに注意してください。バケット数が10であることから、1つのバケット内に含まれる範囲の選択率は最大でも0.1(10%)となります。以下の計算では0.1に絞り込まれた後、バケット内で値が一様分布していると見なしてさらに計算しています。
選択率(Selectivity) 
Sel(COL3<=10000) = 1−Sel(COL3>10000)
= 1 −0.1 * (1000000−10000)/(1000000−91)
= 0.900991
Sel(COL3>500000) = 0.1 * (1000000−500000)/(1000000−91)
= 0.050005
ヒット行数 
(COL3<=10000)    = 1000000 * 0.900991 =  
900,991
(COL3>500000)    = 1000000 * 0.050005 =   
50,005
ヒット行数の見積もりは、ヒストグラムを作らなかった時よりはかなり向上した(現実に近づいた)と言えます。アクセスパスもそれぞれ正しいものを選択するようになりました。
SQL1 
90万(900K)行がヒットすると見積もり、フルスキャンを選択しています。
SQL2 
5万5行がヒットすると見積もり、インデックススキャンを選択しています。以上から、高さ調整ヒストグラムによって、適切な実行計画が選択される可能性が向上することが理解できるかと思います。 
さらに、ポピュラー値が現われるケースを見てみましょう。次のSQL文で、COL3の列値に偏りを作ってみます。 
update TEST1 set COL3=30 where COL3 between 31 and 39;
これによりCOL3で列値が30台のものがすべて「30」になりましたので、COL3の値の種類としては9個減って92、COL3=30の行が以前の10倍になり、全体の10%になりました。それでは、全体の10%を占める値を高さ調整ヒストグラムで検出するのに適切なバケット数はいくつでしょうか。 
すでに述べたように、高さ調整ヒストグラムでは2つ以上のバケットのエンドポイントとなっている値がポピュラー値と呼ばれ、ポピュラー値の存在によって値の発生頻度の偏りが検出できます。2つのバケットのエンドポイントに同じ値が現われるためには、少なくとも1つのバケットにすべて同じ値が入る必要があります。そのため、2バケット分の行数が存在すれば、確実にポピュラー値となります。したがって全体の10%を占める値を検出するには、10%が2バケットに相当するバケット数を使用すれば良いことになります。ヒストグラム作成のバケット数として20バケットを使用すれば、1バケットが5%に相当するため、2バケットで10%を表わせます。 
次のコマンドでバケット数20の高さ調整ヒストグラムを作成します。
execdbms_stats.gather_table_stats
(ownname=>'TEST',tabname=>'TEST1', -
estimate_percent=>100,method_opt=>'FOR COLUMNS
COL3  
SIZE 20',cascade=>true)
LIST8のようなヒストグラムが作成されました。 
LIST8 高さ調整ヒストグラム(ポピュラー値あり)
ENDPOINT_NUMBERが6のエントリが欠落しています(9～19の間は単なる省略です)。したがってその次のエントリのENDPOINT_VALUEである「30」はポピュラー値であることが分かります 注6。 
値30は全体の10%あるため、20バケットの高さ調整ヒストグラムでこの値の偏りをポピュラー値として検出できました。全体の10%に相当する行数を取り出すのに適切なアクセスパスは何でしょうか。
ポピュラー値を指定 
select count(col1) from TEST1 where COL3=30; 
ヒストグラムから10万行がヒットすると見積もり、フルスキャンが妥当と判断されました。
非ポピュラー値を指定 
select count(col1) from TEST1 where COL3=40; 
非ポピュラー値の場合、等価条件の選択率は1/NDVとなるため、1万行がヒットすると見積もり、索引アクセスが妥当と判断されました。
門外不出のOracle現場ワザ 第4章
