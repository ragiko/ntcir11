
トロン
【質問1】ITRONとは
「ITRON」とは何でしょうか?
【回答1】
「ITRON」は「Industrial TRON」の略称であり、組込み機器制御用のリアルタイムOS仕様の名称です。
ITRON仕様は、ハードウェアやプロセッサへの適応化を可能とし、実行時のオーバヘッドや使用メモリの削減を重視する「弱い標準化」の方針に基づいて仕様を策定しています。
現在、国内の組込みシステムの50%以上が、ITRON仕様に準拠したOSを採用しています。
<参考>
http://www.t-engine.org/ja/tron-project/itron
Page TOP
トロン
【質問2】ITRONと&mu;ITRON
「ITRON」と「&mu;ITRON」の違いは?
【回答2】
&mu;ITRON仕様は、ITRON仕様をメモリ容量や性能に制限のあるプロセッサへ適用するために機能を絞り込んだリアルタイムOS仕様の名称です。
当初、&mu;ITRON仕様は、8～16ビットのMCU向け仕様としていましたが、現在では、8～32ビットの各規模のMCUに適用できるスケーラビリティを持った仕様となっています。
Page TOP
トロン
【質問3】ITRONとT-Kernel、&mu;T-Kernelの関係「ITRON」と「T-Kernel」、「&mu;T-Kernel」の関係は?
【回答3】
ITRONはコンパクトでかつ性能を高めるため機能を絞り設計されています。
&mu;ITRONは小型の組込み機器にも適応できるようにすることを目指して、リアルタイムOSとしての仕様のみを規定し、具体的な実装は自由にできるようにしました。
一方、T-Kernelは仕様書だけでなくソースコードもオープンにすることで、細かな実装上の違いをなくし、デバイスドライバやミドルウェアの流通を促進できるようにしました。
T-KernelはITRONをベースに互換性と拡張性を重視して設計された新しいリアルタイムOS仕様です。仕様を厳格に定めてソフトウェアの高い移植性を実現しています。
また、ITRONのリアルタイム制御機能をそのまま活かしつつも、サブシステムの機能を導入してOSの拡張性を高め、それを利用して、ファイル管理やプロセス管理の機能を提供する基本ミドルウェア(T-Kernel Standard Extension)が実装されています。
&mu;T-KernelはT-Kernelの設計方針の互換性と拡張性を保ちつつ、小型組込み機器などに実装するため、最小のリソース環境下でも十分なリアルタイム性能を発揮できるように設計されたリアルタイムOS仕様です。
ITRONとT-Kernelの歴史
Page TOP 
トロン
【質問4】弱い標準化
弱い標準化とは?
【回答4】
弱い標準化とは、共通化すると実行時性能の低下につながるような部分については無理に標準化を行わず、ハードウェアやアプリケーションに依存して決めるべき部分として残すアプローチのことをいいます。弱い標準化の考え方により、多種多様なハードウェアの上で,その性能を最大限に発揮させることが可能になります。
ITRONは弱い標準化の方針のもとに設計されています。
Page TOP
ITRON仕様準拠製品登録制度
【質問5】ITRON仕様準拠製品登録審査
ITRON仕様準拠製品登録審査について教えてください。
【回答5】
T-Engineフォーラムでは、ITRON仕様の普及と発展を促進するため、ITRON仕様に準拠した製品の登録制度を実施しています。各社で開発されたITRON仕様に準拠した製品をご登録いただき、T-Engineフォーラムの広報活動などを通じて、ITRON仕様ならびに登録製品の普及を図るのが目的です。詳細はT-EngineフォーラムのWebページを参照してください。
<ITRON仕様準拠製品登録制度のURL>
http://www.t-engine.org/ja/tron-project/itron/i_products
Page TOP
学習、教育
【質問6】学習の取っ掛かりITRONやT-KernelなどのRTOSを勉強するためには、まず何から始めたら良いですか?
【回答6】
まずはC言語を使用して、プログラムが作れるように勉強してください。ITRONもT-Kernelも、RTOSの機能(サービスコールと呼びます)はC言語の関数で定義されていますので、RTOSを使用したアプリケーションプログラム(目的とする動作を行うプログラム)も、一般的にはC言語で開発します。
RTOSを使う目的や意義などについては、専門雑誌や書籍がいくつか出版されています。サービスコールの使い方、タスクの分割方法や例などの情報は、Webなどにも紹介されています。また各所でセミナーも開催されていますので、自分に合ったセミナーを探し、参加するのも良いと思います。
T-Engineフォーラムでもセミナーを開催していますので、参加をご検討ください。
Page TOP
プログラミング
【質問7】リアルタイム性
RTOSを使用すれば、リアルタイム性が保証できるプログラムは作れますか?
【回答7】
リアルタイム性はアプリケーションプログラムの作り方次第で大きく性能が左右されます。
RTOSはアプリケーションプログラムが、リアルタイム性を保証できるプログラムを作成できるように、必要な機能の提供を行っています。RTOSが提供している機能をうまく組み合わせることによって、リアルタイム性を保証するプログラムを作成することができます。
Page TOP
プログラミング
【質問8】高速実行RTOSを使用すれば、プログラムは速くなりますか?
【回答8】
複数の機能を実現する場合、RTOSを使用しない効率のあまり良くないプログラムと比較して、RTOSを使用するとタスク分割などによって比較的効率よく動作させることができます。効率よく動作させることによって、全体的にシステムを速く動作させることは可能です。
ただし、MPUの性能以上は速くなりませんので、単機能なアプリケーションプログラムであれば、RTOSを使用せずに、アプリケーションプログラムのみを実行するという選択もあります。
Page TOP
プログラミング
【質問9】使用できるMPU
ITRONやT-Kernelは、どのようなMPUで使用することができますか?
【回答9】
8bitから64bitまでの、各種MPUで動作します。また汎用的なMPU以外でも、DSPなどでも動作しています。具体的な対応MPUについては、ITRONについては各OSベンダに、またT-KernelはT-EngineフォーラムのWebで確認してください。
Page TOP
プログラミング
【質問10】標準ライブラリの使用
ITRONで標準ライブラリを使うには、どうすればよいですか?
【回答10】
留意すべき点としては、以下が挙げられます。
(1)ライブラリ関数が再入可能かどうか
再入に対応できないライブラリ関数の場合は、排他制御が必要になります。
(2)メモリ管理
コンパイラによっては、メモリ管理(mallocなど)関数の低水準な処理をライブラリの外側に託しているものがあります。このような場合は、ユーザ側で低水準関数を実装して、ITRONのメモリプール機能に関連付けたり、あるいは独自にメモリ管理処理を実装します。
Page TOP
プログラミング
【質問11】タスクのスタックサイズ
タスクのスタックサイズはどのように決めればよいのでしょうか?
【回答11】
スタックの必要サイズはシステムやアプリケーションに依存します。そのタスクで使用するローカル変数に必要な領域や、関数の呼び出し等で使用する領域以外にも、タスクのスケジューリングや割込み時に行うタスクコンテキストの保存領域、サービスコールで使用する領域などを確保する必要があります。
まずは、スタックオーバーフローが発生しない程度の十分な大きさのスタックを用意し、その後、サイズを縮小しながら調整するという方法が考えられます。
Page TOP
タスク管理機能
【質問12】タスクとは
タスクとはどのような概念ですか?
【回答12】
カーネルから見た、プログラムの実行単位をタスクと呼びます。アプリケーションから見ると、タスクは互いに独立して並列実行されているように見えます。
Page TOP
タスク管理機能
【質問13】優先度の指定優先度は 1, 2, 3, … と連続していなければならないのでしょうか?それとも、2, 5, 6, 9, … というように飛び飛びの値を指定してもいいのでしょうか?
【回答13】
優先度には任意の値を指定できます。2, 5, 6, 9 というような値を指定することもできます。
Page TOP
タスク管理機能
【質問14】タスクのコードの共有
&mu;ITRONではタスクの本体としてC言語の関数を指定するようですが、1つの関数で複数のタスクを生成することはできるのでしょうか?
【回答14】
プログラムコードを共用したタスクを複数生成することは可能です。必要な数だけタスクの生成とタスクの起動を実行してください。なお、1つの関数で複数のタスクを生成する場合、関数は再入可能(リエントラント)な関数として実装してください。
Page TOP
タスク管理機能
【質問15】タスクの起動時優先度の変更
タスク生成後に、タスクの起動時優先度を変更することはできるのでしょうか?
【回答15】
タスク生成後にタスクの起動時優先度を変更することはできません。一旦タスクを削除して、タスクの起動時優先度を別の値に変更してから、再度タスクを生成してください。
Page TOP
タスク管理機能
【質問16】優先度の設定と自動変更
あるシステムでchg_priでタスクの優先度を変更して動作させていたのですが、しばらくすると別の優先度に変わっていました。なぜでしょうか?
【回答16】
以下の要因が考えられます。
別のタスクやハンドラからchg_priが発行された。
タスクが一旦終了し、その後で再び起動された。タスクの優先度は起動する時にタスクの起動時優先度に変更されます。
ミューテックの影響で一時的に変化している。
Page TOP
タスク管理機能
【質問17】タスクの強制終了と資源の解放
ter_tskでタスクを強制終了した場合、そのタスクで生成していたセマフォなどのオブジェクトやメモリプールで確保していたメモリブロックも一緒に削除されるのでしょうか?
【回答17】
セマフォなどのカーネルオブジェクトやメモリブロックはタスクとは独立して存在します。このため、ter_tskでタスクを強制終了した場合も削除されることはありません。これは、ext_tskで自タスクを終了させた場合も同様です。カーネルオブジェクトなどを削除してからタスクを終了させる必要がある場合は、タスク例外処理などを利用してオブジェクトなどを削除してから自タスクを終了するような実装にしてください。
Page TOP
タスク付属同期
【質問18】tslp_tskとdly_tskの使い分けtslp_tskとdly_tskはどちらでも一定時間の待ちを実装できますが、どのように使い分ければよいのでしょうか?
【回答18】
tslp_tskは、別のタスクやハンドラなどからwup_tskなどが発行されることによって起床される場合に使用するのが前提です。待っている間に起床された場合に正常終了となり、E_OKが戻値となります。(自タスクに対する起床要求がキューイングされていた場合は待ちは発生せずに正常終了します。)指定された時間以内に起床されなかった場合はタイムアウトエラーが発生し、E_TMOUTが戻値となります。
dly_tskは、自タスクを一定時間待ち状態にしたい場合に使用します。別のタスクやハンドラなどの操作で起床する必要はありません。指定された時間待つことができた場合に正常終了となり、E_OKが戻値となります。
なお、時間待ちを指定するtslp_tsk、dly_tskなどでは、指定された時間が経過する前に強制的に待ちが解除される場合があります。このような場合はエラーとなり、E_RLWAIが戻値として返されます。
Page TOP
タスク付属同期
【質問19】tslp_tskとdly_tskで指定する待ち時間
tslp_tskとdly_tskはどちらもパラメータに待ち時間を指定しますが、指定できる値に違いがありますか。
【回答19】
tslp_tskのパラメータはTMO型であり、無限待ちのTMO_FEVRを指定できます。一方、dly_tskのパラメータはRELTIM型であり、TMO_FEVRは指定できません。
また、待ち時間として0(tslp_tskの場合はTMO_POLと同義)を指定した場合の挙動に違いがありますので注意が必要です。&mu;ITRON4.0仕様では、tslp_tsk(0)では待ち状態にはなりませんが、dly_tsk(0)とした場合には自タスクを待ち状態に移行させ、次のタイムティックで待ちが解除されます。
Page TOP
同期通信機能
【質問20】メールボックスで使用するメモリ領域メールボックスでメッセージを送信すると、受信したメッセージが壊れていて正常に送信できないことがあります。これはなぜでしょうか?ただ、メッセージバッファならば正常にメッセージを送受信することができました。
【回答20】メールボックスでは、メッセージを入れたメモリ領域の先頭アドレスを送信します。受信側では、受け取った先頭アドレスを利用してメッセージにアクセスします。つまり、受信側がメッセージを利用し終わるまでメッセージを入れたメモリ領域を保持し、その内容(メッセージ)を破壊しないようにしておく必要があります。
例えば、メッセージを入れたメモリ領域を自動変数として確保し、その先頭アドレスをメールボックスで送信したとします。この時、自動変数を確保していた関数を終了するとその時点でメモリ領域が解放されてしまいますので、受信側では、先頭アドレスを正常に受信することはできますが、メッセージを利用できるとは限らないことになります。(メッセージが残っている場合もありますが、正しいデータとは限りません。)
メッセージを格納するメモリ領域は静的領域として確保して受信側が利用し終わったことを確認できるまで(データを破壊せずに)保持するか、または、送信側でメモリプールやmallocを利用してメモリ領域を確保し、受信側でメモリ領域を解放するといった処理が必要となります。
一方で、メッセージバッファを利用する場合、メッセージが一旦メッセージバッファ内のバッファ(メモリ領域)にコピーされます。このため、送信完了後に送信に利用したメモリ領域を保持しておく必要はありません。ただし、メッセージバッファでは送信時と受信時にメッセージがコピーされますので大きなメッセージを送受信する場合は、送信と受信の処理に時間がかかることになります。
Page TOP
同期通信機能
【質問21】タスクに対するメッセージ送信
特定のタスクに対して、メッセージを送ることは可能ですか?
【回答21】
タスクを指定してメッセージを送るといった機能は備えていません。この機能は、受け取るタスクが使用する メールボックスを専用に1つ作成することにより、実現が可能です。
Page TOP
同期通信機能
【質問22】メッセージの受信順
メッセージバッファに対して複数のタスクがメッセージを待っている場合、どのような順番でメッセージが渡されますか?
【回答22】
メッセージ待ちになった順番 (FIFO 順) に渡されます。タスクの優先度順に渡されるといった機能は備えていません。
Page TOP
同期通信機能
【質問23】rot_rdqによる実行権の放棄
ディスパッチ禁止状態でrot_rdqを発行するとどうなるのでしょうか?
【回答23】
ディスパッチ禁止状態でも、rot_rdqを発行すると優先順位の回転を実行します。ただし、ディスパッチは発生しません。ディスパッチ許可状態になった時点で最も高い優先順位を持つタスクにディスパッチします。このため、対象優先度に自タスクの現在優先度を指定してrot_rdqを発行してもすぐに実行権を放棄することにはなりません。
Page TOP
割込み管理機能
【質問24】割込みハンドラからの復帰
割込みハンドラからixxx_yyyサービスコールを発行した後、ret_int()を発行せずに割込みから復帰するとどうなりますか?
【回答24】
&mu;ITRON仕様4.0ではret_int()サービスコールは規定されていませんが、実装依存で類似サービスコールを定義した場合、発行せずに割込みから復帰するとディスパッチが保留された状態になる場合があります。
Page TOP
割込み管理機能
【質問25】カーネル管理外の割込み
カーネル管理外の割り込みによる割込みハンドラからixxx_yyyサービスコールを発行できますか?
また、このような割り込みハンドラではret_int()を発行を発行する必要がありますか?
【回答25】
μITRON4.0仕様では、OSの実装によっては、ある優先度よりも高い優先度を持つ割込み(禁止できない割込みを含む)をカーネル管理外の割込みとして定義することができます。カーネル管理外の割込みは、OS内の割込み禁止区間においても割込みハンドラを実行できます。ただし、サービスコールを呼び出してはいけません。
Page TOP
割込み管理機能
【質問26】割込みハンドラからのサービスコール発行
割込みハンドラ(サービスルーチンを含む)から、許可されていないサービスコール(ixxx_yyy/sns_yyy以外)を発行するとどうなりますか?
【回答26】
一般的には、E_CTXエラーが返り、サービスコールは実行されません。ただし、実装によっては、呼び出せる場合やエラーが返らない場合があります。
Page TOP
システム状態管理機能
【質問27】CPUロック状態
「CPUロック状態」とは何でしょうか?
【回答27】
CPUロック状態とは、割込みハンドラやタイムイベントハンドラ等が起動されず、タスクのディスパッチも起こらない状態のことをいいます。
Page TOP
リアルタイムOS製品
【質問28】タスクコントロールブロック
タスクコントロールブロックの構造は?
【回答28】
タスクを1つ使用するごとにタスクコントロールブロック用に領域がメモリ上に必要です。タスクコントロールブロックの構造、サイズは各OSにより異なります。
Page TOP
リアルタイムOS製品
【質問29】TLB
RTOSが内部的に使用するTLBの構造は?
【回答29】
MMUを利用したメモリ管理を行うOSの場合は、TLB領域がメモリ上に必要です。
TLBの構造、サイズは各OSにより異なります。
Page TOP
リアルタイムOS製品
【質問30】検証内容
OSの検証状況を教えてください。
【回答30】
検証状況は各OSにより異なります。OS提供者にお問い合わせください。
ITRON仕様準拠製品登録制度に登録されている製品や登録製品の問合せ先一覧 については下記をご覧ください。
http://www.t-engine.org/ja/tron-project/itron/i_products
Page TOP
ITRON FAQ - T-Engine Forum Japan
