
C言語とは
C言語は、パソコンやマイコンなどのCPUに対する命令を記述するためのプログラミング言語です。
1972年ごろミニコン用のOSを記述する言語として開発されましたが、移植性の高さからワークスーションやパソコンでも使用されるようになっていきました。
最近は、学校でもC言語の教育が行われるようになり、電子、コンピュータ関係の学校を卒業された方ならば、経験があると思います。(私の学生時代はFORTRANでしたが...)
コンピュータの進歩は早く、さまざまな言語が使用されていますが、その中でC言語(C++を含む)が、もっとも多く使用されています。 特に組み込み(マイコン)の場合は、ほとんどCと言って良いでしょう。 
コンピュータ関係、マイコン関係の仕事をする人間にとって必修項目と言えるでしょう。
他の言語との比較
C言語とはどんな言語か? イメージをはっきりさせるために、よく使われる言語と比較してみたいと思います。
VB (Visual Basic)
従来のBASICに対してオブジェクト指向の考え方を導入して、Windowsの開発に便利なクラス・ライブラリーを付加したものです。
マウスを使ってのプログラム作成(ウインドウのGUIのデザイン)ができ、テキスト・ファイルによるプログラム作成が少なくて済むように工夫されています。
VBの簡略化したものがMicrosoft Office製品にVBAという形で組み込まれていて、Officeからマクロの形でVBAを呼び出すことができます。
BASICといっても、オブジェクト指向を理解する必要があり、従来のBASICとは別物と思った方がよいでしょう。
私の主観ですが他の言語と比べて実行速度が非常に遅い気がします。
Java
アプリケーションの互換性と国際化
Javaの最も重要な設計目標は互換性と国際化です。
コンピュータとは融通のきかないもので、機種やOSのバージョンなどのわずかな違いでアプリケーション・ソフトが動かなくなります。
一般ユーザーにとってみれば、なぜ全ての機種、全てのOSで動作するように作らないのかと素朴な疑問が生じます。
コンピュータの世界において、この問題は、長い間放置されていましたが、ようやくJavaの登場で現実のものとなりつつあります。
*互換性を実現する細かい技術的なことは後述します。
もう一つの問題点は、あるコンピュータ上で入力した文章を、他の国のコンピュータにもっていくと正常に表示されないという問題です。
紙に書かれた日本語の文章ならば、アメリカのコピー機でコピーすることができます。
この当たり前のはずのことが、最新のコンピュータでもうまくいかないことがあるのです。
それは、文字コードがばらばらであることに起因します。
世界にはさまざまな言語があり、その文字コードは、自国の文字のみを表すように設計されています。ある1つの国の言語を表す文字コードに限定しても複数の文字コードがあるというしまつです。
Javaでは、文字コードにUnicodeを採用し、国際化に対応しました。
そしてごく当たり前に日本語の識別子が使用できます。
Unicodeには問題点も指摘されていますが、文字コードを共通化できたという点は評価して良いと思います。
かくしてJavaは特定のハードウェアや特定のOSから開放され、パソコンやワークステーションなどの環境、インターネット関連でよく使用されるようになっています。
IOの操作とファンションコールの呼び出し
Javaは、互換性を実現するため、IOの直接操作とOSのファンションコールの呼び出しを制限するという方針をとりました。
そのためJavaを組み込みに使用する際にはいくつかの制限事項があります。
IOの操作を制限するというのは、ハードウェアをよく理解しないプログラマーによるトラブルを、防止するという意味合いもあります。
安全性と設計思想
CとJavaは文法的には似通っていますが、設計思想が異なります。
Cは熟練したプログラマー(十分な知識があり、信頼性の高いプログラムが書ける)を想定しており、プログラマーには悪意はないもの、という前提で設計されています
(プログラマーのやりたいことを妨げない。自己責任)。
Javaはバグのあるプログラム、悪意のあるプログラムであってもコンピュータ・システムが危険にさらされないように配慮をしています。(安全性は高いが、実行速度やできることに制限がある)
Javaのメモリーの管理
JavaとCで、決定的に違うのはメモリーの管理とリアルタイム性です。
Cでは明示的にメモリーの確保/解放をします。
Cで開発されたソフトウェアにおいて、メモリーの解放を忘れるとそれはバグとなり、長時間連続動作させていると、OSがダウンすることがあります。
これらのバグを言語(Java)の方でカバーする仕組みが考えられました。Javaでは使用しなくなると自動的にメモリーが解放されます(ガーベジ・コレクションと言う)。
そしてメモリーが断片化するとJavaが、自動的にメモリーの整理を行います。
しかしプログラマーが、自分の頭のなかでメモリーの確保と開放を考えなくなるというデメリットがあり、そのため動作速度が極端に落ちたり、ガーベジ・コレクションが多発してしまうことがあります。
大容量のメモリーが必要な場合や頻繁に確保と開放を行う場合は、Cの方が、うまくコントロールできます。
Javaのリアルタイム性
Javaは主に人間を相手にすることを想定したUI(ユーザ・インターフェース)に焦点をあわせており、ある決められた時間以内に制御すること(リアルタイム制御)が苦手です。
Javaでは、プログラマーが予測しえないタイミングでガーベジ・コレクションが発生し、対象物の制御が止まってしまうことがありります。割り込みをじかに扱えないこともリアルタイム制御を困難にしています。
人間を相手にする場合には、長時間相手を待たせることも可能ですが、機械を相手にする場合は長時間待たせることはできません。
たとえばマイコンで温度制御している時、決められた時間間隔で必ず温度測定と温度に対応したヒータの制御をしなければ、制御対象が加熱して内容物をだめにしてしまったり、火災など大きな事故の原因となります。
モータ制御では一定時間、制御がないと回転数が不安定になったり、モーターが暴走したりします。
注) 一般的なパソコン用のJava(J2SEなど)の話です。
組み込み用のJava
最近ではパワーのあるCPUを使う事が多くなり、リッチなUIを付けたいというニーズがあります。
Javaは豊富なUIがAPI(Cの標準ライブラリーに相当)として初めから準備されています。
そしてAPIの標準化がされており、OSや開発環境に依存しません。
リッチなUIを追加するのに便利です。
また最近ではパソコンのソフトウェアしか経験のない(ハードウェアのことがわからない)プログラマーが多く、デバッガと完成されたハードウェアがないとプログラムを書けないという方が増えています。
(私は、仕様書とテキスト・エディタさえあればプログラムを書き始めることができると思うのですが...)
Javaはハードウェアが完成していない段階でソフトウェアの開発を進められるというメリットがあります。
それらの場合は、組み込みに特化したJavaを検討してください。
たとえばリアルタイムOSであるITRONとJavaを組み合わせたJTRON、携帯電話などで使用されている、特別に小さく作ったJavaであるJ2ME、KVMなどです。
アセンブリ言語とマシン語
マシン語はCPUが理解できる唯一の言語で、16進,または8進の数字の羅列で表されます。
マシン語は、人間には読みにくいので、マシン語と1対1に対応し、人間にわかりやすい英字表したのが、アセンブリ言語です。
CPUが直接実行できるのはマシン語のみであるので、CやJavaなどで記述されたプログラムも最終的にはマシン語に変換されます。
アセンブリ言語はCPUの種類により、異なり、CPUの種類が変わるたびに書き換の必要があります。
アセンブリ言語は熟練したプログラマが書けば最も性能を出すことができますが、移植性や書きやすさの点でC言語が優れています。
現代の組み込みでは、ほとんどの部分をCで作成して、スタートアップの部分や特殊レジスタをアクセスする部分など、Cでは書けない部分をアセンブリ言語で書きます。
C++
C++は、Cに対してオブジェクト指向の考え方を導入したもので、パソコン,ワークステーション,組み込み のいずれの分野でも使用されています。 
初めてプログラミングを学習する人間にとって、オブジェクト指向は、難しく「オブジェクトの壁」と呼ばれます。
Javaが、オブジェクト指向を必須条件として強制しているのに対して、C++はオブジェクト指向を使用することもできますし、使わなくても書けるので、自分のペースでオブジェクト指向の利用やクラス化ができます。 
オブジェクトの壁に対する配慮とCとのソース・ファイル・レベルでの互換性がうれしい所です。 
現在のC++ではソース・ファイルの1行とアセンブラの文の対応がしずらいことと、オブジェクト効率が悪い点(ROMのサイズが大きくなる)が組み込みで使用する場合の問題点です。
特にROMサイズの小さいマイコンの場合はC++ではなくCの方が良いかもしれません。
Ada
米国国防総省が音頭をとって作成した信頼性・保守性に優れた、主として組み込み向けの言語。MIL/ANSI/ISOで標準化されている。
初期のプログラミング言語は、ソースファイルの文字数を少なくするため、省略形や型の自動変換を行なうものが多かった。
しかしプログラミム規模が大きくなるに従い、タイプ数の削減より、型を厳密にした方が良いという意見が多くなった。
Adaは型に厳密であるが、先進的な機能を持ち、信頼性・保守性に優れているという特徴があるので、航空機の制御プログラムなどで使用されている。
最近はプログラムが大規模化し、従来のプログラミング言語ではバグを取りきれないという現実がある。日本ではあまり使われていないようだが、もっと使われても良いプログラミング言語だと思う。
なぜ今でもC言語が使われるのか?
K&RのC言語ができて38年(1972年)、ANSI Cが制定されて21年(1989年)、最近では多くの便利な言語ができています。なのになぜ古いC言語が今でも使用されているのでしょうか?
大きな理由は、C言語がハードウェアに近い部分からアプリケーションに近い部分までオールラウンドに使え、かつCPUの種類にほとんどない依存しない言語だからだと思います。
C言語は、アセンブリ言語に近い細かい制御ができ、コンピュータのリソースを無駄遣いしません。
パソコン用の言語は、ソフトウェアの開発工数を削減するため、ハードウェアによりかかることを前提に設計されてしまっています。
とにかくメモリーやハードティスクの容量、CPUの処理能力を無駄使いし、リッチなハードウェアでしか動作せず、消費電力が大きくなります。
(つまり小さなハードウェアで実行しなければならない組み込みには使いづらい。)
最近の便利な言語をつかったとしても、その言語を作るためにはなんらかのプログラミング言語が必要です。またアプリケーションに近い部分を新しい言語を使ったとしても、BIOSやOS、デバイスドライバーなどハードウェアに近い部分ではC言語がよく使われます。
アプリケーションを作っている人から見て、表層に見えているのは新しい言語かもしれませんが、その土台として非常に多くの部分でC言語のお世話になっています。
その他の理由として互換性が高いということがあります。
新しい言語は、特定のベンダーでしか提供されれおらず、標準規格となってないことが多いです。
特定のベンダーでしか提供されていないと、開発環境にバグや制限事項があった時に困ります。複数のベンダーから供給されていれば、最悪買い換えることもできます。
また特定のベンダーに依存する言語は、突然言語仕様が変更になったり、売れなくなれば販売中止、サポートの打ち切りなどの問題があります。
C言語ならば、ANSI/ISO/JISで標準規格になっているため、ある程度はコンパイラ依存部分はありますが、互換性が取れ、安心して使えます。
多く蓄えられているソースファイルを再利用する(会社資産の継承)という意味でも互換性は重要なのです。
「新しい言語を覚えるのが面倒だからC言語を使っているのでしょうか?」
これはあえて否定はしません。最近では社内教育をするのが難しくなっています。教育とはコストがかかるものです。
「新しい言語は自宅で勉強してきなさい。社内で勉強しても残業代は出ません。」と言われたらいやですよネ。もちろん理由はそれだけではありません
開発環境(CコンパイラやICEなど)も新しい言語に対応させるのには大変コストがかかります。ユーザーから見ても新しい開発環境を買い/再教育するのは大きな負担です。C言語で必要十分な機能があるのですから、特別な事情がない限りわざわざ新しい言語に変える必要がないということです。
C言語の問題点
初めてC言語を使った時にすばらしいと思ったのはライブラリーの作成により拡張できることです。これにより言語のコアとなる部分はシンプルとなり、
ハードウェアに近いところから、アプリケーションに近いところまで同じ言語を使用できるようになっています。
特定のOSに対応したり、ある特殊なアプリケーションに適合させるのもライブラリーを開発することで対応可能です。
しかしANSI/JISで標準化されているライブラリーはUNIX/CUIの環境で使用することを前提としており、現在のGUIや組み込みで使用するには機能が不足しています。
よって実務においては、すでに開発済みのライブラリー(つまりIP、ミドルウェア)を使用するのですが、API(インターフェースとなる部分の関数や変数)がベンダー毎に統一されていないのでIPの移植に時間がかかってしまいます。それに教育/学習にコストもかかります。
IPを使用しているはずなのになかなか開発期間の短縮ができないという経験をお持ちの方も多いと思います。
GUIに関するAPI、組み込み用のライブラリーの統一が望まれます。
ベンダー毎に互換性がないために発生したコストについては損失となり、それは誰かが負担しなければなりません。
利益を生まない仕事を削減すれば、その分、創造的な仕事、性能や信頼性を上げるために工数を使う事ができるわけですから。
もちろんそのライブラリーは、特定のベンダーや特定のOSに依存せず、全ての開発者に対してオープンであること。ANSI/JISなどで標準化されること、マニュアルが日本語であることが必要です。
[補足] 
新しいC言語の規格として1999年に「ISO/IEC 9899:1999 - Programming Language C」(以下C99)というのができました。互換性重視で堅実なバージョンアップとなっています。
これについては後ほど説明したいと思います。
まずは動作させてみる
実行する前の準備 〜 スタートアップ
パソコンではOS*1 やBIOS*2があるのが一般的であるので、main関数*3 が呼ばれる前に重要なレジスタの設定やIOの初期化、グローバル変数の初期化が終わっています。
しかし小規模なマイコン・システムではOSを使用しないため、これらの初期化を行う必要があります。
このOSやBIOSの代わりに初期化を行うプログラムでは「スタートアップ」と呼ばれます。
スタートアップでは、特殊なレジスタの初期化などを行う必要があるため、通常はアセンブラで書きます。
開発環境によっては、C言語に特殊な文法を追加して、C言語で記述できるようにしている場合もあります。
スタートアップは、開発環境が自動的に生成してくれる場合と、マニュアルに書き方の説明があり一から作成しなければならない場合があります。
前者の場合であっても自動的に全ての周辺回路を初期化してくれるわけではありません。
また自動生成されたスタートアップではメモリーの消費が大きい、もしくはCPUのクロック切り替えがされていないなどの不都合があるかもしれません。
通常はターゲット(開発中のハードウェア)に適合するようにスタートアップを修正する、もしくはmain関数の先頭に周辺回路の初期化ルーチンを追加する必要があります。
開発環境に自動生成機能がない場合は、簡略化したスタートアップでテストを始めるとよいかもしれません。
簡略化したスタートアップでは、スタートアップの先頭でスタック・ポインタの設定、割り込みの設定(禁止/許可)を行います。
mainルーチンの先頭でグローバル変数の初期化、IOの初期化を行い、その後に、テスト・プログラム本体を記述します。
この時の注意点ですが、コンパイラに付属しているライブラリーは正式な移植をしなければ動作しないことが多いので、この時点では使用しないようにします。
HEW**/R8Cマイコンの環境であればウィザードが自動生成してくれます。
しかし正式なスタートアップにするには手間がかかるので、ここではテスト・プログラム用(製品では使用しない)と割り切って、ウィザードが生成したままのスタートアップで実習を始めることにします。
*1 OS (オペレーション・システム)
IOやファイル・システム、メモリーなどのパソコンの資源を一括して管理するソフトウェア部分。
パソコンで言えばLinuxやWindowsにあたる。 
*2 BIOS (バイオス)
IOを制御するためのサブルーチン集。
パソコンの場合、リセット直後に一番初めに実行されIOの初期化を行い、その後OSに制御が渡る。マザーボード上のROMに格納されているプログラム。
*3 main関数
C言語のプログラムの中で始めに実行される関数。C言語のプログラムは1つ以上の関数からなり、mainという名前
の関数が必須である。
**HEW (High-performance Embedded Workshop)
ルネサス・エレクトロニクス社の統合開発環境。R8Cマイコンの開発に使用するソフトウェア・ツール。
矩形波を出力する
できたばかりのハードウェアには問題があるかもしれません。初めて使用する開発環境は使い方の誤り、設定ミスのため正常に動作しないことがあります。
よって初めから複雑なソフトウェアを動作させようとはせずに、始めは、単純なプログラムでテストを行うのが良いでしょう。
パソコンでは「 Hello world」という文字をディスプレイに表示させるプログラムを、初めに作る場合が多いのですが、マイコンの場合はある1つのポートに対して矩形波を出力させる(あるいはLEDを点滅させる)のが定石です。
R8C/15マイコン、OSなしを想定したテストプログラムをリスト1に掲載します。
/* [リスト1] 矩形波を出力する */
/* R8C/15マイコン用 */
void    main(void);
void    main()
{
p1 = 0x40;      /* P1_6='H', それ以外P1は'L'    */
pd1 = 0xd4;     /* P1_7, P1_6, P1_4, P1_2は出力 */
while( 1 )
{           /* まずCPUの確認 (P1_6に矩形波がでればOK) */
p1 = 0x40;  /* P1_6=H   CPUが動作しているか確認 */
P1 = 0;     /* P1_6=L */
}           /* このプログラムは永遠に終了しない */
}               /* OSを使用しないのであればmainは終了させない */
電源を接続、電源電圧をマルチメータで確認します。
OKならば、ブート・モードに切り替え、リセットし、プログラムの書き込みを行います。
ユーザ・モードに切り替え、リセットしてください。
オシロスコープをテスト用のIOポート(P1_6)に接続して矩形波が出ていれば、少なくとも開発環境や最低限のハードウェアは正常に動作しています。
うまくいかない時には、スタートアップの書き方が正しいか、各種設定が正しいかを確認します。
パソコンではOSがアドレスの設定を自動的に行いますが、組み込みのプログラムではコンパイル時の設定で物理アドレスを正しく設定する必要があります。
ありがちなのは物理アドレスが正しくない。つまりスタックや変数領域がRAMに割り当てられていない、またはプログラムがROMにわり当てられていない、2つ以上のアドレス領域が重なっている、メモリーがない領域に割り当てているなどです。
ワンチップマイコンの開発環境では、デバッガ(ICE)がROMやRAMのある決められたアドレス領域を使う事になっていて、ユーザー・プログラムがそのアドレス領域を使ってはいけないことになっていることがあります。
スタックのアドレス設定にミスがある、あるいはデバッガ専用領域をユーザー・プログラムがアクセスしてしまっている場合、デバッガそのものが、予測不能な動作をし、ハードウェアが悪いのかソフトウェアが悪いのかわからなくなることがあります。
デバッガ専用領域とユーザー・プログラムが重ならないようにアドレスの設定を行ってください。
制限事項があることを知らずにデバッグを始めると思わぬ落とし穴にはまります。
横着をしないでマニュアルをしっかり読むことが肝要です。
ハードウェアの動作確認が終わり、正常であることが確認されたならなば、正式なスタートアップを作成し、その後アプリケーション・ソフトの開発を行います。
抽象化されたIO 〜 ストリーム
ストリームとは
IO(あるいは周辺機器、デバイス)にはさまざまタイプが存在するため、アプリケーションから直接IOをコントロールしようとするとアプリケーションの数×デバイスの種類だけ制御プログラムが必要になってしまいます。
UNIXにおいては、いかなるIOも可能なかぎり、シンプルで統一された方法で制御可能にするため「ストリーム」という考え方が導入されました。
UNIXと共に進歩してきたC言語は、ストリームを強く意識して設計されています。
ストリームとは、IOからCPUに入力されるバイト列の流れ、あるいはCPUからIOに出力されるバイト列の流れです。
シーケンシャル・ファイルに対するリード/ライトもストリームとして扱われます。
IOやファイルをシリアライズ、あるいは抽象化したものと言えます。
最近は、高性能なハードウェアが安価になったので、組み込みであってもフル・キーボードやQVGA以上のディスプレイが付くことがあります。
それらのシステムではストリームを使うことがあります。
R8Cなど小さなマイコン・システムではストリームを使用することが少ないのですが、以下簡単に説明しておきます。
パソコンにおけるストリームとリダイレクト
ストリームの内、明示的に指定されていない場合に使用されるストリームはstdin(標準入力)とstdout(標準出力)です。
sidinとstdoutは、リダイレクト*4 されていないならばコンソール(キーボードとディスプレイ)に割り当てられます。
一般的なアプリケーションではなんらかのデータ処理を行う際の入力データをsidinから、とりこみ計算結果をstdoutに出力します。
stdinとstdoutは、シーケンシャル・ファイル(通常はテキスト・ファイル)にリダイレクトされることがあります。
エラーが発生した時、エラーメッセージは、ファイルに保存するのではなく、コンソールですぐに確認できた方がよい(リダイレクトの影響を受けない)ので、エラーメッセージはstderrを使用します。
stderrは、リダイレクトされていないならばコンソールに割り当てられます。
sidin、stdout、stderr以外のストリームは任意であり、好きな名称をつけることができます。デバイス(IO)もストリームとして扱うことを前提としているので、stdinやstdoutを任意のデバイスに切り替えることがでます。
たとえば計算結果をコンソールではなく、プリンタ(prn)に出力したければstdoutをprnにリダイレクトします。
*4 リダイレクト: 
ストリームの接続を切り替えること。出力先を切り替える場合と、入力元を切り替える場合がある。
組み込みではどんなふうにストリームを使うか?
組み込みでストリームを使うのは「printfデバッグ」を行う時です。
printfデバッグというのは開発中のプログラムの中にprintf関数を埋め込み、確認したい変数の値をstdoutに出力する手法です。
あるいはプログラムの通った道筋がわかるような文字列をprintf関数またはputs関数で出力します。
ターゲットにコンソールがある場合は、そのままターゲットのコンソールを使用しますが、コンソールがない場合でも、開発環境によってはデバッグ用のターミナルをstdin,stdoutとして使用できることがあります。
ICEがとても高価であった時代に、ICEの代わりにコンソールでprintfデバッグをしていました。
ICEが入手できるまでのつなぎとしてprintfデバッグをすることがあります。
発売したばかりのCPU(またはASIC内で使用するカスタマイズされたCPU)は、ICEが使えるまで、時間がかかるのでprintfデバッグが必要になることがあります。
特別なハードがなくても対応できるツールとしてprintfとストリームは有用です。
開発段階ではバグがないと思っていても、ユーザー環境で動作させると、ノイズで誤動作をしたり、とんでもないデータが入力されてトラブルが発生することがあります。その時にいちいちICEや開発環境一式を現場に持っていくのはたいへんです。
顧客先でのデバッグやシステムが正常に動作しているか確認する際には、ICEが無くても対応できる方が便利です。
コマンドプロンプトの下で動作するシステム設定プログラムやごく簡単なツール集などをしこんでおきます。
ストリームをきちんと作っておくと、それら小さなプログラム同士の連携ができるようになるため、現場でのトラブル解析やちょっとしたカスタマイズに重宝すると思います。
(大規模なシステムをバリバリ開発するようになったらの話ですが...)
通常動作時、全てのデバイスに対する操作をストリームで行なうと、エレガントなプログラムになると思います。ただし作業工数はかなり増えると思います。
一般的な開発ツールの構成
開発の流れ
C関連の開発ツールは一般的に左の図のような構成になっています。
統合開発環境といって1つのウインドウから、各種のツールを呼び出すことができることが多いのですが、実際の処理は複数のプログラムで行っています。
このような複雑な構成になっているのは、ターゲット・プログラムを複数の小さなソースファイルに分割し、最後に1つの連結されたプログラムに組み立てるためです。
特にROMサイズの小さなマイコンを使用する場合は、ソフトウェア部品の最小単位は1つのソースファイル(モジュール)であるため、ソースファイルの大きさを関数数個ぐらいのにおさえるのが理想です。
組み込みのためのC言語 - N.Kojima
