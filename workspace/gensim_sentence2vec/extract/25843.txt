これまでに書き漏らしたことをいろいろと書きます。
周辺の雑多な話題とか、話の腰を折りそうなので避けて通った話題とか。
特に前半は、サターンが、非常にプログラム可能な部分が多かった、と言う話題。
…ここでいう「プログラム可能」というのは、細かな調整ができるという意味ね。
いわゆるソフトウウェアプログラム…チューリング完全とかの話ではないです。
目次
セガ・サターン(別ページ)
サターンの3D性能(別ページ)
サターンのCPU(別ページ)
太陽系の惑星たち(別ページ)
画像関連のプロセッサ&emsp;VDP1のプログラム&emsp;VDP2のプログラム音関係のプロセッサ&emsp;音源チップ&emsp;DSP&emsp;MC68000データアクセス&emsp;CD−ROM&emsp;SCUメイン CPU&emsp;メインメモリST−Vコントローラーサターンリングプロテクトカートリッジスロット
もう一つのライブラリ(別ページ)
次世代ゲーム機戦争(別ページ)
反論紹介(別ページ)
画像関連のプロセッサ
VDP1のプログラム
スプライトを生成する VDP1は、スプライト描画「コマンド」を受け付けて動作します。
スプライト表示パラメータを渡す、とかじゃないのね。
…そもそもプログラムしない人にはわかりにくい話だな。
ファミコンを例にとると、1つのスプライトは4つのパラメータで定義されます。
横座標、縦座標、キャラクタ、その他(上下・左右の反転や、色など)の4つでスプライト1つ分。
ファミコンでは各1バイトで表されるので、4バイト。
この4バイトの構造を繰り返し並べます。プログラム用語では、同じ内容の繰り返しをテーブル(表)と呼ぶため、スプライトテーブルなどと呼ばれます。スプライトを表示する、とは、プログラムから見ればこの表を作成することに他なりません。
スプライトテーブルは大抵サイズが決まっていて、ファミコンの場合 256 バイトでした。スプライト1つに4バイト使うので、 256/4 = 64 。最大で64枚のスプライトが表示できることになります。
同じく任天堂のスーファミやゲームボーイだけでなく、他社のPCエンジンやメガドラ、パソコンの MSX や X68000 、FM-Towns などでも同じような構造でした。つまり、これがスプライトを扱う際の一般的な方法だと思ってよいでしょう。
でも、サターンは違います。
4頂点をそれぞれ違う座標にしたりできますし、「キャラクタ」を指定しないで塗りつぶしたり、グラデーションをかけたりできる。スプライトごとに必要なパラメータのサイズが違うんです。
そのため、スプライトはテーブルで定義されるのではなく、VDP1 に与えるコマンド列…つまり、プログラムとして作られていました。処理速度の限界や、コマンドを保持するメモリの限界はあるかもしれませんが、「テーブル」ではないので、定義数の限界(表のサイズ上限)はありません。
おそらくは、これが「スプライト表示枚数:無限大」という謎のスペックの理由。
この、VDP1 コマンドの中には、「表示ウィンドウを変更」なんて命令もあったと思います。(うろおぼえ)
表示エリア外はスプライトが描画されませんので、上下2画面分割などの際に使えます。
たしか、「原点を移動」もできました。普通は座標の原点(縦にも横にも 0 の点)は画面の左上ですが、3Dゲームなどでは画面中央を原点とした方が計算しやすいのです。画面外に原点を指定することもできたと思います。
そして、これがプログラムらしいところ…「ジャンプ」とか「サブルーチン呼び出し」も可能でした。
メガドライブのスプライトにも「ジャンプ」に相当する仕組みがある。
普通、スプライトは定義順に優先順位が付けられる。しかし、メガドライブでは定義順とは別に、スプライトの処理順を変更する(処理をジャンプさせる)しくみがあった。
サブルーチン呼び出しは、この考え方をさらに拡張したものかもしれない。
たとえば、ソニック2の対戦モードのようなゲームを作ったとしましょう。
…知らない人の方が多いだろうから説明します。
スーパーマリオみたいな横スクロールアクションゲームですが、2人用のモードとして、画面が上下に2分割され、ゴールまでの競争ができました。(右図:クリックで拡大)
画面は分割されているけど、同じ世界です。2人のプレイヤーが違うところにいれば、それぞれの画面は違う表示をしますが、近くにいれば類似した表示になります。
さて、「お互いの画面が重なる程度に近接している」ことを前提に、VDP1 で表示することを考えてみましょう。
まず、両者の周辺のスプライトを全て描く VDP1 コマンドを準備し、これを「サブルーチン」とします。(右図のキャラクターの配置)
次に、上画面だけを描くように表示ウィンドウを設定。上のプレイヤーが中央に表示されるように原点位置をずらし、サブルーチンを呼び出します。(右図の赤枠部分の表示)
続いて、下画面だけを描くように表示ウィンドウ設定。下プレイヤーが中央に表示されるように原点位置を設定し、サブルーチンを呼び出します。(右図の緑枠部分の表示)
これで2画面が描けるわけです。
CPU から見ると、スプライトの描画は1画面分(サブルーチン部分)しか用意していませんが、画面はちゃんと2プレイヤー分描かれます。
…理論上はね。実際この機能を使ったソフトがあったのか不明。
以前書きましたが、おそらくはほとんどのゲームがSGLを使っていたと思います。基本的にはSGLが VDP1 プログラムを自動的に生成します。
たしか SGL にも「VDP1 コマンド」を1つ分渡してプログラムに表示を行う、と言う命令はあったと思います。画面にライン描いたりするのに使った気がするから。
でも、サブルーチン定義までは対応していなかったんじゃないかな。やればできたかもしれませんけどね。
そんなわけで、せっかくの「サブルーチン機能」は多分活用されていないんじゃないかと思います。
2Dゲームなら、サターンの CPU 性能は十分高かったので、同じ画面2回描いても速度的な問題はなかったと思うしね。
(3Dでは視点が変わるので、単純なサブルーチンでは対応できません)
VDP2のプログラム
VDP2 は、背景やグラフィック、VDP1 の作ったスプライトなどを重ね合わせ、表示画面を作るためのプロセッサです。
VDP1と比べれば、VDP2は「プログラム可能」と言うほどではないかもしれません。
普通に、キャラクタ定義して、そのキャラクタをどう並べるのかを指定すれば画面が表示されます。
画面の解像度を決めたり、表示できる色数のモードを決めたりと言うのもよくある機能でしょう。
でも、以前に書いたように回転画面を使ったり縮小機能を使ったりすると、「特別なRAMアクセス」が必要になりました。ここら辺のタイミングはユーザーが指定する必要があります。
また、ある機能に必要なタイミングを指定すると、別の機能に必要なタイミングが得られなくなります。どの機能を使うか、よく考慮して決定する必要がありました。
ほかにも、背景として使用する枚数とか色数により、1枚の背景に必要なメモリ量は変わります。
キャラクタの定義や背景の配置定義に必要なメモリを、VDP2 の VRAM のどこに配置するか、などもプログラマが指定する必要がありました。
こういう部分に頭を使う必要がある…というのは、結局「プログラム可能である」ことになります。
プログラムしていた当時は、VRAM とメインメモリのメモリマップの「枠」だけ…いわゆる白地図みたいなものを作って、たくさんコピーして手元に置いていました。
メモリの使い方に大きな変化が出るたびに、新たな紙にメモリの割り当てを書き記しておくの。これやらないと、何が何だか分からなくなることあったから。
必要なメモリは、画面の解像度や色数、使いたいキャラクタの量などで刻々と変わります。
ゲームのプランナーの意見、グラフィックデザイナーの意見を聞きながら割り振りを調整するのは、パズル的でなかなか面白いものでした。
細かな話題 - 魔法使いの森
