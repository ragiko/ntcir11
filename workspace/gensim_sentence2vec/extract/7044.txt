皆さんこんにちは、今年も残暑が厳しいと思っていたら、急に涼しくなってきましたが体調はいかがでしょうか。
今回は、第6回の続きとして索引の設計方法などについて説明しようと思います。若手エンジニアと話す機会があり、索引の使い方や効果などをあまり知らないようだったので、具体的な例などを使用して説明しようと思います。このようなことは一概には言えませんが、多少の参考にはなると思いますので、参考にして下さい。
1. 索引の決め方
まずは、索引(Bツリー索引)の決め方について説明しましょう。
索引はデータのアクセス性能を向上するための基本的な方法ですが、索引以外にも様々な方法(索引構成表、クラスタ化表、パーティション化、ビットマップ索引など)があります。それぞれには、メリットとデメリットがありますので、上手く使い分けないと効率の良いシステムにはなりません(例えば、大量の範囲スキャンをする場合には、パーティションは全表スキャンすることが可能ですが、索引はあまり効果がないなどです)。Bツリー索引以外については次回以降で説明しようと思います。
索引の設計を難しいと思われている方は多いのではないでしょうか。必要最小限の索引にするために(あまり効果のない索引は作らないために)、どのようなアクセスが最適かを考える必要があります(これが難しいため様々な索引の効果を実際にテストしているのが一般的です)。そして、作り過ぎないようにするには、SQLに優先順位を付けることも重要になります。このようなことが難しいと感じる要因だと思います。アドバイス機能(SQLチューニング・アドバイザ、SQLアクセス・アドバイザ)を使用すれば簡単に行えると思っているかもしれませんが、できれば基本を確りと身に付けて使用して欲しいですので、参考になることをまとめてみました。 
ここでは、作成する索引を決めるための注意点(作成する列の候補、複数列索引、重複度の割合、参照整合性制約)について説明します。
(1)作成する列の候補 
索引を作成する候補の列としては以下のようになりますので、このような列を求めることから始めます。 
・頻繁にWHERE句の比較条件で使用されている選択率の低い列 
比較条件の列に索引が作成されていると索引範囲スキャン(INDEX RANGE SCAN)が行われます(一意索引で等価条件の場合はINDEX UNIQUE SCANになります)。このアクセスする範囲は少ない方が性能が良いため選択率が低くなる列が効果的です(逆に選択率が高くなる列は、オプティマイザが選択しません)。カーディナリティの高い列は選択率が低くなりますが、範囲指定(<,>など)では選択率が高くなる場合があるので注意が必要です。
・頻繁に結合が行われている列 
ネステッド・ループ結合では内部表(最初にアクセスしないテーブル)の結合列で索引を使用して結合しますので、結合列に索引がないと効率の良いアクセスにはなりません(この場合はハッシュ結合などが行われると思います)。結合する行数が少ない場合は、結合列に索引を作成してネステッド・ループ結合をする方が効率良いです。 
・頻繁にソートされている列 
索引はソートして格納されていますので、ORDER BYのようなソート処理にも効果があります(索引範囲スキャンや全索引スキャンするだけでソート結果になります)。ただし、NULLが存在する列のBツリー索引では効果がありません(使用されません)ので注意して下さい(Bツリー索引ではキー値にNULLは含まれないためです。ただし、複数列索引ではすべての列値がNULLの場合のみ含まれないようになります)。
・頻繁に更新されていない列 
索引が作成されている列が更新されると索引も更新する必要がありますので、頻繁に更新されるとオーバーヘッドが大きくなり、断片化も発生し易くなるため効果が低下してしまいます。その断片化を解消するための再構築の頻度も多くなる可能性がありますので、作成しない方が良いです(作成しなくても良いようにデータベースを設計して下さい)。ただし、検索の性能が更新よりも優先度が高い場合もありますので、その場合のみ作成するとすれば良いでしょう。
(2)複数列索引 
列の候補ができたら、次に複数列索引を作成するかどうかです。このときに、どの列で作成するかは悩むところですが、索引はできるだけ一意性が高いように作成した方が効率が良いので、1つの列で一意なのであれば単独で良いです(他の列を付けても無意味ですしキー長が長いと索引の効率が悪くなります)。そうでないものはできるだけ一意性になるような複数の列で作成することを検討します。このときの列の順番が問題ですが、第6回で説明したように、選択率の低い順と使用頻度の高い順(使用頻度が高くても、あまりにも索引の効果がない列は対象外にして下さい)に先頭から配置した方が効率が良いですが、クラスタ化係数の検討も忘れないようにして下さい。
・クラスタ化係数
クラスタ化係数とは、オプティマイザ統計の索引統計情報の一つです。テーブルのデータ格納順が索引とどれくらい異なるかを表す値で、低い値ほど同じ割合が高いことを意味します(この値が低いと、オプティマイザがこの索引を使用する優先順位を上げます)。このような列に索引を作成して、索引アクセスをすると範囲スキャンの物理I/Oを削減することができます(重複値が多いような場合は同じ値は隣接して格納されますので、同じブロックに格納される割合が高くなるからです)。そのため、テーブルにデータを格納するのが、ある列の値順になるような場合には(列でソートなどして格納するような場合には)、この列を先頭にした(クラスタ化係数の低い)索引の方がアクセス効率が良くなります。ただし、これは挿入や削除をして行くと効果が薄れていきます(この値が高くなっていきます)ので注意して下さい。このようなデータの格納を自動的に行うのがクラスタ化表や索引構成表です(これは次回以降で説明します)。
(3)重複度の割合 
カーディナリティが低い場合は、Bツリー索引はあまり効果がないと言われていますが(ビットマップ索引の方が効果的と言われています)、重複度の割合が極端に異なると索引の効果がある場合があるので検討してみて下さい(例えば、以下のように値が1～5までは重複度が高いが、6～20までは一意性が高い場合などです)。このような場合は、重複度の低い値が条件に指定されたときは索引アクセス、重複度の高い値が条件に指定したときは全表スキャンが性能が良くなりますが、オプティマイザが効果的に選択してくれます(これはコストベース・オプティマイザの良さが出る良い例です)。ただし、バインド変数を使用している場合には、第7回で説明したOracle Database 11gからの「優れたカーソル共有」機能を使用しないと、このように動作しませんので注意して下さい。
(4)参照整合性制約
参照整合性制約は、親表と子表の関係をOracleデータベースが保障してくれる機能です(子表の外部キー値は親表の主キーに存在することを保障します)。これを使用すると、主キーには一意性を保証するために一意索引が作成されますが、外部キーには索引が作成されません。ただし、子表の外部キー列に索引が存在しないと、以下の図のように親表の主キーを更新することで子表を共有ロック(子表を処理する間)してしまいますので、他のトランザクションから更新できなくなります。そのため、大量に更新を行うようなシステムでは、子表の外部キーの索引を作成するか、または参照整合性制約を使用しないことを検討して下さい。
これは、親表をDELETEなどすると、それに対応する子表のデータを処理する必要がありますが、索引が存在しないと全表スキャンになるため、その間はアクセスさせないように共有ロックする必要があるからです。ON DELETE句(子表の外部キーの同じ値をNULLにするか、または行を削除する)が指定されていない場合でも、参照整合性制約の違反チェックをするために共有ロックが行われます(同じキー値が子表の外部キーに存在する場合は、主キーの削除などをできないようにする必要があるからです)。
2. 組合せの効果
索引に効果がある処理が単独であれば、それに対応する索引を作成すれば良いのですが、索引は多く作成し過ぎるとオーバーヘッドになるため、少ない数の索引で最大限の効果を出すことがベストです。そのため、効果がある処理を組み合わせて索引を作ることも検討すると更に効率的です。ただし、単純に組み合わせても効果がない場合がありますので、ここでは索引の効果がある以下の処理の組合せの効果について説明します。知っている方には簡単かもしれませんが復習として確認してみて下さい。
・比較条件
・ORDER BY句
・GROUP  BY句(DISTINCT句) 
・結合
それでは、それぞれについて説明します。
(1)ORDER BY句と比較条件
ORDER  BY句と比較条件が一緒の場合の索引の効果について考えてみましょう。次のようなWHERE句とORDER BY句があるSQL文は(列c1の選択率が1%未満で索引アクセスが効率良いとした場合)、どのような索引を作成すると効率良いか考えてみましょう。代表的な索引の候補①~③を使用して、どの索引が効率が良いか説明します。
SQL> SELECT c1,c2,c3 FROM tab01 WHERE c1 = 10 ORDER BY c2;
①	CREATE INDEX ix_tab01_1 ON tab01 (c1,c2);
②	CREATE INDEX ix_tab01_2 ON tab01 (c2,c1);
③	CREATE INDEX ix_tab01_3 ON tab01 (c1,c2,c3);
これは、①(または③)が効率が良いです。どうしてか分からない方のために、以下の実行計画を見ながら説明します。①と②の違いは、INDEX RANGE SCAN(索引範囲スキャン)かINDEX FULL SCAN(全索引スキャン)かですので、①のようにWHERE句の比較条件に指定している列を最初に指定すると索引範囲スキャンになり、アクセスするブロックが少なくなり効率良いことになります。③はアクセスするすべての列で索引を作成しているので、テーブルにアクセスする必要がなくなります。選択リストに指定している列が少なければ、これが最適なアクセスになりますので、このように作成して下さい。③は高速全索引スキャンになる場合もありますが、このSQL文では行われません(高速全索引スキャンは索引の順番に読込みませんので、SORT ORDER BY を行う必要があります。②の全索引スキャンは、すべてのリーフ・ブロックを順番に読込みますのでSORT ORDER BYは必要ありません)。
①の索引
実行計画
--------------------------------------------------
| Id  | Operation                   | Name       |
--------------------------------------------------
|   0 | SELECT STATEMENT            |            |
|   1 |  TABLE ACCESS BY INDEX ROWID| TAB01      |
|*  2 |   INDEX RANGE SCAN          | IX_TAB01_1 |
第21回 索引について(2)
