
16  複数層環境でのユーザー識別情報の保持
複数層環境でセキュリティを規定することは非常に困難な場合があります。 この章では、複数の層にまたがるコンピューティング環境に関連するリスクについて説明します。また、プロキシ認証の実装方法およびユーザー識別情報を保持するためのクライアント識別子の使用方法についても説明します。
この章の内容は、次のとおりです。
3層コンピューティングのセキュリティの課題
ユーザー識別情報の保持に使用するOracle Databaseのソリューション
3層コンピューティングのセキュリティの課題
3層コンピューティングには多くのメリットがありますが、セキュリティの問題も多数存在します。 次の各項では、これらの問題について説明します。
実際のユーザーとは
中間層での権限の数が適切であるか
監査方法および監査対象のユーザー
3層システムの認証要件
実際のユーザーとは
多くの組織では、アクセス制御、リソースの監視または監査上の理由から、データベースに実際にアクセスしているユーザーの識別情報を把握する必要があります。ユーザーの識別情報がアプリケーションのすべての層でトレースできない場合、そのユーザーのアカウンタビリティは低下します。 
また、アプリケーション・サーバーのみがユーザーを認識している場合、各ユーザーに対するセキュリティはすべて、アプリケーション自体で規定する必要があります。アプリケーション・ベースのセキュリティは非常にコストがかかります。 データにアクセスするアプリケーションごとにセキュリティの規定が必要な場合は、すべてのアプリケーションでセキュリティを個別に再実装する必要があります。 通常は、データ自体にセキュリティを構築し、さらにデータベース内で各ユーザーに対するアカウンタビリティを規定することが望まれます。 
中間層での権限の数が適切であるか
一部の組織では、企業内に3層システムを積極的に取り入れています。 このアーキテクチャでは、トランザクション処理(TP)モニターなど、すべての権限を持つ中間層が全ユーザーに対するアクションをすべて実行できます。 中間層がすべてのアプリケーション・ユーザーにかわって、同一ユーザーとしてデータベースに接続します。 このため、中間層にはアプリケーション・ユーザーがジョブを実行するために必要なすべての権限が必要です。 
このコンピューティング・モデルは、ファイアウォールの外側、ファイアウォール上またはファイアウォールのすぐ内側に中間層が常駐するインターネット上では適切でない場合があります。 このコンテキストでは、制限付きトラスト・モデルの方が適切です。このモデルの場合、実際のクライアントの識別情報はデータ・サーバーに認識され、アプリケーション・サーバー(またはその他の中間層)には、制限付きの権限セットが付与されます。 
さらに、中間層がかわりに接続できるユーザーや、中間層がユーザーに対して想定できるロールを制限する機能が有効です。たとえば、多くの組織では、ユーザーが接続元に応じて異なる権限を持つようにしています。この場合、ファイアウォール上のWebサーバーまたはアプリケーション・サーバーに接続するユーザーは、最低限の権限のみを使用してデータにアクセスでき、企業内のWebサーバーまたはアプリケーション・サーバーに接続するユーザーは、許可されているすべての権限を使用できます。
監査方法および監査対象のユーザー
監査によるアカウンタビリティは情報セキュリティの基本原則です。ほとんどの組織では、トランザクションを実行する特定のアプリケーション・サーバーのみでなく、そのトランザクションがどのユーザーによって行われたかを把握している必要があります。そのため、システムでは、トランザクションを実行しているユーザーと、ユーザーのかわりにトランザクションを実行しているアプリケーション・サーバーを区別する必要があります。 
3層システムでの監査は、実際のユーザーの認識という問題に結び付いています。3層アプリケーションの中間層を介してユーザーの識別情報を保持できない場合は、そのユーザーのためのアクションを監査できません。
3層システムの認証要件
クライアント/サーバー・システムでは、認証は単純です。つまり、クライアントがサーバーに対して認証されます。 3層システムでの認証はかなり複雑になります。これは、複数の認証タイプが存在する可能性があるためです。
中間層に対するクライアントの認証
データベースに対する中間層の認証
中間層を介するデータベースへのクライアントの再認証
中間層に対するクライアントの認証
システムがセキュリティの基本原則に準拠する必要がある場合は、中間層に対するクライアントの認証が必要になります。通常、中間層はユーザーがアクセスできる有用な情報への最初のゲートウェイです。 このため、ユーザーは中間層に対して認証される必要があります。 このような認証には相互関係があります。つまり、クライアントが中間層に対して認証されるのと同じように、中間層もクライアントに対して認証されます。
データベースに対する中間層の認証
通常、中間層はデータベースへの接続を開始し、(中間層自体のため、またはユーザーのかわりに)データを取得する必要があるため、このセッションは確実に認証される必要があります。 実際に、Oracle Databaseでは認証されていないセッションは許可されません。 データベース認証をサポートしているSSLなどのプロトコルを使用している場合は、データベースに対する中間層の認証についても相互関係があります。
中間層を介するデータベースへのクライアントの再認証
3層システムでの中間層からデータベースへのクライアントの再認証には多くの問題があります。 中間層とデータベースではユーザー名が異なる場合があります。 この場合、ユーザーは、中間層がユーザーにかわって接続するために使用するユーザー名と資格証明を再入力する必要があります。 中間層は通常、指定されたユーザー名をデータベース・ユーザー名にマップする必要があります。多くの場合、このマッピングはOracle Internet DirectoryなどのLDAP準拠のディレクトリ・サービスで行われます。
データベースに対して再認証を行うクライアントの場合、中間層は、ユーザーに資格証明(データベースに渡すことができる信頼できる資格証明)を要求するか、またはユーザーの資格証明を取得し、これを使用してユーザーを認証する必要があります。 これらの方法のどちらにも、セキュリティ上のリスクが伴います。これは、中間層にユーザーの資格証明が提供されるためです。 
バック・エンド・データベースに対するクライアントの再認証は、必ずしも利点があるとはかぎりません。 第1に、各ユーザーに対する2組の認証ハンドシェイクによって、かなりのネットワーク・オーバーヘッドが生じます。第2に、ユーザーを認証させるには、中間層を信頼する必要があります したがって、中間層による認証が適切であることをデータベースが単純に受け入れることは、妥当なことです。つまり、データベースは、実際のクライアントにそのクライアント自身の認証を要求せずに、実際のクライアントの識別情報を受け入れます。 
一部の認証プロトコルでは、クライアントの再認証はできません。たとえば、ブラウザやアプリケーション・サーバーの多くは、Secure Sockets Layer(SSL)プロトコルをサポートしています。 (Oracle Advanced Securityを介する)Oracle DatabaseおよびOracle Application Serverは、クライアント認証にSSLの使用をサポートしています。ただし、SSLはポイント・トゥ・ポイント・プロトコルであり、エンドツーエンド・プロトコルではありません。 したがって、データベースに対するブラウザ・クライアントの(中間層を介する)再認証には使用できません。
つまり、3層システムを配置する組織では、クライアントの再認証に関する柔軟性が必要になります。
ユーザー識別情報の保持に使用するOracle Databaseのソリューション
多くの組織では、中間層のメリットを犠牲にせずに、アプリケーションのすべての層でユーザーを認識する必要があります。 Oracle Databaseは、次の方法によって、アプリケーションの中間層を介したユーザー識別情報の保持をサポートしています。
プロキシ認証
Oracle Databaseでは、OCIまたはThick JDBCによって、データベース・ユーザーまたはエンタープライズ・ユーザーにプロキシ認証を提供します。 エンタープライズ・ユーザーは、Oracle Internet Directoryで管理されるユーザーで、データベースの共有スキーマにアクセスします。
クライアント識別子
Oracle Databaseでは、アプリケーション・ユーザーに対して、組込みアプリケーション・コンテキスト・ネームスペースUSERENVのCLIENT_IDENTIFIER属性を提供します。 アプリケーション・ユーザーは、アプリケーションには認識されますが、データベースには認識されません。 CLIENT_IDENTIFIER属性を使用すると、アプリケーションで識別またはアクセス制御に使用する任意の値を取得し、その値をデータベースに渡すことができます。 CLIENT_IDENTIFIER属性は、OCI、Thick JDBCおよびThin JDBCでサポートされています。
プロキシ認証
次の各項では、プロキシ認証の機能と使用方法について説明します。
プロキシ認証を使用した実際のユーザーの識別情報の引渡し
中間層の権限の制限
中間層からデータベースへのユーザーの再認証
実際のユーザーのかわりに行われるアクションの監査
プロキシ認証のメリット
プロキシ認証を使用した実際のユーザーの識別情報の引渡し
エンタープライズ・ユーザーまたはデータベース・ユーザーの場合は、OCIまたはThick JDBCを使用して、単一のデータベース接続内で、中間層に多数のユーザー・セッションを設定できます。ユーザー・セッションごとに接続ユーザーが一意に識別されます。 通常、これは接続プーリングと呼ばれます。これらのセッションによって、中間層からデータベースへの個別のネットワーク接続を確立するためのネットワーク・オーバーヘッドが排除されます。
クライアントからデータベースへの中間層を介した認証プロセス
次に、クライアントからデータベースへの中間層を介した完全な認証順序を示します。
クライアントは、中間層が受け入れる任意の認証形式を使用して、中間層に対する認証を行います。 たとえば、クライアントは、ユーザー名とパスワード、またはSSLによるX.509証明書を使用して、中間層に対する認証を実行できます。
中間層は、データベースが受け入れる任意の認証形式を使用して、中間層自体をデータベースに対して認証します。 認証形式には、パスワード、またはKerberosチケットやX.509証明書(SSL)などのOracle Advanced Securityがサポートしている認証メカニズムがあります。
次に、中間層はOCIまたはThick JDBCを使用して、ユーザーに対して1つ以上のセッションを作成します。 
ユーザーがデータベース・ユーザーの場合、セッションには少なくともデータベース・ユーザー名が含まれている必要があります。 データベースで必要な場合は、このセッションにパスワードも含まれます(データベースでは、このパスワードをデータベース内のパスワード・ストアに対して検証します)。また、ユーザーに対するデータベース・ロールのリストが含まれる場合もあります。 
ユーザーがエンタープライズ・ユーザーの場合、セッションはユーザーの認証方法に応じて異なる情報を提供します。次に例を示します。
ユーザーがSSLを介して中間層に認証された場合、中間層は、そのユーザーのX.509証明書またはセッション内の証明書自体からDNを提供できます。データベースは、DNを使用してOracle Internet Directoryでユーザーを検索します。
ユーザーがパスワード認証方式のエンタープライズ・ユーザーの場合、中間層は、少なくともユーザーのグローバルな一意の名前を提供する必要があります。 データベースは、この名前を使用してOracle Internet Directoryでユーザーを検索します。 セッションがユーザーのパスワードも提供する場合、データベースでは、このパスワードをOracle Internet Directoryに対して検証します。 ユーザー・ロールは、セッションが確立した後でOracle Internet Directoryから自動的に取得されます。
中間層は、必要に応じてクライアントに対するデータベース・ロールのリストを提供する場合があります。 クライアントのかわりにロールを実行する権限がプロキシにある場合は、これらのロールが使用可能になります。 
データベースは、ユーザーのかわりにセッションを作成する権限が中間層にあるかどうかを検証します。
アプリケーション・サーバーがクライアントのプロキシとして機能することを管理者によって許可されていない場合、またはアプリケーション・サーバーが指定されたロールをアクティブにすることを許可されていない場合、OCISessionBeginコールは失敗します。
中間層の権限の制限
「最低限の権限」原則とは、ユーザーが、その業務を実行するために必要最小限の権限のみを持ち、それ以上の権限は持たないという原則です。この原則を中間層アプリケーションに適用すると、中間層も必要以上の権限を持つ必要がないことになります。 Oracle Databaseでは、特定のデータベース・ロールのみを使用して、中間層が特定のデータベース・ユーザーのかわりに接続できるように制限できます。 中間層の権限は、LDAPディレクトリに格納されているエンタープライズ・ユーザーのかわりとしてのみ接続するように制限できます。この場合は、マップされたデータベース・ユーザーとして接続する権限を中間層に付与します。 たとえば、エンタープライズ・ユーザーがAPPUSERスキーマにマップされている場合は、最低限APPUSERのかわりに接続できる機能を中間層に付与する必要があります。権限が付与されていない場合は、エンタープライズ・ユーザーのセッションを確立しようとしても失敗します。
ただし、中間層がエンタープライズ・ユーザーのかわりに接続する機能は制限できません。たとえば、ユーザーSarahが中間層appsrv(データベース・ユーザーでもある)を介してデータベースに接続するとします。Sarahには複数のロールがありますが、Sarahのかわりにclerkロールのみを実行できるように中間層を制限します。
DBAは、appsrvに対して、Sarahのclerkロールのみを使用してSarahのかわりに接続を開始する許可を効果的に付与できます。次の構文を使用します。
ALTER USER sarah GRANT CONNECT THROUGH appsrv WITH ROLE clerk;
デフォルトでは、中間層はどのクライアントに対する接続も確立できません。 許可はユーザーごとに付与する必要があります。
appsrvに対して、クライアントSarahに付与されているすべてのロールの使用を許可するには、次の文を使用します。
ALTER USER sarah GRANT CONNECT THROUGH appsrv;
中間層が別のデータベース・ユーザーのOCIまたはThick JDBCセッションを開始するたびに、データベースでは指定されたロールを使用して、そのユーザーに対する接続を開始する権限が中間層にあるかどうかを検証します。
注意:
デフォルトのロールを使用せずに、独自のロールを作成し、そのロールに必要な権限のみを割り当てるようにしてください。 独自のロールを作成すると、ロールによって付与される権限を制御でき、Oracleでデフォルトのロールが変更または削除された場合も保護されます。 たとえば、現在、CONNECTロールには、データベースへの接続で直接必要になるCREATE SESSION権限のみが含まれています。 
以前は、CONNECTロールにより、多くのユーザーに対して不要または不適切な権限が提供されていました。 余分な権限があると、データベースやアプリケーションのセキュリティが危険にさらされることになりかねません。 CONNECTからはこのような余分な権限が削除されています。CONNECTおよびRESOURCEの両ロールは、Oracle Databaseの将来のバージョンでは非推奨になる予定です。 
中間層からデータベースへのユーザーの再認証
管理者は、ALTER USER SQL文でAUTHENTICATION REQUIREDプロキシ句を使用して、認証が必要であることを指定できます。 この場合、中間層はユーザーの認証資格証明を提供する必要があります。
たとえば、ユーザーSarahが中間層appsrvを介してデータベースに接続するとします。 DBAは、次の構文を使用して、appsrvに対してSarahの認証資格証明を提供するように要求できます。
ALTER USER sarah GRANT CONNECT THROUGH appsrv AUTHENTICATION REQUIRED;
AUTHENTICATION REQUIRED句は、ユーザーが指定されたプロキシを介して認証される場合に、ユーザーの認証資格証明が提示される必要があることを示しています。
パスワード・ベースのプロキシ認証の使用
パスワード・ベースのプロキシ認証を使用すると、クライアントのパスワードは中間層サーバーに渡されます。次に、中間層サーバーは、そのパスワードを属性として、検証のためにデータ・サーバーに渡します。この認証の主なメリットは、データベース操作を実行するために、クライアント・マシンにOracleソフトウェアを実際にインストールする必要がないことです。
クライアントのパスワードを渡す場合、中間層サーバーは、次の疑似インタフェースを使用してOCIAttrSet()関数をコールします。
OCIAttrSet (OCISession *session_handle,
OCI_HTYPE_SESSION,
lxstp *password,
(ub4) 0,
OCI_ATTR_PASSWORD,
OCIError *error_handle);
エンタープライズ・ユーザーでのプロキシ認証の使用
中間層がエンタープライズ・ユーザーであるクライアントとしてデータベースに接続している場合は、識別名または識別名を含むX.509証明書のいずれかが、データベース・ユーザー名のかわりに渡されます。 ユーザーがパスワード認証方式のエンタープライズ・ユーザーの場合、中間層は、少なくともユーザーのグローバルな一意の名前を提供する必要があります。 データベースは、この名前を使用してOracle Internet Directoryでユーザーを検索します。
クライアントの識別名を渡す場合、アプリケーション・サーバーは、次の疑似インタフェースを使用してOCIAttrSet()をコールします。
OCIAttrSet(OCISession *session_handle,
OCI_HTYPE_SESSION,
lxstp *distinguished_name,
(ub4) 0,
OCI_ATTR_DISTINGUISHED_NAME,
OCIError *error_handle);
証明書全体を渡す場合、中間層は次の疑似インタフェースを使用します。
OCIAttrSet(OCISession *session_handle,
OCI_HTYPE_SESSION,
ub1 *certificate,
ub4 certificate_length,
OCI_ATTR_CERTIFICATE,
OCIError *error_handle);
証明書のタイプが指定されていない場合、サーバーはデフォルトの証明書タイプX.509を使用します。
パスワード認証方式のエンタープライズ・ユーザーにプロキシ認証を使用する場合は、パスワードで認証されるデータベース・ユーザーと同じOCI属性(OCI_ATTR_USERNAME)を使用します。 データベースでは、最初にユーザー名をデータベースに対してチェックします。 ユーザーが見つからなかった場合、データベースはディレクトリ内のユーザー名をチェックします。 このユーザー名はグローバルに一意である必要があります。
実際のユーザーのかわりに行われるアクションの監査
Oracle Databaseのプロキシ認証機能を使用すると、中間層がユーザーのかわりに実行するアクションを監査できます。たとえば、アプリケーション・サーバーhrappserverがユーザーAjitおよびJaneに対して複数のセッションを作成するとします。DBAは、hrappserverがJaneのかわりに開始するbonus表に対するSELECTの監査を次のように使用可能にできます。
AUDIT SELECT TABLE BY hrappserver ON BEHALF OF Jane;
また、DBAは、中間層を介して接続している複数のユーザー(この場合はJaneとAjit)のかわりに、次のように監査を使用可能にすることもできます。
AUDIT SELECT TABLE BY hrappserver ON BEHALF OF ANY;
この監査オプションによって監査されるのは、hrappserverが他のユーザーのかわりに開始したSELECT文のみです。DBAは別の監査オプションを使用可能にして、データベースに直接接続しているクライアントからbonus表に対するSELECT文を取得できます。
AUDIT SELECT TABLE;
実際のユーザーのかわりに実行されるアクションの監査の場合は、CONNECT ON BEHALF OF DNを監査できません。これは、LDAPディレクトリ内のユーザーはデータベースに認識されないためです。ただし、ユーザーが共有スキーマ(APPUSERなど)にアクセスする場合は、CONNECT ON BEHALF OF APPUSERを監査できます。
プロキシ認証のメリット
複数層環境では、プロキシ認証を使用すると、すべての層を通じてクライアントの識別情報と権限が保持され、クライアントのかわりに実行されるアクションが監査されるため、中間層アプリケーションのセキュリティを制御できます。 たとえば、この機能によって、Webアプリケーション(プロキシとして機能する)を使用するユーザーの識別情報を、アプリケーションを介してデータベース・サーバーに渡すことができます。
3層システムは、組織にとって多くのメリットがあります。 
組織は、アプリケーション・ロジックをアプリケーション・サーバーに、データ記憶域をデータベースにパーティション化することによって、アプリケーション・ロジックとデータ記憶域を分離できます。 
アプリケーション・サーバーおよびWebサーバーを使用して、データベースに格納されているデータにアクセスできます。 
ユーザーは、操作が簡単で使い慣れたブラウザ・インタフェースを使用できます。 
組織では、多数のファット・クライアントを多数のシン・クライアントと1つのアプリケーション・サーバーに置き換えることによって、コンピューティング・コストを低く抑えることもできます。
さらに、Oracleのプロキシ認証には、次のセキュリティ上のメリットがあります。
中間層がかわりに接続できるユーザー、および中間層がユーザーに対して想定できるロールを制御することによって制限付きトラスト・モデルが実現します。
OCIおよびThick JDBCでユーザー・セッションをサポートし、クライアント再認証のためのオーバーヘッドを排除することによってスケーラビリティが得られます。
実際のユーザーの識別情報をデータベースに到達するまで保持し、実際のユーザーのかわりに行われるアクションの監査を可能にすることによって、アカウンタビリティが得られます。
ユーザーがデータベースに認識されている環境と、ユーザーが単なるアプリケーション・ユーザーでデータベースには認識されていない環境の両方をサポートすることによって柔軟性が得られます。
クライアント識別子
次の各項では、クライアント識別子の機能と使用方法について説明します。
クライアント識別子を使用したアプリケーション・ユーザー・モデルのサポート
CLIENT_IDENTIFIER属性を使用したユーザー識別情報の保持
グローバル・アプリケーション・コンテキストから独立したCLIENT_IDENTIFIERの使用
クライアント識別子を使用したアプリケーション・ユーザー・モデルのサポート
多くのアプリケーションでは、セッション・プーリングを使用して、複数のアプリケーション・ユーザーが再利用できる多数のセッションを設定します。 ユーザーは中間層アプリケーションに対して自分自身を認証します。中間層アプリケーションは、単一の識別情報を使用してデータベースにログインし、すべてのユーザー接続を保持します。 このモデルでは、アプリケーション・ユーザーは、アプリケーションの中間層に対して認証されますが、データベースには認識されません。Oracle Databaseでは、このタイプのアプリケーションに対して、アプリケーション・ユーザー・プロキシのように機能するCLIENT_IDENTIFIER属性の使用をサポートしています。
このモデルでは、セッションの確立時に、中間層がクライアント識別子をデータベースに渡します。 クライアント識別子は、実際には、CookieまたはIPアドレスなど中間層に接続しているクライアントを表すものなら何でもかまいません。アプリケーション・ユーザーを表すクライアント識別子は、ユーザー・セッション情報内で使用可能です。また、アプリケーション・コンテキスト(USERENVネーミング・コンテキスト)を使用してアクセスすることもできます。 このように、アプリケーションはセッションを設定して再利用しながら、セッション内でアプリケーション・ユーザーを追跡できます。アプリケーションはクライアント識別子を再設定し、別のユーザーに対してそのセッションを再利用できるため、パフォーマンスが向上します。
CLIENT_IDENTIFIER属性を使用したユーザー識別情報の保持
組込みアプリケーション・コンテキスト・ネームスペースUSERENVの事前定義の属性CLIENT_IDENTIFIERを使用すると、グローバル・アプリケーション・コンテキストで使用する(または独立して使用できる)アプリケーション・ユーザー名を取得できます。グローバル・アプリケーション・コンテキストから独立して使用する場合、CLIENT_IDENTIFIERは、DBMS_SESSIONインタフェースを使用して設定できます。 CLIENT_IDENTIFIERをデータベースに渡す機能は、OCIおよびThick JDBCでサポートされています。
CLIENT_IDENTIFIERをグローバル・アプリケーション・コンテキストで使用すると、アプリケーションの作成に必要な柔軟性と高いパフォーマンスが得られます。たとえば、ビジネス・パートナに情報を提供するWebベース・アプリケーションに、ゴールド・パートナ、シルバー・パートナおよびブロンズ・パートナという3タイプのユーザーが用意されていて、それぞれが異なるレベルの使用可能な情報を表しているとします。アプリケーションでは、ユーザーごとに個別のアプリケーション・コンテキストを持つユーザー独自のセッションを設定するのではなく、ゴールド・パートナ、シルバー・パートナおよびブロンズ・パートナ用のグローバル・アプリケーション・コンテキストを設定できます。 次に、CLIENT_IDENTIFIERを使用して正しいコンテキストのセッションを指すことによって、適切なタイプのデータを取得します。 アプリケーションでは、この3つのグローバル・コンテキストを一度初期化すれば、CLIENT_IDENTIFIERを使用して適切なアプリケーション・コンテキストにアクセスし、データ・アクセスを制限できます。 これには、セッションを再利用できるということと、セッションごとにアプリケーション・コンテキストを個別に初期化する必要がなく、一度設定したグローバル・アプリケーション・コンテキストにアクセスできるというパフォーマンス上のメリットがあります。
グローバル・アプリケーション・コンテキストから独立したCLIENT_IDENTIFIERの使用
CLIENT_IDENTIFIER属性は、ユーザーがデータベースに認識されていないアプリケーションで特に役立ちます。 このような場合、アプリケーションは通常、単一のデータベース・ユーザーとして接続し、すべてのアクションがそのユーザーで実行されます。 すべてのユーザー・セッションが同じユーザーとして作成されるため、このセキュリティ・モデルでは、ユーザーごとにデータを分離することが非常に困難になります。 これらのアプリケーションでは、CLIENT_IDENTIFIER属性を使用すると、実際のアプリケーション・ユーザーの識別情報をデータベースに保持できます。
この方法によると、CLIENT_IDENTIFIER属性の値を変更することで、複数のユーザーがセッションを再利用できます(この属性は、実際のアプリケーション・ユーザーの名前を取得するために使用されます)。 結果として、ユーザーごとに個別のセッションと属性を設定するためのオーバーヘッドが回避され、アプリケーションによるセッションの再利用が可能になります。 CLIENT_IDENTIFIER属性の値が変更されると、その変更は次のOCIコールまたはThick JDBCコールに伝達されるため、パフォーマンスが向上します。
たとえば、ユーザーDanielがWeb Expenseアプリケーションに接続するとします。Danielはデータベース・ユーザーではなく、一般的なWeb Expenseアプリケーション・ユーザーです。このアプリケーションは組込みアプリケーション・コンテキスト・ネームスペースにアクセスし、CLIENT_IDENTIFIER属性値としてDANIELを設定します。 Danielは自分のWeb Expenseフォームを完了してアプリケーションを終了します。次に、Ajitが同じWeb Expenseアプリケーションに接続します。アプリケーションでは、Ajit用の新しいセッションを設定せずに、CLIENT_IDENTIFIERをAJITに変更することによって、既存のDaniel用のセッションを再利用します。これによって、データベースへの新規の接続を設定するためのオーバーヘッドと、グローバル・アプリケーション・コンテキストを設定するためのオーバーヘッドが回避されます。CLIENT_IDENTIFIER属性には、アプリケーションがアクセス制御の基準としている任意の値を設定できます。 必ずしもアプリケーションのユーザー名である必要はありません。
DBMS_SESSIONパッケージを使用して、中間層でCLIENT_IDENTIFIERを設定および消去するには、次のインタフェースを使用します。
SET_IDENTIFIER
CLEAR_IDENTIFIER
中間層では、SET_IDENTIFIERを使用してデータベース・セッションを特定のユーザーまたはグループに対応付けます。この結果、CLIENT_IDENTIFIERはセッションの属性になるため、セッション情報で確認できます。
CLIENT_IDENTIFIERをOCIによって設定する場合は、OCIAttrSet()のコールでOCI_ATTR_CLIENT_IDENTIFIER属性を使用します。この結果、サーバーに対する次のリクエスト時にその情報が伝播され、サーバー・セッションに格納されます。次に例を示します。
OCIAttrSet (session,
OCI_HTYPE_SESSION,
(dvoid *) "appuser1",
(ub4)strlen("appuser1"),
OCI_ATTR_CLIENT_IDENTIFIER,
OCIError *error_handle);
接続プーリング環境でJDBCを使用するアプリケーションの場合、クライアント識別子を使用すると、現在データベース・セッションを使用中の軽量ユーザーを識別できます。JDBCアプリケーションに対してCLIENT_IDENTIFIERを設定するには、次のoracle.jdbc.OracleConnectionインタフェース・メソッドを使用します。
setClientIdentifier() : 接続用のクライアント識別子を設定します。
clearClientIdentifier() : 接続用のクライアント識別子を消去します。
複数層環境でのユーザー識別情報の保持
