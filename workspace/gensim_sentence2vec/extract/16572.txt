ノート
SocketServer モジュールは、Python 3では socketserver にリネームされました。
2to3 ツールが、ソースコード内のimportを自動的にPython3用に修正します。
SocketServer モジュールはネットワークサーバを実装するタスクを単純化します。
このモジュールには 4 つのサーバクラスがあります: TCPServer は、クライアントとサーバ間に継続的なデータ流路を提供する、インターネット TCP プロトコルを使います。 UDPServer は、順序通りに到着しなかったり、転送中に喪失してしまってもかまわない情報の断続的なパケットである、データグラムを使います。 UnixStreamServer および
UnixDatagramServer クラスも同様ですが、Unix ドメインソケットを使います; 従って非 Unix
プラットフォームでは利用できません。ネットワークプログラミングについての詳細は、W. Richard Steven 著 UNIX Network
Programming や、 Ralph Davis 著 Win32 Network Programming のような書籍を参照してください。
これらの 4 つのクラスは要求を 同期的に (synchronously) 処理します;
各要求は次の要求を開始する前に完結していなければなりません。同期的な処理は、サーバで大量の計算を必要とする、あるいはクライアントが処理するには時間がかかりすぎるような大量のデータを返す、といった理由によってリクエストに長い時間がかかる状況には向いていません。こうした状況の解決方法は別のプロセスを生成するか、個々の要求を扱うスレッドを生成することです;  ForkingMixIn および
ThreadingMixIn 配合クラス (mix-in classes) を使えば、非同期的な動作をサポートできます。
サーバの作成にはいくつかのステップがあります。最初に、 BaseRequestHandler クラスをサブクラス化して要求処理クラス
(request hander class) を生成し、その handle() メソッドを上書きしなければなりません; このメソッドで入力される要求を処理します。次に、サーバクラスのうち一つをインスタンス化して、サーバのアドレスと要求処理クラスを渡さなければなりません。最後に、サーバオブジェクトの
handle_request() または  serve_forever() メソッドを呼び出して、単一または多数の要求を処理します。
ThreadingMixIn から継承してスレッドを利用した接続を行う場合、突発的な通信切断時の処理を明示的に指定する必要があります。
ThreadingMixIn クラスには daemon_threads 属性があり、サーバがスレッドの終了を待ち合わせるかどうかを指定する事ができます。スレッドが独自の処理を行う場合は、このフラグを明示的に指定します。デフォルトは False で、Pythonは ThreadingMixIn クラスが起動した全てのスレッドが終了するまで実行し続けます。
サーバクラス群は使用するネットワークプロトコルに関わらず、同じ外部メソッドおよび属性を持ちます。
+------------+
| BaseServer |
+------------+
|
v
+-----------+        +------------------+
| TCPServer |------->| UnixStreamServer |
+-----------+        +------------------+
|
v
+-----------+        +--------------------+
| UDPServer |------->| UnixDatagramServer |
+-----------+        +--------------------+
UnixDatagramServer は UDPServer から派生していて、
UnixStreamServer からではないことに注意してください — IP と Unix
ストリームサーバの唯一の違いはアドレスファミリーでそれは両方の Unix サーバクラスで単純に繰り返されています。
それぞれのタイプのサーバのフォークしたりスレッド実行したりするバージョンは ForkingMixIn および
ThreadingMixIn ミクシン(mix-in)クラスを使って作ることができます。たとえば、スレッド実行する UDP
サーバクラスは以下のようにして作られます。
ミクシンクラスは UDPServer で定義されるメソッドをオーバライドするために、先に来なければなりません。様々なメンバ変数を設定することで元になるサーバ機構の振る舞いを変えられます。
サービスの実装には、 BaseRequestHandler からクラスを派生させてその handle()
メソッドを再定義しなければなりません。このようにすれば、サーバクラスと要求処理クラスを結合して様々なバージョンのサービスを実行することができます。要求処理クラスはデータグラムサービスかストリームサービスかで異なることでしょう。この違いは処理サブクラス
StreamRequestHandler または DatagramRequestHandler
を使うという形で隠蔽できます。
もちろん、まだ頭を使わなければなりません! たとえば、サービスがリクエストによっては書き換えられるようなメモリ上の状態を使うならば、フォークするサーバを使うのは馬鹿げています。というのも子プロセスでの書き換えは親プロセスで保存されている初期状態にも親プロセスから分配される各子プロセスの状態にも届かないからです。この場合、スレッド実行するサーバを使うことはできますが、共有データの一貫性を保つためにロックを使わなければならなくなるでしょう。
一方、全てのデータが外部に(たとえばファイルシステムに)保存される HTTP サーバを作っているのだとすると、同期クラスではどうしても一つの要求が処理されている間サービスが「耳の聞こえない」状態を呈することになります — この状態はもしクライアントが要求した全てのデータをゆっくり受け取るととても長い時間続きかねません。こういう場合にはサーバをスレッド実行したりフォークすることが適切です。
ある場合には、要求の一部を同期的に処理する一方で、要求データに依って子プロセスをフォークして処理を終了させる、といった方法も適当かもしれません。こうした処理方法は同期サーバを使って要求処理クラスの handle()
メソッドの中で自分でフォークするようにして実装することができます。
スレッドも fork() もサポートされない環境で (もしくはサービスにとってそれらがあまりに高価についたり不適切な場合に)
多数の同時要求を捌くもう一つのアプローチは、部分的に処理し終えた要求のテーブルを自分で管理し、次にどの要求に対処するか
(または新しく入ってきた要求を扱うかどうか)を決めるのに select() を使う方法です。これは(もしスレッドやサブプロセスが使えなければ)特にストリームサービスに対して重要で、そのようなサービスでは各クライアントが潜在的に長く接続し続けます。この問題を管理する別の方法について、 asyncore モジュールを参照してください。
20.17.3. RequestHandlerオブジェクト¶
要求処理クラスでは、新たな handle() メソッドを定義しなくてはならず、また以下のメソッドのいずれかを上書きすることができます。各要求ごとに新たなインスタンスが生成されます。
RequestHandler.finish()¶
handle() メソッドが呼び出された後、何らかの後始末を行うために呼び出されます。標準の実装では何も行いません。 setup()
または handle() が例外を送出した場合には、この関数は呼び出されません。
RequestHandler.handle()¶
この関数では、クライアントからの要求を実現するために必要な全ての作業を行わなければなりません。デフォルト実装では何もしません。この作業の上で、いくつかのインスタンス属性を利用することができます; クライアントからの要求は self.request です;
クライアントのアドレスは self.client_address です;  そしてサーバごとの情報にアクセスする場合には、サーバインスタンスを
self.server で取得できます。
self.request の型はサービスがデータグラム型かストリーム型かで異なります。ストリーム型では、 self.request はソケットオブジェクトです;
データグラムサービスでは、 self.request は文字列とソケットのタプルになります。しかし、この違いは要求処理サブクラスの StreamRequestHandler や
DatagramRequestHandler を使うことで隠蔽することができます。これらのクラスでは setup() および
finish() メソッドを上書きしており、 self.rfile および self.wfile 属性を提供しています。 self.rfile および self.wfile は、要求データを取得したりクライアントにデータを返すために、それぞれ読み出し、書き込みを行うことができます。
RequestHandler.setup()¶
handle()   メソッドより前に呼び出され、何らかの必要な初期化処理を行います。標準の実装では何も行いません。
20.17. SocketServer — ネットワークサーバ構築のためのフレームワーク &mdash; Python 2.7ja1 documentation
