
9. クラス 
Python では、最小限の構文と意味付けを使ってクラス (class) のメカニズム
を言語に追加しています。Python のクラスは、C++ と Modula-3 で
見られるクラスメカニズムを混合したものです。モジュールがそうであるように、
Python におけるクラスでは、クラス定義とユーザとの間に絶対的な障壁を
おかず、ユーザが礼儀正しく、 ``定義に首を突っ込む'' ことはないと
あてにしています。とはいえ、クラスにおける最も重要な機能はそのままに、
完全な力を持っています: クラスの継承 (inheritance) メカニズムでは、
複数の基底クラスを持つことができ、導出されたクラスでは基底クラスの
任意のメソッドをオーバライド (override, 上書き) することができます。
メソッドでは、基底クラスのメソッドを同じ名前で呼び出すことができます。
オブジェクトには任意のプライベートなデータを入れることができます。
C++ の用語では、全てのクラスメンバ (データメンバも含む) は
public (公開されたデータ) であり、メンバ関数はすべて
仮想関数 (virtual) です。特別なコンストラクタ (constructor:
生成関数) やデストラクタ (destructor: 破壊関数) はありません。Module-3
にあるような、オブジェクトのメンバをメソッドから参照するために短縮した
記法は使えません: メソッド関数の宣言では、オブジェクト自体を表すパラメ
タ第一引数に明示せねばなりません。第一引数のオブジェクトはメソッド呼び
出しの際に暗黙の引数として渡されます。Smalltalk に似て、クラスはそれ自
体がオブジェクトです。とはいえ、これは広義のオブジェクトという意味で、
Python では全てのデータ型はオブジェクトです。このことは、import や名前
変更といった操作のセマンティクスにつながります。
C++ や Modula-3 と違って、ユーザは組込みの型を基底クラスにして拡張
を行えます。また、C++ とは同じで Modula-3 とは違う点として、特別な
構文を伴うほとんどの組み込み演算子 (算術演算子 (arithmetic operator)
や添字表記) はクラスインスタンスで使うために再定義できます。
9.1 用語について一言 
クラスに関して広範に受け入れられている用語定義がないので、
Smalltalk と C++ の用語を場合に応じて使っていくことに
します。 (オブジェクト指向における意味付けの方法は C++よりも 
Modula-3 のほうが Python に近いので Modula-3 の用語を使いたいのですが、
ほとんどの読者はそれを耳にしたことがないと思います。)
オブジェクトには個体性があり、同一のオブジェクトに (複数のスコープの) 
複数の名前を割り当てることができます。この機能は他の言語では
別名 (ailias) づけとして知られています。Python を一見しただけでは、
別名づけの重要性は分からないことが多く、変更不能な基本型 (数値、文字列、
タプル) を扱うときには無視して差し支えありません。
しかしながら、別名付けには、リストや辞書、またプログラムの外部
にある実体 (ファイル、ウィンドウ、など) を表現するためのほとんどの型
が入った Python コードで意味付けを行う上で (意図的な!) 効果があります。
別名付けはいくつかの点でポインタのように振舞うので、通常はプログラムに
利するように使われます。例えば、オブジェクトの受け渡しは、実装上は
ポインタが渡されるだけなのでコストの低い操作になります; また、関数が
あるオブジェクトを引数として渡されたとき、関数の呼び出し側から
オブジェクトに対する変更を見ることができます -- これにより、
Pascal にあるような二つの引数渡し機構をもつ必要をなくしています。
9.2 Python のスコープと名前空間 
クラスを紹介する前に、Python のスコープ規則についてあることを話して
おかなければなりません。クラス定義はある巧みなトリックを名前空間に
施すので、何が起こっているのかを完全に理解するには、スコープと
名前空間がどのように動作するかを理解する必要があります。
ちなみに、この問題に関する知識は全ての Python プログラマにとって
有用です。
まず定義から始めましょう。
名前空間 (namespace) とは、
名前からオブジェクトへの対応付け (mapping) です。
ほとんどの名前空間は、現状では Python の辞書として実装されていますが、
そのことは通常は (パフォーマンス以外では) 目立つことはないし、
将来は変更されるかもしれません。
名前空間の例には、組込み名の集合 (abs() 等の関数や組込み
例外名)、モジュールないのグローバルな名前; 関数を呼び出したときの
ローカルな名前、があります。その意味では、オブジェクトの属性から
なる集合もまた、名前空間を形成します。名前空間について知っておくべき
重要なことは、異なった名前空間にある名前の間には全く関係がないと
いうことです; 例えば、二つの別々のモジュールの両方で関数 
``maximize'' という関数を定義することができ、定義自体は混同され
ることはありません  -- モジュールのユーザは名前の前にモジュール名を
つけなければなりません。
ところで、属性という言葉は、ドットに続く名前すべてに対して
使っています -- 例えば式 z.real で、real は
オブジェクト z の属性です。厳密にいえば、モジュール内の名前に
対する参照は属性の参照です: 式 modname.funcname では、
modname はあるモジュールオブジェクトで、funcname は
その属性です。この場合には、たまたまモジュールの属性とモジュール内の
グローバルな名前の間には
この場合はたまたま、モジュールの属性とモジュールで定義されている
グローバル名の間には、直接的な対応付けがされます: これらの名前は
同じ名前空間を共有しているのです!
9.1
属性は読取り専用にも、書き込み専用にもできます。
後者の場合、属性に代入することができます。
モジュール属性は書込み可能です: "modname.the_answer = 42" と書く
ことができます。書込み可能な属性は、del 文で削除することも
できます。例えば、"del modname.the_answer" は、modname 
で指定されたオブジェクトから属性 the_answer を除去します。
名前空間は様々な時点で作成され、その寿命も様々です。
組み込みの名前が入った名前空間は Python インタプリタが起動するときに
作成され、決して削除されることはありません。モジュールのグローバルな
名前空間は、モジュール定義が読み込まれたときに作成されます; 通常、
モジュールの名前空間は、インタプリタが終了するまで残ります。
インタプリタのトップレベルで実行された文は、スクリプトファイルから
読み出されたものでも対話的に読み出されたものでも、__main__
という名前のモジュールの一部分であるとみなされるので、独自の
名前空間を持つことになります。(組み込みの名前は実際にはモジュール内
に存在します; そのモジュールは __builtin__ と呼ばれています。)
関数のローカルな名前空間は、関数が呼び出されたときに作成され、
関数から戻ったときや、関数内で例外が送出され、かつ関数内で処理され
なかった場合に削除されます。
(実際には、忘れられる、と言ったほうが起きていることをよく表して
います。) もちろん、再帰呼出しのときには、各々の呼び出しで各自の
ローカルな名前空間があります。
スコープ (scope) とは、ある名前空間が直接アクセスできる
(directly accessible) ような、Python プログラムのテキスト上の領域
です。
``直接アクセス可能'' とは、限定なし (unqualified) である名前を参照
した際に、その名前空間から名前を見つけようと試みることを意味します。
スコープは静的に決定されますが、動的に使用されます。
実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの
入れ子になったスコープがあります: 
最初に検索される最も内側のスコープには、ローカルな名前が入っています;
あるいは、最も内側のスコープを囲んでいる関数群のスコープで、最も
近傍のスコープから検索を始めます; 中間のスコープが次に検索され、
このスコープには現在のモジュールのグローバルな名前が入っています;
(最後に検索される) 最も外側のスコープは、組み込みの名前が入った
名前空間です。
名前がグローバルであると宣言されている場合、その名前に対する参照や
代入は全て、モジュールのグローバルな名前の入った中間のスコープに
対して直接行われます。そうでない場合、最も内側のスコープより外側に
ある変数は全て読み出し専用(そのような変数に対する書き込みは、単に
新しいローカル変数もっとも内側のスコープで作成し、外部のスコー
プの値は変化しません)となります。
通常、ローカルスコープは (プログラムテキスト上の) 現在の関数の
ローカルな名前を参照します。関数の外側では、ローカルスコープは
グローバルな名前空間と同じ名前空間: モジュールの名前空間を参照します。
クラスを定義すると、ローカルスコープの中にもう一つ名前空間が置かれ
ます。
スコープはテキスト上で決定されていると理解することが重要です:
モジュール内で定義される関数のグローバルなスコープは、
関数がどこから呼び出されても、どんな別名をつけて呼び出されても、
そのモジュールの名前空間になります。反対に、実際の名前の検索は
実行時に動的に行われます -- とはいえ、言語の定義は、``コンパイル'' 
時の静的な名前解決の方向に進化しているので、
動的な名前解決に頼ってはいけません! (事実、ローカルな変数は既に
静的に決定されています。)
Python 特有の癖として、代入を行うと名前がいつも最も内側のスコープに
入るというものがあります。代入はデータのコピーを行いません --
単に名前をオブジェクトに結びつける (bind) だけです。オブジェクトの削除
でも同じです: "del x" は、x をローカルスコープが参照している
名前空間から削除します。実際、新たな名前を導入する操作は全てローカル
スコープを用います: とりわけ、 import 文や関数定義は、モジュールや
関数の名前をローカルスコープに結び付けます。(global 文を使えば、
特定の変数がグローバルスコープにあることを示せます。)
9.3 クラス初見 
クラスでは、新しい構文を少しと、三つの新たなオブジェクト型、そして
新たな意味付けをいくつか取り入れています。
9.3.1 クラス定義の構文 
クラス定義の最も単純な形式は、以下のようになります:
関数定義 (def 文) と同様、クラス定義が効果をもつには
まず実行しなければなりません。
(クラス定義を if 文の分岐先や関数内部に置くことも、
考え方としてはありえます。)
実際には、クラス定義の内側にある文は、通常は関数定義になりますが、
他の文を書くこともでき、それがそれが役に立つこともあります -- 
これについては後で述べます。クラス内の関数定義は通常、メソッドの
呼び出し規約で決められた独特の形式の引数リストを持ちます --
これについても後で述べます。
クラス定義に入ると、新たな名前空間が作成され、ローカルな
名前空間として使われます -- 従って、ローカルな変数に対する
全ての代入はこの新たな名前空間に名要ります。特に、関数定義を
行うと、新たな関数の名前はこの名前空間に結び付けられます。
クラス定義から普通に (定義の終端に到達して) 抜けると、
クラスオブジェクト (class object)  が生成されます。
クラスオブジェクトは、基本的にはクラス定義で作成された名前空間の
内容をくるむラッパ (wrapper) です; クラスオブジェクトについては
次の節で詳しく学ぶことにします。(クラス定義に入る前に有効だった)
元のローカルスコープが復帰し、生成されたクラスオブジェクトは
復帰したローカルスコープにクラス定義のヘッダで指定した名前
(上の例では ClassName) で結び付けられます。
9.3.2 クラスオブジェクト 
クラス・オブジェクトでは2種類の演算: 属性参照とインスタンス生成を
サポートしています。
属性参照 (attribute reference) は、Python におけるすべての
属性参照で使われている標準的な構文、 obj.name を使います。
クラスオブジェクトが生成された際にクラスの名前空間にあった名前すべてが
有効な属性名です。従って、以下のようなクラス定義:
では、MyClass.i と MyClass.f は妥当な属性参照であり、
それぞれ整数と関数オブジェクトを返します。
クラス属性に代入を行うこともできます。従って、MyClass.i の値を
代入して変更できます。
__doc__ も有効な属性で、そのクラスに属している docstring、
この場合は "A simple example class" を返します。
クラスの インスタンス生成 (instantiation) には関数のような
表記法を使います。クラスオブジェクトのことを、単にクラスの新しい
インスタンスを返すパラメタを持たない関数かのように扱います。
例えば (上記のクラスでいえば):
9. クラス
