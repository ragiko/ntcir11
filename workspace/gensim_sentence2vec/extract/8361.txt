
RSA暗号とは、桁数が大きい合成数の素因数分解問題が困難であることを安全性の根拠とした公開鍵暗号の一つである。 暗号 (Cipher) とデジタル署名 (Digital signature) を実現できる方式として最初に公開されたものである。
概要[編集]
1977年に発明され、発明者であるロナルド・リベスト (Ron Rivest) 、アディ・シャミア (Adi Shamir) 、レオナルド・エーデルマン (Len Adleman) の頭文字をつなげてこのように呼ばれる。当時、ディフィーとヘルマンによって発表されたばかりの公開鍵暗号という新しい概念に対し、秘匿や認証を実現できる具体的なアルゴリズムを与えた。発明者3氏は、この功績によって2002年のチューリング賞を受賞した。
RSA暗号は次のような方式である: 鍵ペア(公開鍵と秘密鍵)を作成して公開鍵を公開する。まず、適当な正整数 e(通常は小さな数。(65537 =216+1) がよく使われる)を選択する。また、大きな2つの素数 {p ,q } を生成し、それらの積 n (=pq) を求めて、{e, n } を平文の暗号化に使用する鍵(公開鍵)とする。2つの素数 {p ,q } は、暗号文の復号に使用する鍵(秘密鍵)d の生成にも使用し () 、秘密に保管する。
暗号化(平文 m から暗号文 c を作成する): 
復号(暗号文 c から元の平文 m を得る): 
ここで、暗号化(e 乗)は、{e, n } があれば容易に計算できるのに対して、復号(e 乗根)は、「n の素因数を知らないと難しい(大きい合成数の素因数分解も難しい)」と考えられている。つまり秘密鍵を用いずに暗号文から平文を得ることは難しい、と信じられている。これがRSA暗号の安全性の根拠である。
RSA暗号のアルゴリズムは、1983年9月20日にアメリカ合衆国で特許(4,405,829号)を取得し、RSA Security 社がライセンスを独占していたが、特許期間満了に伴って2000年9月6日からは誰でも自由に使用できるようになった。
暗号の用語については、暗号の用語、暗号理論の用語を参照。
歴史[編集]
歴史的見解を正すのであれば、暗号に革命を起こしたこの理論の最初の発案者はジェイムズ・エリス(英語版)である。彼らはイギリス最高機密機関、英国政府通信本部 (GCHQ) の職員であり、その独創的な先見の明は内部文書として長い間公開されなかった。また実用にはコンピュータの性能等から機が熟していなかった。以下はその概要である。
エリスは1969年にこの理論を発見しているが、専門の数学者ではなかったため、具体的な方法を発見できなかった。幾人ものGCHQの優秀な数学者が挑戦したが、具体的な方法を提示する事はできなかった。1973年、突拍子もない暗号のアイデアとしてエリスの「一方向関数(非対称性鍵の概念)・公開鍵」を用いた暗号論の話を聞かされ、わずか30分程度でモジュラー算術と素因数を用いた具体的な方法を考案したのは、GCHQ所属の若き数学者クリフォード・コックス(英語版)である(コックスは上記のリベストの計算式と同じものを発見した)。しかしエリスとコックスの業績は機密事項とされたため、1997年までは世に知られることはなかった。
暗号方式[編集]
鍵生成、暗号化、復号の3つのアルゴリズムで定義される。
鍵生成[編集]
k をセキュリティパラメタとする。
p, q (p≠q)を k/2 ビットの素数とし、n = pq とする。e を φ(n) 未満の正の整数で、φ(n) と互いに素な数とし、d を、φ(n) を法としたe の逆数( de ≡ 1 ( mod φ(n) ) )とする。 ただしここで φ(n) は n のオイラー関数で、この場合は (p - 1)(q - 1) に等しい。d は、e, φ(n) が既知のときには拡張されたユークリッドの互除法を使えば容易に求まる( de を φ(n) で割った整数商を x とした場合、de + (-x)φ(n) = 1が成り立ち、かつ e の取り方から gcd (e,φ(n)) = 1 であるのでこれを解けば良い)。d を秘密鍵とし、n, e を公開鍵とする(p,qが漏れるとdが計算で求まるため、pとqは安全に破棄すること)
以下では、0 以上 n 未満の整数の集合を  で表すことにする。 平文空間および暗号文空間は 。
暗号化[編集]
a を平文空間  の元とする。b = ae mod n (n を法とする剰余)を計算し、b を出力する。
復号[編集]
b を暗号文とする。a = bd mod n を計算し、a を出力する。ここで a = a となり復号できる。
完全性の証明[編集]
以下に証明を示す。ここで a は、ae にさらに d を乗したものの n を法とする余剰で、de ≡ 1 ( mod φ(n))であるから、
a ≡ a(de) (mod n) ≡ a( x * φ(n) + 1) (mod n)
ここでオイラーの定理により、n と互いに素な整数 a については aφ(n) ≡ 1 (mod n) であるため、
a ≡ 1x * a1 ≡ a (mod n)
となる。GCD(n,a) = p である整数 a については, a=p*i=aq+q*j, 0<i<q, 0<=j<p として
a ≡ 0 (mod p)
a ≡ a ≡ aq (mod q)
となるから中国の剰余定理により、p*xp=1+q*xq として
a ≡ 0*q*xq + aq*p*xp ≡ (p*i-q*j)*p*xp ≡ p*i*p*xp ≡ p*i*(1+q*xq) ≡ p*i + p*i*q*xq ≡ p*i ≡ a (mod n)
となる(GCD(n,a) = q である整数についても同様)。ここで、 a も a も n を法とした余剰なので、
a = a
が成り立ち b は d と n を用いて a に復号できることが分かる。
性能[編集]
n を法とするべき剰余の計算[編集]
k=1024の場合、n は1024ビットサイズという大きな数となり、d もほぼ n と同サイズの数となる。 a = bd mod n を計算するには、バイナリ法というアルゴリズムを用いると、剰余乗算 (1024bit × 1024bit) を、1500回程繰り返すことで実現できる。 これには相当の計算時間を要するため、中国の剰余定理を用いて、
ap = bd mod φ(p) mod p, aq = bd mod φ(q) mod q, a = ap (1/q mod p) q + aq (1/p mod q) p
として求めることがある。
素数生成[編集]
桁数が大きい場合、確実に素数であると保証できる整数を見つけることは容易ではない。このため実際には、素数であるとは断言できないものの、素数である可能性が非常に高い自然数を用いる。こういった自然数の生成はMiller-Rabinテストなどの確率的素数判定法によって高速に行える。確率的素数判定法をパスした自然数を確率的素数 (probable prime) という。確率的素数には、素数の他に擬素数が含まれるが、その確率は判定回数を増やすことで極めて低くすることができる。
(なお、拡張リーマン予想が正しければ、Miller-Rabinテストは素数かどうかを正しく判定する、という事実が知られている)。
2002年8月、インド工科大学 のアグラワルらが素数判定を多項式時間で行うAKS素数判定法を発表したが、これは多項式の次数が高すぎて遅いので未だRSAの鍵生成に実用するには足らない。
安全性[編集]
RSA暗号と素因数分解問題の関係[編集]
RSA暗号は、安全性が素因数分解問題と同値であると期待されている暗号方式であるが、本当に両者が同値であるかどうかについては分かっていない。
素因数分解を解けるオラクルを用いれば、nからpおよびqが計算でき鍵生成と同様にして、秘密鍵dを知ることが出来る。即ち、RSA暗号が解読出来る。従って、RSA仮定が証明できれば素因数問題の困難性が示せる。しかし、逆が成立するかどうかはよく分かっていない。ある条件下では否定的な結果もでている。
RSA暗号が選択平文攻撃に対して完全解読できない、ということとRSA仮定とは同値である。
RSA問題を解く方法として、現在知られている有力な方法は、素因数分解問題を解くことに使える方法だけである。 素因数分解問題を解く方法として、楕円曲線法や数体篩法などのアルゴリズムが知られているが、これらの方法はどれも準指数時間アルゴリズムであり、多項式時間で素因数分解問題を解く方法は知られていない。
暗号理論の世界では、多項式時間で解読することができない暗号方式を安全であると定義することがある(計算量的安全性)。 この意味で、RSA暗号の安全性について、現在知られている範囲では、安全であると期待されていて、その反証がない、と言える。
RSA問題や素因数分解問題はNP問題であるので、これらの問題が (deterministicな) 多項式時間では解けないことが証明できれば、P≠NP予想が肯定的に解決することになる。 但し、ハミルトン閉路問題など他のNP問題(NPかつNP困難なNP完全問題を含む)が多項式時間で解けることが証明されればP=NPとなってしまう。
素因数分解可能な範囲[編集]
2004年現在、インターネットで公募した数多くのPCを用いると512ビット程度の数なら素因数分解できる。 したがって、現在では、RSA暗号に使用する法 n を1024-4096ビット(10進数で300-1000桁程度)にすることが推奨されている。
しかしShamirは、RSA問題を解くための専用装置 (TWIRL) を作成すれば、1024ビットの n に関するRSA問題ですら解くことができると主張している。
RSA暗号解読コンテスト[編集]
RSA社は「RSA Factoring Challenge」を1991年から2007年まで実施し、最新の計算機環境でどの程度のビット数の整数が素因数分解可能かを調べた。
1991.04.01 RSA-100 (330ビット)
1992.04.14 RSA-110 (364ビット)
1993.06.09 RSA-120 (397ビット)
1994.04 RSA-129 (426ビット)
1996.04.10 RSA-130 (430ビット)
1999.02.02 RSA-140 (463ビット)
2004 RSA-150 (496ビット)
1999.08.22 RSA-155 (512ビット)
2003.04.01 RSA-160 (530ビット)
2009.12.29 RSA-170 (563ビット)
2003.12.03 RSA-576 (576ビット,10進174桁)
yet RSA-180 (596ビット)
yet RSA-190 (629ビット)
2005.11.02 RSA-640 (640ビット)
2005.05.09 RSA-200 (663ビット,10進200桁)
yet RSA-210 (696ビット,10進210桁)
yet RSA-704 (704ビット)
2009.12.12 RSA-768 (768ビット)
以下は未踏
RSA-896
RSA-1024
RSA-1536
RSA-2048
RSA暗号の性質[編集]
RSA暗号は選択暗号文攻撃を行なえば完全解読できる。また、RSA暗号は選択平文攻撃に対してすらindistinguishable(識別不能)ではない。よってRSA暗号は選択平文攻撃に対してnon-malleable(頑強性)でもsemantic secure(強秘匿性)でもない。non-malleable、semantic secureの定義は公開鍵暗号に記されている。
RSA暗号の誤用[編集]
パラメータの選択[編集]
Strong Prime
脆弱な平文[編集]
RSA暗号の安全性が素因数が不明な法nでの冪根を求めるのが難しい事実に基づいていることから、その最大の攻撃が素因数分解であることは明白である。
しかし平文によっては、それ以外の攻撃方法でも暗号文から平文を入手することが可能である。
決まりきった平文[編集]
これは公開鍵暗号全般に言えることであるが、確定的暗号であれば、例えば平文が「はい」か「いいえ」のどちらかしか有り得ないなら、それぞれを暗号化したものと暗号文とを比較すれば平文を知ることができる。
実際の暗号への応用においてはフォーマットとしてmの一部に毎回生成する乱数を挿入することでこの攻撃を回避している(復号側で後半の乱数を無視するよう機械を設定すればよい)
小さなm[編集]
もしも平文 m が、n の e 乗根よりも小さかったら、暗号文となるから、通常の冪根演算によって c の e 乗根を計算するだけで平文 m が復元できてしまう。
実際の暗号への応用においてはフォーマットの一部として、m の比較的高位のビットに1を挿入することでこの攻撃を回避している。
同一平文[編集]
法nにおけるe乗根が計算できれば、暗号文を復号できる。 当然これは(法nの素因数がわからない限り)非常に難しいと考えられていて、RSA暗号の安全性の重要な根拠の一つになっている。
しかし、まったく同一の平文を、異なる法において同一のeを用いて暗号化した暗号文をe個以上集めることで、各々の法に関して中国の剰余定理を用いれば通常の冪根演算によって平文を復元できる。これが同報通信の誤用である。
ここから中国の剰余定理によって上記式を満たす
を求めることができる。このときであり、またmはどの法nよりも小さいためであることから、
このcのe乗根を求めることで平文mが求められる。
これはeとして特に3や65537が、2進数表示したときに1の個数が少ないために暗号化処理を高速化できるという理由から好んで用いられるために発生しうる問題である。実際の暗号への応用においてはフォーマットとして、mの一部に毎回生成する乱数を挿入することでこの攻撃を回避している。
その他[編集]
RSA暗号の入力は、モジュラスをnとすると0～ (n-1) の範囲の整数である。n以上の値の平文を暗号化する際には、平文を分割して処理することになる。
この時に留意しなければならない点として、例えば、nが1024ビット(=128バイト)であるとき、平文を同じ1024ビット毎に分割処理するのでは十分ではないという点がある。これは、n, mが共に1024ビットであったとしても、n<mの場合には、結果として出力されるのは、m mod nに対応する暗号文であり、復号してもmは出力されないためである。
平文をビット単位(やバイト単位)で分割する際には、まず、nの下限を定めたうえで、平文の全ビットを1に(全バイトを0xFFに)してもnより小さくなるビット数(バイト数)で分割しなければならない。例えば、nの下限をn≧2^1023とした場合、平文は1023ビットごとに分割する。こうすることでm<nの条件が常に満たされる。
一方で、出力となる暗号文は0～ (n-1) の範囲の整数になるため、先の例で(nの下限より小さいビット数)1023ビット毎に分割されたmに対応する暗号文の中には、1024ビットが必要となるものがある。つまり、平文をビット単位で分割する場合には暗号化によってメッセージサイズが増加するといえる。これを回避するにはビット単位で分割するのではなく、平文mをn進数表示したときの各桁毎に分割すればよい。
暗号や署名への応用[編集]
RSA暗号[編集]
暗号方式のままの方式(生RSA、教科書的RSAということがある)では、
暗号文を分解して、個々の暗号文に対応する平文を入手できる(選択暗号文攻撃)と、元の暗号文に対応する平文を求めることができてしまう、
攻撃者が暗号文を変形して、平文自体を知ることはできないが、平文を変形できてしまう(非展性がない)、
などの好ましくない性質があるため、実際に暗号として使用する際には、パディングなどのフォーマットを定義し、平文空間を限定することが必要である。パディングも含めたものとして、
RSA_PKCS
RSA_OAEP
などがある。
RSA署名[編集]
RSA暗号が実現した公開鍵暗号方式は、従来の暗号方式(共通鍵暗号)とは異なり、暗号化は公開鍵を使って誰でもできるが、復号は秘密鍵を持つ本人だけしかできない方式である。この復号は「本人だけしかできない」という性質を利用すると、デジタル署名(あるいは認証機能)が実現できる。
そのためには、公開鍵・秘密鍵を次のように使用する。
暗号の場合
平文 ---公開鍵(暗号化)----> 暗号文、暗号文 ---秘密鍵(復号)-----> 平文
署名の場合
文書 ---秘密鍵(署名生成)--> 署名値、署名値 --公開鍵(署名検証)--- 文書
公開鍵と秘密鍵の役割は通常の場合においては上記の通り、公開鍵は暗号化に使われ、秘密鍵は復号に用いられるが、RSA暗号においては平文と暗号文の定義域が同じ(平文空間=暗号文空間である)ため、任意の文書(メッセージ)を暗号文とみなして復号することができる。つまり秘密鍵を用いて任意の文書について署名値を生成でき、公開鍵を用いてその署名値を暗号化して元の文書と一致するかを調べることで署名の検証ができる。
ただし、RSA暗号と同様に、生RSAでは、署名の潜在的偽造等の好ましくない性質があるため、パディングなどが必要である。また、暗号文空間よりも大きなメッセージを扱うためにハッシュ関数と組み合わせて使用する。
このようなパディングなども含めたものとして、
RSA_PSS with SHA-1
などがある。
RSA-129[編集]
1977年、マーティン・ガードナーがコラムを連載していたScientific American誌に129桁の鍵を使ったRSA方式で暗号化されたメッセージを掲載。解読が成功したものにMITから$100を与えるという懸賞金問題を掲載。当時、解読には2万年は必要だろうと予測されていたが掲載から17年後、オックスフォード大ポール・レイランド、アイオワ州立大マイケル・グラフ、MITデレク・アトキンスらで、二次ふるい法とインターネット(600名からなる有志)を使いRSA-129に対する大規模攻撃を開始。8ヶ月で800万以上の下位問題が解かれ、スーパーコンピューターで解析、解読に成功。答えは「The magic words are squeamish ossifrage」(MITのジョークで骨折りの意)
参考文献[編集]
原論文[編集]
A Method for Obtaining Digital Signature and Public-key Cryptsystems; R.L.Rivest,A.Shamir,and L.Adelman; MIT Laboratory for Computer Science; Thechnical Memo LCS/TM82; April 4,1977(Revised December 12,1977); (「日経エレクトロニクス」に翻訳が出たと思う)
関連項目[編集]
暗号
暗号理論
RSA-OAEP
RSA-OAEP+
素因数分解
フェルマーの小定理
ElGamal暗号
楕円曲線暗号
RSA暗号 - Wikipedia
