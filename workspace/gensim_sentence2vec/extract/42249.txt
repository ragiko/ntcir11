 この連載もついに最終回となりました。今までの連載で紹介したテクニックを使えば、ほとんどのデータウェアハウスは大幅に高速になるはずですが、統計情報の取得方法に問題があって想定どおりに動いていなかったら元も子もありません。「SQLが遅い」という理由の一つに「実行計画が悪い」ということがありますが、オプティマイザは統計情報を基にして実行計画を作ります。なので、正しくない統計情報を使っていると正しくない実行計画が作られてしまい、その結果、SQLが遅いという結果になってしまいます。ある程度のコストが掛かる統計情報収集はデータの変更とリアルタイムで行われるわけではないので、統計情報を収集するタイミングや方法によっては現在のデータの実態を反映していない、正しくない統計情報になってしまいます。そこで今回は正しい統計情報の取り方と、その統計情報で正しい実行計画が作られたかどうかの監視の仕方についてご紹介します。
いつ統計情報を収集するか
データウェアハウスの場合、データ量がどんどん増加していく傾向のものが多いでしょう。データ量が少ないときの統計情報から作られた実行計画では、結合方法にネステッド・ループが選ばれやすかったり、パラレル実行時の分散方法 (PQ_DISTRIBUTE) にBROADCAST(外部表のすべての行が各コンシューマに転送される方法)が選ばれたりしやすいですが、これらの方法はデータ量が多い場合には適切ではないことが多いです。そのため、適切なタイミングで統計情報を取得しなおすことで現在のデータに合った実行計画が検討しなおされ、性能が徐々に劣化していくという問題の発生を防げます。自動オプティマイザ統計収集をオフにしていなければ、このタスクが自動的に必要なタイミングで再収集してくれますが、オフにしている場合はデータの変化に合わせて統計情報を手動で取得しなおすことを忘れないようにしてください。再取得の時期の目安は表全体の10%が挿入 / 更新 / 削除されたタイミングです。
Oracle Database 11gの自動オプティマイザ統計収集は、月曜日から金曜日は22時から翌日2時まで、土曜日と日曜日は6時から翌日2時までの間に実行されるようにデフォルトでは設定されていますので、各システムの負荷状況に合わせて変更してください。現在の設定値はDBA_AUTOTASK_WINDOW_CLIENTSビューで確認でき、DBMS_SCHEDULER.SET_ATTRIBUTEプロシージャで変更することができます。ただ、DBMS_SCHEDULER.SET_ATTRIBUTEプロシージャは構文が複雑なので、Enterprise Managerから変更したほうが簡単でしょう。
統計情報のロック
夜間バッチのタイミングによっては、自動オプティマイザ統計収集が実行される前の日次バッチでTRUNCATEされますが、自動オプティマイザ統計収集が行われた後にロードされなおすような表も存在するでしょう。このような場合はDBMS_STATS.LOCK_TABLE_STATSプロシージャを使用してください。このプロシージャを実行すると、DBMS_STATS.UNLOCK_TABLE_STATSプロシージャを実行するまで対象の表の統計情報は変更できなくなりますので、自動オプティマイザ統計収集が間違った再収集を行うことを防げます。
統計情報のリストア
とはいえ、「年次バッチを考慮することを忘れた」などの様々な理由で、通常の状態を反映しない統計情報を取得してしまう場合もあるでしょう。そのようなときはDBMS_STATS.RESTORE_TABLE_STATSプロシージャを使用して、指定した日時の統計情報に戻すことができます。
履歴はデフォルトでは31日分保存していますが、この日数を変更したい場合はDBMS_STATS.ALTER_STATS_HISTORY_RETENTIONプロシージャで変更できます。現在の値はDBMS_STATS.GET_STATS_HISTORY_RETENTIONファンクションで確認できます。設定した日数を超えた履歴は1日に1回自動消去されますが、DBMS_STATS.PURGE_STATSプロシージャで手動削除することもできます。
統計情報のエクスポートとインポート
本番環境のデータと量や個別値 (NDV) に違いがないテスト環境が存在する場合は、そちらの環境で統計情報を取得し、DBMS_STATS.EXPORT_TABLE_STATSプロシージャで統計情報を書き出し、本番環境にDBMS_STATS.IMPORT_TABLE_STATSプロシージャを使って読み込むことで、本番環境での統計情報取得時の負荷をなくすことができます。ただし、テスト環境のデータ量が少なかったり、ダミー・データのためにNDVの数が本番より少なかったりする場合には、正しくない統計情報を使用してしまうことになりますので注意してください。
※個別値 (NDV) とは: Number of Distinct Valueの略で、1つの列に存在する値の種類の数のことです。たとえば「性別」列の値は「男」か「女」の2種類なので、NDVは最大2です。Oracle Databaseは統計情報の一つとしてNDVを収集しています。
また、この方法はDBMS_STATS.ALTER_STATS_HISTORY_RETENTIONプロシージャで設定した期間よりも古い統計情報でリストアしたい場合などにも有効です。信頼できる統計情報をDBMS_STATS.EXPORT_TABLE_STATSプロシージャでバックアップしておくと、万が一の時にも安心です。
統計情報の保留と比較
新しい統計情報に万が一問題があった場合でも、統計情報のリストアやインポートによって簡単に元に戻すことができますが、いずれの方法も問題発生後の対応になってしまいます。しかし、Oracle Database 11gからは統計情報を保留することで事前対応が行えるようになりました。
Oracle Database 11gからは統計プリファレンスにPUBLISHが追加されました。PUBLISHはデフォルトではTRUEであるため、収集された統計情報は自動的に公開されてオプティマイザにすぐに使用されますが、これをFALSEにしておくと、そのあとに収集された統計情報は公開されずに保留されます。以下ではUSER1ユーザーのTAB1表のPUBLISHプリファレンスをFALSEに変更しています。
保留中の統計情報をオプティマイザは使用しませんが、OPTIMIZER_USE_PENDING_STATISTICSパラメータをTRUEにしたセッションだけは保留中の統計情報を使用します。つまり、現在の信頼できる統計情報を使用中のユーザー・アプリケーションが実行されている環境で、並行してOPTIMIZER_USE_PENDING_STATISTICSパラメータがTRUEのテスト・スクリプトが新しい統計情報を使って各SQLをテスト実行することで、性能劣化が起きるかどうかを事前確認することができます。
シバタツ流! DWHチューニングの極意  第5回 統計情報と実行計画
