
最小の真に正の値(非正規化数)は2−16493 ≈ 10−4965であり、1ビットの精度である。 最小の正の正規化数は2−16382 ≈ 3.3621 × 10−4932であり、112ビットの精度がある。 最大の表現可能な値は216384 - 216272 ≈ 1.1897 × 104932である。
四倍精度の例[編集]
下記の例は浮動小数点数の16進数によるビット表現である。これは符号、(バイアスされた)指数、仮数を含む。
3fff 0000 0000 0000 0000 0000 0000 0000   = 1
c000 0000 0000 0000 0000 0000 0000 0000   = -2
7ffe ffff ffff ffff ffff ffff ffff ffff   ≈  1.189731495357231765085759326628007 × 104932 (最大の四倍精度浮動小数点数)
0000 0000 0000 0000 0000 0000 0000 0000   = 0
8000 0000 0000 0000 0000 0000 0000 0000   = -0
7fff 0000 0000 0000 0000 0000 0000 0000   = infinity
ffff 0000 0000 0000 0000 0000 0000 0000   = -infinity
3ffd 5555 5555 5555 5555 5555 5555 5555   ≈  1/3
デフォルトでは、1/3は倍精度と同様、切り捨てられる。これは仮数のビット数が奇数であるため、丸め位置以降のビット列が0101...となり、1/2ulpより小さいためである。
サポート[編集]
四倍精度をサポートする処理系やアーキテクチャについて述べる。
利用者数が極めて少ないためか、利用環境は整っているとは言い難い現状がある。まず、処理系の独自拡張としての実装は存在するが、標準の言語仕様では四倍精度が定義されていない。従って、移植性が犠牲になるため、安易にプログラムに組み込むことが出来ない。また、CPUの浮動小数点計算ユニットも最高の場合で拡張倍精度までのサポートに留まり、四倍精度以上の精度の計算は、ハードウェア上でサポートされる精度の変数を複数組み合わせたソフトウェア上のアルゴリズムで実行するのが一般的である。その場合には、単純な四則演算一つ取っても長大な命令数が必要となるため、大きく計算速度が低下する。
一部の処理系や、64ビットアーキテクチャの場合に long double が128ビット(sizeof(long double) が 16)のことがあるが、単に拡張倍精度フォーマットを格納するのに16バイトを使うだけであることもある。また、オプションで切り替える場合はバイナリ互換性がなくなることがありうるので注意を要する。独自拡張で(最新のGCCなど) __float128 といった型が使えることもあるが、文字列表現との相互変換などのサポートが十分でないこともある。
IBMのアーキテクチャには、次節で述べるdouble-doubleの原理による四倍精度の扱いをサポートしているものがある。
SPARC-V9には四倍精度浮動小数点演算の命令があるが、2012年現在これをハードウェアで実装した実機は無く、現状では命令はソフトウェアで実行される。
専用計算機では、GRAPE-MPが四倍精度に特化して設計されている。
(SSEでは128ビットレジスタを対象として浮動小数点演算を行うが、複数の単精度や倍精度演算を同時に行う機能のみで四倍精度演算のサポートはない。次節のdouble-doubleの実装に使用されることがある)
double-double演算[編集]
有名なソフトウェア手法として、倍精度浮動小数点数のペアを用いて四倍精度に近い精度を実現する手法があり[4][5][6]、「double-double演算」や「擬似四倍精度」と呼ばれる。 真の四倍精度計算とは異なり、仮数53ビットのIEEE倍精度数のペアを用いることで、double-double演算は少なくとも[4]2×53=106ビットの仮数(もしくは可能性としては符号ビットの巧妙な扱いにより107ビット[7])を実現する計算手法である。これはIEEEのbinary128の113ビットよりわずかに少ないだけである。一方、指数は11ビットのままであるため、表せる値の範囲は基本的に倍精度と同じである[4]。これは四倍精度の15ビット仮数と比べ格段に劣る(double-doubleのに対し、binary128は)。 具体的には、double-double/四倍精度の値qをdouble-doubleの技術で表す場合、2つの倍精度数xとyのペアを用いてq=x+yという和の形で表現する。この各々はqの仮数の半分ずつを与える[5]。つまり、qの代わりに(x,y)というペアが保存されており、qに対する演算(加減乗除等)はxとyに対する等価な(ただし複雑な)演算に変換される。これにより、四倍精度の演算は(複数の)倍精度の演算へと簡略化される。倍精度演算は一般的にハードウェアに搭載されているため、double-double演算は通常、一般の任意精度演算よりも十分に高速である[5][4]。 なお、double-double演算は次のような特徴がある[8]。
値の絶対値が減少すると、追加の精度も減少する。そのため、正規化数の範囲での最小の数は倍精度よりも狭い。完全な精度を持つ最小の数は1000...02 (ゼロが106個) × 2-1074、あるいは 1.000...02 (ゼロが106個) × 2-968である。
実際の精度は変化する。一般に、ペアの下位パートの絶対値は上位パートのULPの半分を超えない。下位パートが上位パートのULPの半分より小さいならば、上位と下位の仮数の間に黙示的な全0あるいは全1のビットが存在する。仮数のビット数が固定であることに依存するアルゴリズムは128ビット長の倍精度数を使うとき失敗する可能性がある。
上の理由により、1 + 2-1074のような値を表現する事ができる。これは1より大きい表現可能な最小の値である。
更に高精度が要求されるならば、triple-double(159または161ビット精度)やquad-double(212または215ビット精度)演算を考えることもできる。
同様の手法で2つの四倍精度数からなるdouble-quad演算を考えることもできる。これは少なくとも226または227ビットの精度を持つ。[9]
八倍精度[編集]
四倍精度より精度が高く、任意精度演算より高性能な計算のためのフォーマットとして、6倍から8倍までの精度が検討されており[10][11]、いくつかの方式によるソフトウェアによる実装の報告[12][13][14][15]、GRAPE-MP 4/6/8の試作や、FPGAへの実装[16]といったハードウェアの報告などがある。
関連項目[編集]
コンピュータの数値表現
浮動小数点数
半精度浮動小数点数 (16bit) – 単精度浮動小数点数 (32bit) – 倍精度浮動小数点数 (64bit) – 拡張倍精度浮動小数点数 (80bit) – 四倍精度浮動小数点数 (128bit)
IEEE 754
References[編集]
四倍精度浮動小数点数 - Wikipedia
