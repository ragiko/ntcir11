
正規表現の解説 中級編
前へ｜
目次へ戻る｜
次へ
例を上げながら、
正規表現の書き方を解説していきます。
以降、
検索に正規表現を使うことを前提に説明をします。
［共通設定］−［一般設定］で［検索文字の色分けをする］
にチェックを入れておいた方が分かりやすいかもしれません。
検索対象ファイルは K2Editor の ReleaseNote.txt(Readme.txt ではありません)です。
(あら捜しに近いこともやっていますが、
ご了承ください(笑))
前のパターンの繰り返し
ここでは、
「*」「+」「?」の使い方を説明します。
とりあえず、
「.*」で検索してください。
改行以外のすべての文字がマッチすると思います。
(空白だけの行は色がつきませんが、
下移動等で動かしていくと、
マッチしていることが確認できます)
それでは、
何故全ての文字がマッチしたのかを解析してみます。
検索語は
「.*」です。
初級編での解説をみると、
「.」は
改行を除く任意の1文字
「*」は
直前のパターンの0回以上の繰り返しとなっています。
この場合、
直前のパターンは
「.」ですから、
改行を除く任意の1文字が0回以上繰り返している文字列がマッチすることになります。
0回以上の繰り返しですから空行でも良いことになります。
それでは空行をマッチしないようにしてみます。
空行にマッチしないようにするには行頭が改行でないものにマッチさせることになります。
簡単なのは0回以上の繰り返しでは無く、
1回以上の繰り返しにしてしまうことです。
直前のパターンの1回以上の繰り返しを表すメタキャラクタは、
「+」です。
ですから、
「.+」にすることによって、
空行をマッチさせないように出来ます。
では、
「 +」(半角スペースと+記号)で検索するとどうなるでしょうか?
この場合、
半角スペースが連続しているところがマッチします。
単語間の半角スペースにもマッチしていますが、
半角スペースが連続1回していると思えば、
間違いではないといえます。
次に、
「?」ですが、
「K2E?」で検索をしてみてください。
K2Editor, K2E.exeのK2Eの部分と、
K2GrepのK2の部分がマッチすると思います。
「?」は
直前のパターンが0回または1回現われるです。
この場合の直前のパターンはEですから、
K2又は
K2Eがマッチするからです。
今回は存在していませんが、
たとえば、
K2EEという文字列があっても、
K2Eにしかマッチしません。
目次へ戻る｜
ページの先頭へ戻る
行頭と行末と改行
アンカーの使い方の初級です。
行末と改行の差もここで説明します。
行頭(行の始まり)を表すのは
「^」です。
とりあえず「^ 」
(^ 記号と半角スペース)で検索してみましょう。
行頭の半角スペースがマッチします。
行頭ではない半角スペース(単語間のスペース等)にはマッチしません。
「 $」
(半角スペースと $ 記号)で検索すると(物理)行末の半角スペースにマッチします。
同じような検索が
「 \n」でも出来ます。
それではこの2つは同じ意味なのでしょうか?
この2つで異なっているのは半角スペースの後ろの記号です。
初級編での解説では「$」は
行の終端位置です。
「\n」は
改行です。
この2つは微妙に意味が違います。
「$」は行の終端ですが改行文字を含みません。
マッチする位置としては改行文字の手前になります。
「\n」は改行文字そのものを示します。
実際に検索してみるとその表示が異なるのが分かります。
「 $」
では半角スペース1つだけが選択されているように見えますが、
「 \n」
では半角スペース1つと改行文字が選択されるため選択範囲が広くなります。
それぞれの場合でクリップボードにコピーして別の場所に貼り付けると、
「 $」では半角スペースのみが貼り付くのに対して、
「 \n」では改行も貼り付きます。
検索ではそれほど差は感じないと思いますが置換に使う場合は注意が必要です。
改行を消すつもりではなかったのに消してしまうことがあります。
目次へ戻る｜
ページの先頭へ戻る
キャラクタのクラス化
ここからが正規表現の要になります。
基本的には単純なのですがそれだけに効率的な使い方は難しいです。
説明の関係で、大文字小文字の区別をする設定で検索するようにして下さい。
まず実際にクラス化する前に単純な検索をして見ます。
「E」1文字を正規表現で検索して下さい。
大文字のEにしかマッチしないはずです。
基本的には正規表現では英文字の大文字小文字を区別します
(Perlでは大文字小文字を区別させないためには特別なフラグを立てなければなりません)。
従って前記の「E」
ではGrepのeにはマッチしません。
でも時には区別したくない事も有ります。
たとえばHTMLではタグの大文字小文字を区別しません。
従って書く人によってそれらがばらばらになる可能性があります。
だからといって2回も3回も検索したくはないですよね?そんな時にクラスを使います。
それでは、
「GREP」で検索してみてください。
GREP機能に関する場所が全て選択されましたか?実は、
「Grep」と表記されている部分があるので、
全てではないのです。
では両方を一度に検索するにはどうしたらよいでしょうか?
キャラクター(文字)をクラス化すると、
そのクラスの中にある文字のどれか1つにマッチしていればマッチすると認識してくれます。
従って両方をマッチさせるには、
「[Gg][Rr][Ee][Pp]」とします。
G又はg,R又はr,E又はe,P又はp
の順番で並んでいる文字列
という意味になります。
次に英大文字だけで構成されている部分を検索したい場合を考えてみましょう。
英大文字だけですから、
クラスを使って、
「[ABCDEFGHIJKLMNOPQRSTUVWXYZ]」で表せます。
それで構成されているということは、
最低1文字は英大文字がなくてはいけないはずです。
ということで、
「[ABCDEFGHIJKLMNOPQRSTUVWXYZ]+」になります。
A,B,C,D,E,F,G,H,
I,J,K,L,M,N,O,P,
Q,R,S,T,U,V,W,X,
Y又はZのうちのどれかを1回以上繰り返す文字列とマッチします。
このように、クラス化した文字は1文字として扱われます。
繰り返し記号をつけることで連続しているものをマッチさせることが出来ますが、
その場合もクラス化した文字のうちのどれかの連続です。
ところで長いですよね?
[ABCDEFGHIJKLMNOPQRSTUVWXYZ]なんて手で入れたくないですよね?
私はいやになりました(笑)
実はこれ短く出来ます。
短く書くと、「[A-Z]」ですみます。
クラスの中でハイフン(-)を使うと
文字コード上の連続した範囲を指定することが出来ます。
文字コード上では英文字は連続していて、
先頭がAでZで終わります。
従って、
「[A-Z]+」は
文字コードでAからZ間での範囲のどれかを1回以上繰り返す文字列
とマッチすることになって、
前出のものと同じ動作をすることになります。
連続した範囲といわれても、
ある程度文字コードの並びを知っている人にしか分かりませんから、
よく使われると思われるものを上げておきます。
範囲指定の例
正規表現
説明
[0-9]
半角数字
[A-Z]
半角英大文字
[a-z]
半角英小文字
[0-9]
全角数字
[A-Z]
全角英大文字
[a-z]
全角英小文字
[ぁ-ん]
全角ひらがな
[ァ-ヶ]
全角カタカナ
これらは組み合わせて使うことが出来ます。
たとえば
「A-Za-z」で英文字の大文字小文字の両方を指定できます。
「[A-Za-z_]+」で英単語を探すことが出来ます。
「[A-z]」とすると、
英文字だけでなく、
一部の記号も含まれてしまうので注意してください([\]^_`が含まれる)。
クラスの中ではアンカーは使えません。行頭や行末、単語境界等は入れられないということです。
\bはクラス外では単語境界ですが、
クラス内ではバックスペースを意味するようになります。
同じように、行頭を表す^は
否定の意味になります。
「[^:]+」とすると、
:以外の文字の連続がマッチします。
このとき注意しなければならないのは、^は[の直後に置かなければならないということです。
たとえば、「[a^b]+」とすると、
a,^又はbがマッチします。
つまり、^は否定の意味ではなく、通常の文字として扱われます。
^自体をクラスの中に入れるときには[の直後以外に指定する事になります。
ちなみに「[^^]」では
^以外の文字がマッチします。
目次へ戻る｜
ページの先頭へ戻る
パターンのグループ化
大きなものはこれが最後です。
ここでは()を使ったグループ化と
「|」について説明します。
まず、
「|」について説明しておきます。
これが使えないと、
グループ化する意味が半減します(笑)
「|」は
論理和を現します。
数学の【集合】の中に出てくるはずです(大昔の事なので忘れました)。
要は、
AかBを含むということを現すものです。
たとえば、
前に出てきたGREPは
「GREP|Grep」でも検索できます。
この場合、
GREPかGrepがマッチします。
gREPにはマッチしません。
前の方法だとgREPにもマッチします。
では、
マクロコマンドのBeginUpdateとEndUpdateの出てくる所を検索したい時にはどうしたら良いでしょう?
「BeginUpdate|EndUpdate」?
前記の表現でも検索できます。
でも、
グループ化するともう少し効率的に記述することが出来ます。
グループ化すると、
その中身をまとめて1パターンとして扱います。
そこで、
BeginUpdateとEndUpdateを比べてみると、
Updateが共通して使われていることが分かります。
そこで、
BeginとEndをグループ化してあげると短く書けそうです。
グループ化した場合、
「(Begin|End)Update」となります。
もう一つグループ化した例をあげてみましょう。
「CTRL(\+LEFT|\+RIGHT)」で検索してみてください。
(+をグループの中に入れているのはわざとです。
+はメタキャラクタなので、
エスケープして検索していることに注意)
CTRL+LEFT,CTRL+RIGHTにマッチしているはずです。
CTRL+HやCTRL+Mにはマッチしません。
中身をまとめて1パターンですから、
「\+LEFT」又は
「\+RIGHT」で1パターンになっているため、
たとえ+が入っていても+Mにはマッチしません。
CTRL+Lという文字列があってもマッチしません。
グループで注意しなければならないのは、クラスの中では使えないという点です。
たとえば、「[(K2E)]」で検索すると、
(,K,2,E又は)がマッチします。
つまり、クラスの中では()は通常の文字として扱われます。
目次へ戻る｜
ページの先頭へ戻る
メタキャラクタのエスケープ
意外と嵌り易い落とし穴かもしれません。
メタキャラクタ自体を検索したい場合、
たとえばクラス外で(を検索したい場合、
ただ「(」で検索しても何もマッチしてくれません。
なぜなら(はメタキャラクタですので通常の文字と認識しないからです。
全てのメタキャラクタはそれ自身を検索する場合エスケープしてあげる必要があります。
エスケープするにはその文字の前にエスケープキャラクタの\をつけてあげます。
前記の例だと「\(」で(を検索できます。
エスケープキャラクタ自体を検索するには、エスケープキャラクタをエスケープします。
「\\」と書くということですね。
検索文字列の中にパスが含まれているとつい忘れがちな点です。
前へ｜
目次へ戻る｜
ページの先頭へ戻る｜
次へ
正規表現の解説 中級編
