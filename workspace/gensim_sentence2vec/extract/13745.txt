
動機付け
情報検索は、集めたオブジェクトから特徴量を抽出し、得られた特徴から検索用のインデックスを作成します。例えば今回の作成しているWeb検索システムの場合、クローラが集めたWebページが検索対象オブジェクトとなり、それぞれのページに記述されているテキストや埋めこまれている画像、メタデータなどがコンテンツとなります。そして、それらのコンテンツから、時間表現や単語頻度、画像ヒストグラムなどを特徴量として抽出できます。
このように、あるオブジェクトから特徴を抽出し、それをベクトルとして表現したものを、このオブジェクトの 特徴ベクトル と呼びます。特徴ベクトルを用いた検索については、「文書の検索」の回で改めて解説します。
今回扱う正規表現と自然言語処理は、テキストコンテンツから特徴量を抽出するのに用いることができます。例えば次のような文書があったとしましょう。:
Python(パイソン)は、オランダ人のグイド・ヴァンロッサムが作った
オープンソースのプログラミング言語。
最新リリース
3.2 / 2011年2月20日
このような文書から
時間表現の抽出
2011年2月20日
単語(名詞)の抽出
Python、パイソン、オランダ人、グイド・ヴァンロッサム、オープンソース、プログラミング、言語
のような特徴を抽出できるようにすることが、今回の目標です。
正規表現
正規表現とは文字列のパターンを表現する表記法のことで、マッチする文字列を直接指定せず、パターンを指定することで、表記ゆれを吸収しての操作が可能となります。正規表現は多くのプログラミング言語で実装されていますが、それぞれの実装内容が微妙に異なっています。今回は、多くの正規表現実装に共通して用いられているメタ文字について触れ、Pythonで正規表現を提供するreモジュールの使い方について説明します。
メタ文字
単一の文字にマッチするメタ文字
'.'
(任意の1文字) Pythonでは改行文字以外の任意の一文字にマッチします。DOTALLフラグを用いると、改行にもマッチするようになります。
'[...]'
(括弧内の任意の1文字) 文字の集合を指定するのに使用します。括弧内の任意の1文字に対応します。文字は個々に記述するか、文字の範囲を、2つの文字と '-' でそれらを分離して指定することができます。例えば、 [ab] は文字 'a' 、 'b' とマッチします。 [a-z] は任意の小文字と、 [a-zA-Z0-9] は任意の英数字にマッチします。文字集合に '-' や ']' を含めたい場合は、その前にバックスラッシュを付けるか、 [ の直後に置きます。
'[^...]'
(括弧内以外の任意の1文字) [...] の 補集合 とマッチします。例えば、 [^ab] は文字 'a' 、 'b' 以外とマッチします。
量指定子?: "繰り返し"を提供するために付加されるメタ文字
'?'
直前にある正規表現を0回か1回繰り返したものにマッチします。
'*'
直前にある正規表現を0回以上繰り返したものにマッチします。
'+'
直前にある正規表現を1回以上繰り返したものにマッチします。
'{min,max}'
直前にある正規表現を 'min' 回以上 'max' 回以下繰り返したものにマッチします。
'??', '*?', '+?'
'?', '*', '+' は全てできるだけ多くのテキストにマッチするようになっており、このようなマッチを 最長一致 と言います。一方、 '?' を修飾子の後に追加するとできるだけ少ないテキストにマッチするようになり、これを 最小一致 と言います。
位置を表すメタ文字
'^'
(行の先頭の位置) 文字列の先頭とマッチします。PythonではMULTILINEオプションを指定すると各改行文字の直後にマッチするようになります。
'$'
(行の文末の位置) 文字列の末尾か文字列の末尾の改行の直前にマッチします。PythonではMULTILINEオプションを指定すると各改行文字の直前にマッチするようになります。
その他のメタ文字
'|'
(選択 OR) 任意の正規表現 A と B に対して、 A|B は A か B のどちらかとマッチする正規表現を作成します。
'(...)'
(グループ化) 丸括弧の中にどのような正規表現があってもマッチし
文字クラス
'\s'
(空白文字(タブ、スペース、改行)) Pythonでは [\t\n\r\f\v] と同じ意味です。
'\S'
(s以外の任意の文字) Pythonでは [^\t\n\r\f\v] と同じ意味です。
'\w'
(英数字とアンダーステア) [a-zA-Z0-9_] と同じ意味です。
'\W'
(w以外の任意の文字) [^a-zA-Z0-9_] と同じ意味です。
'\d'
(数字) [0-9] と同じ意味です。
'\D'
(d以外の任意の文字) [^0-9] と同じ意味です。
注意点
メタ文字自身を使う場合は前に \ を付ける必要がある。
| は 遅い
^(a|b|c|d|e|f)+$
^(?:a|b|c|d|e|f)+$
^[a-f]+$
これらは全て同じ文字列にマッチしますが、 BはAの3倍、CはAの20倍高速 に動作します。
[] の中では特殊文字は効果を持ちません。なので、 [.] は文字 . に のみ マッチします。
任意の深さを持つ入れ子構造に正規表現をマッチさせることは できません。 (ライブラリによる拡張はある)
正規表現を理解するのに良いWebアプリ
RegExr
正規表現は実際に記述しなければ理解することが難しいので、自分で試してみることが重要でが、毎回毎回Pythonのreモジュールを使って試すのは大変ですし、時間もかかります。
RegExrは入力した正規表現の適合箇所を簡単に確認することができるWebアプリケーションです。
上のテキストボックスに正規表現を入力すると、下の文書の中でそれにマッチする箇所を表示してくれるので、トライアンドエラーのサイクルが短くすることができます。
プログラムを書く前に、意図した通りに表現できているかを確かめる用途にも使うことができます。
URL: http://www.gskinner.com/RegExr/
strfriend
正規表現は理論的にはオートマトンを用いて説明することができます。
strfriendは入力された正規表現を表す非決定性オートマトンを出力してくれるWebアプリケーションです。
これを用いて正規表現を可視化することで、複雑で難しい正規表現が理解しやすくなるかも知れません。
URL: http://www.strfriend.com/
メールアドレスにマッチする正規表現を入力した場合
Pythonでの使用法
マッチするものを全て列挙する場合、findallを使います。:
>>> import re
>>> text = 'pythonとはlightweightな、programming言語である'
>>> re.findall('\w+', text)
['python', 'lightweight', 'programming']
findallはグループにも対応しています。:
>>> text = 'pythonとはlightweightな、programming言語である'
>>> re.findall('(\w+)とは(\w+)', text)
[('python', 'lightweight')]
グループが邪魔な場合は(?:...)の様に、?:をグループの最初につけます。:
>>> re.findall('(?:\w+)とは(?:\w+)', text)
['python\xe3\x81\xa8\xe3\x81\xaflightweight']
マッチ部分に対応するMatchObjectを取得したい場合は、finditerを使います。:
>>> import re
>>> text = 'pythonとはlightweightな、programming言語である'
>>> for mo in re.finditer('(\w+)とは(\w+)', text)
...     print mo.group(0)
...     print mo.group(1)
...     print mo.group(2)
...
pythonとはlightweight
python
lightweight
MatchObjectは名前付きのグループを使った時に特に便利です。次のようにgroupdictを使うことで、グループ名をキーとした辞書が返されます。:
>>> text = 'pythonとはlightweightな、programming言語である'
>>> re.findall('(?P<first>\w+)とは(?P<second>\w+)', text)
[('python', 'lightweight')]
>>> for mo in re.finditer(pattern, text):
...     print mo.groupdict()
...
{'first': 'python', 'second': 'lightweight'}
例えば日付表現を抽出する場合、次のように名前付きグループを作ることで、マッチした箇所の抽出するプログラムの可読性を高めることができます。:
>>> pattern = '(?P<year>[1-9]\d{1,3})年(?P<month>1[0-2]|[1-9])月(?P<day>3[01]|[12]\d|[1-9])日'
>>> text = '''リリース
... 3.2/ 2011年2月20日
... 2.7.1/ 2010年11月27日
... '''
>>> for mo in re.finditer(pattern, text):
...    # mo.group(2)と比べて月を抽出していることが明確になる。
...    print mo.groupdict()['month']
...
2
11
文字列を先頭から順番に見ていき、正規表現にマッチする最初の箇所が欲しい場合はsearchを使います。searchの返り値はMatchObjectなので、groupdictを利用することができます。:
>>> import re
>>> text = 'pythonとはlightweightな、programming言語である'
>>> mo = re.search('l\w+', text)
>>> print s.group()
lightweight
文字列が先頭から正規表現にマッチしているかを知りたい場合はmatchを使います。:
>>> import re
>>> text = 'pythonとはlightweightな、programming言語である'
>>> re.match('l\w+', text) # 先頭はlで始まらない
None
>>> print re.match('\w+', text).group()
python
逆にmatchを使うと暗黙的に文字列の先頭からを意味することになるので、注意して下さい。
正規表現パターンから正規表現オブジェクトに変換するのは時間のかかる処理です。そのため、繰り返し利用される正規表現パターンはcompileを使うことで、正規表現オブジェクトを再利用することができます。:
>>> import re
>>> regex = re.compile('\w+')  # regexを繰り返し再利用することができる
>>> text = 'pythonとはlightweightな、programming言語である'
>>> regex.findall(text)
['python', 'lightweight', 'programming']
ただし、re.match(), re.search(), re.compile()は渡された最後の物がキャッシュとして残るので、正規表現パターンが1種類しかでてこない場合は、compileを利用する必要はありません。
複数行にまたがる文字列に対し、各行の行頭や(各改行の直後)や行末(改行の直前)にマッチさせたい場合、re.MULTILINEオプションを指定した上で、^や$を使います。:
>>> import re
>>> pattern = '^\w+'
>>> text = '''python
... パイソン
... ルビー ruby
... perl
... C言語
... '''
>>> re.findall(pattern, text, re.MULTILINE)
['python', 'perl', 'C']
>>> re.findall(pattern, text, re.M)  # re.MでもOK
['python', 'perl', 'C']
逆に、re.MULTILINEをつけ忘れると、^と$は文字列の最初と最後にのみマッチするようになります。:
>>> re.findall('^\w+', text)
['python']
自然言語処理
Warning
ここでは情報検索のために、与えられた文書に対して単語ベースの特徴ベクトルを作成することを主眼において、自然言語処理について説明していますが、これは本来の意味での自然言語処理が指す領域からすると、極めて限定的な話題のみを扱っていることを意味します。
形態素解析
自然言語処理ではまず、自然言語で記述された文書を文法や辞書を情報源として、形態素(Morpheme, 言語で意味を持つ最小単位)に分割する必要があります。形態素解析とは、自然言語を形態素に分割し、それぞれの品詞を判別する作業のことをいいます。
例えば、「すもももももももものうち」という文章は次のように分解することができます。
単語
品詞
sphinx_information_retrieval/natural_language_processing.rst at master 揃 pika-shi/sphinx_information_retrieval 揃 GitHub
