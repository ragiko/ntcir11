単一のデータベーステーブルからデータを選択するためにアクティブレコード (AR) を使う方法を見てきました。
この章では、AR を使って、いくつかの関係するデータベーステーブルをつなげ、結合されたデータセットを取得する方法を示します。
リレーショナル AR を使う場合は、結合すべきテーブルに主キー・外部キー制約が宣言されていることが推奨されます。
この制約がリレーショナルデータの一貫性と整合性を保持するために役立ちます。
分りやすくするために、この章では例題として、以下のエンティティ関係 (ER) 図に示されるデータベーススキーマを使用します。
情報: 外部キー制約のサポートは DBMS 毎に異ります。
SQLite 3.6.19 またはそれ以前のものは外部キー制約をサポートしませんが、テーブルを作成する際に制約を宣言することが出来ます。
MySQL の MyISAM エンジンは外部キーを全くサポートしません。
1. リレーションの宣言 ¶
AR のリレーショナルクエリを使用する前に、AR に対して他の AR クラスとどのように関係しているかを知らせる必要があります。
二つの AR クラスのリレーションは、AR クラスによって表現されるデータベーステーブルのリレーションと直接関係しています。
データベースの観点からは、二つのテーブル A と B の関係には、3つのタイプがあります。
1対多 (例えば tb_user と tbl_post)、1対1 (例えば tbl_user と tbl_profile)、多対多 (例えば tbl_category と tbl_post)。
ARでは、以下の4種類のリレーションがあります。
BELONGS_TO: テーブル A と B の関係が1対多ならば、B は A に属しています (例 Post blongs to User)。
HAS_MANY: 同じくテーブル A と B の関係が1対多ならば、A は多くの B を持っています (例 User has many Post)。
HAS_ONE: これは A がたかだか一つの B を持っている HAS_MANY の特例です (例 User has at most one Profile)。
MANY_MANY: これはデータベースにおいて多対多の関係と対応します。
多対多の関係は、1対多の関係に分割するために、関連付け用のテーブルが必要になります。
なぜなら大部分の DBMS は、直接には多対多の関係をサポートしないためです。
例題のデータベーススキーマでは、tbl_post_category がこの目的のために使用されます。
AR 用語では、BELONGS_TO と HAS_MANY の組合せとして、MANY_MANY を説明することができます。
例えば Post は多くの Category に属しています。そして Category には多くの Post があります。
5番目に、リレーションのレコードで集計クエリを実行する特殊なタイプがあります。
STAT と呼ばれるリレーションです。
詳細については、統計クエリ を参照してください。
AR でのリレーション宣言は、CActiveRecord クラスの relations() メソッドをオーバライドすることで行います。
このメソッドはリレーション構成の配列を返します。
各々の配列要素は以下のフォーマットで示す一つのリレーションを意味します。
ここで VarName はリレーションの名前です。
RelationType はリレーションのタイプを指定します。
そしてそれは4つの定数、self::BELONGS_TO, self::HAS_ONE, self::HAS_MANY, self::MANY_MANY のうちの一つです。
ClassName はこの AR クラスに関係する AR クラスの名前です。
ForeignKey はリレーションに関係する外部キーを指定します。
そして各リレーションについて、最後に付加オプションを指定することができます (後で説明します)。
以下のコードでどのように User クラスと Post クラスのリレーションを宣言するかを示します。
class Post extends CActiveRecord
{
......
public function relations()
{
return array(
'author'=>array(self::BELONGS_TO, 'User', 'author_id'),
'categories'=>array(self::MANY_MANY, 'Category',
'tbl_post_category(post_id, category_id)'),
);
}
}
class User extends CActiveRecord
{
......
public function relations()
{
return array(
'posts'=>array(self::HAS_MANY, 'Post', 'author_id'),
'profile'=>array(self::HAS_ONE, 'Profile', 'owner_id'),
);
}
}
情報: 外部キーは2個以上のカラムで構成される複合キーでもかまいません。
この場合は、外部キーのカラムの名前をカンマで区切って結合した文字列か、または array('key1','key2') のような配列を使わなければなりません。
標準的でない PK->FK 結合を指定する必要があるときは、array('fk'=>'pk') として定義することが出来ます。
複合キーの場合は、array('fk_c1'=>'pk_c1','fk_c2'=>'pk_c2') となります。
MANY_MANY のリレーションにおいては、外部キーとして、関連付けテーブル名も指定されなければなりません。
例えば、Post における categories リレーションは、tbl_post_category(post_id, category_id) という外部キーにより指定されます。
AR クラスにおいてリレーションを宣言すると、各々のリレーションを表わす暗黙のプロパティがクラスに加えられます。
リレーショナルなクエリが実行された後、対応するプロパティは関連する AR の (単一または複数の) インスタンスで満たされます。
例えば、$author が User AR インスタンスを表している場合、$author->posts を使って、関連した Post インスタンスにアクセスすることが出来ます。
2. リレーショナルクエリの実行 ¶
リレーショナルクエリを実行する最も単純な方法は、AR インスタンスのリレーショナルなプロパティを読み出すことです。
プロパティが以前にアクセスされていない場合には、リレーショナルクエリが開始されます。
このクエリは二つの関係するテーブルを結合し、現行の AR インスタンスのプライマリキーでフィルタリングするものです。
そして、クエリの結果は、関連する AR の (単一または複数の) インスタンスとして、プロパティに保存されます。
これは レイジーローディング (Lazy Loading) アプローチとして知られており、リレーショナルクエリは関連するオブジェクトが最初にアクセスされて初めて実行されます。
以下の例は実際にこのアプローチをどのように使用するかを示します。
データベースを使う: リレーショナルアクティブレコード | The Definitive Guide to Yii | Yii PHP Framework
