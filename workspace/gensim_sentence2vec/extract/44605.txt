
13 オブジェクト・モデルの管理
このドキュメントでは、Coherence名前付きキャッシュのコレクションでその状態を管理する、オブジェクト・モデル管理のベスト・プラクティスについて説明します。一連のエンティティ・クラスとエンティティ・リレーションシップがあることを前提に、Coherence名前付きキャッシュのコレクション間でオブジェクト・モデルを表現および管理するための最適な方法について考えます。
キャッシュの使用パラダイム
クラスタ化されたキャッシング・ソリューションの価値は、その使用方法に依存します。それは、アプリケーション層のデータベースのデータをキャッシングして、瞬時にアクセスできるよう準備を整えておくことでしょうか。次の段階に進んでトランザクション制御をアプリケーション層に移行することでしょうか。または、さらに段階を踏んで積極的にトランザクション制御を最適化することでしょうか。
単純なデータ・キャッシング
特に並行処理制御が必要ない場合(コンテンツのキャッシングなど)やトランザクション制御がデータベースで管理されている場合(Hibernate製品およびJDO製品のプラグイン・キャッシュなど)は、単純なデータのキャッシュが一般的です。このアプローチはアプリケーション設計への影響が最低限に抑えられ、多くの場合、オブジェクト・リレーショナル・マッピング(ORM)層またはアプリケーション・サーバー(EJBコンテナ、Springなど)で透過的に実装されます。ただし、これではデータベース・サーバーのオーバーロードの問題が完全には解決されません。特に非トランザクション読取りがアプリケーション層で処理されている場合、すべてのトランザクション・データ管理にはデータベースとの相互作用が依然として必要です。
データ・アクセス要件が主キーによる単純なアクセス以上のことを必要とする場合、キャッシングは無関係な問題ではないということを認識することが重要です。つまり、キャッシングの恩恵を確実に受けるには、キャッシングを念頭に置いてアプリケーションを設計する必要があります。
トランザクション・キャッシング
データベースを単独で操作し、独自のスケーラビリティを必要とするアプリケーションは、データ管理のより大きな役割を担うことから始める必要があります。これには、Coherenceの読取りアクセス機能(リードスルー・キャッシング、キャッシュ問合せ、集計)、データベース・トランザクションの最小化機能(ライトビハインド)、および並行処理の管理機能(ロック、キャッシュ・トランザクション)を使用することがあります。
トランザクションの最適化
フォルト・トレランス、短い待機時間、および高いスケーラビリティを組み合せる必要があるアプリケーションでは、一般に、トランザクションをより最適化する必要があります。従来のトランザクション制御では、Orderオブジェクトを管理する際、アプリケーションでSERIALIZABLE分離を指定する必要があることがありました。分散環境では、これは非常にコストのかかる操作です。分散環境以外でも、ほとんどのデータベースおよびキャッシング製品では、多くの場合、これを実現するために表ロックを使用します。そのため、使用可能なハードウェア・リソースに関係なく、スケーラビリティに大きな制限がかかります。実際に、最新のハードウェアを使用してもトランザクション率が毎秒数百トランザクションに制限される場合もあります。ただし、慣例によるロックは、たとえば、すべてのアクセッサが親Orderオブジェクトのみをロックする必要がある場合などに役立ちます。これを実行すると、ロックの有効範囲が表レベルから命令レベルに小さくなり、より高いスケーラビリティを達成できます(もちろん、アプリケーションによっては、複数のJMSキュー間でイベント処理をパーティション化して明示的な並行処理制御の必要性を排除することで、すでに同様の結果を実現しているものもあります)。さらに最適化するためには、EntryProcessorを使用してクラスタ化の調整を不要にすることなどがあります。これにより、特定のキャッシュ・エントリに対するトランザクション率を飛躍的に増加させることができます。
オブジェクト・モデルを管理するテクニック
リレーションシップという用語は、オブジェクト同士がどのように関連し合うかを意味します。たとえば、Orderオブジェクトには、一連のLineItemオブジェクト(のみ)が含まれます。Orderオブジェクトに関連付けられたCustomerオブジェクトを指す場合もあります。
データ・アクセス層は、一般にデータ・アクセス・オブジェクト(DAO)とデータ転送オブジェクト(DTO)の2つのキー・コンポーネント(つまり動作と状態)に分けられます。DAOはデータ・アクセスの動作を制御し、通常はデータベースまたはキャッシュを管理するロジックを含みます。DTOには、DAOで使用するデータ(Orderレコードなど)が含まれます。また、(一部のアプリケーションでは)単一のオブジェクトがDTOとDAOの両方として動作するものもあります。これらの用語は使用パターンを述べています。これらのパターンはアプリケーションにより異なりますが、コアとなる原理は応用できます。このドキュメントのサンプルは、わかりやすくするために、DAO/DTOの組合せアプローチ(動作の豊富なオブジェクト・モデル)に従っています。
エンティティ・リレーションシップの管理は、特にスケーラビリティおよびトランザクション性が求められる場合、困難な作業になります。この課題のコアは、理想的な解決策として、開発者の作業を極力抑えてこれらのエンティティ間リレーションシップの複雑性を管理可能にする必要があることにあります。概念的には、(XMLやJavaソースなどのいくつかの任意の形式で表示可能な)リレーションシップ・モデルを使用して、その記述を遵守する実行時動作を提供することにあります。
現在の課題は次のいくつかのグループに分類できます。
コード生成(.javaまたは.classファイル)
実行時バイトコードの使用(ClassLoaderインターセプション)
事前定義のDAOメソッド
コード生成
コード生成は、.javaまたは.classファイルの生成を含む一般的なオプションです。このアプローチは、通常、いくつかの管理および監視、AOPおよびORMツール(AspectJ、Hibernate)で使用されます。このアプローチの主な課題はアーチファクトの生成にあり、ソフトウェア構成管理(SCM)システムでの管理が必要になることがあります。
バイトコードの使用
このアプローチでは、ClassLoaderのインターセプションを使用して、JVMへのロード時にクラスを調整します。このアプローチは、一般にはAOPツール(AspectJ、JBossCacheAop、TerraCotta)および一部のORMツール(JDOの実装では一般的)で使用されます。実行時のコード変更(アプリケーション・サーバーでのホット・デプロイ・オプションのブレーク傾向を含む)に関する(認識された、または実際の)リスクがあるため、多くの組織ではこのオプションは実行されません。そのため、これは初期オプションではありません。
開発者実装クラス
最も柔軟なオプションは、実行時問合せエンジンを使用することです。ORM製品は、ほとんどの処理をデータベース・サーバーに委任しています。また、問合せエンジンをアプリケーション層内で提供する方法もありますが、これは完全なデータベース・サーバーの管理性および保守性を制限することと同じ複雑性をもたらします。
Coherenceにおける推奨案は、DAOメソッドの綿密な計画を明示的に立てることです。これにより、開発に多少の手間を掛けた、決定性のある(動的に評価される問合せを回避する)動作が提供されます。この取組みにおける努力は、リレーションシップ・モデルの複雑さに正比例します。小規模から中規模サイズのモデル(Coherenceで管理する最大50エンティティのタイプ)の場合は、非常にわずかな開発努力で済みます。大規模な(特に複雑なリレーションシップを持つ)モデルになると、相当な開発努力を必要とすることがあります。
ベスト・プラクティスとしては、すべての状態、リレーションシップおよびアトミック・トランザクションをオブジェクト・モデルで処理してください。より高度なトランザクション制御では、並行性を調整する追加のサービス層を用意する必要があります(これにより構成可能なトランザクションを使用できます)。
構成可能なトランザクション:
Coherenceのトランザクションの詳しい使用法は、『Oracle Coherence開発者ガイド』のトランザクションの実行に関する項を参照してください。
ドメイン・モデル
NamedCacheには(データベース表にエンティティの1つのタイプを含めるのと同様に)1つのエンティティ・タイプを含める必要があります。これに共通の唯一の例外は、多くの場合に任意の値が含まれる、ディレクトリタイプのキャッシュです。
それぞれの追加のNamedCacheでは、参加クラスタ・メンバーごとに数十バイトしか消費しません。これは、バッキング・マップに応じて異なります。透過的なデータベース統合に使用する<read_write_backing_map_scheme>で構成されたキャッシュは、ライトビハインド・キャッシュが有効な場合はさらにリソースを消費しますが、数百の名前付きキャッシュがなければこれは要素になりません。
可能であれば、ビジネス・トランザクションが単一のキャッシュ・エントリの更新にマップするように、キャッシュ・レイアウトを設計します。これによりトランザクションの制御が簡略化され、その結果、大きなスループットが得られます。
ほとんどのキャッシュでは意味のあるキーを使用する必要があります(それに対してリレーショナル・システムでは、一般には同一性を管理するための意味のないキーが使用されます)。このデメリットの1つは問合せのサポートが制限されることです(Coherenceの問合せでは現在、エントリ・キーでなく、エントリ値にのみ適用されます)。キー属性に対して問い合せるには、値を属性に複製する必要があります。
例13-1 NamedCacheアクセスのメソッドの実装
public class Order
implements Serializable
{
// static"Finder" method
public static Order getOrder(OrderId orderId)
{
return (Order)m_cacheOrders.get(orderId);
}
// ...
// mutator/accessor methods for updating Order attributes
// ...
// lazy-load an attribute
public Customer getCustomer()
{
return (Customer)m_cacheCustomers.get(m_customerId);
}
// lazy-load a collection of child attributes
public Collection getLineItems()
{
// returns map(LineItemId -> LineItem); just return the values
return ((Map)m_cacheLineItems.getAll(m_lineItemIds)).values();
}
// fields containing order state
private CustomerId m_customerId;
private Collection m_lineItemIds;
// handles to caches containing related objects
private static final NamedCache m_cacheCustomers = CacheFactory.getCache("customers");
private static final NamedCache m_cacheOrders    = CacheFactory.getCache("orders");
private static final NamedCache m_cacheLineItems = CacheFactory.getCache("orderlineitems");
}
オブジェクト・モデルの管理
