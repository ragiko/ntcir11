
予想に反して、L1距離が最も高速という結果になりました。次点で64bitベースのハミング距離でした。意外と有意な差があります。
考察
まず結果から言えることは、ハミング距離の計算そのものが特に高速というわけではないようです。この理由について、作っていて感じたことが2つあります。下記のL1距離とハミング距離の関数を見てください。
//L1距離計算
inline int dist_l1_sse(unsigned char* p,unsigned char* q)
{
__m128i t=_mm_setzero_si128();
for(unsigned d=0;d<D;d+=ALIGN)
{
t=_mm_add_epi32(t,
_mm_sad_epu8(
_mm_load_si128((__m128i*)(p+d)),
_mm_load_si128((__m128i*)(q+d))
)
);
}
return int(t.m128i_i64[0]+t.m128i_i64[1]);
}
//ハミング距離計算(64ビット版で x64 のみ対応)
inline int dist_hamming64_sse(unsigned char* p,unsigned char* q)
{
long long result=0;
unsigned long long* p64=reinterpret_cast<unsigned long long*>(p);
unsigned long long* q64=reinterpret_cast<unsigned long long*>(q);
for(unsigned d=0;d<D;d+=ALIGN)
{
// this is probably faster than using _mm_xor_si128().
result+=_mm_popcnt_u64((*p64++)^(*q64++));
result+=_mm_popcnt_u64((*p64++)^(*q64++));
}
return int(result);
}
第一にL1距離計算に用いる「_mm_sad_epu8()」が優秀すぎ、第二にハミング距離計算に用いる「_mm_popcnt_u64()」がややお粗末なこと、があります。前者のほうは差分をとって絶対値をとってそれらを一部加算してくれるという、かゆいところに手が届きまくりの命令になっています。本来なら差分計算で1bit符号が増えるぶんの対策が必要なのですが、そういうものも不要です。これはすごい。一方後者はなぜか64bit長までしか対応しておらず、SSEの128ビットレジスタから値をそのまま渡すということができません。数多くのモダンなアルゴリズムにとって PopCount は超重要命令であるにもかかわらずこの設計ぶりには何か理由があるのでしょうか。。。
以上のことから、バイナリ化の真の恩恵というのは「次元削減(コード長の削減)」にあるということになります。例えば今回のベンチマークは128×8=1024ビットにしましたが、実際には128ビット程度まで落としても精度が落ちないという報告もあります(もちろんデータにもよります)。仮に1/8サイズまでデータ量を削減できると、通信量の削減、ストレージの節約、メモリ上へのガン並べによるディスクアクセス回避、などなど多くの点でメリットが生じます。一般のベクトルでもPCAなどによって次元削減可能ですが、例えばPCA-SIFTでも128次元⇒32次元で1/4サイズどまりですし、ビット単位での長さ調整もできず比較的使い勝手がよくありません。また次元削減時の変換に要する計算コストでも、バイナリコードのほうに分があります。このあたりがバイナリ化の大きな利点でしょうか。
おわりに
昨日7時間かけて作った(L2がメンドクサかった)のですが、実際に手を動かして検証するのは大事だなと思った一日でした。L1がここまで速いというのは自分でも意外でした。
上で述べたように、絶対値誤差和命令のほうはかなりギリギリまで効率化されている一方、PopCount命令のほうはまだまだ改善の余地があります。今後のハードウェアの発展によってより効率的な命令が実現されれば、今回の実験をくつがえす結果となることも予想されます。楽しみに待つことにしましょう。
バグ報告やより効率的な実装アイデアなど遠慮なくコメントください。他の環境での実験報告も大歓迎です。
ツイートする
2013-12-08 - A440Hz ブログ
