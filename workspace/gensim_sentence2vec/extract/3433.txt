本発明は、異なるサイクル周期に基づく試験信号を生成する複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、複数の試験モジュールエミュレート部のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、同期エミュレート部が生成した複数の試験信号生成タイミングを時刻順に整列して順次出力するタイミング整列部と、タイミング整列部が出力した一の試験信号生成タイミングに対応する試験モジュールエミュレート部に、一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるスケジュール部と備えた試験エミュレート装置を提供するものである。        
【発明の詳細な説明】  文献の参照による組み込みが認められる指定国については、下記の出願に記載された内容を参照により本出願に組み込み、本出願の記載の一部とする。    米国特許出願10/404,002  出願日  平成15年3月31日    米国特許出願10/403,817  出願日  平成15年3月31日国際特許出願PCT/JP2004/001649  出願日平成16年2月16日国際特許出願PCT/JP2004/001648  出願日平成16年2月16日【技術分野】  本発明は、試験エミュレート装置、試験モジュールエミュレート装置、及びこれらのプログラムを記録した記録媒体に関する。特に本発明は、被試験デバイスに試験信号をそれぞれ供給する、交換可能な複数の試験モジュールを備える試験装置をエミュレートし、被試験デバイスや試験モジュール等の実物を用いることなく試験環境を検証することができる試験エミュレート装置、試験モジュールエミュレート装置、及びこれらのプログラムを記録した記録媒体に関する。【背景技術】  従来、被試験デバイスや試験装置等の実物を用いることなく試験環境を検証する手段として、特開平10−320229号、特開2000−267881号、特開2001−51025号、特開2001−134457号、特開2002−333469号に示す技術が開示されている。  特開平10−320229号は、半導体試験装置の各ハードウェアユニットの機能をエミュレートする各エミュレータユニットと、DUTの機能をエミュレートするデバイスエミュレータと、テストプログラムに基づいて、各エミュレータユニットからテストプログラムの実行に必要なデータを収集する手段と、収集したデータに基づきデバイスエミュレータに試験信号を発生し、デバイスエミュレータからの結果信号を比較して結果を格納するデバイステストエミュレータとを備えるエミュレータを開示する。  特開2000−267881号は、DUTの内部抵抗に依存して変化する電圧値、電流値を的確にシミュレートする半導体シミュレート装置を開示する。  特開2001−51025号は、半導体試験装置の動作をエミュレートするテスタエミュレート手段と、ハードウェア記述言語に基づきDUTをシミュレートするハードウェア記述言語シミュレート手段と、DUTのシミュレート結果に基づいて半導体試験用プログラムのデバッグを行なうデバッグ手段とを備える半導体試験用プログラムデバッグ装置を開示する。  特開2001−134457号は、半導体試験装置の動作をエミュレートする際に、各ピンに対応した波形データを高速に作成することができる半導体試験用プログラムデバッグ装置を開示する。  特開2002−333469号は、アナログ出力端子を備える半導体デバイス用に作成された半導体試験用プログラムの検証を行なうことができる半導体試験用プログラムデバッグ装置を開示する。  上記に示した試験装置のエミュレート装置は、主として試験装置ベンダによって独自に開発されたアーキテクチャによる試験装置を前提とする。一方、将来の試験装置においては、試験装置がオープンアーキテクチャにより実現され、様々なベンダによって開発されたモジュールを組み合わせて試験装置を構成する方式が期待されており、様々なモジュールを混載して使用する試験装置を適切にエミュレートすることができるエミュレート装置を提供することが望ましい。  そこで本発明は、このような問題を解決することを目的とする。【発明の開示】  このような目的を達成するために、本発明の第1の形態によると、試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置であって、異なるサイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールエミュレート部のそれぞれが、当該試験モジュールエミュレート部のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する前記試験モジュールエミュレート部に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるスケジュール部とを備える試験エミュレート装置を提供する。  擬似的に生成された前記試験信号に基づいて被試験デバイスの動作をシミュレートする被試験デバイスシミュレート部を更に備えてもよい。  前記同期エミュレート部は、複数の前記試験モジュールエミュレート部のそれぞれが、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において擬似的に発生する、前記制御装置に対する割込みを収集する割込み収集タイミングを更に生成し、前記タイミング整列部は、前記複数の試験信号生成タイミング及び複数の前記割込み収集タイミングを時刻順に整列して順次出力し、前記スケジュール部は、タイミング整列部が一の前記割込み収集タイミングを出力した場合に、当該割込み収集タイミングに対応する前記試験モジュールエミュレート部に、当該割込み収集タイミングの直前に当該試験モジュールエミュレート部が試験信号を生成したサイクル時間において擬似的に発生した前記割込みを前記制御エミュレート部に対して通知させてよい。  前記複数の試験モジュールエミュレート部のそれぞれは、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクル時間中における試験信号の変化タイミングを生成し、当該試験エミュレート装置は、前記複数の試験モジュールエミュレート部により生成された複数の前記変化タイミングを取得し、前記複数の変化タイミングに基づいて、試験信号を時刻順に順次擬似的に変化させる被試験デバイス接続部を更に備えてもよい。  前記被試験デバイス接続部は、前記複数の試験モジュールエミュレート部から取得した複数の前記変化タイミングを前記タイミング整列部に供給し、前記タイミング整列部は、前記複数の変化タイミング、前記複数の試験信号生成タイミング及び複数の前記割込み収集タイミングを時刻順に整列して順次出力し、前記スケジュール部は、前記タイミング整列部が一の前記変化タイミングを出力した場合に、前記被試験デバイス接続部に、当該変化タイミングに試験信号を擬似的に変化させてもよい。  前記複数の試験モジュールエミュレート部のそれぞれは、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクル時間が終了するサイクル終了タイミングを前記同期エミュレート部に通知し、前記同期エミュレート部は、前記複数の試験モジュールエミュレート部のそれぞれから通知された前記サイクル終了タイミングに基づいて、当該試験モジュールエミュレート部が次のサイクル時間に対応する試験信号を擬似的に生成すべき前記試験信号生成タイミングを生成してもよい。  次のサイクル時間に対応する前記試験信号生成タイミングを前記タイミング整列部が出力した場合に、前記スケジュール部は、当該試験信号生成タイミングの直前のサイクル時間における試験信号の生成において、当該試験信号生成タイミングに対応する前記試験モジュールエミュレート部が擬似的に発生した割込みを前記制御エミュレート部に対して通知させてもよい。  前記複数の試験モジュールエミュレート部のそれぞれは、当該試験モジュールエミュレート部に対応する試験モジュールエミュレートプログラムをコンピュータで動作させることにより実現され、前記試験モジュールエミュレートプログラムは、前記試験モジュールが前記制御装置から受信する複数のコマンドのそれぞれに対応して設けられ、当該コマンドに対応する前記試験モジュールの動作をエミュレートする複数のハードウェアエミュレート関数と、前記スケジュール部が、前記試験信号生成タイミングに対応するサイクル時間における試験信号を生成させるために用いる制御関数とを有してもよい。  本発明の第2の形態によると、コンピュータを、試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置として機能させるプログラムを記録した記録媒体であって、前記プログラムは、前記コンピュータを、異なるサイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールエミュレート部のそれぞれが、当該試験モジュールエミュレート部のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する前記試験モジュールエミュレート部に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるスケジュール部として機能させる記録媒体を提供する。  本発明の第3の形態によると、異なるサイクル周期に基づく試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置において、一の前記試験モジュールをエミュレートする試験モジュールエミュレート装置であって、前記試験エミュレート装置は、前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールのそれぞれが、当該試験モジュールのサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する当該試験モジュールエミュレート装置に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させることを指示するスケジュール部とを備え、当該試験モジュールエミュレート装置は、前記スケジュール部からの指示に基づき、前記一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成するパターン発生器エミュレート部を備える試験モジュールエミュレート装置を提供する。  前記一の試験信号生成タイミングに対応するサイクルが終了するサイクル終了タイミングを同期エミュレート部に通知し、前記同期エミュレート部に前記サイクル終了タイミングに基づき当該試験モジュールエミュレート装置が次に試験信号を擬似的に生成すべき前記試験信号生成タイミングを更に生成させる試験モジュールインターフェイスエミュレート部を更に備えてもよい。  本発明の第4の形態によると、異なるサイクル周期に基づく試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置において、コンピュータを、一の前記試験モジュールをエミュレートする試験モジュールエミュレート装置として機能させるプログラムを記録した記録媒体であって、前記試験エミュレート装置は、前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールのそれぞれが、当該試験モジュールのサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する当該試験モジュールエミュレート装置に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させることを指示するスケジュール部とを備え、前記プログラムは、前記コンピュータを、前記スケジュール部からの指示に基づき、前記一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成するパターン発生器エミュレート部として機能させる記録媒体を提供する。  本発明の第5の形態によると、試験信号を被試験デバイスに供給する試験モジュールを備える試験装置であって、前記被試験デバイスの試験を制御する制御装置と、サイクル周期に基づき試験信号を生成する試験モジュールと、前記試験モジュールをエミュレートする試験モジュールエミュレート部とを備え、前記制御装置は、前記被試験デバイスの実試験又は擬似試験のいずれを行うかの指示を入力し、前記被試験デバイスの実試験を行う指示を受けた場合に、前記被試験デバイスの試験を行う試験プログラムを前記試験モジュールに供給して、前記試験モジュールにより前記被試験デバイスの試験を行わせ、前記被試験デバイスの擬似試験を行う指示を受けた場合に、前記試験プログラムを前記試験モジュールエミュレート部に供給して、前記試験モジュールエミュレート部により前記被試験デバイスの試験をシミュレートさせる試験装置を提供する。  前記制御装置は、当該制御装置と前記試験モジュールとの間の通信処理を行う通信ソフトウェアを実行し、前記通信ソフトウェアは、前記制御装置と協働して、当該通信ソフトウェアを初期化する呼び出しに含まれる前記指示に基づいて、前記試験プログラムを前記試験モジュール及び前記試験モジュールエミュレート部のいずれに供給するかを判断してもよい。  本発明の第6の形態によると、試験信号を被試験デバイスに供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置であって、サイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、前記複数の試験モジュールエミュレート部のそれぞれが、サイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングをスケジュールするスケジュール部とを備え、前記試験モジュールエミュレート部は、関数呼び出しにより前記試験信号生成タイミングの通知を受けて、当該試験信号生成タイミングに対応するサイクル時間中における試験信号の電圧の変化を、出力チャネルをエミュレートする出力チャネルオブジェクトの電圧設定メソッドを複数回呼び出すことにより出力し、当該サイクル時間に対応する試験信号の電圧の変化の出力を終えた後に、当該サイクル時間に対応する試験信号の電圧の変化の出力を終えたことを、前記出力チャネルオブジェクトの終了メソッドを呼び出すことにより通知する試験エミュレート装置を提供する。  前記スケジュール部は、前記複数の試験モジュールエミュレート部のそれぞれから通知された前記終了メソッドに基づいて、全ての前記試験モジュールエミュレート部が試験信号の電圧の変化の出力を終えた期間を算出し、前記期間内における前記試験信号を取得して、当該試験信号に基づいて被試験デバイスの前記期間内における動作をシミュレートする被試験デバイスシミュレート部を更に備えてもよい。  前記出力チャネルオブジェクトは、前記終了メソッドの呼び出しを受けた後に、当該終了メソッドにより通知された、既に試験信号の電圧の変化の出力を終えた期間内の電圧の変化を禁止してもよい。  なお、上記の発明の概要は、本発明の必要な特徴の全てを列挙したものではなく、これらの特徴群のサブコンビネーションも又発明となりうる。【図面の簡単な説明】  図1は、本発明の実施形態に係る試験装置10の構成を示す。  図2は、本発明の実施形態に係る試験エミュレート装置190の機能構成を示す。  図3は、本発明の実施形態に係るコンピュータ20のハードウェア構成の一例を示す。  図4は、本発明の実施形態に係る試験モジュールエミュレート部270の機能構成を示す。  図5は、本発明の実施形態に係るクラス階層構造500の一例を示す。  図6は、本発明の実施形態に係る試験エミュレート装置190の試験信号生成処理フローを示す。  図7は、本発明の実施形態に係る試験エミュレート装置190により擬似的に生成される試験信号の一例を示す。  図8は、本発明の実施形態によるソフトウェアアーキテクチャを示している。  図9は、本発明の実施形態によるテストクラスの使用を示している。  図10は、本発明の実施形態による、テスタシステムと異なるベンダが提供するモジュールリソースとの相互作用を示す統一モデリング言語(UML)ダイアグラムである。  図11は、サイトコントローラによって保持されているときのユーザのテストを管理するためのサイトコントローラオブジェクトの一実施形態を示している。  図12は、図11に示されているサイトコントローラオブジェクトを表しているシステムコントローラ側のオブジェクトの代理の一実施形態を示している。  図13は、本発明の実施形態によるテスト環境を示している。  図14は、本発明の実施形態に係るシミュレーションコンフィギュレーションファイルの一例を示す第1の図である。  図15は、本発明の実施形態に係るシミュレーションコンフィギュレーションファイルの一例を示す第2の図である。  図16は、本発明の実施形態に係るオフラインコンフィギュレーションファイルの一例を示す第1の図である。  図17は、本発明の実施形態に係るオフラインコンフィギュレーションファイルの一例を示す第2の図である。  図18は、本発明の実施形態に係るクラス階層構造5200の一例を示す。  図19は、本発明の実施形態に係るチャネルオブジェクトの使用ダイアグラムを示す。  図20は、本発明の実施形態に係るイベントオブジェクトの仕様ダイアグラムを示す。  図21は、本発明の実施形態に係るデジタルモジュールの基本クラスの一例を示す。  図22は、本発明の実施形態に係るデジタルドライバモジュールのクラス宣言の一例を示す。  図23は、本発明の実施形態に係るデジタルドライバモジュールのhandleEventメソッドの一例を示す。  図24は、本発明の実施形態に係るデジタルストローブモジュールのクラス宣言を示す。  図25は、本発明の実施形態に係るデジタルストローブモジュールのhandleEventメソッドの一例を示す。  図26は、本発明の実施形態に係るDUTモデルのクラス定義の一例を示す。  図27は、本発明の実施形態に係るDUTモデルのrunメソッドの一例を示す。  図28は、実環境6000及びエミュレート環境6050におけるシステムバスアクセスライブラリ6014の位置付けを示す。【発明を実施するための最良の形態】  以下、図面を参照して本発明の実施の形態の一例を説明する。  図1は、本発明の実施形態に係る試験装置10の構成を示す。試験装置10は、試験信号を生成してDUT100(Device  Under  Test:被試験デバイス)に供給し、DUT100が試験信号に基づいて動作した結果出力する結果信号が期待値と一致するか否かに基づいてDUT100の良否を判断する。本実施形態に係る試験装置10は、オープンアーキテクチャにより実現され、DUT100に試験信号を供給する試験モジュール170等として、オープンアーキテクチャに基づく各種のモジュールを用いることができる。そして、試験装置10は、DUT100の実試験をエミュレートする試験エミュレート装置190を有し、試験エミュレート装置190により、実試験に用いる試験モジュール170等の変更に対応して適切に構成を変更し、DUT100の実試験を適切にエミュレートするエミュレート環境を提供することができる。  試験装置10は、システム制御装置110と、通信ネットワーク120と、サイト制御装置130a〜cと、バススイッチ140と、同期モジュール150a〜bと、同期接続モジュール160a〜bと、試験モジュール170a〜bと、ロードボード180と、試験エミュレート装置190とを備え、DUT100a〜bに接続される。  システム制御装置110は、試験装置10がDUT100a〜bの試験に用いる試験制御プログラム、試験プログラム、及び試験データ等を外部のネットワーク等を介して受信し、格納する。通信ネットワーク120は、システム制御装置110、サイト制御装置130a〜c、及び試験エミュレート装置190を接続し、これらの間の通信を中継する。  サイト制御装置130a〜cは、本発明に係る制御装置の一例であり、DUT100の試験を制御する。ここで、複数のサイト制御装置130は、それぞれ一のDUT100の試験を制御する。例えば、図1においては、サイト制御装置130aはDUT100aの試験を制御し、サイト制御装置130bはDUT100bの試験を制御する。これに代えて、複数のサイト制御装置130は、それぞれ複数のDUT100の試験を制御してもよい。  より具体的には、サイト制御装置130は、通信ネットワーク120を介してシステム制御装置110から試験制御プログラムを取得し実行する。次に、サイト制御装置130は、試験制御プログラムに基づいて、当該DUT100の試験に用いる試験プログラム及び試験データをシステム制御装置110から取得し、バススイッチ140を介して当該DUT100の試験に用いる同期モジュール150及び1又は複数の試験モジュール170等のモジュールに格納する。次に、サイト制御装置130は、試験プログラム及び試験データに基づく試験の開始をバススイッチ140を介して同期モジュール150に指示する。そして、サイト制御装置130は、試験が終了したことを示す割込み等を例えば同期モジュール150から受信し、試験結果に基づいて次の試験を各モジュールに行なわせる。  バススイッチ140は、複数のサイト制御装置130のそれぞれを、当該サイト制御装置130が制御する同期モジュール150及び1又は複数の試験モジュール170に接続し、これらの間の通信を中継する。ここで、予め定められた一のサイト制御装置130は、試験装置10の使用者や試験制御プログラム等の指示に基づいて、複数のサイト制御装置130のそれぞれを、当該サイト制御装置130がDUT100の試験に用いる同期モジュール150及び1以上の試験モジュール170に接続させるべくバススイッチ140を設定してよい。例えば、図1においては、サイト制御装置130aは、同期モジュール150a及び複数の試験モジュール170aに接続する様に設定され、これらを用いてDUT100aの試験を行なう。また、サイト制御装置130bは、同期モジュール150b及び複数の試験モジュール170bに接続する様に設定され、これらを用いてDUT100bの試験を行なう。  ここで、サイト制御装置130bが同期モジュール150b、同期接続モジュール160b、及び1又は複数の試験モジュール170bを用いてDUT100bを試験するための構成及び動作は、サイト制御装置130aが同期モジュール150a、同期接続モジュール160a、及び1又は複数の試験モジュール170aを用いてDUT100aを試験するための構成及び動作と略同様であるため、以下相違点を除きサイト制御装置130aがDUT100aを試験するための構成及び動作を中心に説明する。  同期モジュール150aは、サイト制御装置130aの指示に基づいて、DUT100aの試験に用いる複数の試験モジュール170aが試験信号を生成すべき試験信号生成タイミングを生成する。また、同期モジュール150aは、同期接続モジュール160aを介して1又は複数の試験モジュール170aから試験結果を受信し、試験結果の良否に対応した試験プログラムのシーケンスを1又は複数の試験モジュール170aに実行させる。  同期接続モジュール160aは、同期モジュール150aが生成した試験信号生成タイミングを、当該試験信号生成タイミングに対応して動作させるべき試験モジュール170aに通知し、1又は複数の試験モジュール170aのそれぞれを指定したタイミングで動作させる。また、同期接続モジュール160aは、1又は複数の試験モジュール170aから試験結果を受信し、同期モジュール150aに送信する。  複数の試験モジュール170aは、DUT100aが有する複数の端子の一部ずつにそれぞれ接続され、サイト制御装置130aにより格納された試験プログラム及び試験データに基づいてDUT100aの試験を行なう。DUT100aの試験において、試験モジュール170aは、試験プログラムにより定められたシーケンスに基づいて試験データから試験信号を生成し、当該試験モジュール170aに接続されたDUT100aの端子に試験信号を供給する。次に、試験モジュール170aは、DUT100aが試験信号に基づいて動作した結果出力する結果信号を取得し、期待値と比較する。そして、試験モジュール170aは、結果信号と期待値との比較結果を、試験結果として同期接続モジュール160aに送信する。ここで複数の試験モジュール170aは、試験プログラム及び試験データに基づいて、試験信号のサイクル周期を動的に変化させるため、異なるサイクル周期に基づいて試験信号を生成する。  また、試験モジュール170aは、試験プログラムの処理が完了した場合や、試験プログラムの実行中に異常が生じた場合等において、サイト制御装置130aに対して割込みを発生する。この割込みは、バススイッチ140を介して当該試験モジュール170aに対応するサイト制御装置130aに通知され、サイト制御装置130aが有するプロセッサにより割込み処理が行われる。  ロードボード180は、複数のDUT100を載置し、複数の試験モジュール170を対応するDUT100の端子に接続する。  試験エミュレート装置190は、システム制御装置110に格納された試験制御プログラム、試験プログラム、及び試験データに基づいて試験装置10をエミュレートし、DUT100のシミュレーションモデルを用いてDUT100の試験を擬似的に行なう。本実施形態において、試験エミュレート装置190は、一のサイト制御装置130と、当該サイト制御装置130により制御される同期モジュール150、同期接続モジュール160、及び1又は複数の試験モジュール170と、当該サイト制御装置130による試験対象となるDUT100の動作を擬似的に行なう。試験エミュレート装置190を用いることにより、試験装置10の使用者は、DUT100、同期モジュール150、同期接続モジュール160、及び/又は試験モジュール170等の実物を準備していない段階で、試験制御プログラム、試験プログラム、及び/又は試験データの検証を開始することができる。また、試験エミュレート装置190を複数用意することにより、複数の使用者のそれぞれがより高価な実試験環境を占有することなく、試験制御プログラム、試験プログラム、及び/又は試験データを開発することができる。  以上において、試験装置10は、オープンアーキテクチャにより実現され、オープンアーキテクチャ規格を満たす各種のモジュールを使用することができる。そして、試験装置10は、同期モジュール150、同期接続モジュール160、及び試験モジュール170等のモジュールを、バススイッチ140が有する任意の接続スロットに挿入して使用することができる。この際、試験装置10の使用者等は、例えばサイト制御装置130aを介してバススイッチ140の接続形態を変更し、DUT100の試験に用いる複数のモジュールを、当該DUT100の試験を制御するサイト制御装置130に接続させることができる。これにより、試験装置10の使用者は、複数のDUT100のそれぞれの端子数、端子の配置、端子の種類、又は試験の種類等に応じて適切なモジュールを選択し、試験装置10に実装することができる。  なお、以上に代えて、同期接続モジュール160a及び同期接続モジュール160bは、試験装置10に用いられる全ての試験モジュール170に共通して設けられた一の同期接続部により実現されてもよい。この場合において、試験装置10の使用者等は、バススイッチ140の接続形態の変更と共に同期接続部と試験モジュール170との接続形態を変更することにより、複数のDUT100の特性に応じて適切なモジュールを選択することができる。  図2は、本発明の実施形態に係る試験エミュレート装置190の機能構成を示す。試験エミュレート装置190は、サイト制御エミュレート部230と、バススイッチエミュレート部240と、同期モジュールエミュレート部250と、同期接続モジュールエミュレート部260と、1又は複数の試験モジュールエミュレート部270と、DUT接続部280と、DUTシミュレート部200と、スケジュール制御部275とを有する。以下、試験エミュレート装置190が、サイト制御装置130aによるDUT100aの試験をエミュレートする場合を例に説明を行なう。  サイト制御エミュレート部230は、図1に示したサイト制御装置130aをエミュレートする。すなわち、サイト制御エミュレート部230は、通信ネットワーク120を介してシステム制御装置110から試験制御プログラムを取得し実行する。次に、サイト制御エミュレート部230は、試験制御プログラムに基づいてDUT100aの試験に用いる試験プログラム及び試験データをシステム制御装置110から取得し、バススイッチエミュレート部240を介して同期モジュールエミュレート部250及び1又は複数の試験モジュールエミュレート部270等のモジュールエミュレート部に格納する。  ここで、サイト制御エミュレート部230は、サイト制御装置130aが同期モジュール150a及び1又は複数の試験モジュール170aに対して発行する、当該モジュール内の記憶領域への読出アクセス、書込アクセス等のコマンドをバススイッチエミュレート部240に対して擬似的に発行する。サイト制御エミュレート部230は、試験プログラム及び試験データの書込アクセスをバススイッチエミュレート部240に対して擬似的に発行することにより、バススイッチエミュレート部240を介して同期モジュールエミュレート部250及び1又は複数の試験モジュールエミュレート部270等に試験プログラム及び試験データを格納してよい。  また、サイト制御エミュレート部230は、同期モジュールエミュレート部250及び試験モジュールエミュレート部270が擬似的に発生する割込みをバススイッチエミュレート部240を介して受信し、サイト制御装置130aの割込み処理を擬似的に実行する。  バススイッチエミュレート部240は、図1に示したバススイッチ140をエミュレートし、サイト制御エミュレート部230と、同期モジュールエミュレート部250及び1又は複数の試験モジュールエミュレート部270との間の通信を中継する。  同期モジュールエミュレート部250は、図1に示した同期モジュール150をエミュレートし、サイト制御エミュレート部230からの指示に基づき複数の試験モジュールエミュレート部270のそれぞれが、当該試験モジュールエミュレート部270のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する。次に、同期モジュールエミュレート部250は、試験信号を生成した当該試験モジュールエミュレート部270からサイクル時間の終了タイミングであるサイクル終了タイミングを受信する。そして、同期モジュールエミュレート部250は、サイクル終了タイミングに基づき、当該試験モジュールエミュレート部270が次に試験信号を生成すべき試験信号生成タイミング、当該試験モジュールエミュレート部270から試験結果を収集する試験結果収集タイミング、当該試験モジュールエミュレート部270にサイクル時間の処理を終了させるサイクル終了処理タイミング、及び、当該試験モジュールエミュレート部270からサイト制御エミュレート部230に対する割込みを収集する割込み収集タイミングを生成する。ここで、試験モジュールエミュレート部270からサイト制御エミュレート部230に対する割込みとは、複数の試験モジュールエミュレート部270のそれぞれが、試験信号生成タイミングに対応するサイクル時間における試験信号の生成において擬似的にサイト制御装置130aに対して発生する割込みである。  同期接続モジュールエミュレート部260は、図1に示した同期接続モジュール160をエミュレートし、同期モジュールエミュレート部250が擬似的に生成した試験信号生成タイミング、及び、同期モジュールエミュレート部250がエミュレーションのために生成した試験結果収集タイミング、サイクル終了処理タイミング、及び割込み収集タイミングをスケジュール制御部275に通知する。また、同期接続モジュールエミュレート部260は、1又は複数の試験モジュールエミュレート部270から試験結果を受信し、同期モジュールエミュレート部250に送信する。  試験モジュールエミュレート部270は、試験信号生成の指示を受けた同期モジュールエミュレート部250からサイクル開始の指示を受け、サイト制御エミュレート部230により格納された試験プログラム及び試験データに基づいて、当該試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成する。より具体的には、試験モジュールエミュレート部270は、試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクル時間中における試験信号の変化タイミングを擬似的に生成する。ここで、試験モジュールエミュレート部270は、試験信号の変化タイミングとして、当該試験モジュールエミュレート部270に対応する試験モジュール170の仕様により定められた数の変化タイミングを、一のサイクル時間に対応して生成してもよい。また、試験モジュールエミュレート部270は、DUTシミュレート部200が試験信号に基づいて擬似的に動作した結果出力する出力信号を取得し、試験プログラム及び試験データに基づき定められた期待値と比較する。そして、試験モジュールエミュレート部270は、結果信号と期待値との比較結果を、試験結果として同期接続モジュールエミュレート部260を介して同期モジュールエミュレート部250に送信する。  また、試験モジュールエミュレート部270は、スケジュール部277から割込み発生の指示を受けて、割込み発生の指示を受ける前に最後に試験信号を生成したサイクル時間中において擬似的に発生した割込みを、バススイッチエミュレート部240を介してサイト制御エミュレート部230に通知する。  DUT接続部280は、複数の試験モジュールエミュレート部270により生成された複数の変化タイミングを取得し、複数の変化タイミングに基づいて、試験信号を時刻順に擬似的に変化させる。  DUTシミュレート部200は、例えばVerilog−HDLやVHDL等のハードウェア記述言語により記述されたDUT100の動作を、DUT接続部280から取得した試験信号に基づきシミュレートする。そして、DUTシミュレート部200は、DUT100が試験信号に基づいて動作した結果出力する結果信号をシミュレーションにより生成し、DUT接続部280を介して試験モジュールエミュレート部270に供給する。  スケジュール制御部275は、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、複数の試験モジュールエミュレート部270、及びDUT接続部280によるDUT100の擬似的な試験において、これらの複数のモジュールエミュレート部が生成する各種のタイミングに基づいて、それぞれのモジュールエミュレート部を動作させるスケジュールを制御する。スケジュール制御部275は、タイミング整列部276と、スケジュール部277とを含む。  タイミング整列部276は、同期モジュールエミュレート部250が生成した複数の試験信号生成タイミング、複数の割込み収集タイミング、複数のサイクル終了処理タイミング、及び複数の試験結果収集タイミングと、1又は複数の試験モジュールエミュレート部270により生成され、DUT接続部280により供給された複数の変化タイミングを、時刻順に整列して順次スケジュール部277に出力する。スケジュール部277は、タイミング整列部276が順次出力するそれぞれのタイミングを、当該タイミングに対応するモジュールエミュレート部やDUT接続部280に通知し、モジュールエミュレート部又はDUT接続部280に当該タイミングに対応する動作を行わせる。以下に、タイミング整列部276が出力したタイミングの種類に応じたスケジュール部277の動作を説明する。(1)  タイミング整列部276が試験信号生成タイミングを出力した場合  スケジュール部277は、当該試験信号生成タイミングを同期モジュールエミュレート部250に通知し、当該試験信号生成タイミングに対応する試験モジュールエミュレート部270による試験信号の生成を同期モジュールエミュレート部250を介して指示する。これにより、スケジュール部277は、同期モジュールエミュレート部250を介して、当該試験信号生成タイミングに対応する試験モジュールエミュレート部270に、当該試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させる。(2)  タイミング整列部276が割込み収集タイミングを出力した場合  スケジュール部277は、当該割込み収集タイミングに対応して指定された試験モジュールエミュレート部270に割込みの発生を指示する。これにより、スケジュール部277は、当該試験モジュールエミュレート部270に、当該割込み収集タイミングの直前に試験信号を生成したサイクル時間において擬似的に発生した割込みを、バススイッチエミュレート部240を介してサイト制御エミュレート部230に対して通知させる。(3)  タイミング整列部276がサイクル終了処理タイミングを出力した場合  スケジュール部277は、当該サイクル終了処理タイミングに対応する試験モジュールエミュレート部270に、サイクル終了タイミングが到達したことを通知する。(4)  タイミング整列部276が試験結果収集タイミングを出力した場合  スケジュール部277は、当該試験結果収集タイミングに対応する試験モジュールエミュレート部270に、試験結果収集タイミングが到達したことを通知する。これを受けて、当該試験モジュールエミュレート部270は、当該サイクル時間における結果信号と期待値との比較結果を同期接続モジュールエミュレート部260を介して同期モジュールエミュレート部250に通知する。(5)  タイミング整列部276が変化タイミングを出力した場合  DUT接続部280は、複数の試験モジュールエミュレート部270から取得した複数の変化タイミングをタイミング整列部276に供給する。これを受けてタイミング整列部276は、複数の変化タイミングと、他の各種タイミングとを合わせて時刻順に整列する。  タイミング整列部276が変化タイミングを出力すると、スケジュール部277は、当該変化タイミングに試験信号を擬似的に変化させるべく、DUT接続部280に変化タイミングが到達したことを通知する。これを受けて、DUT接続部280は、当該変化タイミングに試験信号を擬似的に変化させる。  ここで、試験モジュールエミュレート部270は、結果信号を取得すべきタイミングである結果信号取得タイミングをスケジュール制御部275に通知し、他の各種タイミングと併せてタイミング整列部276により時刻順に整列させてもよい。この場合、スケジュール部277は、タイミング整列部276が結果信号取得タイミングを出力した場合に、DUT接続部280に、当該結果信号取得タイミングにおいて、当該結果信号を取得すべき試験モジュールエミュレート部270に結果信号を供給させてもよい。  また、DUT接続部280は、複数の試験モジュールエミュレート部270により生成された複数の変化タイミングを取得し、時刻順に整列することなくDUTシミュレート部200に供給してもよい。この場合、DUTシミュレート部200は、供給された複数の変化タイミングを時刻順に整列し、整列した複数の変化タイミングに基づきDUT100のシミュレーションを行なってよい。  以上に示した試験エミュレート装置190によれば、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び1又は複数の試験モジュールエミュレート部270を、試験装置10の実機における同期モジュール150、同期接続モジュール160、及び1又は複数の試験モジュール170にそれぞれ対応して設けることにより、これらのモジュールエミュレート部を他のモジュールエミュレート部に容易と置換することができる。これにより、例えば試験装置10の実機において一のモジュールを他のモジュールに変更した場合に、試験エミュレート装置190において当該一のモジュールに対応するモジュールエミュレート部を、他のモジュールに対応するモジュールエミュレート部に置換し、試験装置10の実機と略同一の試験環境を試験エミュレート装置190上で提供することができる。  なお、以上に代えて、サイト制御エミュレート部230、バススイッチエミュレート部240、同期モジュールエミュレート部250、試験モジュールエミュレート部270、スケジュール制御部275、DUT接続部280、及びDUTシミュレート部200は、サイト制御装置130等の1台のコンピュータにより実現されてもよく、複数のコンピュータによる分散システムにより実現されてもよい。  図3は、本発明の実施形態に係る試験エミュレート装置190のハードウェア構成の一例を示す。本実施形態に係る試験エミュレート装置190は、CPU300、ROM310、RAM320、通信インターフェイス330、ハードディスク・ドライブ340、フレキシブルディスク・ドライブ350、及びCD−ROMドライブ360を備えるコンピュータ20により実現される。  CPU300は、ROM310及びRAM320に格納されたプログラムに基づいて動作し、各部の制御を行う。ROM310は、コンピュータ20の起動時にCPU300が実行するブートプログラムや、コンピュータ20のハードウェアに依存するプログラム等を格納する。RAM320は、CPU300が実行するプログラム及びCPU300が使用するデータ等を格納する。通信インターフェイス330は、通信ネットワークを介して他の装置と通信する。ハードディスク・ドライブ340は、コンピュータ20が使用するプログラム及びデータを格納し、RAM320を介してCPU300に供給する。フレキシブルディスク・ドライブ350は、フレキシブルディスク390からプログラム又はデータを読み取り、RAM320に提供する。CD−ROMドライブ360は、CD−ROM395からプログラム又はデータを読み取り、RAM320に提供する。  RAM320を介してCPU300に提供されるプログラムは、フレキシブルディスク390、CD−ROM395、又はICカード等の記録媒体に格納されて利用者によって提供される。プログラムは、記録媒体から読み出され、RAM320を介してコンピュータ20にインストールされ、コンピュータ20において実行される。  コンピュータ20にインストールされて実行され、コンピュータ20を試験エミュレート装置190として機能させるプログラムモジュールは、DUTシミュレートモジュールと、サイト制御エミュレートモジュールと、バススイッチエミュレートモジュールと、同期モジュールエミュレートモジュールと、同期接続モジュールエミュレートモジュールと、試験モジュールエミュレートモジュールと、スケジュール制御モジュールと、タイミング整列モジュールと、スケジュールモジュールと、DUT接続モジュールとを含む。これらのプログラム又はモジュールは、コンピュータ20を、DUTシミュレート部200、サイト制御エミュレート部230、バススイッチエミュレート部240、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、スケジュール制御部275、タイミング整列部276、スケジュール部277、及びDUT接続部280としてそれぞれ機能させる。  以上に示したプログラム又はモジュールは、外部の記録媒体に格納されてもよい。記録媒体としては、フレキシブルディスク390、CD−ROM395の他に、DVDやPD等の光学記録媒体、MD等の光磁気記録媒体、テープ媒体、ICカード等の半導体メモリ等を用いることができる。また、専用通信ネットワークやインターネットに接続されたサーバシステムに設けたハードディスク又はRAM等の記憶装置を記録媒体として使用し、通信ネットワークを介して外部のネットワークからプログラムをコンピュータ20に提供してもよい。  図4は、本発明の実施形態に係る試験モジュールエミュレート部270の機能構成を示す。図4において、試験モジュールエミュレート部270は、当該試験モジュールエミュレート部270に対応する試験モジュールエミュレートプログラム又は試験モジュールエミュレートモジュールをコンピュータ20で動作させることにより実現される。  試験モジュールエミュレート部270は、試験モジュール170がサイト制御装置130からバススイッチ140を介して受信する複数のコマンドのそれぞれに対応して設けられた複数のハードウェアエミュレート関数と、試験モジュールエミュレート部270に各種のタイミングを通知する目的で呼び出される制御関数とを有し、バススイッチエミュレート部240及びスケジュール制御部275からこれらの関数に対する呼び出しを受けて動作する。ここで、制御関数は、スケジュール制御部275が、試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるため、及び、割込み収集タイミングの直前に試験モジュールエミュレート部270が試験信号を生成したサイクル時間において擬似的に発生した割込みをサイト制御エミュレート部230に対して通知させるため等に用いられる。  試験モジュールエミュレート部270は、試験モジュールIFエミュレート部400(試験モジュールインターフェイスエミュレート部)と、パターン発生器エミュレート部430と、波形整形器エミュレート部440と、ピン制御エミュレート部450と、パラメータ測定エミュレート部460とを含む。  試験モジュールIFエミュレート部400は、バススイッチエミュレート部240からハードウェアエミュレート関数の呼び出しを受けた場合、及びスケジュール制御部275から制御関数の呼び出しを受けた場合に起動され、これらの関数呼び出しに対応する試験モジュールエミュレート部270の動作を制御する。試験モジュールIFエミュレート部400は、マシンワードDB420と、制御関数処理部410とを含む。  マシンワードDB420は、試験モジュール170に設けられた記憶領域に格納される記憶領域をエミュレートし、ハードウェアエミュレート関数の呼び出しによりサイト制御エミュレート部230からバススイッチエミュレート部240を介してコマンドを擬似的に受け取った場合に、当該コマンドに対応してマシンワードDB420内の記憶領域をアクセスする。  より具体的には、本実施形態に係る試験モジュールIFエミュレート部400は、読出しアクセスや書込みアクセス等の複数のコマンドに対応する試験モジュールエミュレート部270の動作をそれぞれエミュレートする複数のハードウェアエミュレート関数を実装する。バススイッチエミュレート部240を介してサイト制御エミュレート部230から読出しアクセスを受け取ると、試験モジュールIFエミュレート部400は、当該読出しアクセスの対象となる記憶領域に対応するマシンワードDB420内のデータをバススイッチエミュレート部240を介してサイト制御エミュレート部230に返信する。また、書込みアクセスを受け取ると、マシンワードDB420は、当該書込みアクセスの対象となる記憶領域に対応するマシンワードDB420内の記憶領域に、書込み対象のデータを格納する。例えば、マシンワードDB420は、バススイッチエミュレート部240を介してサイト制御エミュレート部230から試験プログラム又は試験データの書込みアクセスを受け取ると、当該書込みアクセスに対応するマシンワードDB420内の記憶領域にこれらの試験プログラム又は試験データを格納する。  制御関数処理部410は、スケジュール制御部275から制御関数の呼び出しを受けた場合に、当該制御関数に対応してパターン発生器エミュレート部430、波形整形器エミュレート部440、ピン制御エミュレート部450、及びパラメータ測定エミュレート部460を動作させ、当該制御関数の指示に対応する試験モジュール170の動作をエミュレートする。より具体的には、スケジュール制御部275が制御関数を用いて試験信号生成タイミングに対応するサイクル時間における試験信号の生成を指示すると、制御関数処理部410は、マシンワードDB420に格納された試験プログラム及び試験データのうち、当該サイクル時間中に試験モジュールエミュレート部270が処理すべきプログラム部分及びデータ部分を読み出し、これらのプログラム部分及びデータ部分に対応する処理をパターン発生器エミュレート部430、波形整形器エミュレート部440、ピン制御エミュレート部450、及びパラメータ測定エミュレート部460に行なわせる。  パターン発生器エミュレート部430は、試験モジュール170が有するパターン発生器をエミュレートする。すなわち、パターン発生器エミュレート部430は、マシンワードDB420に格納された試験プログラム及び試験データを、例えば関数呼び出しにより制御関数処理部410から受信し格納する。そして、あるサイクル時間について試験信号を生成すべきことを示す指示を、スケジュール制御部275から制御関数処理部410を介して例えば関数呼び出しにより受け取り、当該サイクル時間中に発生すべき試験信号を擬似的に生成する。  また、パターン発生器エミュレート部430は、DUTシミュレート部200が試験信号に基づいて動作した結果擬似的に出力する結果信号をDUT接続部280及び波形整形器エミュレート部440を介して取得し、期待値との比較を行なう。  波形整形器エミュレート部440は、試験モジュール170が有する波形整形器をエミュレートする。すなわち、波形整形器エミュレート部440は、パターン発生器エミュレート部430から試験信号を受けて、試験信号の波形を擬似的に整形し、DUT接続部280へ出力する。  ピン制御エミュレート部450は、試験モジュール170が有するピン制御部をエミュレートする。すなわち、ピン制御エミュレート部450は、試験プログラムに基づいて、波形整形器エミュレート部440及び/又はパラメータ測定エミュレート部460が試験信号を擬似的に出力する各端子に、動作電圧等のパラメータを設定する。  パラメータ測定エミュレート部460は、試験モジュール170が有するパラメータ測定部をエミュレートする。すなわち例えば、パラメータ測定エミュレート部460は、関数呼び出しにより直流試験(DCパラメトリック試験)の指示を、スケジュール制御部275から制御関数処理部410を介して受け取り、直流試験において当該サイクル時間中に発生すべき試験信号を擬似的に生成する。また、パラメータ測定エミュレート部460は、DUTシミュレート部200が直流試験において試験信号に基づいて動作した結果擬似的に出力する結果信号を取得する。  また、制御関数処理部410は、試験信号生成タイミングに対応するサイクル時間における試験信号を試験モジュールエミュレート部270が生成した場合、当該試験信号生成タイミングに対応するサイクルが終了するサイクル終了タイミングを同期モジュールエミュレート部250に通知する。  以上において、制御関数処理部410は、試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクルが終了するサイクル終了タイミングをスケジュール制御部275を介して同期モジュールエミュレート部250に通知してもよい。これにより、制御関数処理部410は、同期モジュールエミュレート部250に、当該サイクル終了タイミングに基づき試験モジュールエミュレート部270が次に試験信号を擬似的に生成すべき試験信号生成タイミングを更に生成させることができる。  また、制御関数処理部410は、スケジュール制御部275から割り込み発生の指示を受けた場合、例えば関数呼び出しにより割込み発生の指示をパターン発生器エミュレート部430、波形整形器エミュレート部440、及びピン制御エミュレート部450に送信する。割込み発生の指示を受けたパターン発生器エミュレート部430、波形整形器エミュレート部440、及びピン制御エミュレート部450は、試験モジュールエミュレート部270が試験信号を生成した各サイクル時間のうち、当該割込み収集タイミングの直前のサイクル時間において擬似的に発生した割込みを制御関数処理部410に通知する。制御関数処理部410は、割込みの通知を受けると、例えばバススイッチエミュレート部240が有する割込み通知用のハードウェアエミュレート関数を呼び出すことにより、バススイッチエミュレート部240を介してサイト制御エミュレート部230に割込みを通知する。  図5は、本発明の実施形態に係るクラス階層構造500の一例を示す。本実施形態において、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270等のモジュールエミュレート部を実現するモジュールエミュレートプログラムは、試験装置10のオープンアーキテクチャを擬似的に実現するために定められたモジュールエミュレートプログラムの枠組みであるクラス関数を用いて作成される。  シミュレーションコンポーネントクラス510は、モジュールエミュレートプログラムが備えるべき複数のメソッド関数のパラメータや戻り値等の呼び出し規則を、仮想メソッド関数により定義するクラスである。シミュレーションコンポーネントクラス510は、複数の仮想ハードウェアエミュレート関数512と、複数の仮想制御関数514とを有する。  ここで、read()は、サイト制御エミュレート部230が読出アクセスコマンドを擬似的に発行する場合に呼び出される、読出アクセスに対応するモジュールの動作をエミュレートするメソッド関数である。write()は、サイト制御エミュレート部230が書込アクセスコマンドを擬似的に発行する場合に呼び出される、書込アクセスに対応するモジュールの動作をエミュレートするメソッド関数である。setBaseAddress()は、試験モジュール170が有する記憶領域のベースアドレスを設定する際にサイト制御装置130が発行するベースアドレス設定コマンドを、サイト制御エミュレート部230が擬似的に発行する場合に呼び出されるメソッド関数である。  registerEvent()は、同期モジュールエミュレート部250からの通知を受けた同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、及びDUT接続部280が、割込み収集タイミング、変化タイミング、及び結果信号取得タイミング等をタイミング整列部276に通知し登録する場合に呼び出されるメソッド関数である。handleEvent()は、試験信号生成タイミング、割込み収集タイミング、変化タイミング、及び結果信号取得タイミングに到達したとき等に、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、及びDUT接続部280にこれらのタイミングに対応する処理を行なわせるためにスケジュール制御部275により呼び出されるメソッド関数である。raiseEvent()は、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、及びDUT接続部280が、タイミングに関わりなく非同期に処理すべきイベントをスケジュール制御部275に通知する場合に呼び出されるメソッド関数である。  A社モジュールクラス520及びB社モジュールクラス530は、シミュレーションコンポーネントクラス510から派生されたクラスであり、例えばモジュールを提供する製造業者等により提供される、当該製造業者のモジュールが共通して備える共通機能をエミュレートするモジュールエミュレートプログラムである。A社モジュールクラス520及びB社モジュールクラス530は、それぞれ複数の実ハードウェアエミュレート関数522と、複数の実制御関数524とを有する。複数の実ハードウェアエミュレート関数522及び複数の実制御関数524のそれぞれは、複数の仮想ハードウェアエミュレート関数512及び複数の仮想制御関数514のそれぞれに対応して記述され、仮想メソッド関数に対応する実メソッド関数(非仮想メソッド関数)の処理内容を記述したモジュールエミュレートプログラムである。  A社モジュールクラス520及びB社モジュールクラス530は、更に派生したクラスを有してよい。例えば、図5において、B社モジュールクラス530は、デジタル試験モジュールクラス540、電源モジュールクラス560、及び同期モジュールクラス590に更に派生される。  デジタル試験モジュールクラス540は、DUT100の機能試験を行なう試験モジュール170をエミュレートする試験モジュールエミュレートプログラムのクラスである。デジタル試験モジュールクラス540は、250MHzで動作してDUT100の機能試験を行なう試験モジュール170をエミュレートする250MHzデジタル試験モジュールクラス550に更に派生される。電源モジュールクラス560は、DUT100に電源を供給するモジュールをエミュレートするモジュールエミュレートプログラムのクラスである。電源モジュールクラス560は、DUT100に高電圧電源を供給するモジュールをエミュレートする高電圧電源モジュールクラス570と、DUT100に低電圧電源を供給するモジュールをエミュレートする低電圧電源モジュールクラス580とに更に派生される。同期モジュールクラス590は、同期モジュール150をエミュレートするモジュールエミュレートプログラムのクラスである。  250MHzデジタル試験モジュールクラス550、高電圧電源モジュールクラス570、低電圧電源モジュールクラス580、及び同期モジュールクラス590のそれぞれは、B社モジュールクラス530に含まれるhandleEvent()を置き換えて(オーバーライドして)使用される、それぞれのモジュールの独自機能をエミュレートする実メソッド関数handleEvent()を含む。  試験エミュレート装置190が有する同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び1又は複数の試験モジュールエミュレート部270等は、クラス階層構造500に含まれるモジュールエミュレートプログラムのクラスのいずれかのインスタンスとして実現されてよい。  以上に示した通り、試験エミュレート装置190が有する同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270等のモジュールエミュレート部は、例えばクラス階層構造500に含まれるいずれかのクラスに対応するモジュールエミュレートプログラムにより実現される。試験エミュレート装置190の使用者は、例えば試験装置10の実機に実装されるべきモジュールの組合せに対応するクラスの組合せからモジュールエミュレートプログラムのインスタンスを生成することにより、試験装置10の実機と略同一の試験環境を試験エミュレート装置190上で構築することができる。また、新たなモジュールに対応する新たなクラスを作成する場合においても、新たなクラスをいずれかのクラスの派生クラスとして作成することにより、モジュールエミュレートプログラムの作成工数を低減することができる。  図6は、本発明の実施形態に係る試験エミュレート装置190の試験信号生成処理フローを、一の試験モジュールエミュレート部270により試験を行なう場合について示す。  試験プログラム及び試験データが同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び1又は複数の試験モジュールエミュレート部270に格納された状態で、サイト制御エミュレート部230が試験の開始を同期モジュールエミュレート部250に指示すると、試験エミュレート装置190は以下に示す手順で擬似的に試験を行なう。  まず、スケジュール制御部275(図中SCHED)中のスケジュール部277は、タイミング整列部276が試験信号生成タイミングを出力した場合に、同期モジュールエミュレート部250(図中SYNC)のhandleEvent()関数を呼び出し、試験信号生成タイミングに至ったことを通知する(S600)。これにより、スケジュール制御部275は、同期モジュールエミュレート部250を介して、試験信号生成タイミングに対応する試験モジュールエミュレート部270に、当該試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させる。ここで、スケジュール制御部275は、対応する試験モジュールエミュレート部270の試験信号生成タイミングに至ったことを示すイベント識別子をhandleEvent()関数のパラメータに含めることにより、試験信号生成タイミングを同期モジュールエミュレート部250に通知してもよい。  次に、同期モジュールエミュレート部250は、当該試験信号生成タイミングにおいて試験信号を擬似的に生成すべき試験モジュールエミュレート部270(図中TM)に対して、サイクル時間の処理を開始し試験信号を生成させる指示であるサイクル開始を通知する(S605)。ここで、同期モジュールエミュレート部250は、サイクル開始を指示するイベント識別子をraiseEvent()関数のパラメータに含めてスケジュール制御部275を呼び出すことにより、タイミング整列部276が時刻順に整列したタイミングと非同期にスケジュール制御部275を介して試験モジュールエミュレート部270にサイクル開始を通知してよい。  次に、試験モジュールエミュレート部270は、サイクル開始の通知を受けて、対応するサイクル時間における試験信号を擬似的に発生する(S610)。すなわち、S600においてスケジュール制御部275が試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に発生させるべく同期モジュールエミュレート部250に試験信号生成タイミングを通知し、この通知を受けた同期モジュールエミュレート部250がスケジュール制御部275を介して試験モジュールエミュレート部270にサイクル開始を通知することにより、試験モジュールエミュレート部270は、当該サイクル時間における試験信号を擬似的に発生する。ここで、試験モジュールエミュレート部270は、当該サイクル時間における試験信号の生成において、当該サイクル時間中における試験信号の変化タイミングを擬似的に生成する。  次に、DUT接続部280(図中LB)は、試験モジュールエミュレート部270から試験信号の変化タイミングを受けて、変化タイミングをタイミング整列部276に通知し登録する(S615)。  次に、試験モジュールエミュレート部270は、当該サイクルを終了するタイミングを同期モジュールエミュレート部250に通知する(S620)。ここで、試験モジュールエミュレート部270は、試験プログラム及び試験データによる指定に基づき、各サイクル時間を動的に変更しつつパターン発生器エミュレート部430により試験信号を生成する。このため、試験モジュールエミュレート部270における試験モジュールIFエミュレート部400内の制御関数処理部410は、各サイクルの終了するタイミングをパターン発生器エミュレート部430から取得して同期モジュールエミュレート部250に通知し、同期モジュールエミュレート部250が次の試験信号生成タイミングを正しく生成できるようにする。  次に、同期モジュールエミュレート部250は、S620において試験モジュールエミュレート部270から通知されたサイクル終了タイミングに基づいて、試験モジュールエミュレート部270が次のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成し、タイミング整列部276に通知して登録する(S625)。また、同期モジュールエミュレート部250は、試験モジュールエミュレート部270から試験結果を収集する試験結果収集タイミング、試験モジュールエミュレート部270の当該サイクル時間を終了させるサイクル終了処理タイミング、当該サイクル時間における試験信号の生成において試験モジュールエミュレート部270が擬似的に発生した割込みを収集する割込み収集タイミングを更に生成し、タイミング整列部276に通知して登録する(S625)。ここで、同期モジュールエミュレート部250は、スケジュール制御部275のregisterEvent()関数を呼び出すことにより、これらのタイミングをタイミング整列部276に登録してよい。  なお、同期モジュールエミュレート部250は、試験モジュールエミュレート部270から受信したサイクル終了タイミングと略同一のタイミングを、当該試験モジュールエミュレート部270における次の試験信号生成タイミング、試験結果収集タイミング、サイクル終了処理タイミング、及び割り込み収集タイミングとして生成してもよい。  次に、タイミング整列部276がS615において登録された変化タイミングを出力すると、スケジュール部277は、当該変化タイミングに試験信号を擬似的に変化させるべく、DUT接続部280に変化タイミングが到達したことを通知する(S630)。  次に、スケジュール部277から変化タイミングの通知を受けると、DUT接続部280は、当該変化タイミングに試験信号を擬似的に変化させることにより試験信号を生成し、DUTシミュレート部200に供給する(S635)。DUTシミュレート部200は、DUT接続部280から取得した試験信号に基づきDUT100の動作をシミュレートする。そして、DUTシミュレート部200は、DUT100が試験信号に基づいて動作した結果出力する結果信号を擬似的に生成し、DUT接続部280を介して試験モジュールエミュレート部270に供給する。試験モジュールエミュレート部270は、結果信号と期待値とを比較し、比較結果を得る。  次に、タイミング整列部276がS625において登録された試験結果収集タイミングを出力すると、スケジュール部277は、DUTシミュレート部200から試験モジュールエミュレート部270に供給された結果信号に基づく結果の良否を収集するべく、試験モジュールエミュレート部270に試験結果収集タイミングが到達したことを通知する(S640)。試験結果収集タイミングの通知を受けると、試験モジュールエミュレート部270は、当該サイクル時間における結果信号と期待値との比較結果を、同期接続モジュールエミュレート部260を介して同期モジュールエミュレート部250に通知する。同期モジュールエミュレート部250は、各試験モジュールエミュレート部270から収集した比較結果に基づき試験結果の良否(パス又はフェイル)を判定し、試験結果の良否を各試験モジュールエミュレート部270に配信することにより通知する(S645)。複数の試験モジュールエミュレート部270に供給される試験プログラム及び試験データは、この試験結果の良否に基づいて、当該サイクル時間以降に行なう試験のシーケンスを変更するように記述されていてもよい。  次に、タイミング整列部276がS625において登録されたサイクル終了処理タイミングを出力すると、スケジュール部277は、試験モジュールエミュレート部270にサイクルを終了させるタイミングが到達したことを通知する(S650)。  次に、タイミング整列部276がS625において登録された割込み収集タイミングを出力すると、スケジュール部277は、試験モジュールエミュレート部270に割込み収集タイミングが到達したことを通知する(S655)。割込み収集タイミングの通知を受けると、試験モジュールエミュレート部270は、当該割込み収集タイミングの直前に試験モジュールエミュレート部270が試験信号を生成したサイクル時間において擬似的に発生した割込みを、バススイッチエミュレート部240を介してサイト制御エミュレート部230に対して擬似的に通知する。  試験エミュレート装置190は、上記のS600からS655に示した処理を、試験が終了するまで繰り返す(S660)。  なお、複数の試験モジュールエミュレート部270により試験を行なう場合、スケジュール制御部275は、これらの複数の試験モジュールエミュレート部270のそれぞれが動作すべきタイミングを時刻順に整列し、スケジュールする。このため、複数の試験モジュールエミュレート部270についてのS600、S630、S640、S650、及びS655は、時刻順に整列された順序で実行される。  図7は、本発明の実施形態に係る試験エミュレート装置190により擬似的に生成される試験信号の一例を示す。本図において、試験エミュレート装置190は、試験モジュールエミュレート部270として、試験モジュールAをエミュレートする試験モジュールエミュレート部270aと、試験モジュールBをエミュレートする試験モジュールエミュレート部270bとを含む。  まず、時刻t1以前において、タイミング整列部276は、試験モジュールエミュレート部270aの試験信号生成タイミングt1と、試験モジュールエミュレート部270bの試験信号生成タイミングt2とを登録しており、これらを時刻順に整列して出力する結果、まず試験信号生成タイミングt1を出力する。これを受けて、スケジュール部277は、時刻をt1に進めると共に、試験信号生成タイミングt1に至ったことを同期モジュールエミュレート部250に通知する。  試験信号生成タイミングt1の通知を受けると、同期モジュールエミュレート部250は、同期接続モジュールエミュレート部260及び試験モジュールエミュレート部270を介して、試験信号生成タイミングt1に対応する試験モジュールエミュレート部270aにサイクル開始を通知する。これを受けて、試験モジュールエミュレート部270aは、図中サイクル1と示したサイクル時間における試験信号を擬似的に発生する。ここで、試験モジュールエミュレート部270aは、当該サイクル時間中の変化タイミングt4において試験信号がHレベルに変化することを、DUT接続部280に通知する。これを受けて、DUT接続部280は、変化タイミングt4をタイミング整列部276に登録する。  次に、試験モジュールエミュレート部270aは、サイクル1における試験信号の生成を終えると、サイクル1のサイクル終了タイミングt6を同期モジュールエミュレート部250に通知する。これを受けて、同期モジュールエミュレート部250は、サイクル終了タイミングt6に基づき、次の試験信号生成タイミングt6、試験結果収集タイミングt6−Δ、サイクル終了処理タイミングt6−Δ、及び割り込み収集タイミングt6−Δを生成し、タイミング整列部276に登録する。ここで、t6−Δは、次の試験信号生成タイミングt6の微小時間前であることを示す。  次に、タイミング整列部276は、登録されたタイミングを時刻順に整列し、試験信号生成タイミングt2を出力する。これを受けて、スケジュール部277は、時刻をt2に進めると共に、試験信号生成タイミングt2に至ったことを同期モジュールエミュレート部250に通知する。  試験信号生成タイミングt2の通知を受けると、同期モジュールエミュレート部250は、試験信号生成タイミングt2に対応する試験モジュールエミュレート部270bに、スケジュール制御部275を介してサイクル開始を通知する。これを受けて、試験モジュールエミュレート部270bは、試験モジュールエミュレート部270bのサイクル1における試験信号を擬似的に発生する。この結果、試験モジュールエミュレート部270bは、試験信号の変化タイミングt3及びt5を生成し、DUT接続部280はこれらの変化タイミングをタイミング整列部276に登録する。  次に、試験モジュールエミュレート部270bは、サイクル1における試験信号の生成を終えると、サイクル1のサイクル終了タイミングt7を同期モジュールエミュレート部250に通知する。これを受けて、同期モジュールエミュレート部250は、サイクル終了タイミングt7に基づき、次の試験信号生成タイミングt7、試験結果収集タイミングt7−Δ、サイクル終了処理タイミングt7−Δ、及び割り込み収集タイミングt7−Δを生成し、タイミング整列部276に登録する。  次に、タイミング整列部276は、登録されたタイミングを時刻順に整列し、変化タイミングt3、t4、t5を順次出力する。これらの変化タイミングのそれぞれを受けて、スケジュール部277は、変化タイミングをDUT接続部280に通知する。この結果、DUT接続部280は、当該変化タイミングに試験信号を擬似的に変化させ、DUTシミュレート部200に供給する。  次に、タイミング整列部276は、試験結果収集タイミングt6−Δを出力する。これを受けて、スケジュール部277は、時刻をt6−Δに進めると共に、試験モジュールエミュレート部270aに試験結果収集タイミングt6−Δを通知する。この結果、試験モジュールエミュレート部270a及び同期モジュールエミュレート部250の間で試験結果の収集及び配信を行なう。  次に、タイミング整列部276は、サイクル終了処理タイミングt6−Δを出力する。これを受けて、スケジュール部277は、試験モジュールエミュレート部270aにサイクル1の終了を通知する。  次に、タイミング整列部276は、割込み収集タイミングt6−Δを出力する。これを受けて、スケジュール部277は、試験モジュールエミュレート部270aに割込み収集タイミングt6−Δを通知する。この結果、試験モジュールエミュレート部270aは、サイクル1において擬似的に発生した割込みをサイト制御エミュレート部230に対して通知する。  次に、タイミング整列部276は、試験信号生成タイミングt6を出力する。これを受けて、スケジュール部277は、時刻をt6に進めると共に、試験信号生成タイミングt6に至ったことを同期モジュールエミュレート部250に通知する。以降試験エミュレート装置190は、時刻t1と同様にして、変化タイミングt8、結果信号を取得すべきタイミングを示す結果信号取得タイミングt11、次の試験信号生成タイミングt12、試験結果収集タイミングt12−Δ、サイクル終了処理タイミングt12−Δ、及び割込み収集タイミングt12の生成及びタイミング整列部276への登録を行なう。  次に、タイミング整列部276は、登録されたタイミングを時刻順に整列し、試験信号生成タイミングt7を出力する。これを受けて、スケジュール部277は、時刻をt7に進めると共に、試験信号生成タイミングt7に至ったことを同期モジュールエミュレート部250に通知する。以降試験エミュレート装置190は、時刻t2と同様にして、変化タイミングt9及びt10、次の試験信号生成タイミングt13、試験結果収集タイミングt13−Δ、サイクル終了処理タイミングt13−Δ、及び割込み収集タイミングt13の生成及びタイミング整列部276への登録を行なう。  以上に示した通り、本実施形態に係る試験エミュレート装置190によれば、試験信号生成タイミング、試験信号の変化タイミング、試験結果収集タイミング、結果信号取得タイミング、及び割込み収集タイミング等の各種のタイミングをスケジュール制御部275により時刻順に整列してスケジューリングする。このため、試験エミュレート装置190は、異なるサイクル周期に基づく複数の試験モジュール170が実装された場合における試験装置10の動作を適切にエミュレートすることができる。  なお、本実施形態において、同期接続モジュールエミュレート部260は、試験モジュール170からサイクル終了タイミングを受けた場合に、試験結果収集タイミング、サイクル終了処理タイミング、及び割込み収集タイミングをタイミング整列部276に登録するが、これに代えて、以下の方法を用いてもよい。  図6のS625において、同期モジュールエミュレート部250は、サイクル終了タイミングに基づいて、試験モジュールエミュレート部270が次のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成し、タイミング整列部276に通知して登録する。一方、この時点において、同期モジュールエミュレート部250は、試験結果収集タイミング、サイクル終了処理タイミング、及び割り込み収集タイミングを生成せず、タイミング整列部276に対して登録しない。  この結果、試験エミュレート装置190は、図6のS630及びS635の処理の後、S640、S650、及びS655を行なうことなく、S600に処理を進める。そして、S600において次のサイクル時間に対応する試験信号生成タイミングをタイミング整列部276が出力した場合に、スケジュール部277は、当該試験信号生成タイミングに至ったことを同期モジュールエミュレート部250に通知する。これを受けて、同期モジュールエミュレート部250は、次のサイクル時間の試験信号生成の前に、試験結果の収集、サイクル終了の通知、及び割込みの収集を、当該試験信号生成タイミングに対応する試験モジュールエミュレート部270に指示する。  以上の処理により、スケジュール制御部275は、次のサイクル時間の試験信号生成の前に、S640、S645、S650、及びS655に示した処理を同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270等に行わせる。より具体的には、スケジュール制御部275は、当該試験信号生成タイミングの直前のサイクル時間における試験信号の生成において、試験モジュールエミュレート部270に供給された結果信号に基づく試験結果の良否を同期モジュールエミュレート部250及び同期接続モジュールエミュレート部260により収集及び配信させ、当該試験モジュールエミュレート部270が擬似的に発生した割込みをサイト制御エミュレート部230に対して通知させる。  以上発明の実施の形態を説明したが、本出願に係る発明の技術的範囲は上記の実施の形態に限定されるものではない。上記実施の形態に種々の変更を加えて、請求の範囲に記載の発明を実施することができる。そのような発明が本出願に係る発明の技術的範囲に属することもまた、請求の範囲の記載から明らかである。  例えば、以上に示した試験装置10は、同期モジュール150、同期接続モジュール160、及び試験モジュール170等によるDUT100の実試験と、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、及びDUTシミュレート部200等によるDUT100の擬似試験とを、同一の試験制御プログラム及び/又は試験プログラムにより実行可能な試験装置10の使用者に提供すると共に、使用者により実試験及び擬似試験を切替可能としてもよい。  すなわち、サイト制御装置130は、DUT100の実試験又は擬似試験のいずれを行うかの指示を、例えば試験開始コマンドのオプション等により入力する。そして、システム制御装置110又はサイト制御装置130は、DUT100の実試験を行う指示を受けた場合に、DUT100の試験を行う試験プログラムをバススイッチ140を介して1又は複数の試験モジュール170に供給して、これらの試験モジュール170によりDUT100の試験を行わせる。一方、サイト制御装置130は、DUT100の擬似試験を行う指示を受けた場合に、試験プログラムを試験エミュレート装置190又はサイト制御装置130等の上でソフトウェアにより実現される試験モジュールエミュレート部270に供給して、試験モジュールエミュレート部270等によりDUT100の試験をシミュレートさせる。  以上において、サイト制御装置130は、当該制御装置と試験モジュール170との間の通信処理を行う通信ソフトウェア(通信ライブラリ)を実行し、当該通信ソフトウェアを通じて実試験環境及び擬似試験環境をアクセス可能としてもよい。この場合、サイト制御装置130上で実行される試験制御プログラムは、当該通信ソフトウェアにより提供される同一のアクセス関数(read/write関数等)を用いて、同期モジュール150、同期接続モジュール160、及び試験モジュール170等をアクセスして実試験を行い、また、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270等をアクセスして擬似試験を行うことができる。  ここで、上記の通信ソフトウェアは、サイト制御装置130と協働して、当該通信ソフトウェアを初期化する呼び出しに含まれる、実試験環境及び擬似試験環境を選択する指示に基づいて、試験プログラムを試験モジュール170等及び試験モジュールエミュレート部270等のいずれに供給するかを判断してもよい。このような実装の一例を、補足説明C.2.4.3に示す。  また、例えば、以上に示した試験モジュールエミュレート部270は、次に示す構成を採ってもよい。まず、各試験モジュールエミュレート部270は、スケジュール制御部275内のスケジュール部277によりスケジューリングされた試験信号生成タイミングの通知を、関数呼び出しにより受ける。そして、各試験モジュールエミュレート部270は、当該試験信号生成タイミングに対応するサイクル時間中における試験信号の電圧の変化を、出力チャネルをエミュレートする出力チャネルオブジェクトの電圧設定メソッド(setメソッド)を複数回呼び出すことにより出力する。そして、試験モジュールエミュレート部270は、当該サイクル時間に対応する試験信号の電圧の変化の出力を終えた後に、当該サイクル時間に対応する試験信号の電圧の変化の出力を終えたことを、出力チャネルオブジェクトの終了メソッド(endメソッド)を呼び出すことによりスケジュール部277等に通知する。このような実装の一例を、補足説明B.3.3等に示す。  そして、スケジュール部277は、複数の試験モジュールエミュレート部270のそれぞれから通知された終了メソッドに基づいて、全ての試験モジュールエミュレート部270が試験信号の電圧の変化の出力を終えた期間を算出し、この期間内におけるDUT100の動作のシミュレーションをDUTシミュレート部200に要求する。これを受けて、DUT接続部280は、この期間内における試験信号を取得して、当該試験信号に基づいて被試験デバイスのこの期間内における動作をシミュレートする。  以上において、出力チャネルオブジェクトは、終了メソッドの呼び出しを受けた後に、当該終了メソッドにより通知された、既に試験信号の電圧の変化の出力を終えた期間内の電圧の変化を禁止する。これにより、既にシミュレーションを終えた期間のシミュレーション結果が不整合となるのを防ぐことができる。このような実装の一例を補足説明B.3.4等に示す。  以下に、本実施形態に係る試験装置10及び試験エミュレート装置190を実現するための各種の具体例・仕様例を補足説明する。(補足説明A)ソフトウェアアーキテクチャの具体例  図8は、本発明の一実施形態によるソフトウェアアーキテクチャ2200を示している。ソフトウェアアーキテクチャ2200は、関連するハードウェアシステムの要素110と、130と、150、160及び170とに対応して、システムコントローラ2200と、少なくとも一つのサイトコントローラ2240と、少なくとも一つのモジュール2260とのための要素を有している分散オペレーティングシステムを表している。モジュール2260に加えて、アーキテクチャ2200は、ソフトウェアでのモジュールエミュレーションのための対応するSW(ソフトウェア)モジュールエミュレーション2280を含んでいる。  例示的な選択として、このプラットフォーム用の開発環境はマイクロソフトのウィンドウズに基づいていてもよい。このアーキテクチャの使用は、プログラムおよびサポートの移植性において副次的な利点(例えばフィールドサービスエンジニアは高度な診断を行うためのテスタオペレーティングシステムを動作させるラップトップコンピュータを接続することができるであろう)を有している。しかし、大規模な計算集約型の動作(テストパターンのコンパイル等)については、関連するソフトウェアは、独立して動作して分散されたプラットフォームを横断してのジョブスケジューリングを可能にすることができる独立した構成要素とされ得る。したがって、バッチジョブに関連するソフトウェアツールは、複数のプラットフォームタイプ上で動作することができる。  例示的な選択として、ANSI/ISO標準のC++をソフトウェア用のネイティブ言語とすることができる。当然のことながら、サードパーティが自身の選択した代わりの言語をシステムにまとめることを可能にする、(名目上のC++インタフェース上のレイヤを提供するための)使用可能な複数の選択肢がある。  図8は、名目上のソースによる組織化(あるいはサブシステムとしての集合的な展開)にしたがって、テスタオペレーティングシステムインタフェース2290、ユーザコンポーネント2292(例えば、テスト目的のためにユーザによって供給される)、システムコンポーネント2294(例えば、基本的な接続性および通信のためのソフトウェアインフラとして提供される)、モジュール開発コンポーネント2296(例えば、モジュールディベロッパによって提供される)、および外部コンポーネント2298(例えばモジュールディベロッパ以外の外部ソースによって提供される)を含む要素を陰付きで示している。  ソースベースの構成の観点から、テスタオペレーティングシステム(TOS)インタフェース2290は、システムコントローラ−サイトコントローラインタフェース2222、フレームワーククラス2224、サイトコントローラ−モジュールインタフェース2245、フレームワーククラス2246、所定のモジュールレベルインタフェース2247、バックプレーン通信ライブラリ2249、シャーシスロットIF(インタフェース)2262、ロードボードハードウェアIF2264、バックプレーンシミュレーションIF2283、ロードボードシミュレーションIF2285、DUTシミュレーションIF2287、DUTのVerilogモデル用のVerilogPLI(プログラミング言語インタフェース)2288、およびDUTのC/C++モデル用のC/C++言語サポート2289を含んでいる。  ユーザコンポーネント2292は、ユーザテストプラン2242、ユーザテストクラス2243、ハードウェアロードボード2265、DUT2266、DUT  Verilogモデル2293およびDUT  C/C++モデル2291を含んでいる。  システムコンポーネント2294は、システムツール2226、通信ライブラリ2230、テストクラス2244、バックプレーンドライバ2250、バススイッチ140を含むHWバックプレーン2261、シミュレーションフレームワーク2281、バックプレーンエミュレーション2282およびロードボードシミュレーション2286を含んでいる。  モデル展開コンポーネント2296は、モジュールコマンドインプリメンテーション2248、モジュールハードウェア2263およびモジュールエミュレーション2284を含んでいる。  外部コンポーネント2298は外部ツール2225を含んでいる。  図1に示したシステム制御装置110上で動作するソフトウェアであるシステムコントローラ2220は、サイトコントローラに対するインタフェース2222、フレームワーククラス2224、システムツール2226、外部ツール2225および通信ライブラリ2230を含んでいる。システムコントローラソフトウェアは、ユーザに対する相互作用の主要な点である。これは、本実施形態のサイトコントローラへのゲートウェイと、同一譲受人による米国出願第60/449,622号に述べられているマルチサイト/DUT環境におけるサイトコントローラの同期化とを提供する。ユーザアプリケーションおよびツールは、グラフィカルユーザインタフェース(GUI)ベースかそれ以外のものであり、システムコントローラ上で動作する。システムコントローラは、テストプラン、テストパターンおよびテストパラメータファイルを含むすべてのテストプラン関連の情報の収納庫としても機能する。テストパラメータファイルは、発明の一実施形態のオブジェクト指向の環境におけるテストクラス用のパラメータ化されたデータを含んでいる。  サードパーティのディベロッパは、標準的なシステムツール2226に加えて(あるいはその代わりとして)ツールを提供することができる。システムコントローラ2220上の標準的なインタフェース2222は、ツールがテスタおよびテストオブジェクトにアクセスするために用いるインタフェースを有している。ツール(アプリケーション)2225、2226は、テストおよびテスタオブジェクトの相互的なバッチ制御を可能にする。このツールは、(例えばSECS/TSEM等の使用を通じて)自動化能力を提供するためのアプリケーションを含んでいる。  システムコントローラ2220上にある通信ライブラリ2230は、ユーザアプリケーションおよびテストプログラムにトランスペアレントな形でサイトコントローラ2240と通信するメカニズムを提供する。  インタフェース2222は、システムコントローラ2220と関連したメモリに常駐しており、システムコントローラ上で実行するフレームワークオブジェクトに対するオープンインタフェースを提供する。サイトコントローラベースのモジュールソフトウェアがパターンデータにアクセス、取得することを可能にするインタフェースが含まれる。また、アプリケーションおよびツールがテスタおよびテストオブジェクトにアクセスするために用いるインタフェース、ならびに、スクリプトエンジンを通じてテスタおよびテストコンポーネントにアクセスして操作することができる能力を提供するスクリプトインタフェースも含まれる。これにより、インタラクティブな、バッチおよびリモートアプリケーションのための共通のメカニズムがそれらの機能を行うことが可能となる。  システムコントローラ2220に関連しているフレームワーククラス2224は、これらの上述したオブジェクトと相互に作用するメカニズムを提供し、これは標準的なインタフェースのリファレンスインプリメンテーションを提供する。例えば、本実施形態のサイトコントローラ2240は機能テストオブジェクトを提供する。システムコントローラフレームワーククラスは、この機能テストオブジェクトのリモートシステムコントローラベースの代理として、対応する機能テストプロキシを提供してもよい。したがって、標準的な機能テストインタフェースは、システムコントローラ2220上のツールに対して利用可能とされる。システム、モジュール開発コンポーネントおよびインタフェースコンポーネント2294、2296および2290はそれぞれ、システムコントローラとサイトコントローラとの間で分散されたオペレーティングシステムであると考えてもよい。フレームワーククラスは、ホストシステムコントローラに関連するオペレーティングシステムインタフェースを実質的に提供する。これらはまた、サイトコントローラに対するゲートウェイを提供するソフトウェア要素も構成し、マルチサイト/DUT環境におけるサイトコントローラの同期を提供する。したがってこのレイヤは、コミュニケーションレイヤを直接扱う必要なくサイトコントローラを操作し、それにアクセスするのに適している、発明の一実施形態におけるオブジェクトモデルを提供する。  図1に示したサイト制御装置130上で動作するソフトウェアであるサイトコントローラ2240は、ユーザテストプラン2242、ユーザテストクラス2243、標準テストクラス2244、標準インタフェース2245、サイトコントローラフレームワーククラス2246、モジュールハイレベルコマンドインタフェース(例えば所定のモジュールレベルのインタフェース)2247、モジュールコマンドインプリメンテーション2248、バックプレーン通信ライブラリ2249、およびバックプレーンドライバ2250のホストとなる。好ましくは、テストの機能の大半をサイトコントローラ2104/2240が扱い、それによってテストサイト2110の独立した動作が可能である。  テストプラン2242はユーザによって書かれる。このプランは、C++のような標準的なコンピュータ言語で直接記述されてもよいし、実行可能なテストプログラムへとコンパイル可能であるC++コードを生成するような、より高レベルのテストプログラミング言語で記述されてもよい。  このテストプランは、フレームワーククラス2246および/または、サイトコントローラに関連する標準あるいはユーザによって供給されるテストクラス2244を用いて、テストオブジェクトを作り出し、標準インタフェース2245を用いてハードウェアを構成し、テストプランのフローを定義する。また、テストプランの実行中に必要とされる追加的なロジックも提供する。テストプランは、いくつかの基本的なサービスをサポートし、デバッグサービス(例えばブレークポイント)等のその下にあるオブジェクトのサービスに対するインタフェースと、その下にあるフレームワークおよび標準クラスへのアクセスとを提供する。  サイトコントローラに関連するフレームワーククラス2246は、共通のテスト関連動作をインプリメントするクラスおよび方法のセットである。サイトコントローラレベルフレームワークは、例えば、電力供給およびピンエレクトロニクスの順番付け、レベルおよびタイミング条件の設定、測定値取得、テストフロー制御のためのクラスを含んでいる。フレームワークオブジェクトは、標準インタフェースをインプリメントすることを通じて動作してもよい。例えば、テスタピンフレームワーククラスのインプリメンテーションは、テストクラスがハードウェアモジュールピンと相互に作用するために用いるであろう汎用のテスタピンインタフェースをインプリメントするように統一される。  あるフレームワークオブジェクトは、モジュールと通信するためにモジュールレベルインタフェース2247の助けを借りて動作するようにインプリメントされてもよい。サイトコントローラフレームワーククラスは、実質的に、各サイトコントローラをサポートするローカルオペレーティングシステムとして機能する。  一般的に、プログラムコードの90%以上は装置テスト用のデータであり、残りの10%のコードがテスト方法を実現する。装置テストデータはDUT依存のデータ(例えば電力供給条件、信号電圧条件、タイミング条件等)である。テストコードは、指定された装置条件をATEハードウェア上にロードする方法からなり、またユーザが指定した目的(データロギング等)を実現するのに必要である方法からも構成される。発明の一実施形態のフレームワークは、ハードウェア依存性のテストと、ユーザがDUTテストプログラミングのタスクを行うことを可能にするテスタオブジェクトモデルとを提供する。  テストコードの再利用性を高めるために、このようなコードは、装置特有のデータ(例えばピンの名前、活性化データ等)、あるいは装置テストに特有のデータ(例えばDCユニットの条件、測定ピン、ターゲットピンの数、パターンファイルの名前、パターンプログラムのアドレス)のいずれに対しても独立とされてもよい。もしテスト用のコードをこれらのタイプのデータとともにコンパイルすれば、テストコードの再利用性は低下する。したがって、発明の一実施形態によれば、いかなる装置特有のデータあるいは装置テストに特有のデータも、コード実行期間中の入力として、外部からテストコードに役立てられてもよい。  発明の一実施形態においては、標準テストインタフェースのインプリメンテーションであるテストクラスは、ここではITestと記載するが、特定のタイプのテストに関してテストデータとコードとの分離(したがってコードの再利用性)を実現する。このようなテストクラスは、装置特有および/あるいは装置テスト特有のデータにおいてのみ異なるような別々のテストクラスの「テンプレート」とみなしてもよい。テストクラスはテストプランファイルにおいて指定される。各テストクラスは、典型的には、具体的なタイプの装置テストあるいは装置テスト用のセットアップをインプリメントする。例えば、発明の一実施形態は、DUTに関するすべての機能テストの基本となるクラスとして、ITestインタフェースの具体的なインプリメンテーション、例えばFunctionalTestを提供する。それは、テスト条件の設定、パターンの実行および、失敗したストローブの存在に基づくテスト状況の判定という基本的な機能を提供する。他のタイプのインプリメンテーションは、ここではACParametricTestおよびDCParametricTestとして表記されるACおよびDCテストクラスを含んでいてもよい。  全てのテストタイプは、いくつかの仮想的な方法のデフォルトのインプリメンテーション(例えば、init()、preExec()およびpostExec())を提供してもよい。これらの方法は、デフォルトの動作を乗り越えてテスト特有のパラメータを設定するためのテストエンジニアのエントリポイントとなる。しかしながら、カスタムテストクラスもテストプランにおいて用いることができる。  テストクラスは、そのテストの特定の場合に関するオプションを指定するために用いられるパラメータを提供することによって、ユーザがクラスの動作を構成することを可能にする。例えば、機能テストは、実行すべきパターンリストとテスト用のレベルおよびタイミング条件とを指定するために、パラメータPlistおよびTestConditionと採用してもよい。(テストプラン記述ファイルにおける異なる「テスト」ブロックの使用を通して)これらのパラメータについて異なる値を指定することにより、ユーザは機能テストの異なる例を作り出すことが可能である。図9は、どのようにして単一のテストクラスから異なるテスト例が導き出されるかを示している。テンプレートライブラリは、一般的なアルゴリズムおよびデータ構造の汎用ライブラリとして採用されてもよい。このライブラリはテスタのユーザに見えてもよく、ユーザは、例えば、ユーザ定義のテストクラスを作り出すようにテストクラスのインプリメンテーションを改変してもよい。  ユーザによって展開されるテストクラスに関して、システムの一実施形態は、このようなテストクラスを、全てのテストクラスが単一のテストインタフェース、例えばITestから得られるようなフレームワークに統合することをサポートし、その結果、そのフレームワークはシステムテストクラスの標準的なセットと同じようなやり方でそれらを処理することができる。ユーザは、追加のファシリティを生かすためには自分達のテストプログラムにおいてカスタムコードを用いなければならないという理解のもとで、自分達のテストクラスに追加の機能を自由に追加することができる。  図1に示したサイト制御装置130、同期モジュール150、同期接続モジュール160、及び試験モジュール170を含んで構成される各テストサイトは、一つ以上のDUT100のテスト専用のものであり、試験モジュール170等のテストモジュールの構成可能な集合体を通じて機能する。各テストモジュールは特定のテストタスクを行う主体である。例えば、テストモジュールは、DUTの電源、ピンカード、アナログカード等であり得る。モジュールによるこのアプローチは、高いフレキシビリティと構成可能性を提供する。  モジュールコマンドインプリメンテーションクラス2248は、モジュールハードウェアベンダによって提供されてもよく、ベンダによって選択されるコマンド実行方法に応じて、ハードウェアモジュールに関するモジュールレベルインタフェースをインプリメントするか、あるいは標準的なインタフェースのモジュール特有のインプリメンテーションを提供する。これらのクラスの外部インタフェースは、所定のモジュールレベルインタフェース要件およびバックプレーン通信ライブラリ要件によって規定される。またこのレイヤは、標準的なセットのテストコマンドの拡張も提供し、それにより方法(機能)およびデータ要素の追加が可能となる。  バックプレーン通信ライブラリ2249は、バックプレーンをまたいでの標準的な通信のためのインタフェースを提供し、それによってテストサイトに接続されたモジュールとの通信に必要な機能を提供する。これにより、ベンダに特有のモジュールソフトウェアが対応するハードウェアモジュールとの通信にバックプレーンドライバ2250を用いることが可能である。バックプレーシ通信プロトコルはパケットベースのフォーマットである。  テスタピンオブジェクトは、物理的なテスタチャネルを表しており、ここではITesterPinで示されるテスタピンインタフェースから得られる。発明の一実施形態によるソフトウェア開発キット(SDK)は、TesterPinと呼ばれることもあるITesterPinのデフォルトのインプリメンテーションを提供し、これは所定のモジュールレベルインタフェースIChannelに関してインプリメントされる。ベンダは、IChannelに関して彼らのモジュールの機能をインプリメントすることができるのであればTesterPinを自由に使うことができるが、そうでなければ、彼らのモジュールとどもに動作するITesterPinのインプリメンテーションを提供しなければならない。  本実施形態のテスタシステムによって提供される標準的なモジュールインタフェースは、ここではIModuleと表記するが、これは一般的には、ベンダのハードウェアモジュールを表している。ベンダによって供給される、システム用のモジュール特有のソフトウェアは、ダイナミックリンクライブラリ(DLL)のような実行可能な形態で提供されてもよい。ベンダからの各モジュールタイプ用のソフトウェアは、単一のDLLにカプセル化されていてもよい。このようなソフトウェアモジュールのそれぞれは、モジュールソフトウェア展開のためのAPIを備えている、モジュールインタフェースコマンド用のベンダに特有なインプリメンテーションを提供することを担っている。  モジュールインタフェースコマンドには2つのの局面がある。それらは、第一に、ユーザがシステムにおける特定のハードウェアモジュールと(間接的に)通信するためのインタフェースとして機能し、第二に、サードパーティディベロッパが彼ら自身のモジュールをサイトコントローラレベルのフレームワークに統合するために活用することができるインタフェースを提供する。したがって、フレームワークによって提供されるモジュールインタフェースコマンドは、2つのタイプに分けられる。  一つ目は、最も疑う余地のないものであるが、フレームワークインタフェースを通じてユーザに対してあらわになる「コマンド」である。したがって、例えば、テスタピンインタフェース(ITesterPin)は、レベルおよびタイミングの値を取得、設定するための方法を提供し、一方で電源インタフェース(IPowerSupply)は電力を上げたり下げたりする方法を提供する。  また、フレームワークは、モジュールとの通信に用いられることができる、所定のモジュールレベルインタフェースの特別なカテゴリを提供する。これらは、ベンダのモジュールとの通信のためにフレームワーククラスによって用いられるインタフェース(すなわち、フレームワークインタフェースの「標準的な」インプリメンテーション)である。  しかしながら、第二の局面、モジュールレベルインタフェースの使用は、任意のものである。それをすることの利点は、ベンダは、モジュールレベルインタフェースをインプリメントすることによって彼らのハードウェアに対して送られる具体的なメッセージの内容を注視しつつ、ITesterPinおよびIPowerSupplyのようなクラスのインプリメンテーションを活用し得るということである。しかし、もしこれらのインタフェースがベンダに不適切であれば、それらはフレームワークインタフェースのそれらのカスタムインプリメンテーション(例えばITesterPin、IPowerSupply等のベンダインプリメンテーション)を提供することを選択してもよい。そうすればこれらは、それらのハードウェアに対して適切であるカスタム機能を提供するであろう。  したがって、モジュールに特有なベンダソフトウェアの統合は、2つの異なった手段、すなわち、関連するフレームワーククラスおよびインタフェースのカスタムインプリメンテーション、あるいはモジュールレベルインタフェースの特別なカテゴリのカスタムインプリメンテーションを通じて実現され得る。  次に、両方の方法の例示的な応用を図10の助けを借りて説明する。図10は、発明の一実施形態によるテスタシステムとベンダによって供給されるモジュールとの相互作用を示すユニバーサルモデリング言語(UML)クラスダイアグラムである。  新しいデジタルモジュールのベンダであるサードパーティA(TPA)は、そのハードウェアモジュールと通信するためのソフトウェアモジュールを提供する。このソフトウェアモジュールは、標準的なインタフェースIModuleをインプリメントする。このモジュールオブジェクトをTPAPinModuleと呼ぶことにしよう。ベンダTPAは、そのモジュールにおいて、関連する所定のモジュールレベルインタフェース、この場合にはIChannelをインプリメントすることによって、ここではTesterPinとして表されている、ITesterPinインタフェースの標準的なシステムインプリメンテーションを利用することができる。これは、TesterPinがモジュールと通信するためにIChannelのような標準的な所定のモジュールレベルインタフェースを用いるという事実によって可能とされる。したがって、TPAPinModuleは、TesterPinオブジェクトを単に作り出してあらわにすることでピンを提供する。  ここで、IChannelインタフェースは自分達のハードウェアとともにはうまく動作しないと判断する、異なるベンダであるサードパーティB(TPB)を考える。したがって、TPBは、彼ら自身のIModuleインプリメンテーション(TPBPinModule)だけではなく、ITesterPinインタフェースのインプリメンテーションTPBTesterPinも提供することが必要となる。  このアプローチは、サードパーティディベロッパがどのようにして自分達のハードウェアを展開するかの選択およびソフトウェアのサポートにおいて、多大なフレキシビリティをサードパーティディベロッパに与える。彼らはIModuleインタフェースをインプリメントすることを求められながら、モジュールレベルインタフェースをインプリメントすることか、適合するとわかればTesterPinのようなオブジェクトをインプリメントすることかを選択し得る。  実際に、ベンダは、ITesterPinインタフェースにおいてはサポートされていない拡張を提供するためにTesterPinをインプリメントすることを選択してもよい。フレームワークはユーザに、特定のインタフェースを取り出すためのメカニズムあるいはオブジェクトへのインプリメンテーションポインタを提供する。これは、ユーザコードがITesterPinポインタを有している場合に、フレームワークはそれが必要であるときにいわゆるTPBTesterPinオブジェクトをポイントしているかどうかを判断することができるということを意味している。(この特徴は標準的なC++ランタイムタイプ識別(RTTI)を介して提供されてもよいことに留意されたい。)言い換えると、テストプランがITesterPinインタフェースを要求するときには、インタフェースは、TesterPinクラスのベンダのテスタピンのインプリメンテーションを直接呼び出し、これがモジュールに特有の情報(例えば、特定のDUT刺激を与えるように設定されるべきレジスタのアドレス)を内蔵している。  まとめると、フレームワークコードが常にITesterPinインタフェースを使用している間、ユーザは、必要なときにモジュールベンダによって提供される具体的な特徴および拡張を自由に使うことができる。言い換えると、モジュールベンダは、例えば、クラスの標準的なシステムインプリメンテーションに方法(機能)を付加することができる。ユーザに対するトレードオフは、具体的なベンダの拡張を活用することが他のベンダのモジュールに対するテストコードの有用性を低下させるということである。  モジュールのレベルでは、試験装置10は、名目上2つの動作モードを有している。動作のオンラインモードでは、バススイッチ140、同期モジュール150、同期接続モジュール160、試験モジュール170、ロードボード180、及びDUT100を含んで構成されるモジュールエレメント2260(例えばハードウェアエレメント)が用いられ、動作のオフラインモードでは、バススイッチエミュレート部240、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、試験モジュールエミュレート部270、スケジュール制御部275、DUT接続部280、及びDUTシミュレート部200を含んで構成されるソフトウェアにおけるモジュールエミュレーション2280が用いられる。  動作のオンラインモードについて、モジュールエレメント2260は、図1に示したバススイッチ140を含むHW(ハードウェア)バックプレーン2261と、シャーシスロットIF(インタフェース)2262と、同期モジュール150、同期接続モジュール160、及び試験モジュール170等を含むモジュールハードウェア2263と、ロードボードハードウェアIF2264と、ロードボード180に対応するハードウェアロードボード2265と、図10に示したDUT100に対応するDUT2266とを有している。  動作のオフラインモードについて、ソフトウェアでのモジュールエミュレーション2280は、図2に示したスケジュール制御部275を含むシミュレーションフレームワーク2281と、バススイッチエミュレート部240を含むバックプレーンエミュレーション2282と、バックプレーンシミュレーションIF2283と、同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270等を含むモジュールエミュレーション2284と、ロードボードシミュレーションIF2285と、DUT接続部280を含むロードボードシミュレーション2286と、DUTシミュレーションIF2287を有している。2つのモデルをDUTシミュレーションに関して示す。Verilogを用いるモデルは、Verilog  PLI(プログラミング言語インタフェース)2288とDUT  Verilogモデル2293とを有している。C/C++を用いるモデルは、C/C++言語サポート2289とDUT  C/C++モデル2291とを有している。シミュレーションは、PC等のいかなるコンピュータ上でも行うことができることに留意されたい。  オンラインモードでは、モジュールベンダは、デジタルテスタチャネル、DUT電源、あるいはDC測定ユニットといった、テストをサポートするための物理的なハードウェアコンポーネントを提供する。モジュールは、シャーシスロットIF2262を通じてHWバックプレーン2261にインタフェース接続される。  オフラインでの作業については、システムコントローラと等価なものを動かすPCベースあるいは他の環境が、付加的に、サイトコントローラレベルのフレームワークと、ソフトウェアのより低いレイヤのランタイム環境とを提供するとともにハードウェアをエミュレートするための全ての任務を引き受ける。  バックプレーンエミュレーション2282は、物理的なバックプレーン2261のためのソフトウェアによる代理を提供する。これは、バックプレーンシミュレーションインタフェース2283を通して(ベンダが供給する)モジュールエミュレーションソフトウェア2284と通信する。  モジュールエミュレーションソフトウェア2284は、好ましくはモジュールベンダによって提供され、典型的にはモジュール2263の特定のベンダインプリメンテーションと密接に結びついている。したがって、モジュールエミュレーションソフトウェアは、典型的には、異なるベンダによって供給されるモジュール間で詳細で異なっている。この場合、モジュールシミュレーションにより、ベンダは、ソフトウェアモデル(例えばモジュールエミュレーションソフトウェア2284)を通してハードウェアの機能をあらわにし、シミュレートされるロードボード2286に対して活性化信号を送り、DUTシミュレーションIF2287を介してDUTモデリングソフトウェア2291、2293に接続されている、シミュレートされるロードボード2286からのDUT応答信号を受け取って処理することが可能になる。モジュールの単純な機能シミュレーションを提供してモジュールファームウェアのエミュレーションを迂回することが有利であるとベンダが考える場合もある。モジュールエミュレーションソフトウェアは、シミュレートされたモジュール活性化信号に対するシミュレートされたDUTの応答を、既知の良好なDUT応答と比較する。この比較に基づいて、ソフトウェアは、そのモジュールによって実行されているテストが所望のとおりDUTをテストするという目標に適合しているかを判断し、ユーザがオンラインの実際のテスタ上のIC(実際のDUT)上でそれを用いるのに先立って、モジュールのデバッグを行うことを助ける。  ロードボードシミュレーションインタフェース2285は、モジュールエミュレーションレイヤおよびシミュレートされるロードボード2286への、およびこれらからの信号のためのルートとして機能する。ロードボードシミュレーションコンポーネント2286は、デバイスソケットマッピングと、DUTシミュレーションIF2287への、およびそれからの信号伝達とをサポートする。  DUTシミュレーションは、ネイティブコード(すなわちC/C++)シミュレーション2291、または対象のDUTモデル2293の機能モデルに対するVerilogプログラミング言語インタフェース(PLI)であってもよい。このモデルは、DUTシミュレーションインタフェース2287を通じて、シミュレートされるロードボードとインタフェース接続する。  これらのレイヤの全体の制御はシミュレーションフレームワーク2281によって提供されることに留意されたい。シミュレーションフレームワークは、既知の活性化信号に対するシミュレートされたDUT応答を測定する。システムエミュレーションの方法は、米国出願第10/403,817号に開示されている。通信および制御  通信および制御は、関連するソフトウェアオブジェクトの管理を通じて実現される。好ましくは、通信のメカニズムは、システムコントローラ上のオブジェクトモデルの後ろに隠れている。このオブジェクトモデルは、サイトコントローラ上に見られるクラスおよびオブジェクトに対してプロキシを提供し、それによって、アプリケーションの開発(例えばIC装置のテスト)のための便利なプログラミングモデルを提供する。これにより、アプリケーションの開発者(例えばATEシステムのユーザ)は、アプリケーションとサイト/システムコントローラとの間の通信の具体的な情報に関連する不要な詳細を避けることが可能である。  図11は、サイト制御装置130内のサイトコントローラソフトウェア2240に維持されているときのサイトコントローラオブジェクトの具体的な実施形態を示している。サイトコントローラオブジェクトは、CmdDispatcher2602、FunctionalTestMsgHandler2604およびFunctionalTest2606を有している。インタフェースは、IMsgHandler2608およびITest2610を有している。  好ましくはサイトコントローラ2240は、アプリケーションがアクセスのために必要とする機能クラスの全てを含んでいる。これらのクラスは、例えば、テスト、モジュール、ピン等を含む。ユーザのテストおよびソフトウェアツールは典型的には異なるコンピュータ上に存在するので、メッセージは、システムコントローラ上のツールからサイトコントローラ上のサーバに送られる。このサーバは、コマンド発送オブジェクトに関する方法を必要とする。  コマンド発送オブジェクト(CmdDispatcher)2602は、IMsgHandlerインタフェース2608をインプリメントするメッセージハンドラオブジェクトのマップを保持する。図11は、IMsgHandlerの具体的なインプリメンテーションFunctionalTestMsgHandler2604を示している。DmdDispatcherオブジェクト2602によって受信されたメッセージは通信すべきオブジェクトの識別子を含んでいる。この識別子は、内部のマップにおいて見られ、具体的なインプリメンテーション、この場合には図示されているFunctionalTestMsgHandlerオブジェクト2604に帰着する。  本例では、IMsgHandler2608は、単一の方法handleMessage()からなる。この方法は、好ましくは単一のインプリメンテーションクラスとしてインプリメントされる。図示されている場合においては、FunctionalTestMsgHandler2604は、入ってくるメッセージの正確な性質に応じて、6つの方法のうちの1つにメッセージを送る。入ってくるメッセージのヘッダは、メッセージハンドラがどのようにメッセージを解釈し、どこにメッセージを送るかを決定することを可能にするメッセージIDを含んでいる。  システム制御装置110における対応する通信環境は、システムコントローラソフトウェア2220のツール2225、2226セクションに関連する。図12は、システムコントローラソフトウェア2220においてシステム制御装置110上に保持されるツールオブジェクト(あるいはシステムコントローラオブジェクト)の一実施形態を、図11に示したサイトコントローラオブジェクトと対応するように示している。ツールオブジェクトは、オブジェクトCmdDispatcher2702、FunctionalTestMsgHandler2704およびFunctionalTestProxy2706を含んでいる。インタフェースは、IMsgHandler2708、ITestClient2710、およびIDispatch2712を含んでいる。またユーティリティアプリケーション2714も含まれる。  この例に関して、クラスCmdDispatcher2702、IMsgHandler2708、およびFunctionalTestMsgHandler2704は図11に示したものと同じである。しかしながら、FunctionalTest2606(あるいは他のいかなるサイトコントローラクラス)のインスタンス化は用いられない。代わりに、ツールオブジェクトは、サイト制御装置130上の各オブジェクトと通信するためのプロキシクラスを有している。したがって例えば、ツールオブジェクトはFunctionalTest2606に代えてクラスFunctionalTestProxy2706を含んでいる。同様に、ツールオブジェクトにおけるITestClient2710は、サイトコントローラオブジェクトにおけるITest2610と同じではない。一般的に、サイト制御装置130上で動作するアプリケーションは、サイト制御装置130上に設けられているものそのもののようなインタフェースを用いない。この場合、ITest2610の3つの方法(すなわち、preExec()、execute()およびpostExec())はITestClient2710における単一の方法(すなわちrunTest())に置き換えられる。またITestClient2710は、好ましくはデュアルインタフェース、すなわち、IDispatch712を受け継ぐものであり、マイクロソフトコンポーネントオブジェクトモデル(COM)としてインプリメントされる。それは、そのインタフェースをインプリメントするオブジェクトへのスクリプトエンジンのアクセスを可能にするようなインタフェースを提供する。これによって、システムをマイクロソフトウィンドウズプラットフォーム上で記述することが可能となる。  図11〜12に示す実施形態の動作の一例として、(例えば、ツールセクション2226、2228のうちの一つにおいて)システム制御装置110上で動作するアプリケーションは、テストプラン2242が一つ以上のFunctionalTestオブジェクト2606を有しているようなサイト制御装置130と通信してもよい。サイト制御装置130上でのテストプラン2242の初期化中に、対応するテストプランオブジェクトはサイト制御装置130上にロードされ、TestPlanMessageHandlerオブジェクトを構成し、それをCmdDispatcherオブジェクト2602とともに登録する。これがメッセージハンドラに独自のIDを割り当てる。同様な動作は、テストプラン2242を構成する他のTestPlanオブジェクトでも起こる。  システム制御装置110上の(例えばツール2226、2228における)アプリケーションは、通信ライブラリ2230を初期化し、通信チャネルを介してサイト制御装置130に接続し、TestPlanオブジェクトのためのIDを取得する。この初期化中に、プロキシオブジェクトは、それがテストをいくつ含んでいるかと、それらのタイプおよびIDとを決定する。それはタイプごとに(この場合には一つだけのタイプ)適切なDLLをロードし、それらに関するプロキシオブジェクトを構成し、それらをID値を用いて初期化する。  TestProxyオブジェクトも初期化する。これをするために、それらは、それらの名前を(それらのID値を用いて)取得するための適切なメッセージを構成してサイト制御装置130の通信サーバに送信する。通信サーバは、メッセージをCmdDispatcher2602に渡す。このオブジェクトは、その内部マップにおいて宛先IDを調べて、FunctionalTestMsgHandler2604のhandleMessage()方法にメッセージを送る。例えばもしメッセージがテスト名取得の要求であれば、これらのオブジェクトは、それぞれのテスト名を取得し、適切なネーム列でアプリケーションのTestProxyオブジェクトに応答する。  初期化が完了すると、アプリケーションは、TestPlanオブジェクトへのリモートアクセスと、それを通じて両方のTestオブジェクトへのリモートアクセスを有する。ユーザはここで、例えば、アプリケーション上の「テストプラン起動」のボタンを押す。その結果、アプリケーションはTestPlanProxyオブジェクト上のRunTestPlan()方法を呼び出す。この方法は、TestPlanオブジェクトの宛先IDでRunTestPlanメッセージを構成し、RPCプロキシ上でsendMessage()機能を呼び出す。この機能がサイトコントローラにメッセージを送信する。  サイト制御装置130上の通信サーバは、CmdDispatcherオブジェクト2602上のhandleMessage()方法を呼び出し、TestPlanオブジェクトのIDをそれに渡す。CmdDispatcherオブジェクト2602はその内部マップでこのIDを調べて、TestPlanオブジェクト用のメッセージハンドラを見つけて、このオブジェクト上のhandleMessage()方法を呼び出し、これがTestPlanオブジェクト上のRunTestPlan()方法を呼び出す。同じようなやり方で、アプリケーションは名前とTestオブジェクトの最近の動作状況とを取得することができる。通信ライブラリを用いる方法  通信ライブラリ2230を用いる例を以下に述べる。  通信ライブラリ2230は好ましくは静的なライブラリである。アプリケーションは、CommLibrary.hファイルを通してこの通信ライブラリを使用することができる。通信ライブラリクラスをエクスポートする必要があるアプリケーションは、上記インクルードファイルを含むことに加えて、定義されたプリプロセッサ定義COMMLIBRARY＿EXPORTS、COMMLIBRARY＿FORCE＿LINKAGEを有していなければならない。通信ライブラリをインポートするアプリケーションは、プリプロセッサ定義を何も定義する必要はない。通信ライブラリがサーバとして用いられるときには、アプリケーションは、CcmdDispatcherの次の静的な関数を呼び出さなければならない:InitializeServer(unsigned  long  portNo)。  このportNoは、サーバが要求を待たなければならないポート番号である。サーバに対応するコマンドディスパッチャは、静的な関数getServerCmdDispatcherをCcmdDispatcherクラス上に呼び出すことによって読み出される。  通信ライブラリがクライアントとして用いられるときには、アプリケーションはCcmdDispatcherの静的な関数「InitializeClient(const  OFCString  serverAddress,unsigned  long  serverPortNo,CcmdDispatcher  **pCmdDispatcher,OFCString  serverId)」を呼び出さなければならない。  このserverAddressおよびServerPortNoは、クライアントが接続しなければならないものである。この関数は、クライアント用のコマンドディスパッチャポインタおよびそれが接続するサーバIDを初期化する。また、後の時点で、クライアントは、静的な関数getClientCmdDispatcherを呼び出すことによってサーバIDに対応するコマンドディスパッチャを取り出すことができる。  通信ライブラリがコンパイルされるときには、ファイルClientInterface.idlおよびServerInterface.idl上ではビルドは排除される。好ましい実施形態は、これらのインタフェース定義ファイルに関して既に生成されたスタブおよびプロキシファイルを適用して、プロキシおよびスタブインプリメンテーションファイルを同じライブラリにリンクする。したがって、サーバおよびクライアントは、同じアドレス空間内にインスタンス化される。インタフェース定義ファイルおよびスタブファイルにおける以下の変更は、好ましくは、通信ライブラリをサーバおよびクライアントとして同じアドレス空間内で動作させるために行われる。インタフェース定義ファイルにおける変更  以下のネームスペースの宣言は、好ましくは、インタフェース定義ファイルのそれぞれにおいて付加される。これは、プロキシインプリメンテーション機能とインタフェース機能の我々自身のインプリメンテーションとの名前の衝突を避けるためである。以下のネームスペースの宣言は、serverInterface.idlにおいて付加される。  スタブインプリメンテーションファイルにおける関数は、インタフェースにおいて宣言された機能のための我々自身のインプリメンテーション関数を呼び出すように変更される。すなわち、我々は、インタフェースにおいて宣言された機能のそれぞれに対応する異なる名前の関数をもつことになる。  関数呼び出しにおける競合を避けるために、インプリメンテーション関数の名前を「COMM＿」列で始まる名前とすることが好ましい。そうすればスタブ関数におけるコードは、「functionName」に代えて「COMM＿functionName」を呼び出すように変更される。  この方法が動作するためには、存在する全ての機能クラスは、対応するメッセージハンドラオブジェクトおよびプロキシクラスも有していなければならない。全てのメッセージハンドラオブジェクトは、通信ライブラリによって提供されるIMsgHandlerクラスから得られなげればならない。IMsgHandlerクラスは抽象的なクラスである。メッセージハンドラのインプリメンタの任務は、handleMessage、setObject、handleErrorの定義を提供することが好ましい。全てのメッセージタイプは、1から始まらなければならない(ゼロはhandleErrorのためにとっておく)。機能クラスは好ましくは、そのメンバが可変であるように対応するメッセージハンドラを有する。機能クラスのコンストラクタにおいて、機能クラスは、そのメッセージハンドラによって提供される関数を呼び出すことによって、メッセージハンドラとともに自身を登録させる。次にメッセージハンドラオブジェクトは、addMsgHandler関数をコマンドディスパッチャ上にパラメータとしてのメッセージハンドラとともに呼び出すことによって、コマンドディスパッチャとともに登録されなければならない。addMsgHandler関数は、メッセージハンドラおよび機能クラスにIDを割り当てる。機能クラスのデストラクタは、パラメータとしての機能クラス識別子を送ることによって、コマンドディスパッチャ上にremoveMsgHandler関数を呼び出さなければならない。またプロキシクラスも、機能クラスに関して説明されたように、同じ登録手順に従わなければならない。システム構成とテスト  図13は、本発明の一実施形態による名目上のテストシーケンス2800を示している。テストシーケンス2800は、テスト環境2804におけるモジュールのインストール2815を含んでおり、これはテスト準備2806とシステムテスト2808とを包含している。初めに新しいモジュール(ハードウェアまたはソフトウェアまたはこれらの組み合わせ)2810が(ベンダの品質管理に基づいているかもしれないいくつかの外部手順によって)認証2812される。インストール2815はまず、オフラインシミュレーション2809のためのハードウェアモジュールエミュレーションの設定、テストプログラム開発2814のためのモジュールリソースファイルおよびインタフェースの設定、ならびにパターンコンパイル2816のためのモジュール特有のパターンコンパイラの設定を含むテスト準備2806を必要とする。次にシステムテスト2808が、較正2817、診断2818および構成2820からの入力を用いて実行される。そして新しいモジュールに対して、(1)インタフェース制御、(2)同期、順序付けおよび再現性、(3)エラー/アラーム対応、(4)マルチサイト制御、ならびに(5)マルチインストゥルメントモジュール制御を含むシステムテスト2808が行われる。(補足説明B)DUT100のシステムソフトウェアのフレームワークの仕様例B.1  概要  本仕様は、試験エミュレート装置190、又は、システム制御装置110及びサイト制御装置130の分散システムによるエミュレート環境(オフライン環境)を中心として、DUT100のシステムソフトウェアのユーザ及び開発者向けのフレームワークを示す。B.2  ユーザの仕様  本章は、試験装置10のシステムソフトウェアの、ユーザ向けのフレームワークを示す。B.2.1  SimTester  「SimTester(シミュレーションされた試験装置)」は、コンピュータ20を図2に示した試験エミュレート装置190として機能させるアプリケーションプログラムである。SimTesterは、各モジュール及びDUTのDLLをロードして、システムソフトウェアからのコマンドに応答して試験装置をエミュレートする。ここで、システムソフトウェアは、シミュレートするパターンをロードし実行するランタイムソフトウェアである。  SimTesterは、起動されると、シミュレーションコンフィギュレーションファイルを読み出す。この結果、試験エミュレート装置190を同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び/又は試験モジュールエミュレート部270として機能させる全てのモジュールエミュレーションDLLがロードされる。DLLがロードされると、SimTesterは、システム制御装置110からの接続を待つ。システム制御装置110は、テストプランをロードするとSimTesterに接続する。テストプランは、オフラインコンフィギュレーションファイルを含む。システム制御装置110がテストプランのデータを実際にロードする前に、オフラインコンフィギュレーションファイルをSimTesterに渡し、初期化を完了できるようにする。オフラインコンフィギュレーションファイルのロードに成功すれば、SimTesterはDUTモデルをロードし、DUT接続部280及びDUTシミュレート部200として試験モジュールエミュレート部270等のモジュールエミュレータに接続させる。この時点で、シミュレーションは、パターンの読み出し及び実行の準備ができたこととなる。  テストプランがアンロードされると、SimTesterはDUTモデルをアンロードするシグナルを受け、新たなオフラインコンフィギュレーションファイルの受付を待つ。B.2.2  コンフィギュレーションファイル  SimTesterは、2つのコンフィギュレーションファイルを使用する。第1のファイルは、シミュレーションコンフィギュレーションファイルである。本ファイルは、シミュレーション中にどのようなモジュールが使用可能となるかを特定する。第2のファイルは、オフラインコンフィギュレーションファイルである。このファイルは、どのDUTモデルがロードされ、どのように試験装置に接続されるかを特定する。B.2.2.1  シミュレーションコンフィギュレーションファイル  図14から15は、シミュレーションコンフィギュレーションファイルの一例である。シミュレーションコンフィギュレーションファイルは、階層的にブロック化されている。  グローバルセクション5010は、全体的な設定を行う。InitialVoltageパラメータは、シミュレーションスタート時における全ての配線の電圧の初期値を設定する。この値は、ドライブされていない配線の電圧レベルの指定にも用いられる。  RecoveryRateパラメータは、オプションのパラメータであり、2つのアナログ信号が対向してドライブされた場合に用いられる。より具体的には、当該パラメータは、2つのアナログ信号により配線がドライブされた場合に、一定の電圧レベルとなるまでに要する時間を決定するために用いられる、時間当たりの電圧変化量を示す。  モジュールエミュレーションセクション5020は、モジュールDLLを指定し、当該モジュールDLLの設定を行う。  Waveformセクションは、各モジュールにおいて使用される波形モデルを宣言する。波形モデルは、DUTの端子に接続されるチャネル毎に、Step(ステップ波形)、Slew(スリュー波形)、及びAnalog(アナログ波形)等を指定する。  Portセクションは、試験エミュレート装置190を同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び/又は試験モジュールエミュレート部270等として機能させるモジュールエミュレータのインスタンスを宣言する。  LogicalPortパラメータは、実機におけるあるチャネルの不良等により、当該チャネルに挿入されていたモジュールを他のチャネルに差替えた場合に、モジュールエミュレータ上で当該差替えを記述するために設けられる。  モジュールエミュレーションセクション5020にけるParamsセクションは、モジュールDLLに渡すべきパラメータを記述する。B.2.2.2  オフラインコンフィギュレーションファイル  図16から17は、オフラインコンフィギュレーションファイルの一例である。  グローバルセクション5110は、全体的な設定を行う。RegSelectパラメータは、パターンのトレース時にトレースすべきレジスタを選択するファイルを指定する。  DUTモデルセクション5120は、DUTモデルとなるDLLファイルの指定や、各種の設定を行う。  Waveformパラメータは、各DUTの端子ごとに、波形モデルを設定する。DUTブロックは、主にParamsブロックと、PinConnectionsブロックとを含む。  Paramsブロックは、モジュールDLLに渡すべきパラメータを記述する。  PinConnectionsブロックは、試験装置のリソースとDUTの端子との接続を指定する。すなわち例えば、「L3.11  10  1.0ns」は、論理ポート3の11番目のリソースはDUTの端子10に接続され、配線遅延が1.0nsであることを示す。ここで、論離ポートとは、例えばモジュールが実装されるポートであり、リソースとは、当該モジュール内に設けられたチャネル対応論理等である。B.3  開発者向けの仕様  試験装置のモジュールやDUTモデルは、図5に示したモジュールエミュレートプログラムのフレームワークを用いて、例えばC++言語のクラス関数から派生することにより作成される。この派生に伴い、基本クラス中の幾つかの仮想関数を実装する必要がある。また、このフレームワークは、試験装置のモジュールとDUTモデルの間のI/Oの実現を容易化する関数を含む。そして、このフレームワークに従うことにより、得られたDLLを試験エミュレート装置190上で他のコンポーネントに接続してエミュレーションを行うことができる。B.3.1  オフラインフレームワーククラスの構造  図18は、図5に示したクラス階層構造をより詳細に記述したクラス階層構造5200である。ThirdPartyModuleクラスやThirdPartyDUTクラス内の各メソッドは仮想メソッドであり、本モデルの振る舞いを定義するために実メソッドの実装を要する。SimComponent基本クラス内のcreateDomain、registerDomain、releaseDomain、getDomain、registerEvent、及びraiseEventメソッドは、試験エミュレート装置190をスケジュール制御部275等として機能させる、DUT100のソフトウェアシミュレーションエンジンをアクセスするサービスを提供する。  図19は、当該フレームワークにおいてインターフェイスとして用いられるチャネルオブジェクトの使用ダイアグラムを示す。試験装置のモジュール及びDUTモデルは、SimChannelオブジェクトの配列を含む。SimChannelオブジェクトの各インスタンスは、当該モデルのI/Oチャネルに対応する。I/Oチャネルは、SimChanIDオブジェクトを用いて識別される。SimChannelクラスは、モジュールやDUTモデルが、出力チャネルに出力すべき電圧のタイミングを書き込み、入力チャネルから特定のタイミングで電圧を読み出すために用いられる。入力チャネルからある時間ウィンドウの間に入力された信号のエッジをスキャンする場合、SimChannel::getWaveformIterメソッドを呼び出して、SimWavefromIterのインスタンスを得ることができる。そして、SimWaveformIterオブジェクトは、呼び出し側のルーチンに、有限の時間ウィンドウの全てのエッジについて繰返し処理を行うことを可能とさせる。  図20は、当該フレームワークにおいてインターフェイスとして用いられるイベントオブジェクトの使用ダイアグラムを示す。イベントは、当該フレームワークとサードパーティモデルとの間における通信に用いられる。イベントは、SimEventクラスによりカプセル化されている。SimEventのインスタンスは、SimEventMgrクラスにより生成される。一般的には、1つのモデルはSimEventMgrの1つのインスタンスを持つ。しかし、もし1つのモデルが他のモジュールに特別なイベントを送信する場合、複数のSimEventMgrインスタンスが必要となる。B.3.2  試験装置のモジュールの実装  本節では、単純なデジタルドライバモジュール及びデジタルストローブモジュールを例として、モジュールの実装方法を示す。  図21は、試験装置のモジュールの一例として、単純なデジタルモジュールの基本クラスを示す。デジタルドライバモジュール及びデジタルストローブモジュールのクラスは、基本クラスの派生クラスとして生成する。  開発者は、当該基本クラスに基づいて、基本クラスのコンストラクタ、チャネルオブジェクトを返すgetChannelメソッド、モジュールのメモリアドレス空間を設定するsetBaseAddressメソッド、バススイッチ140のスロット番号を設定するsetBusNumberメソッド、割込みの禁止/許可を設定するlockInterrupt/unlockInterruptメソッド、及び、モジュールのメモリアドレス空間をアクセスするread/writeメソッド等を実装する。B.3.2.1  ローカルイベント  オフラインのシミュレーションは、イベントドリブンで行われる。すなわち、各モジュールはイベントを登録する。そして、イベントが発生するとイベントを登録したモジュールのhandleEventメソッドが呼び出される。  イベントは、SimEventクラスによって定義され、同期イベント及び非同期イベントに分類される。非同期イベントは、更にシステムイベント及びローカル非同期イベントに分類される。システムイベントは、例えばシステム割込み、及びパターン生成の終了等である。B.3.2.1.1  ローカル非同期イベント  ローカル非同期イベントは、モジュール間の通信に用いられる。このイベントには、時間は関連付けられない。非同期イベントの受信を要求する場合、モジュールは、オーバーロードされた、時間の引数を持たないregisterEventメソッドによりイベントを登録する。非同期イベントを発生する場合、モジュールは、raiseEventメソッドを呼び出す。非同期イベントを受信するモジュールは、オーバーロードされた、時間の引数を持たないhandleEventメソッド内においてイベント処理を行う。B.3.2.1.2  ローカル同期イベント  ローカル同期イベント(同期イベント)は、モジュールがリードイベント又はライトイベント、すなわち信号のストローブ又はドライブをスケジュールするために用いられる。同期イベントは、モジュールが特定のタイミングで通知を受けるために用いられ、モジュール間の通信には用いられない。B.3.3  単純なデジタルドライバモジュール  図22は、単純なデジタルドライバモジュールのクラス宣言を示す。開発者は、当該クラスのコンストラクタ、ベンダ/モジュールの情報を返すgetModuleIDsメソッド、及び、ドライバモジュールを初期化するinitEventsメソッド等を実装する。  図23は、デジタルドライバモジュールのhandleEventメソッドの一例である。デジタルドライバモジュールは、現在のサイクルにおいて、全てのチャネルにエッジを書き込む。この書き込みは、SimChannelオブジェクトの配列であるm＿channelsの各要素におけるsetメソッドにより行われる。SimChannelオブジェクトは、setメソッドの他、offメソッド及びendメソッドを有する。offメソッドは、信号のドライブを中止する。endメソッドは、当該チャネルが所定の期間、すなわち例えばサイクル期間の信号の生成を終えたことをフレームワークに通知する。この通知を受けると、チャネルの反対側のコンポーネント、すなわち例えばDUT接続部280に対してチャネルの読み出しを指示するシグナルが通知される。この結果、生成した信号が当該コンポーネントによって読み出される。一般的には、使用者は、複数のsetメソッドにより所定の期間の電圧を特定した後、当該期間の最後にendメソッドを1回呼び出すことで、当該期間の信号を生成し伝搬させることができる。なお、setメソッド及びendメソッドの関係については、B.3.5において詳細に示す。B.3.4  単純なデジタルストローブモジュール  図24は、単純なデジタルストローブモジュールのクラス宣言を示す。開発者は、デジタルドライバモジュールと同様にして、コンストラクタ、getModuleIDメソッド、initEventsメソッド等を実装する。ここで、デジタルストローブモジュールにおいては、DUTの出力値及び期待値の比較結果をフェイルメモリに格納するため、read及びwriteメソッドを変更する。  図25は、デジタルストローブモジュールのhandleEventメソッドの一例である。デジタルストローブモジュールは、SimChannelのreadメソッドを用いて、特定のタイミングにおける当該チャネルの電圧を読み出す。そして、サイクル期間の処理を終えた後、SimEventMgrオブジェクトに次のサイクルの終了タイミングを通知しイベントの発生を要求すると共に、registerEventメソッドにより当該イベントを登録する。B.3.5  DUTモデルの実装  DUTモデルは、イベントドリブンでない点を除き、試験装置のモジュールと同様の手順により作成できる。したがって、DUTモデルの基本クラスSimComponentSteppedは、initEventsメソッド、handleEventメソッド、及びバスI/Oメソッドを実装可能とする。パターン実行の間におけるDUTモデルの振る舞いを定義するために、関数runを実装する必要がある。  図26は、試験装置によりドライブされた8本の配線が、試験装置に再度入力されるDUTモデルのクラス定義を示す。開発者は、当該クラスに基づいて、コンストラクタ、getChannelメソッド、及びrunメソッド等を実装する。  図27は、本DUTモデルのrunメソッドの一例を示す。runメソッドは、開始時刻及び終了時刻の2つの引数を有する。これらの引数により、DUTモデルは、入力端子からの入力に基づいて内部状態を開始時刻から終了時刻まで進め、DUTの内部状態の変化の結果に基づいてデータを出力する。入力は、SimChannelオブジェクトを通して行われ、出力は、SimChannelオブジェクトに対して送られる。ここで、出力は、終了時刻の後にまとめて行われる。  runメソッドは、入力端子をスキャンし、DUTの内部状態を更新し、DUTの出力チャネルにデータを出力するステップを含む。ここで、実行の時間ウィンドウの外に出力信号のfallエッジが存在する場合においても、fallエッジを出力チャネルにsetメソッドにより書き込む必要がある。そして、endメソッドが呼び出される際には、出力信号はfallした状態でなければならない。これにより、出力信号の値が変化しないため、当該チャネルの反対側のコンポーネントは、終了時刻までのチャネルの電圧値を正しく読み出すことができる。これを保証するために、フレームワークは、最後のendメソッドの呼び出し後に、当該endメソッドより先の時刻についてのチャネルへの書き込みを禁止する。B.3.6  オフラインのDLLインターフェイス  次に、当該フレームワークに基づくモジュール及びDUTモデルのDLLをビルドし、これらのモデルのインスタンスを生成する関数、及び、処理の終了後にクリーンアップする関数をエクスポートする。これにより、試験装置のモジュールをエミュレートするDLL及びDUTをエミュレートするDLLを生成することができる。(補足説明C)システムバスアクセスライブラリの仕様例C.1  概要  図28は、実環境6000及びエミュレート環境6050におけるシステムバスアクセスライブラリ6014の位置付けを示します。DUT100の実環境6000及び試験エミュレート装置190によるエミュレート環境6050において共通して用いられます。  図28(a)は、実環境6000(オンライン環境)におけるシステムバスアクセスライブラリ6014の位置付けを示します。ソフトウェア6010は、図1に示したサイト制御装置130上で動作するソフトウェアです。ソフトウェア6010は、試験装置10の試験を制御するプログラムからHLC(High  Level  Command)を受け取って解釈してハードウェア6030へのアクセスコマンドを生成するHLC処理部6012と、アクセスコマンドに基づいて通信処理を行う通信ライブラリ及び通信ライブラリの指示に基づきシステムバス(本例においてはPCIバス)をアクセスするバスアクセスライブラリを含むシステムバスアクセスライブラリ6014と、システムバスアクセスライブラリ6014の指示に基づいてシステムバスを制御するPCIバスドライバ6016とを含みます。  ハードウェア6030は、図1に示したサイト制御装置130が有するバスIF6032と、バススイッチ140と、同期モジュール150、同期接続モジュール160及び/又は試験モジュール170等とを含みます。サイト制御装置130のバススロットに接続されたバスIF6032は、PCIバスドライバ6016により発行されたアクセスを、バススイッチ140を介して同期モジュール150及び/又は試験モジュール170等のモジュールへ送信し、当該アクセスの処理を行わせます。  図28(b)は、エミュレート環境6050(オフライン環境)におけるシステムバスアクセスライブラリ6014の位置付けを示します。オフラインプロセス6060は、図1に示したサイト制御装置130又は試験エミュレート装置190上で動作するソフトウェアであり、試験エミュレート装置190をサイト制御エミュレート部230として機能させます。オフラインプロセス6060は、ソフトウェア6010においてハードウェア6030を制御する代わりに試験装置エミュレートプロセス6080を制御するように変更されたプロセスです。オフラインプロセス6060は、ソフトウェア6010と略同様のHLC処理部6012及びシステムバスアクセスライブラリ6014を用いて、ソフトウェア6010の使用者に対してソフトウェア6010と共通のユーザレベルインターフェイスを提供します。  試験装置エミュレートプロセス6080は、試験装置10をエミュレートするプロセスであり、バススイッチ140をエミュレートするシステムバスエミュレータ6084と、同期モジュール150、同期接続モジュール160、及び/又は試験モジュール170をエミュレートするモジュールエミュレータ6086とを含みます。システムバスエミュレータ6084は、試験エミュレート装置190をバススイッチエミュレート部240として機能させます。モジュールエミュレータ6086は、試験エミュレート装置190を同期モジュールエミュレート部250、同期接続モジュールエミュレート部260及び/又は試験モジュールエミュレート部270として機能させます。以下、明記しない限り、「モジュール」は、オンライン環境における同期モジュール150、同期接続モジュール160、及び試験モジュール170と、オフライン環境における同期モジュールエミュレート部250、同期接続モジュールエミュレート部260、及び試験モジュールエミュレート部270との総称として用います。C.2  モジュール制御汎用関数  本章では、サイト制御装置130上で動作し同期モジュール150、同期接続モジュール160、及び/又は試験モジュール170を制御するモジュールドライバで利用できる汎用的な機能を説明します。モジュールドライバ内では、当ライブラリを用いて各種モジュール内のレジスタやメモリをアクセスし、デバイス測定に必要なデータをリード/ライトします。本章で説明する主な機能は下記のとおりです。1.プログラムIOを用いたバスアクセス2.DMA機能を用いたバスアクセス3.インターラプトハンドリング4.ライブラリ/システムバスの制御C.2.1  プログラムIOを用いたバスアクセス  システムバスのアクセスは、バス上に接続された各モジュールのレジスタへMW(Machine  Word)を直接に書き込む方式と、各モジュールへHLC(High  Level  Command)を転送する方式の2種類があります。何れの場合も、AddressとDataがシステムバス上を流れます。各モジュール側でAddressによりHLCと認識された場合、各モジュール側でそのHLCに対応した処理を実行します。サイトCPU(サイト制御装置130)から各モジュールへのデータ書き込みは、サイトCPUに接続されている各モジュールへ同じデータが一斉に送出され、各モジュール側で該当するデータを取り込みます。  システムバスや各モジュール内にはFIFOが配置されており、サイトCPUから各モジュールへデータを転送した場合、各モジュールのライト動作の終了を待たないでCPUのライト動作を終了します(posted  write)。データが実際にレジスタに格納されるまでの時間は、CPUからターゲットのレジスタの間に存在するFIFOの空き状態によって影響を受けます。全てのモジュールに対してデータが確実に届いたことを保証する場合は、FIFOのフラッシュ待ち機能を利用してください。各モジュール内のレジスタのリードを用いてFIFOをフラッシュする場合は、リード対象のモジュールのFIFOのみフラッシュされたことが保証できます。  オフラインのシステムバスエミュレータ6084にはFIFOはありません。そのためFIFOを持たないモジュールエミュレータ6086に対してPIOのライトを実行した場合、モジュールエミュレータ6086のレジスタにデータを格納したあと関数から戻ります。  また、オンライン同様にFIFOを持ったモジュールエミュレータ6086にデータを書き込むと、モジュールエミュレータ6086のFIFOにデータを格納した後、直ちにライト処理を終了します。C.2.1.1  プログラムIOを用いたライト  モジュールのレジスタに対してデータを書き込みます。サイトCPUは、書き込んだデータがモジュールに到達する前にライト動作を終了します(posted  write)。・名前:BCL＿GBI＿write・形式:int  BCL＿GBI＿write(unsigned  int  address,unsigned  int  data);・引数:address(マシンワードのアドレス)、data(書き込むデータ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.1.2  プログラムIOを用いたリード  モジュールのレジスタのデータを読み出します。サイトCPUは、データが読み出されるまで待ちます。また、CPUからターゲットのレジスタの間に存在するFIFO内のデータがフラッシュされるまで対象レジスタのリードは待たされます。・名前:BCL＿GBI＿read・形式:int  BCL＿GBI＿read(unsigned  int  address,unsigned  int  *data);・引数:address(マシンワードのアドレス)、data(データを読み込む変数へのポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.1.3  プログラムIOを用いたブロックライト  モジュールレジスタに対してまとまったデータを書き込みます。データのフォーマットはアドレスとデータをペアで指定します。システムバスはライトサイクルを指定された回数分実行します。  複数の任意アドレスに対してデータを書き込む場合は、毎回BCL＿GBI＿write()関数で書き込むよりも高速に実行することが可能です。これは、関数呼び出しが1回で済む点や複数回の排他処理が行われないためです。・名前:BCL＿GBI＿writeBlock・形式:int  BCL＿GBI＿writeBlock(unsigned  int  *address,unsigned  int  *data,unsigned  int  number);・引数:address(アドレスが格納されている配列へのポインタ)、data(データが格納されている配列へのポインタ)、number(書き込むデータの数)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.1.4  プログラムIOを用いたブロックリード  モジュールのレジスタのデータをまとまった単位で読み出します。レジスタのアドレスは不連続な値で指定が可能です。システムバスはリードサイクルを指定された回数分実行します。  複数の任意アドレスからデータを読み込む場合は、毎回BCL＿GBI＿read()関数で読み込むよりも高速に実行することが可能です。これは、関数呼び出しが1回で済む点や複数回の排他処理が行われないためです。・名前:BCL＿GBI＿readBlock・形式:int  BCL＿GBI＿readBlock(unsigned  int  *address,unsigned  int  *data,unsigned  int  number);・引数:address(アドレスが格納されている配列へのポインタ)、data(データを読み込む配列へのポインタ)、number(読み込むデータの数)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.1.5  プログラムIOを用いた連続ブロックライト  モジュールの等間隔アドレスに配置されたレジスタに対してデータ列を書き込みます。指定された開始アドレスからデータ列を書き込み、データを書き込む毎にアドレスへオフセット値が加算されます。オフセット値は0から0x3ffffffまで指定することが可能です。システムバスはライトサイクルを指定された回数分実行します。  複数の固定オフセットアドレスに対してデータを書き込む場合は、BCL＿GBI＿writeBlock()関数で書き込むよりも高速に実行することが可能です。これは、アドレスの加算がハードウェアで行われることにより、PCIバス上を流れるパケット数が少なくなるためです。・名前:BCL＿GBI＿writeSeq・形式:int  BCL＿GBI＿writeSeq(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset);・引数:address(マシンワードのアドレス)、data(データが格納されている配列へのポインタ)、number(書き込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.1.6  プログラムIOを用いた連続ブロックリード  モジュールの等間隔アドレスに配置されたレジスタからデータ列を読み込みます。指定された開始アドレスからデータ列を読み出し、データを読み出す毎にアドレスへオフセット値が加算されます。オフセット値は0から0x3ffffffまで指定することが可能です。システムバスはリードサイクルを指定された回数分実行します。  複数の固定オフセットアドレスからデータを読み込む場合は、BCL＿GBI＿readBlock()関数で読み込むよりも高速に実行することが可能です。これは、アドレスの加算がハードウェアで行われることにより、PCIバス上を流れるパケット数が少なくなるためです。・名前:BCI＿GBI＿readSeq・形式:int  BCL＿GBI＿readSeq(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset);・引数:address(マシンワードのアドレス)、data(データを読み込むための配列へのポインタ)、number(読み込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.2  DMA機能を用いたバスアクセス  DMAを用いたデータ転送には、以下の同期/非同期のライト/リードの4種類の関数を準備しています。また、それぞれについて、バーストDMA/シングルDMAを選択できます。(1)同期/非同期DMA  同期DMAの場合、関数はDMAの終了を待って関数を終了します。DMAの終了を待って関数は終了しますが、転送データはシステムバスIFやモジュール内のFIFOに残っている場合があります。  非同期DMAの場合、関数はDMAの終了を待たずに関数を終了します。このため、データ領域のライフサイクルをDMAが終了するまで利用者側で保証する必要があります。また、非同期DMAの転送が終了しないあいだに、さらにDMAを利用する関数が実行された場合、前のDMA転送が終了するまで関数は待たされます。非同期DMA処理の完了を待つための識別情報として、転送IDが用意されています。この転送IDは、32ビットの符号なしデータで、32ビットを越える回数のDMA転送があった場合は、0に戻り再利用されます。(2)バースト/シングルDMA  バーストDMA転送は、システムバス上をバースト専用のパケットでデータを転送します。この転送は、1個のアドレスとN個(最大64個)のデータを1組のパケットとして、指定されたデータが終了するまでパケットを繰り返し転送します。このため高速転送が可能です。  また、DMA転送時に各種モジュール側のアドレスの増加値を指定することができます。この増加値は、2組目以降のパケット転送時に、パケットの先頭アドレスの算出に利用します。すなわち、「(パケットのアドレス)=((指定した増加値)*(前回のパケット中のデータの個数))+(前回のパケットの先頭アドレス)」となります。  また、バースト転送が可能なレジスタは、モジュールに依存しているため、利用可能なレジスタかどうかの確認が必要です。  シングルDMA転送は、システムバス上をプログラムIOと同様にアドレスとデータがセットで転送されます。このため、転送速度はバーストDMAより低いですが、どのレジスタに対しても転送が可能です。DMA転送時、システムバス側のアドレスの増加値を指定することができます。この増加値は、アドレスを発生するごとにアドレスに増加値が加算されます。  オフラインの場合、バースト転送を指定しても内部的にはシングル転送として扱う仕様もとり得ます。この場合、バースト転送をサポートしてないレジスタへの転送も可能です。しかし、オンラインでの利用を考慮すると、ハードウェアでバースト転送をサポートしてないレジスタに対しての利用は避けてください。また、オフラインの同期/非同期DMAはオンラインと同様です。C.2.2.1  DMA機能を用いた同期ライト  サイトCPUのメモリ上に配置したデータをDMAを用いて各モジュールへ転送します。この関数は、同期ライトでバースト/シングルの指定が可能です。・名前:BCL＿GBI＿writeSyncDMA・形式:int  BCL＿GBI＿writeSyncDMA(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset,unsigned  int  mode);・引数:address(マシンワードのアドレス)、data(データが格納されている配列へのポインタ)、number(書き込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)、mode(Burst/Singleの動作モード)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.2.2  DMA機能を用いた同期リード  モジュール内のレジスタからDMAを用いてデータをサイトCPUのメモリ上へ読み出します。この関数は、同期リードでバースト/シングルの指定が可能です。・名前:BCL＿GBI＿readSyncDMA・形式:int  BCL＿GBI＿readSyncDMA(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset,unsigned  int  mode);・引数:address(マシンワードのアドレス)、data(データを読み込むための配列へのポインタ)、number(読み込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)、mode(Burst/Singleの動作モード)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.2.3  DMA機能を用いた非同期ライト  サイトCPUのメモリ上に配置したデータをDMAを用いて各種モジュールへ転送します。この関数は、非同期ライトでバースト/シングルの指定が可能です。・名前:BCL＿GBI＿writeAsyncDMA・形式:int  BCL＿GBI＿writeAsyncDMA(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset,unsigned  int  mode,int  *transferID);・引数:address(マシンワードのアドレス)、data(データが格納されている配列へのポインタ)、number(書き込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)、mode(Burst/Singleの動作モード)、transferID(転送終了待ちIDのポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.2.4  DMA機能を用いた非同期リード  モジュール内のレジスタからDMAを用いてデータをサイトCPUのメモリ上へ読み出します。この関数は、非同期リードでバースト/シングルの指定が可能です。・名前:BCL＿GBI＿readAsyncDMA・形式:int  BCL＿GBI＿readAsyncDMA(unsigned  int  address,unsigned  int  *data,unsigned  int  number,unsigned  int  offset,unsigned  int  mode);・引数:address(マシンワードのアドレス)、data(データを読み込むための配列へのポインタ)、number(読み込むデータの数)、offset(データ転送毎にアドレスに加算されるオフセット値)、mode(Burst/Singleの動作モード)、transferID(転送終了待ちIDのポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.2.5  非同期DMA転送の終了待ち  DMAを用いた非同期転送の転送終了を待ちます。この関数は、DMAが終了した場合あるいは指定した時間が経過した場合、関数を終了します。時間の指定範囲は、分解能が1msの32ビット符号付きタイマを使用するため、0〜(INT＿MAX/1000)となります。この範囲外の指定を行った場合は、BCL＿GBI＿INFINITEを指定したのと同じ扱いになります。  また、transferIDを誤った値で指定した場合は、すぐにBCL＿GBI＿OKを返し、この関数を終了します。・名前:BCL＿GBI＿waitDMA・形式:int  BCL＿GBI＿waitDMA(unsigined  int  transferID,double  timeOut);・引数:transferID(非同期モード転送時に返された転送終了待ちID)、timeOut(待ち時間。BCL＿GBI＿INFINITE:DMAが終了するまで待つ)・戻り値:BCL＿GBI＿OK(DMAが正常終了)、BCL＿GBI＿ERROR(DMAがエラー)、BCL＿GBI＿TIMEOUT(タイムアウト)C.2.2.6  非同期DMA転送の状態  非同期DMA転送の現在の状態を通知します。誤ったtransferIDを指定した場合、DMAの終了と同じ状態を通知します。・名前:BCL＿GBI＿getConditionDMA・形式:int  BCL＿GBI＿getConditionDMA(unsigned  int  transferID);・引数:transferID(非同期モード転送時に返された転送終了待ちID)・戻り値:BCL＿GBI＿OK(DMAが正常終了)、BCL＿GBI＿ERROR(DMAがエラー)、BCL＿GBI＿BUSY(DMA実行中)C.2.3  インターラプトハンドリング  システムバスアクセスライブラリでは、インターラプトの基本的な操作を行うための機能を提供します。システムバスアクセスライブラリを利用して操作できるインターラプトには次の4種類があります。1.Busエラー割り込み(オンラインのみ)  最大で65個のインターラプトハンドラを登録することが可能です。2.Busタイムアウト割り込み  最大で65個のインターラプトハンドラを登録することが可能です。3.Syncエラー割り込み(オンラインのみ)  最大で65個のインターラプトハンドラを登録することが可能です。4.各種モジュールから発生する割り込み。  各バス番号で最大2個のインターラプトハンドラを登録することが可能です。  上記の割り込みは、ともにインターラプト専用スレッドで実行されます。  システムバスI/Fが発生する、Busエラー,Busタイムアウト,Syncエラーの割り込みは、インターラプト専用スレッドの内部でインターラプトをディセーブルし、その後、それぞれ登録されている対象のインターラプトハンドラを順次実行します。対象となるインターラプトハンドラの実行終了後、インターラプト専用スレッドはインターラプトの要因をクリアし、内部でインターラプトをイネーブルします。  なお、インターラプトの受付はインターラプトスレッド内でのイネーブル/ディセーブルとは別に当ライブラリの関数でイネーブル/ディセーブルの制御が可能です。種モジュールで発生する割り込みは、インターラプト専用スレッドが内部でインターラプトをディセーブルし、当該モジュールに対してインターラプトのロックを実行します。その後、インターラプトを発生したバス番号に対応するインターラプトハンドラを順次実行します。対象となるインターラプトハンドラの実行終了後、インターラプト専用スレッドは当該モジュールに対してインターラプトの要因をクリアします。その後インターラプトのロックを解除し、内部でインターラプトをイネーブルします。  なお、インターラプトの受付はインターラプトスレッド内でのイネーブル/ディセーブルとは別に当ライブラリの関数でイネーブル/ディセーブルの制御が可能です。インターラプトの禁止/許可は、システムバスI/Fボード上と、各種モジュール上で、それぞれ制御が可能です。  システムバスI/Fボード側での禁止/許可は、単純にモジュールからのインターラプトをイネーブル/ディセーブルしています。モジュール側でのインターラプトのロック/アンロックは、モジュール側のインターラプトの発生元でインターラプトの発生を制御します。ロック中は、モジュール内で新たなインターラプトの発生を禁止し、さらにインターラプト関係のステータスの変化も禁止されています。アンロック後、モジュール側でのインターラプトの発生が可能となります。C.2.3.1  モジュールインターラプトハンドラの登録  モジュールからインターラプトが発生した時のインターラプトハンドラ関数を登録します。登録された関数はインターラプトが発生した場合、インターラプトハンドラ専用のスレッドで実行されます。インターラプトハンドラは、バス番号とともに登録し、インターラプトを上げたモジュールのバス番号と登録されているバス番号が等しいインターラプトハンドラを起動します。  また、インターラプトハンドラに対して、登録時に設定した値を同時に戻します。インターラプトハンドラは、各バス番号ごとに2個登録することが可能です。バス番号は1から64まで指定可能です。登録に成功すると戻り値にキー番号が返されます。このキー番号を使用して登録を行うと、そのキー番号のインターラプトハンドラの再登録及び、削除が可能になります。キー番号を0にして登録を行うと、空いているキー番号にインターラプトハンドラが設定されます。空いているキー番号がない場合は、エラーとなり戻り値に−1が返されます。インターラプトハンドラの実行は、2個登録されている場合、若いキー番号から順に実行されます。  インターラプトハンドラの削除は、コールバック関数のアドレスをBCL＿GBI＿IGNORE＿MODULE＿HANDLERとして登録します。インタラプトスレッドは、BCL＿GBI＿IGNORE＿MODULE＿HANDLERのインタラプトハンドラは実行しません。各バス番号ごとの2個のインターラプトハンドラが両方ともBCL＿GBI＿IGNORE＿MODULE＿HANDLERとなった場合は、そのバス番号のインターラプトハンドラは初期状態に戻ります。(アクセスライブラリ内の標準インターラプトハンドラが設定されます。)・名前:BCL＿GBI＿addInterruptHandler・形式:int  BCL＿GBI＿addInterruptHandler(unsigned  int  BusNo,int  KeyNo,BCL＿GBI＿MODULE＿HANDLER  handler,unsigned  int  arg);・コールバック関数:void  InterruptRoutine(unsigned  int  BusNo,unsigned  int  Factor,unsigned  int  arg);・引数:BusNo(バス番号)、KeyNo(キー番号)、handler(コールバック関数のアドレス)、arg(インターラプトハンドラへ渡す値)、Factor(割り込み要因(各モジュールに依存))・戻り値:インターラプトハンドラが登録されたキー番号(−1の場合、登録に失敗［不正なバス番号または、キー番号］)C.2.3.2  バスエラーインターラプトハンドラの登録  システムバスでエラーが発生した場合のエラー処理関数を登録します。システムバスでエラーが発生した場合、インターラプトスレッドは、登録されている関数を実行します。なお、システムバスでエラーが発生した場合、インターラプトスレッドでインターラプトをクリアします。インターラプトハンドラ内でのクリアは必要ありません。  Busエラーのインターラプトハンドラは65個まで登録することが可能です。登録に成功すると戻り値にキー番号が返されます。このキー番号を使用して登録を行うと、そのキー番号のインターラプトハンドラの再登録及び、削除が可能になります。キー番号を0にして登録を行うと、空いているキー番号にインターラプトハンドラが設定されます。空いているキー番号がない場合はエラーとなり、戻り値に−1が返されます。インターラプトハンドラの削除は、コールバック関数のアドレスをBCL＿GBI＿IGNORE＿BUSERROR＿HANDLERとして登録します。  インタラプトスレッドは、BCL＿GBI＿IGNORE＿BUSERROR＿HANDLERのインタラプトハンドラは実行しません。65個のインターラプトハンドラがすべてBCL＿GBI＿IGNORE＿BUSERROR＿HANDLERとなった場合は、初期状態に戻ります。(アクセスライブラリ内の標準インターラプトハンドラが設定されます。)Busエラーはシステムバス上の通信エラーやハードウェアの故障などが原因となり発生します。  なお、オフラインではBusでエラーが発生する要因がないため、本関数で登録されたハンドラは動作することはありません。・名前:BCL＿GBI＿addBusErrorInterruptHandler・形式:int  BCL＿GBI＿addBusErrorInterruptHandler(int  KeyNo,BCL＿GBI＿BUSERROR＿HANDLER  handler,unsigned  int  arg);・コールバック関数:void  BusErrorInterruptRoutine(unsigned  int  arg);・引数:KeyNo(キー番号)、handler(コールバック関数のアドレス)、arg(インターラプトハンドラへ渡す値)・戻り値:インターラプトハンドラが登録されたキー番号(−1の場合、登録に失敗［不正なバス番号または、キー番号］)C.2.3.3  バスタイムアウトインターラプトハンドラの登録  システムバスでタイムアウトが発生した場合のエラー処理関数を登録します。システムバスでタイムアウトが発生した場合、インターラプトスレッドは、登録されている関数を実行します。なお、システムバスでタイムアウトが発生した場合、インターラプトスレッドでインターラプトをクリアします。  インターラプトハンドラ内でのクリアは必要ありません。Busタイムアウトのインターラプトハンドラは65個まで登録することが可能です。登録に成功すると戻り値にキー番号が返されます。このキー番号を使用して登録を行うと、そのキー番号のインターラプトハンドラの再登録及び、削除が可能になります。キー番号を0にして登録を行うと、空いているキー番号にインターラプトハンドラが設定されます。空いているキー番号がない場合はエラーとなり、戻り値に−1が返されます。インターラプトハンドラの削除は、コールバック関数のアドレスをBCL＿GBI＿IGNORE＿TIMEOUT＿HANDLERとして登録します。  インタラプトスレッドは、BCL＿GBI＿IGNORE＿TIMEOUT＿HANDLERのインタラプトハンドラは実行しません。65個のインターラプトハンドラがすべてBCL＿GBI＿IGNORE＿TIMEOUT＿HANDLERとなった場合は、初期状態に戻ります。(アクセスライブラリ内の標準インターラプトハンドラが設定されます。)Busタイムアウトはケーブル抜け状態でのリード時や受信先がいない場合のリード時に発生します。また、ハードウェアの故障などもその原因となります。・名前:BCL＿GBI＿addTimeoutInterruptHandler・形式:int  BCL＿GBI＿addTimeoutInterruptHandler(int  KeyNo,BCL＿GBI＿TIMEOUT＿HANDLER  handler,unsigned  int  arg);・コールバック関数:void  TimeoutInterruptRoutine(unsigned  int  address,unsigned  int  Factor,unsigned  int  arg);・引数:KeyNo(キー番号)、handler(コールバック関数のアドレス)、address(タイムアウトが発生したマシンワードのアドレス)、Factor(タイムアウトが発生した要因［BCL＿GBI＿FACTOR＿MODULE:モジュールのリード、BCL＿GBI＿FACTOR＿CONFIG:コンフィグレーションのリード、BCL＿GBI＿FACTOR＿WRITE:すべてのライト］)、arg(インターラプトハンドラへ渡す値)・戻り値:インターラプトハンドラが登録されたキー番号(−1の場合、登録に失敗［不正なバス番号または、キー番号］)C.2.3.4  Syncエラーインタラプトハンドラの登録  システムバスでSyncエラーが発生した場合のエラー処理関数を登録します。システムバスでSyncエラーが発生した場合、インターラプトスレッドは、登録されている関数を実行します。なお、システムバスでSyncエラーが発生した場合、インターラプトスレッドでインターラプトをクリアします。インターラプトハンドラ内でのクリアは必要ありません。  Syncエラーのインターラプトハンドラは65個まで登録することが可能です。登録に成功すると戻り値にキー番号が返されます。このキー番号を使用して登録を行うと、そのキー番号のインターラプトハンドラの再登録及び、削除が可能になります。キー番号を0にして登録を行うと、空いているキー番号にインターラプトハンドラが設定されます。空いているキー番号がない場合はエラーとなり、戻り値に−1が返されます。  インターラプトハンドラの削除は、コールバック関数のアドレスをBCL＿GBI＿IGNORE＿SYNCERROR＿HANDLERとして登録します。インタラプトスレッドは、BCL＿GBI＿IGNORE＿SYNCERROR＿HANDLERのインタラプトハンドラは実行しません。65個のインターラプトハンドラがすべてBCL＿GBI＿IGNORE＿SYNCERROR＿HANDLERとなった場合は、初期状態に戻ります。(アクセスライブラリ内の標準インターラプトハンドラが設定されます。)Syncエラーはソフトウェアの設定ミスやハードウェアの設計不良により発生します。また、ハードウェアの故障などもその原因となります。  オフラインではBusでSyncエラーが発生する要因がないため、本関数で登録されたハンドラは動作することはありません。・名前:BCL＿GBI＿addSyncErrorInterruptHandler・形式:int  BCL＿GBI＿addSyncErrorInterruptHandler(int  KeyNo,BCL＿GBI＿SYNCERROR＿HANDLER  handler,unsigned  int  arg);・コールバック関数:void  SyncErrorInterruptRoutine(unsigned  int  arg);・引数:KeyNo(キー番号)、handler(コールバック関数のアドレス)、arg(インターラプトハンドラへ渡す値)・戻り値:インターラプトハンドラが登録されたキー番号(−1の場合、登録に失敗［不正なバス番号または、キー番号］)C.2.4  ライブラリ/システムバスの制御C.2.4.1  FIFOのフラッシュ待ち  サイトCPUに接続されているシステムバスと接続されている全てのモジュールのFIFOのフラッシュを待ちます。FIFOは、システムバスI/Fボード内とモジュール内に存在します。この関数を終了した時、この関数の実行に入る直前のFIFO内に存在するデータが全てモジュールにライトされたことを意味します。この関数を実行中、CPUはPCIバスに対してリードサイクルを発行しているため、FIFOがフラッシュされるまでバスをハード的にロックしています。このためDMA転送やインターラプトの受け付けに遅延を生じる場合があります。また、この関数の実行によりタイムアウトが発生する場合があります。オフラインの場合は、システムバスエミュレータのFIFOは存在しません。また、モジュール内のFIFOの存在はベンダ依存です。・名前:BCL＿GBI＿waitFlushFIFO・形式:int  BCL＿GBI＿waitFlushFIFO(void);・引数:なし・戻り値:BCL＿GBI＿OK(フラッシュ完了)、BCL＿GBI＿ERROR(エラー)C.2.4.2  モジュールのリセット  サイトCPUに接続されているモジュールにたいして、リセットを行います。この関数内では、下記の処理を実行します。1.システムバスへバスリセットパケットの送出。2.システムバスへインターラプトのクリア用パケットの送出。3.システムバスへインターラプトのアンロックパケットの送出。  なお、リセットの動作やかかる時間については、各モジュールに依存します。・名前:BCL＿GBI＿resetModule・形式:int  BCL＿GBI＿resetModule(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.4.3  ライブラリの初期化  システムバスアクセスライブラリの初期化を行います。システムバスアクセスライブラリを利用する場合、最初にこの初期化処理を実行する必要があります。また、この関数内では下記の処理を実行します。1.アクセスライブラリの変数の初期化。2.インターラプトハンドラを実行するためのスレッドを起動。また、システムバスI/F上のインターラプトはディセーブルの状態です。  オフラインの場合はこの関数でシステムバスエミュレータとのプロセス間通信の準備をします。システムバスエミュレータと30秒以内に接続が確立されないとタイムアウトになります。・名前:BCL＿GBI＿init・形式:int  BCL＿GBI＿init(unsigned  int  siteNo,int  mode);・引数:siteNo(サイト番号［1〜8］)、mode(オンライン/オフラインの指定。BCL＿GBI＿ONLINE:オンライン、BCL＿GBI＿OFFLINE:オフライン)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(サイト番号が規定外)、BCL＿GBI＿TIMEOUT(オフラインにおいて30秒以内にシステムバスエミュレータと接続できない)C.2.4.4  ライブラリの開放  システムバスアクセスライブラリの使用終了の処理を行います。・名前:BCL＿GBI＿finish・形式:int  BCL＿GBI＿finish(unsigned  int  siteNo);・引数:siteNo(サイト番号［1〜8］)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(サイト番号が規定外)C.2.4.5  オンライン/オフラインの識別(BCL＿GBI＿isOnline)  現在動作中のシステムバスアクセスライブラリがオンラインで動作中か、オフラインで動作中か識別します。・名前:・形式:int  BCL＿GBI＿isOnline(void);・引数:なし・戻り値:BCL＿GBI＿ONLINE(オンライン)、BCL＿GBI＿OFFLINE(オフライン)C.2.4.6  GBSCとの通信可否の確認  システムバスI/FとGBSC(システム制御装置110)との通信が可能かどうかの確認をします。これにより、GBSCの電源が入っている事が確認できます。・形式:int  BCL＿GBI＿getConnected(unsigned  int  *connect);・引数:connect(通信可否の結果を格納する変数へのポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.2.4.7  詳細エラー情報の取得  システムバスアクセスライブラリがBCL＿GBI＿ERRORを返したときの詳細エラー情報を返します。・名前:BCL＿GBI＿getLastError・形式:unsigned  int  BCL＿GBI＿getLastError(void);・引数:なし・戻り値:無符号の32ビットエラー情報を返します。  bit31:エラーコードの種別を特定する値  0:Windowsのエラーコード(System  Error  Codesを参照)  1:アクセスライブラリ固有のエラーコード  bit30−24:エラーが発生した関数内の場所を特定する値(内部情報)  bit23−16:エラーが発生したアクセスライブラリ関数を特定する値  bit15−0:エラーコード    bit31が0のとき:GetLastError()の下位16bit値    bit31が1のとき:アクセスライブラリの内部エラー値C.2.4.8  詳細エラー情報履歴の取得  現在までに使用されたシステムバスアクセスライブラリがBCL＿GBI＿ERRORを返したときの詳細エラー情報を最大で過去16回分まで返します。・形式:unsigned  int  BCL＿GBI＿getPreviousErrors(unsigned  int  *error,unsigned  int  size);・名前:BCL＿GBI＿getPreviousErrors・引数:error(エラー情報を格納する配列変数のポインタ。エラー情報のフォーマットはBCL＿GBI＿getLastError()と同様)、size(エラー情報を格納する配列変数のサイズ)・戻り値:格納されたエラー情報の数を返します。C.3  タイマ関数  本章では、システムバスI/Fボード上のタイマハードウェアを利用するための関数について説明します。システムバスI/Fボード上に実装されたハードウェアのタイマの分解能は1［us］です。C.3.1  経過時間の読み出しC.3.1.1  時間の読み出し  システムバスアクセスライブラリの初期化が実行されてからの経過時間を秒［s］で読み出します。<制約事項>  分解能は1［us］ですが、double型に変換して読み出しているため、doubleの有効桁*1［us］以上の値が読み出された場合、1［us］の分解能が得られない場合があります。doubleの有効桁は10進の15桁で、理論上、システムバスアクセスライブラリを初期化してから約31年経過した場合、1［us］の分解能が得られなくなります。  ハードウェアのカウンタは64ビットで動作しているため、システムバスアクセスライブラリを初期化してから理論上約58万年後に0に戻ります。プログラム上、一定の間隔で読み出しを行った場合の差分(経過時間)は、CPUの負荷状態、PCIバスの負荷状態およびFIFOの状態により一定の値にならない場合があります。<オフライン>  オフラインでは、オフラインプロセスが動作するサイトCPUが起動してからの経過時間を秒［s］で読み出します。・名前:BCL＿TMR＿readTime・形式:int  BCL＿TMR＿readTime(double  *time);・引数:time(システムバスアクセスライブラリが初期化されてからの経過時間［s］)・戻り値:BCL＿TMR＿OK(正常終了)C.3.1.2  タイマカウンタの読み出し  システムバスアクセスライブラリの初期化が実行されてからの経過時間をカウント値で読み出します。カウント値は1［us］経過するごとに1が加算されます。<制約事項>  ハードウェアのカウンタは64ビットで動作しているため、システムバスアクセスライブラリを初期化してから理論上約58万年後に0に戻ります。また、プログラム上一定の間隔で読み出しを行った場合の差分(経過時間)は、CPUの負荷状態、PCIバスの負荷状態およびFIFOの状態により一定の値にならない場合があります。  オフラインでは、オフラインプロセスが動作するサイトCPUが起動してからの経過時間をカウント値で読み出します。・名前:BCL＿TMR＿readCount・形式:int  BCL＿TMR＿readCount(unsigned＿int64  *count);・引数:count(システムバスアクセスライブラリが初期化されてからのカウント値［1［us］/1カウント］)・戻り値:BCL＿TMR＿OK(正常終了)C.3.2  時間待ち関連関数C.3.2.1  時間待ち  指定された時間の経過後、関数は戻ります。待ち時間(time)に1［us］未満の値を指定した場合、直ちに関数は戻ります。CPUの負荷状況により指定された時間より経過時間が長く過ぎてから戻る場合があります。  オフラインでは、1［ms］未満は切捨てされた値で時間待ちを実行します。たとえば、待ち時間(time)に1［ms］未満の値を指定した場合、直ちに関数は戻ります。また、最大待ち時間は、4294967.296［s］(約49日)です。・名前:BCL＿TMR＿wait・形式:int  BCL＿TMR＿wait(double  time);・引数:time(待ち時間を秒単位［s］で指定)・戻り値:BCL＿TMR＿OK(正常終了)、BCL＿TMR＿ERROR(待ちがキャンセルされた)C.3.2.2  時間待ち関数のキャンセル  現在実行中の全てのBCL＿TMR＿wait関数の実行をキャンセルします。複数のスレッドで動作している場合、すべてのBCL＿TMR＿wait関数について実行がキャンセルされます。・名前:BCL＿TMR＿cancel・形式:int  BCL＿TMR＿cancel(void);・引数:なし・戻り値:BCL＿TMR＿OK(正常終了)C.4  コンフィグレーション/診断専用関数  本章ではハードウェアのコンフィグレーションおよびハードウェア診断で利用する関数を説明します。ハードウェアのコンフィグレーションおよびハードウェア診断以外で利用した場合、各種モジュールへのデータ転送やインターラプトの処理が正しく処理できなくなります。システムバスI/Fボード、BusSwitch、各種モジュールなどハードウェア構造を熟知した上、ハードウェアのコンフィグレーションおよびハードウェア診断関数内で利用してください。  当ライブラリでは実行時にランタイムエラーとなりませんが、バスコンフィグレーション関数およびハードウェア診断関数以外で利用した場合、当ライブラリおよびシステムバスI/Fボードのディバイスドライバのインターラプトに関する動作は保障しません。C.4.1  コンフィグレーション制御(特殊関数)  本節で説明する関数は、システムバスI/Fおよび各種モジュールのコンフィグレーションで利用する関数です。不注意に操作すると各種モジュールへのデータの転送ができなくなりますので、ハードウェアやソフトウェアの構造を熟知した上、利用してください。C.4.1.1  バスコンフィグレーションライト  システムバスI/Fおよび各種モジュールのコンフィグレーションレジスタに対してデータを書き込みます。また、コンフィグレーションデータがシステムバスI/Fおよび各種モジュールに格納された後、この関数を終了します。・名前:BCL＿GBI＿writeBusConfig・形式:int  BCL＿GBI＿writeBusConfig(unsigned  int  address,unsigned  int  config);・引数:address(コンフィグレーションデータのアドレス)、config(書き込むコンフィグレーションデータ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.1.2  バスコンフィグレーションリード  システムバスI/Fおよび各種モジュールのコンフィグレーションレジスタからデータを読み出します。・名前:BCL＿GBI＿readBusConfig・形式:int  BCL＿GBI＿readBusConfig(unsigned  int  address,unsigned  int  *config);・引数:address(コンフィグレーションデータのアドレス)、config(コンフィグレーションデータを格納する変数へのポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.1.3  バススイッチコンフィグレーションの設定終了  オンラインでは、何も実行されません。  オフラインでは、バススイッチのコンフィグレーションライトを完了した際、当関数を実行することによりオフラインのバスの接続が切り替わります。・名前:BCL＿GBI＿decideBusMatrix・形式:int  BCL＿GBI＿decideBusMatrix(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2  インターラプト制御(特殊関数)  本節で説明する関数は、バスコンフィグレーションおよびハードウェア診断で利用する関数です。システムバスI/Fボード上のインターラプトを直接制御するため、不注意に操作するとシステムバスI/Fボードのディバイスドライバや当ライブラリがインターラプトの処理を正しく実行できなくなります。C.4.2.1  Bus  I/Fボードインターラプトイネーブル  各種インターラプト信号をシステムバスI/Fボード上でイネーブルにします。インターラプト信号には、各種モジュールからの割り込み、Busエラー、Busタイムアウト、Syncエラーの4種類があります。これらの信号は下記で定義されたビット情報として設定できます。複数のインターラプト信号を指定する場合は、論理和として設定します。この関数は、システムバスI/F上でインターラプトがイネーブルになったことを確認後、終了します。・名前:BCL＿GBI＿interruptEnable・形式:int  BCL＿GBI＿interruptEnable(unsigned  int  status);・引数:status(インターラプト信号の指定。BCL＿GBI＿INT＿MODULE:モジュールからの割り込み、BCL＿GBI＿INT＿BUSERROR:Busエラー、BCL＿GBI＿INT＿TIMEOUT:Busタイムアウト、BCL＿GBI＿INT＿SYNCERROR:Syncエラー)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.2  Bus  I/Fボードインターラプトディセーブル  各種インターラプト信号をシステムバスI/Fボード上でディセーブルにします。インターラプト信号には、各種モジュールからの割り込み、Busエラー、Busタイムアウト、Syncエラーの4種類があります。これらの信号は下記で定義されたビット情報として設定できます。複数のインターラプト信号を指定する場合は、論理和として設定します。この関数は、システムバスI/F上でインターラプトがディセーブルになったことを確認後、終了します。・名前:BCL＿GBI＿interruptDisable・形式:int  BCL＿GBI＿interruptDisable(unsigned  int  status);・引数:status(インターラプト信号の指定。BCL＿GBI＿INT＿MODULE:モジュールからの割り込み、BCL＿GBI＿INT＿BUSERROR:Busエラー、BCL＿GBI＿INT＿TIMEOUT:Busタイムアウト、BCL＿GBI＿INT＿SYNCERROR:Syncエラー)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.3  Bus  I/Fボードインターラプトリード  各種インターラプト信号をシステムバスI/Fボード上で読み込みます。インターラプト信号には、各種モジュールからの割り込み、Busエラー、Busタイムアウト、Syncエラーの4種類があります。これらの信号は下記で定義されたビット情報として読み込まれます。・名前:BCL＿GBI＿interruptRead・形式:int  BCL＿GBI＿interruptRead(unsigned  int  *status);・引数:status(インターラプト信号を読み込む変数へのポインタ。BCL＿GBI＿INT＿MODULE:モジュールからの割り込み、BCL＿GBI＿INT＿BUSERROR:Busエラー、BCL＿GBI＿INT＿TIMEOUT:Busタイムアウト、BCL＿GBI＿INT＿SYNCERROR:Syncエラー)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.4  Bus  I/Fボードインターラプトクリア  各種インターラプト信号をシステムバスI/Fボード上でクリアします。インターラプト信号には、各種モジュールからの割り込み、Busエラー、Busタイムアウト、Syncエラーの4種類があります。これらの信号は下記で定義されたビット情報として設定できます。複数のインターラプト信号を指定する場合は、論理和として設定します。  モジュールからの割り込み(BCL＿GBI＿INT＿MODULE)のみが指定された場合は、この関数が実行される直前の各モジュールのFIFOをフラッシュしたあと、システムバスI/F上のインターラプトをクリアし、システムバスI/F上でインターラプトがクリアになったことを確認後、終了します。・名前:BCL＿GBI＿interruptClear・形式:int  BCL＿GBI＿interruptClear(unsigned  int  status);・引数:status(インターラプト信号の指定。BCL＿GBI＿INT＿MODULE:モジュールからの割り込み、BCL＿GBI＿INT＿BUSERROR:Busエラー、BCL＿GBI＿INT＿TIMEOUT:Busタイムアウト、BCL＿GBI＿INT＿SYNCERROR:Syncエラー)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.5  Syncするモジュール数の設定  サイトCPUに接続されているシステムバスと接続されている全てのモジュールの数をシステムバスI/Fボード上に設定します。この設定を行うことにより、FIFOをSyncするモジュールの数が決定されます。  オフラインの場合は、システムバスエミュレータのFIFOは存在しません。また、モジュール内のFIFOの存在はベンダ依存です。・名前:BCL＿GBI＿setSyncCount・形式:int  BCL＿GBI＿setSyncCount(unsigned  int  number);・引数:number(Syncするモジュールの数)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.6  インターラプトの設定状態のセーブ  システムバスI/Fボード上のインターラプト信号の設定状態(イネーブル/ディゼーブル)及び、モジュールからのインターラプト発生の設定状態(ロック/アンロック)をセーブします。この関数は、診断等でインターラプト操作を行う前に、現在の設定状態をセーブする目的で使用されます。セーブされた内容は、BCL＿GBI＿restoreInterruptCondition()関数でリストアされます。この関数が2回以上実行された場合は、以前にセーブされた設定状態は取り消され、最後にセーブした設定状態のみ有効となります。  オフラインでは無効な機能のため、本関数内では何も行いません。・名前:BCL＿GBI＿saveInterruptCondition・形式:int  BCL＿GBI＿saveInterruptCondition(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.7  インターラプトの設定状態のリストア  BCL＿GBI＿saveInterruptCondition()関数によりセーブされたシステムバスI/Fボード上のインターラプト信号の設定状態(イネーブル/ディゼーブル)及び、各種モジュールからのインターラプト発生の設定状態(ロック/アンロック)をリストアします。この関数は、診断等でインターラプト操作を行った後に、操作前の設定状態に戻す目的で使用されます。BCL＿GBI＿saveInterruptCondition()関数によるセーブが行わずに本関数が実行された場合は、エラーを返します。この関数が2回以上実行されてもエラーとはならず、常に最後にセーブされた設定状態がリストアされます。  オフラインでは無効な機能のため、本関数内では何も行いません。・名前:BCL＿GBI＿restoreInterruptCondition・形式:int  BCL＿GBI＿restoreInterruptCondition(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.4.2.8  モジュールインターラプト要因の読み出し  各種モジュールからインターラプトが発生した場合の要因とその要因数を読み出します。インターラプトの要因は最大256個(4バイト/要因)あります。このうち発生したインターラプトの要因数分だけ要因を返します。要因の読み出し用バッファは、最大要因数分のインターラプトが発生した場合を考慮して最大要因数(unsigned  int型で256個)確保する必要があります。  オフラインでは無効な機能のため、本関数内では何も行いません。・名前:BCL＿GBI＿readInterruptFactor・形式:int  BCL＿GBI＿readInterruptFactor(unsigned  int  *Factor,int  *number);・引数:Factor(割り込み要因を読み込む配列へのポインタ)、number(割り込み要因数を格納するポインタ)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5  非公開関数  非公開関数です。C.5.1.1  非同期DMA転送のキャンセル(非公開)  実行中の非同期DMA転送をキャンセルします。同期DMAはキャンセルできません。また、誤ったtransfer  IDを指定した場合、DMAのキャンセルは実行されず、正常終了のステータスが戻ります。・名前:BCL＿GBI＿cancelDMA・形式:int  BCL＿GBI＿cancelDMA(unsigned  int  transferID);・引数:transferID(非同期モード転送時に返された転送終了待ちID)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.2  PCIベースアドレスの取得(非公開)  システムバスI/Fボードで使用するPCIバスのベースアドレスを取得します。この関数は、システムバスI/Fボードの診断等で使用されます。このアドレスは、取得したプロセスでのみ使用可能です。取得したアドレスがNULLであった場合は、本ライブラリの初期設定が行われていません。BCL＿GBI＿init関数によりライブラリの初期化を行ってから使用してください。  オフラインでは無効な機能のため、本関数内では何も行いません。・名前:BCL＿GBI＿exportPciBaseAddress・形式:PULONG  BCL＿GBI＿exportPciBaseAddress(void);・引数:なし・戻り値:NULL(エラー)、NULL以外(システムバスI/FのPCIベースアドレス)C.5.1.3  モジュールインターラプトロック(非公開)  モジュールからのインターラプトの発生を発生元で禁止します。インターラプトのロックを設定すると以後新規にインターラプトの発生をモジュール側で禁止します。なお、この関数は、各モジュールにロックが格納された後終了します。・名前:BCL＿GBI＿interruptLock・形式:int  BCL＿GBI＿interruptLock(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.4  モジュールインターラプトアンロック(非公開)  モジュールからのインターラプトの発生を発生元で許可します。この関数を実行すると、ロック中に発生を待たされていたインターラプトやアンロック以後のインターラプトの発生が各種モジュール側で可能となります。  なお、この関数は、各モジュールにアンロックが格納された後終了します。・名前:BCL＿GBI＿interruptUnlock・形式:int  BCL＿GBI＿interruptUnlock(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.5  詳細エラー情報の出力(非公開)  システムバスアクセスライブラリがBCL＿GBI＿ERRORを返したときの詳細エラー情報を標準出力ストリームに出力します。・名前:BCL＿GBI＿printLastError・形式:void  BCL＿GBI＿printLastError(void);・引数:なし・戻り値:なしC.5.1.6  詳細エラー情報履歴の出力(非公開)  現在までに使用されたシステムバスアクセスライブラリがBCL＿GBI＿ERRORを返したときの詳細エラー情報を最大で過去16回分まで標準出力ストリームに出力します。・名前:BCL＿GBI＿printPreviousErrors・形式:void  BCL＿GBI＿printPreviousErrors(void);・引数:なし・戻り値:なしC.5.1.7  デバッグ・モードの制御(非公開)  アクセスライブラリに実装したデバッグ・モードの制御を行います。・名前:BCL＿GBI＿verbose・形式:void  BCL＿GBI＿verbose(int  val);・引数:val(デバッグ・モードの指定)・戻り値:なしC.5.1.8  レース機能のイネーブル(非公開)  システムバスアクセスライブラリのトレース機能をイネーブルにします。トレース機能をイネーブルにすると、バスアクセスや関数のトレースが有効となります。バスアクセスのトレースでは、アクセスしたアドレスとデータ及び、リード/ライトの識別が標準出力ストリームに表示されます。関数のトレースでは、実行された関数名が標準出力ストリームに表示されます。また、トレースを実行する関数は、任意の関数を登録して置き換える事も可能です。  バスアクセスのトレースを行うアクセスライブラリの関数は以下の通りです。BCL＿GBI＿writeBCL＿GBI＿readBCL＿GBI＿writeBlockBCL＿GBI＿readBlockBCL＿GBI＿writeSeqBCL＿GBI＿readSeqBCL＿GBI＿writeSyneDMABCL＿GBI＿readSyncDMABCL＿GBI＿writeAsyncDMABCL＿GBI＿readAsyncDMABCL＿GBI＿writeConfigBCL＿GBI＿readConfig  関数のトレースを行うアクセスライブラリの関数は以下の通りです。BCL＿GBI＿waitFlushFIFOBCL＿GBI＿waitDMABCL＿GBI＿cancelDMABCL＿GBI＿conditionDMABCL＿GBI＿syncCountBCL＿GBI＿resetModule・名前:BCL＿GBI＿ioTraceEnable・形式:int  BCL＿GBI＿ioTraceEnable(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.9  トレース機能のディセーブル(非公開)  システムバスアクセスライブラリのトレース機能をディセーブルにします。トレース機能をディセーブルにすると、バスアクセスや関数のトレースが無効となります。・名前:BCL＿GBI＿ioTraceDisable・形式:int  BCL＿GBI＿ioTraceDisable(void);・引数:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.10  トレース機能のアドレスフィルタ指定(非公開)  バスアクセスのトレース機能に関するアドレスフィルタの指定を行います。フィルタの指定方法は、モードによって単一指定または、連続指定が可能です。指定できる組み合わせは最大で16通りの指定が可能です。トレース機能がイネーブルとなっている場合は、この組み合わせのいずれかに該当したアドレスのみトレース対象となります。・名前:BCL＿GBI＿ioTraceAddress・形式:int  BCL＿GBI＿ioTraceAddress(int  mode,...);      int  BCL＿GBI＿ioTraceAddress(0);      int  BCL＿GBI＿ioTraceAddress(1,addr);      int  BCL＿GBI＿ioTraceAddress(2,start＿addr,stop＿addr);・引数:mode(フィルタ・モードの指定。0:フィルタ指定の解除、1:単一アドレス指定、2:連続アドレス指定)、addr(単一アドレス指定時の対象アドレス)、start＿addr(連続アドレス指定時の開始アドレス)、stop＿addr(連続アドレス指定時の終了アドレス)・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.11  トレース機能の設定情報出力(非公開)  現在設定されているトレース機能に関する設定情報を標準出力ストリームに出力します。トレースのイネーブル/ディセーブル状態やアドレスフィルタの設定状態を確認する事が出来ます。・名前:BCL＿GBI＿ioTraceShow・形式:int  BCL＿GBI＿ioTraceShow(void);・引数:なし・戻り値:なしC.5.1.12  トレース機能の簡易ヘルプ情報出力(非公開)  トレース機能に関する簡易ヘルプ情報を標準出力ストリームに出力します。・名前:BCL＿GBI＿ioTraceHelp・形式:int  BCL＿GBI＿ioTraceHelp(void);・引数:なし・戻り値:なしC.5.1.13  トレース関数の登録(非公開)  トレース機能を実行するデフォルトのトレース関数を任意のトレース関数に置き換えます。トレース機能がイネーブルとなっていれば、直後のトレース対象のアクセスライブラリ関数から登録された関数が実行されます。登録できる関数は1個で、既に登録されている場合は、上書きで登録されます。デフォルトのトレース関数に戻す場合は、BCL＿GBI＿ioTraceResetHandler関数を実行します。  トレースが行われるアクセスライブラリの関数は以下のとおりです。BCL＿GBI＿writeBCL＿GBI＿readBCL＿GBI＿writeBlockBCL＿GBI＿readBlockBCL＿GBI＿writeSeqBCL＿GBI＿readSeqBCL＿GBI＿writeSyncDMABCL＿GBI＿readSyncDMABCL＿GBI＿writeAsyncDMABCL＿GBI＿readAsyncDMABCL＿GBI＿writeConfigBCL＿GBI＿readConfigBCL＿GBI＿waitFlushFIFOBCL＿GBI＿waitDMABCL＿GBI＿cancelDMABCL＿GBI＿conditionDMABCL＿GBI＿syncCountBCL＿GBI＿resetModule・名前:BCL＿GBI＿ioTraceHandler・形式:void  BCL＿GBI＿ioTraceHandler(BCL＿GBI＿TRACE＿HANDLER  handler,void  *arg);・引数:handler(コールバック関数のアドレス)、arg(トレースハンドラへ渡す値)・戻り値:なし・戻り値:BCL＿GBI＿OK(正常終了)、BCL＿GBI＿ERROR(エラー)C.5.1.14  デフォルトのトレース関数の登録(非公開)  BCL＿GBI＿ioTraceHandler関数により置き換えられた任意のトレース関数をデフォルトのトレース関数に戻します。・名前:BCL＿GBI＿ioTraceResetHandler・形式:void  BCL＿GBI＿ioTraceResetHandler(void);・引数:なし・戻り値:なしC.5.1.15  デフォルトのトレース関数の実行(非公開)  BCL＿GBI＿ioTraceHandler関数により登録された任意のトレース関数からデフォルトのトレース関数を実行します。・名前:BCL＿GBI＿ioTraceExecuteDefaultHandler・形式:void  BCL＿GBI＿ioTraceExecuteDefaultHandler(int  cmd,unsigned  int  address,unsigned  int  data,void  *arg);・引数:cmd(トレース対象となる関数)、address(トレース対象のアドレス)、data(トレース対象のデータ)、arg(トレースハンドラに引き渡された引数)・戻り値:なし【産業上の利用可能性】  上記説明から明らかなように、本発明によれば、様々なモジュールを混載して使用する試験装置を適切にエミュレートすることができる試験エミュレート装置、試験モジュールエミュレート装置、及びこれらのプログラムを記録した記録媒体を実現することができる。【図1】【図2】【図3】【図4】【図5】【図6】【図7】【図8】【図9】【図10】【図11】【図12】【図13】【図14】【図15】【図16】【図17】【図18】【図19】【図20】【図21】【図22】【図23】【図24】【図25】【図26】【図27】【図28】
【特許請求の範囲】【請求項1】試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置であって、  異なるサイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、  前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、  前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールエミュレート部のそれぞれが、当該試験モジュールエミュレート部のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、  前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、  前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する前記試験モジュールエミュレート部に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるスケジュール部と  を備える試験エミュレート装置。【請求項2】擬似的に生成された前記試験信号に基づいて被試験デバイスの動作をシミュレートする被試験デバイスシミュレート部を更に備える請求項1記載の試験エミュレート装置。【請求項3】前記同期エミュレート部は、複数の前記試験モジュールエミュレート部のそれぞれが、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において擬似的に発生する、前記制御装置に対する割込みを収集する割込み収集タイミングを更に生成し、  前記タイミング整列部は、前記複数の試験信号生成タイミング及び複数の前記割込み収集タイミングを時刻順に整列して順次出力し、  前記スケジュール部は、タイミング整列部が一の前記割込み収集タイミングを出力した場合に、当該割込み収集タイミングに対応する前記試験モジュールエミュレート部に、当該割込み収集タイミングの直前に当該試験モジュールエミュレート部が試験信号を生成したサイクル時間において擬似的に発生した前記割込みを前記制御エミュレート部に対して通知させる  請求項1記載の試験エミュレート装置。【請求項4】前記複数の試験モジュールエミュレート部のそれぞれは、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクル時間中における試験信号の変化タイミングを生成し、  当該試験エミュレート装置は、前記複数の試験モジュールエミュレート部により生成された複数の前記変化タイミングを取得し、前記複数の変化タイミングに基づいて、試験信号を時刻順に順次擬似的に変化させる被試験デバイス接続部を更に備える  請求項1記載の試験エミュレート装置。【請求項5】前記被試験デバイス接続部は、前記複数の試験モジュールエミュレート部から取得した複数の前記変化タイミングを前記タイミング整列部に供給し、  前記タイミング整列部は、前記複数の変化タイミング、前記複数の試験信号生成タイミング及び複数の前記割込み収集タイミングを時刻順に整列して順次出力し、  前記スケジュール部は、前記タイミング整列部が一の前記変化タイミングを出力した場合に、前記被試験デバイス接続部に、当該変化タイミングに試験信号を擬似的に変化させる  請求項4記載の試験エミュレート装置。【請求項6】前記複数の試験モジュールエミュレート部のそれぞれは、前記試験信号生成タイミングに対応するサイクル時間における試験信号の生成において、当該サイクル時間が終了するサイクル終了タイミングを前記同期エミュレート部に通知し、  前記同期エミュレート部は、前記複数の試験モジュールエミュレート部のそれぞれから通知された前記サイクル終了タイミングに基づいて、当該試験モジュールエミュレート部が次のサイクル時間に対応する試験信号を擬似的に生成すべき前記試験信号生成タイミングを生成する  請求項1記載の試験エミュレート装置。【請求項7】次のサイクル時間に対応する前記試験信号生成タイミングを前記タイミング整列部が出力した場合に、前記スケジュール部は、当該試験信号生成タイミングの直前のサイクル時間における試験信号の生成において、当該試験信号生成タイミングに対応する前記試験モジュールエミュレート部が擬似的に発生した割込みを前記制御エミュレート部に対して通知させる  請求項6記載の試験エミュレート装置。【請求項8】前記複数の試験モジュールエミュレート部のそれぞれは、当該試験モジュールエミュレート部に対応する試験モジュールエミュレートプログラムをコンピュータで動作させることにより実現され、  前記試験モジュールエミュレートプログラムは、  前記試験モジュールが前記制御装置から受信する複数のコマンドのそれぞれに対応して設けられ、当該コマンドに対応する前記試験モジュールの動作をエミュレートする複数のハードウェアエミュレート関数と、  前記スケジュール部が、前記試験信号生成タイミングに対応するサイクル時間における試験信号を生成させるために用いる制御関数と  を有する請求項1記載の試験エミュレート装置。【請求項9】コンピュータを、試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置として機能させるプログラムを記録した記録媒体であって、  前記プログラムは、前記コンピュータを、  異なるサイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、  前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、  前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールエミュレート部のそれぞれが、当該試験モジュールエミュレート部のサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、  前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、  前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する前記試験モジールエミュレート部に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させるスケジュール部と  して機能させる記録媒体。【請求項10】異なるサイクル周期に基づく試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置において、一の前記試験モジュールをエミュレートする試験モジュールエミュレート装置であって、  前記試験エミュレート装置は、  前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、  前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールのそれぞれが、当該試験モジュールのサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、  前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、  前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する当該試験モジュールエミュレート装置に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させることを指示するスケジュール部と  を備え、  当該試験モジュールエミュレート装置は、  前記スケジュール部からの指示に基づき、前記一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成するパターン発生器エミュレート部  を備える試験モジュールエミュレート装置。【請求項11】前記一の試験信号生成タイミングに対応するサイクルが終了するサイクル終了タイミングを同期エミュレート部に通知し、前記同期エミュレート部に前記サイクル終了タイミングに基づき当該試験モジュールエミュレート装置が次に試験信号を擬似的に生成すべき前記試験信号生成タイミングを更に生成させる試験モジュールインターフェイスエミュレート部を更に備える請求項10記載の試験モジュールエミュレート装置。【請求項12】異なるサイクル周期に基づく試験信号を被試験デバイスにそれぞれ供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置において、コンピュータを、一の前記試験モジュールをエミュレートする試験モジュールエミュレート装置として機能させるプログラムを記録した記録媒体であって、  前記試験エミュレート装置は、  前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、  前記制御エミュレート部からの指示に基づき、前記複数の試験モジュールのそれぞれが、当該試験モジュールのサイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングを生成する同期エミュレート部と、  前記同期エミュレート部が生成した複数の前記試験信号生成タイミングを、時刻順に整列して順次出力するタイミング整列部と、  前記タイミング整列部が出力した一の前記試験信号生成タイミングに対応する当該試験モジュールエミュレート装置に、当該一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成させることを指示するスケジュール部と  を備え、  前記プログラムは、前記コンピュータを、  前記スケジュール部からの指示に基づき、前記一の試験信号生成タイミングに対応するサイクル時間における試験信号を擬似的に生成するパターン発生器エミュレート部  として機能させる記録媒体。【請求項13】試験信号を被試験デバイスに供給する試験モジュールを備える試験装置であって、  前記被試験デバイスの試験を制御する制御装置と、  サイクル周期に基づき試験信号を生成する試験モジュールと、  前記試験モジュールをエミュレートする試験モジュールエミュレート部と  を備え、  前記制御装置は、  前記被試験デバイスの実試験又は擬似試験のいずれを行うかの指示を入力し、  前記被試験デバイスの実試験を行う指示を受けた場合に、前記被試験デバイスの試験を行う試験プログラムを前記試験モジュールに供給して、前記試験モジュールにより前記被試験デバイスの試験を行わせ、前記被試験デバイスの擬似試験を行う指示を受けた場合に、前記試験プログラムを前記試験モジュールエミュレート部に供給して、前記試験モジュールエミュレート部により前記被試験デバイスの試験をシミュレートさせる  試験装置。【請求項14】前記制御装置は、当該制御装置と前記試験モジュールとの間の通信処理を行う通信ソフトウェアを実行し、  前記通信ソフトウェアは、前記制御装置と協働して、当該通信ソフトウェアを初期化する呼び出しに含まれる前記指示に基づいて、前記試験プログラムを前記試験モジュール及び前記試験モジュールエミュレート部のいずれに供給するかを判断する  請求項13記載の試験装置。【請求項15】試験信号を被試験デバイスに供給する複数の試験モジュールを備える試験装置をエミュレートする試験エミュレート装置であって、  サイクル周期に基づく試験信号を生成する前記複数の試験モジュールをエミュレートする複数の試験モジュールエミュレート部と、  前記被試験デバイスの試験を制御する制御装置をエミュレートする制御エミュレート部と、  前記複数の試験モジュールエミュレート部のそれぞれが、サイクル時間に対応する試験信号を擬似的に生成すべき試験信号生成タイミングをスケジュールするスケジュール部と  を備え、  前記試験モジュールエミュレート部は、  関数呼び出しにより前記試験信号生成タイミングの通知を受けて、当該試験信号生成タイミングに対応するサイクル時間中における試験信号の電圧の変化を、出力チャネルをエミュレートする出力チャネルオブジェクトの電圧設定メソッドを複数回呼び出すことにより出力し、  当該サイクル時間に対応する試験信号の電圧の変化の出力を終えた後に、当該サイクル時間に対応する試験信号の電圧の変化の出力を終えたことを、前記出力チャネルオブジェクトの終了メソッドを呼び出すことにより通知する  試験エミュレート装置。【請求項16】前記スケジュール部は、前記複数の試験モジュールエミュレート部のそれぞれから通知された前記終了メソッドに基づいて、全ての前記試験モジュールエミュレート部が試験信号の電圧の変化の出力を終えた期間を算出し、  前記期間内における前記試験信号を取得して、当該試験信号に基づいて被試験デバイスの前記期間内における動作をシミュレートする被試験デバイスシミュレート部を更に備える  請求項15記載の試験エミュレート装置。【請求項17】前記出力チャネルオブジェクトは、前記終了メソッドの呼び出しを受けた後に、当該終了メソッドにより通知された、既に試験信号の電圧の変化の出力を終えた期間内の電圧の変化を禁止する請求項15記載の試験エミュレート装置。
試験エミュレート装置、試験モジュールエミュレート装置、及びこれらのプログラムを記録した記録媒体
