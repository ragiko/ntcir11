
注 - フォントの使用にはよく注意してください。異なるフォントは区間の正確な外部数学値と区間のマシン表現可能な内部的な近似値を表します。
区間定数
f95 では、区間定数は、単一の整数または角括弧で囲んだ実 10 進数 [3.5] のいずれか、あるいは、一対の整数またはコンマで区切り角括弧で囲んだ実 10 進数 [3.5 E-10, 3.6 E-10] のいずれかです。縮退した区間がマシンで表現できない場合、正確な算術値は指定された丸めを使って、内部的な制約を満たすことが明らかな内部的なマシン表現可能な区間に丸められます。
デフォルトINTEGER、デフォルト REAL または REAL(8) の両終了点を持つ 区間定数はデフォルト型区間を持ちます。
終了点の型がデフォルト INTEGER、デフォルト REAL または REAL(8) である場合、その終了点は内部的に REAL(8) 型の値へと変換されます。
終了点の型が INTEGER(8) である場合、その終了点は内部的に REAL(16) 型の値へと変換されます。
終了点の型がINTEGER(4)である場合、その終了点は内部的に REAL(8)型の値へと変換されます。
終了点の型が INTEGER(1) または INTEGER(2) である場合、その終了点は内部的に REAL(4) 型の値へと変換されます。
両方の終了点が REAL型であり、異なる KTPV を持つ場合、それらはより大きい小数点精度を持つ終了点の近似値手法を用いて内部的に表現されます。
区間定数の KTPV は、最大小数点精度を持つ部分の KTPV です。
コード例 2-1 は、さまざまな 区間定数の KTPV を示しています。
コード例 2-1 	  区間定数の KTPV
math% cat ce2-1.f95
IF(KIND([9_8, 9.0])      == 16 .AND. &
KIND([9_8, 9_8])      == 16 .AND. & 
KIND([9_4, 9_4])      == 8  .AND. & 
KIND([9_2, 9_2])      == 4  .AND. &
KIND([9, 9.0_16])     == 16 .AND. & 
KIND([9, 9.0])        == 8  .AND. & 
KIND([9, 9])          == 8  .AND. & 
KIND([9.0_4, 9.0_4])  == 4  .AND. & 
KIND([1.0Q0, 1.0_16]) == 16 .AND. & 
KIND([1.0_8, 1.0_4])  == 8  .AND. & 
KIND([1.0E0, 1.0Q0])  == 16 .AND. & 
KIND([1.0E0, 1])      == 8  .AND. & 
KIND([1.0Q0, 1])      == 16 ) PRINT *, 'Check'
END
math% f95 -xia ce2-1.f95
0.1 または [0.1,0.2] のような Fortran 定数は、定数が表す外部値と内部的な近似値の 2 つの値に関連付けられます。Fortran では、定数の値はその内部的な近似値です。定数の外部値と定数の内部的な近似値とを区別する必要はありません。区間ではこれを区別する必要があります。Fortran 定数の外部値を表すには、次の表記が用いられます。
ev(0.1) = 0.1、または、ev([0.1,0.2])= [0.1, 0.2]
ev の表記は外部値を表します。
Fortran 規格に従えば、区間定数の数値は、その内部的な近似値となります。区間定数の外部値は常に明示的にそのように標識付けられます。
たとえば、区間定数 [1, 2] とその外部値 ev ([1, 2]) は、数学値 [1, 2] と同じです。しかし、ev ( [0.1, 0.2] ) = [0.1, 0.2] ですが、数 0.1 と 0.2 はマシンで表現できないので、[0.1, 0.2] は単なるマシンの内部的な近似値にすぎません。このため、区間定数の値 [0.1, 0.2] は、マシン内部の近似値なのです。この外部値は ev ( [0.1, 0.2] ) で表されます。
厳密区間式処理のもとでは、他の Fortran 数値定数の場合と同様に、区間定数の内部的な近似値は固定されます。REAL 定数の値はその内部的な近似値です。同様に、区間定数の内部的な近似値の値は定数の値として参照されます。定数の外部値 (標準 Fortran の定義概念ではありません) は、その内部的な近似値と異なることもあります。最大幅要求式処理のもとでは、区間定数の値は文脈に依存します。しかしその場合でも、strict と最大幅要求式処理の両方で、区間定数の内部的な近似値はその外部値を含まなければなりません。
任意の数学定数と同様に、区間定数の外部値は不変です。名前付き区間定数 (PARAMETER) の外部値は 1 つのプログラム単位の中では変更できません。しかし、任意の名前付き定数の場合と同様に、異なるプログラム単位間では同じ名前付き定数に異なる値を関係付けることができます。
区間は不透明ですから、区間を内部的に表現するのに必要な情報を格納する言語要件は存在しません。区間の最大下限と最小上限にアクセスするために組み込み関数が提供されています。しかし、区間定数は順位付けられた 1 対の REAL または区間定数により定義されます。定数はカンマにより区切られ、1 対の情報は角括弧で囲まれます。第 1 定数は最大下限 (infimum) であり、第 2 定数は最小上限 (supremum) です。
角括弧の中に 1 つの定数が現れる場合に限り、表現される区間は縮退して、同じ最大下限と最小上限を持つようになります。この場合、単一の小数文字定数の外部値を含むことが保証された区間の内部的な近似値が構築されます。
有効な区間は、最小上限より小さいかまたは等しい 1 つの最大下限を持たなければなりません。同様に、区間定数もまた、その最小上限より小さいかまたは等しい 1 つの最大下限を持たなければなりません。たとえば、次の部分コードは true と評価されなければなりません。
INF([0.1]) .LE. SUP([0.1])
コード例 2-2 は、有効な区間定数と無効な区間定数を含んでいます。
区間定数に関する追加情報については、「参考文献」で引用している捕捉 [4] を参照してください。
コード例 2-2 	  有効な区間定数と無効な区間定数
内部的な近似値
REAL 定数の内部的な近似値は定数の外部値と同じであるとは限りません。たとえば、10 進小数 0.1 は 2 進の浮動小数点数集合のメンバーではないので、この値は 0.1 に近い 2 進の浮動小数点数によって近似されます。REAL データ項目について、Fortran 規格では近似の正確性は指定されていません。区間データ項目については、区間定数を記号的に表現するのに使われる 10 進小数を使用して定義された 1 組の数学値を含むことで知られた、一対の浮動小数点数値が用いられます。たとえば、数学区間 [0.1, 0.2] は、区間定数 [0.1,0.2] の外部値です。
Fortran 言語に REAL 定数の正確な近似値を求める要件が存在しないのと同様に、狭い幅の区間定数を使って区間の外部値の近似値を求める言語要件も存在しません。区間定数にはその外部値を含むという要件があります。
ev(INF([0.1,0.2])) 
inf(ev([0.1,0.2])) = inf([0.1, 0.2])
および、
sup([0.1, 0.2]) = sup(ev([0.1,0.2])) 
ev(SUP([0.1,0.2]))
です。
f95 の区間定数は鋭い値です。これは、実装品質の特性です。
区間文
区間宣言文は、f95 の Fortran 言語に追加された唯一の区間固有の文です。区間データ項目との対話を行う 区間宣言文と標準 Fortran 文の詳細な解説については、「INTERVAL」を参照してください。
データ型とデータ項目
f95 のコマンド行に、-xia、または、-xinterval オプションが入力されるか、あるいは、これらのオプションが widestweed とstrict のいずれかに設定されると、INTERVAL データ型は f95 の組み込みの数値データ型として認識されます。f95 のコマンド行にいずれのオプションも入力されないか、あるいは、使用しないと設定されると、INTERVAL データ型は組み込みのデータ型とは認識されません。区間のコマンド行オプションの詳細については、「区間のコマンド行オプション」を参照してください。
名前:INTERVAL
6 個の組み込みの Fortran データ型に、組み込み型の INTERVAL が追加されています。INTERVAL 型は、区間データ項目の内部形式が明記されていないという意味で不透明です。しかし、区間データ項目の外部形式は、区間データ項目と同じ種別型パラメータ値 (KTPV) を持つ一対の REAL データ項目です。
種別型パラメータ値 (KTPV)
区間データ項目は、最大下限と最小上限で構成される算術区間の近似値です。区間データ項目は他の数値データ項目のすべての特性を持っています。
デフォルト区間データ項目の KTPV は 8 です。KTPV の指定のないデフォルト区間データ項目のサイズは 16 バイトです。f95 のデフォルト区間データ項目のサイズは、-xtypemap、または、-r8const コマンド行オプションを使って変更することはできません。より詳細な情報については、「-xtypemap と -r8const コマンド行オプション」を参照してください。このため、-xtypemap を使ってデフォルトの REAL と INTEGER データ項目のサイズが変更されなければ、次のようになります。
KIND([0])= 2*KIND(0) = KIND(0.0_8) = 8
サイズと境界整列のまとめ
INTERVAL 型のサイズと境界整列は、f95 コンパイラオプションの影響を受けません。表 2-2 は、INTERVAL のサイズと境界整列を含んでいます。
表 2-2 	  INTERVAL のサイズと整列
注 - 区間配列は要素と同じ並びになります。
区間配列
区間配列は、異なる数値型のすべての配列特性を持っています。区間配列の宣言については、コード例 2-25 を参照してください。
次の配列組み込み関数については、区間バージョンがサポートされています。
ALLOCATED()、ASSOCIATED()、CSHIFT()、DOT_PRODUCT()、EOSHIFT()、KIND()、LBOUND()、MATMUL()、MAXVAL()、MERGE()、MINVAL()、NULL()、PACK()、PRODUCT()、RESHAPE()、SHAPE()、SIZE()、SPREAD()、SUM()、TRANSPOSE()、UBOUND()、UNPACK()
MINVAL と MAXVAL 組み込み関数が区間配列に適用されると、配列の要素により処理されない区間値を返す可能性があるので、区間配列用の MINLOC() と MAXLOC() 組み込み関数は定義されていません。MAX と MIN 組み込み関数の解説については、下記の節を参照してください。
「最大:MAX(X1,X2,[X3, ...])」
「最小:MIN(X1,X2,[X3, ...])」
例:MINVAL((/[1,2],[3,4]/)) = [1,3]
MAXVAL(/[1,2],[3,4]/) = [2,4]
次の組み込み区間個別関数については、配列バージョンがサポートされています。
ABS()、INF()、INT()、MAG()、MAX()、MID()、MIG()、MIN()、NDIGITS()、SUP()、WID()
次の組み込み区間算術関数については、配列バージョンがサポートされています。
ACOS()、AINT()、ANINT()、ASIN()、ATAN()、ATAN2()、CEILING()、COS()、COSH()、EXP()、FLOOR()、LOG()、LOG10()、MOD()、SIGN()、SIN()、SINH()、SQRT()、TAN()、TANH()
次の区間構成子については、配列バージョンがサポートされています。
INTERVAL()、DINTERVAL()、SINTERVAL()、QINTERVAL()
区間演算式
区間算術式は、他の数値データ型と同じ算術演算子から構築されます。区間式と非区間式間の基本的な相違点は、任意の可能な区間式の結果が区間演算の包合の制約を満たす有効な区間であるということです。これと対照的に、非区間式の結果は任意の近似値であってもかまいません。
混合モードの区間式
混合モード (区間の点) 式は包含を保証するために、最大幅要求式処理が必要となります。-xia コマンド行マクロ、または、-xinterval コマンド行オプションを使用して区間サポートが呼び出された場合の式処理は、デフォルトで最大幅要求となります。最大幅要求の評価が好ましくない場合は、-xia=strict、または、-xinterval=strict のオプションを使って厳密式処理を呼び出してください。厳密式処理のもとでは、混合モードの区間式はコンパイル時エラーとなります。区間とCOMPLEX オペランド間の混合モード演算はサポートされていません。
最大幅要求式処理を使うと、区間式中のすべてのオペランドの KTPV は、全体を通じて最大の区間 KTPVである KTPVmaxへと昇格されます。
注 - KTPV 昇格は式の評価前に実行されます。
最大幅要求式評価の保証:
区間の包含
型または精度の変換は、変換された区間に幅を追加しません。
注意 - 
厳密式処理を使用する必要が特別にない限り、最大幅要求式処理を導入することを強く推奨します。任意の式または式の一部では、明示的な INTEVAL 型と KTPV の変換が常に発生します。
次の例では最大幅要求式処理の動作と効果を示しています。各例には、次の 3 つのコードブロックが存在します。
式処理モード (最大幅要求または厳密) から独立した一般的なコード
最大幅要求コード
厳密と等価なコード
例は、次の 3 つのメッセージを伝えるように設計されています。
特別な環境にある場合を除き、最大幅要求式処理を使用してください。
最大幅式処理は有効であるが、使用したくない場合は、いつでも区間構築子を使って型と KTPV の変換を強制実行するよう上書きすることができます。
厳密式処理を使う場合、INTERVAL 型と精度変換は区間定数と区間構築子を使用して明示的に指定されなければなりません。
値の代入
区間の代入文は、区間のスカラー、配列要素または配列式の値を区間変数、配列要素または配列に代入します。この構文は次のとおりです。
V = expr
expr は区間演算または配列式の可変部分であり、V は区間変数、配列要素または配列です。
区間の代入を実行すると、最大幅要求または厳密式処理を使用して式が評価されます。この後で、結果の値が V に代入されます。最大幅要求式処理を用いた式の評価では次の手順が発生します。
1.	 すべての点 (非区間) データ項目の区間 KTPV が計算されます。
点項目が整数であれば、結果としての区間の KTPV は整数の KTPV の 2 倍となります。その他の場合、区間の KTPV は点項目の KTPV と同じです。
2.	 代入文の左側を含む式が走査され、KTPVmax で表される最大区間 KTPV が求められます。
3.	 式の評価に先立ち、区間式の中のすべての点と区間データ項目が式の評価に先立ち、KTPVmax へと昇格されます。
4.	 KIND(V) < KTPVmax であれば、式の結果は KTPV = KIND(V) を持つ区間を含むものへと変換され、その結果としての値が V に代入されます。
コード例 2-3 	  KIND (左側) に依存するKTPVmax
f95 区間リファレンス
