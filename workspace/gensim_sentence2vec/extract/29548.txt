
プリエンプティブ モデルと協調スケジューリング モデルには、複数のタスク間でコンピューティング リソース (たとえば、プロセッサ、ハードウェア スレッド) を共有できるようにする一般的な方法として 2 つの方法があります。
プリエンプティブ スケジューリングと協調スケジューリング
プリエンプティブ スケジューリングは、ラウンド ロビン方式の優先順位ベースのメカニズムで、すべてのタスクに対し、コンピューティング リソースへの排他アクセス権を所定の時間だけ与え、その後別のタスクに切り替えます。
プリエンプティブなスケジューリングは、マルチタスクのオペレーティング システム (Windows など) の一般的な.協調スケジューリングは、タスクが完了するまで、またはタスクにそのリソースへのアクセスが得られますまで、コンピューティング ・ リソースに各タスクの排他アクセスを提供するメカニズムです。  同時実行ランタイムは、協調スケジューリングとオペレーティング システムのプリエンプティブ スケジューラを併用して、処理リソースを最大限に活用します。  
プリエンプティブ スケジューラは、複数のスレッドに対し、コンピューティング リソースへの公平なアクセス権を付与しようとすることで、すべてのスレッドを進行させます。
多くのコンピューティング リソースのあるコンピューターでは、公平なアクセスを保証すると問題は減少しますが、リソースを効率的に使用することを保証すると問題が増えます。  
プリエンプティブ カーネル モード スケジューラでは、スケジュールの決定をオペレーティング システムに依存するアプリケーション コードが必要になります。
これに対し、ユーザー モード協調スケジューラでは、アプリケーション コードで独自のスケジュールを決定できます。  協調スケジューリングにより、アプリケーションは多くのスケジュールの決定を実行できるため、カーネル モードの同期に関連するオーバーヘッドが大幅に減少します。  協調スケジューラは、スケジュールするその他の作業がない場合、通常はスケジュールの決定をオペレーティング システムのカーネルに委ねます。  また、カーネルに伝達されるブロック操作がある一方で、その操作がユーザー モード スケジューラに伝達されない場合にも、協調スケジューラはオペレーティング システムのスケジューラに従います。  
プリエンプティブ スケジューラにとって、同じ優先順位を持つ作業はすべて同等です。
プリエンプティブ スケジューラは、通常、作成された順番にスレッドをスケジュールします。  さらに、プリエンプティブ スケジューラは、すべてのスレッドに対し、スレッド優先順位に基づきラウンド ロビン方式でタイム スライスを与えます。  このメカニズムは公平です (すべてのスレッドが進行します) が、ある程度効率が損なわれます。  たとえば、計算量が非常に多いアルゴリズムには、公平性は不要です。  代わりに、全体の時間を最小にして関連するタスクを終了させることが重要になってきます。  協調スケジューリングにより、アプリケーションはより効率的に作業をスケジュールできます。  たとえば、多数のスレッドを使用するアプリケーションを考えてみます。  リソースを共有しないスレッドが同時に実行されるようにスケジュールすると、同期のオーバーヘッドを減少させることができ、それにより効率を向上させることができます。  タスクをスケジュールするもう 1 つの効率的な方法は、同じプロセッサでタスクのパイプラインを実行する方法です。タスクのパイプラインでは、前のタスクの出力に基づき各タスクが実行され、各パイプライン ステージの入力がメモリ キャッシュ内に事前に読み込まれます。  
同時実行ランタイムとその他の同時実行モデルの比較
