
char
charは、Unicodeで1文字を表す(つもりで用意された)プリミティブ型。[2007-05-03]
シングルクォーテーションで囲むと文字定数になる。[2010-06-20]
文字の中にエスケープ文字を指定可能。
Unicodeは元々16ビットで1文字を表すつもりだったらしく、char型も16bit。
しかしUnicodeは21ビットで1文字を表すよう改められたらしく、char1つでは厳密には1文字を表せなくなった。
(char1桁ではサロゲートを表せない。Java言語仕様第3版3.10.4章参照[2008-09-13])
そこでJDK1.5から、コードポイント(codePoint)が導入された。コードポイントとは、Unicodeで1文字分のコードを示す言い方。Javaではコードポイントはint型で表す。
Stringクラス等には、コードポイントを扱うメソッドが色々追加されている。
コードポイント1つで1文字を表すが char1桁では足りないため、長い文字コード(補助文字/サロゲート)の場合はchar2桁で1文字を表すようになったらしい。(いわばUTF-16で表現)
(この2桁のcharをサロゲートペアと呼ぶ。先に来るのが上位サロゲート、次のcharが下位サロゲート[2008-04-23])
たぶん今Javaの規約を作るならchar型は24bitにしたいところだろうけど、それじゃメモリ境界的にパフォーマンスがよくないから、32bitになるんだろうなぁ…。
参考: ITアーキテクトの文字操作の変革
JDKがどのバージョンのUnicodeに準拠しているかは、CharacterクラスのJavadocに書かれている。[2008-09-13]
Java言語仕様第3版3.1章によれば、JDK1.4はUnicode3.0、JDK1.5はUnicode4.0。
String
Stringは、内容が変更されない文字列を保持する。
JavaVM(実行時)では、中身はUnicode。いわばchar型の固定長の配列。
ダブルクォーテーションで囲むと文字列定数になる。[2010-06-20]
文字列の中にタブや改行を直接入れることは出来ないので、エスケープ文字を使う。
Stringは不変なので、初期化の際に(キャラセットの指定もせずに)newでインスタンス化するのは無意味。
馬鹿な例:
String str = new String();
str = "abc";
//	直後に代入しているので初期化した値(new String())は使われず、全くの無駄!! せめてnullとか""にすべき
"abc"が代入された時点で 以前strに保持されていたStringインスタンスは使用されなくなるので、全く意味が無い。
それどころか、newで作成したときにメモリ確保が行われ、GCで解放処理を行う必要が生じてしまうので、無駄・邪魔・余計。
馬鹿な例 その2: [2007-02-14]
String str = new String("abc");	//内容は"abc"と同じなのに新しいオブジェクトを作っているのでムダ
String str = "abc".toString();	//"abc"と全く同じオブジェクトを返す…
※"abc"とnew String("abc")は別インスタンスだが、"abc"とnew 
String("abc").intern()は同一インスタンス。intern()は、文字列プールの中で一意となるStringを返す為。[2007-06-20]
参考: JavaFAQ: 文字列
Stringでよく使うメソッド
内容
例
備考
更新日
Java文字列メモ(Hishidama's Java String Memo)
