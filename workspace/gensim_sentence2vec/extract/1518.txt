Weka入門
決定木とデータセットの作り方
インストール手順
まずは決定木を作ってみよう
入力データを用意しよう
分析結果の意味を知ろう
tips
キーワード: データマイニング weka 決定木
この文書を自由に改変、転載することを許可します。連絡不要
Wekaインストール
Weka入手場所 http://www.cs.waikato.ac.nz/~ml/weka/index_downloading.html
Windows版では2種類ダウンロードできるファイルがあるが、これはJavaが含まれているかどうかの違いです。
お手持ちのPCにJava環境が入っていればwithout the Java VMの方を。
Javaが入っているかどうかわからない、もしくはJavaのバージョンが1.4より古い場合は includes Java VM 1.4の方をダウンロードして下さい。
図1
http://www.cs.waikato.ac.nz/~ml/weka/index_downloading.htmlにアクセスすると図1のページに行く。
Click hereと書かれたリンクをクリックすると次のページ図2に移る。
図2
weka-3-4-12jreというファイル(2008.5.21現在)がダウンロードされます。
図3
ダウンロードが完了すると、図3のファイルが指定した場所に置かれます。
これをダブルクリック。
図4
環境によってはこのような警告が出るかもしれませんが、躊躇わず実行ボタンをクリック。
図5
以降はひたすらNextをクリックし続けるだけでインストール完了。お疲れ様でした。
まずは決定木を作ってみよう
Wekaでデータマイニングを実行する場合、主な目的は決定木を作ることです(多分。特に松村研の発表では)。
Wekaで決定木を作ることは非常に簡単です。
データを用意するのは時間・手間が掛かりますので、まずは既に用意されてる学習用のサンプルデータを用いて決定木を作ってみましょう。
Wekaを起動させると図6が表示されます。
図6
4種類の操作方法が用意されていますが、最も簡単に操作できる『Explorer』を利用しましょう。
Explorerボタンを押すと図7が表示されます(ちなみに、図7のWeka Explorerが立ち上がったら図6のWeka GUI Chooserは消してしまっても構いません)
図7
では、用意されたサンプルデータをWekaに読み込ませましょう。
図7、Weka Explorerの左上にある『Open file...』と書かれたボタンをクリック。
図8
『data』フォルダを選択。
図9
『iris.arff』を選択し、開く。
図10
正しく読み込めていれば、図10のようになります。
さて、下準備が終わったところで、そろそろ決定木を作りましょう。
図10の左上のタブ『Classify』をクリック。
図11
図11の左上、『Classifier』欄の『Choose』ボタンをクリック。
図12
J48を選択。これはWekaが実行できる様々な学習型分類アルゴリズムの中で、J4.8という特にメジャーなアルゴリズムを利用しますということ。
J4.8アルゴリズムはC4.5という決定木+データ更新+枝刈りをまとめて実行するアルゴリズムの改良版です。
詳しいことはともかく、J4.8というものを使っておけばよいのだと、とりあえず覚えて下さい。
図13
ここまで正しい順序を踏んでいけば、図13となります。
図13の左中央『Start』ボタンをクリック。
図14
図14。決定木が作成されました。
ただ、このままでは見づらいので、ぱっと見ただけで理解できるようにVisualizeしましょう。
図15
図15の左中央下のResult list (right-click for options)欄にある、実行したコマンドを右クリックするとオプションメニューが表示されます。
その中の『Visualize tree』を選択すると、次の図16のように決定木をVisualizeします。
図16
決定木作成の手順は無事に終了しました。
ここまで上手く行きましたか?
他にもサンプルのデータがあるので、色々試してみて操作に慣れて下さい。
入力データを用意しよう
Wekaではarff、csvと呼ばれる形式のファイルが読み込めます(他の形式もありますが、恐らく皆さんが使う必要はありません)。
arff形式はWeka独自の形式で、Wekaが一番扱いやすいタイプだと言えます、
csv形式(データを,で区切るタイプ)の方が一般的ではありますが(csvだとExcelなどでも扱える)、
6万行以上は読み込めないなどの様々な制限もありますので、arff形式でデータを扱う練習をしましょう。
まずは例としてサンプルデータを開いてみましょう。
Wekaのバージョンが3.4の場合、C:\Program Files\Weka-3-4\dataにarffファイルがあります。
その中で、weather.arffをメモ帳やテキストエディタで開いて下さい(特にEmEditorというテキストエディタをお薦めします。完全に個人的趣味による選択です)。
開いてみると下のようになっています。
@relation weather
@attribute outlook {sunny, overcast, rainy}
@attribute temperature real 
@attribute humidity real 
@attribute windy {TRUE, FALSE} 
@attribute play {yes, no}
@data 
sunny,85,85,FALSE,no 
sunny,80,90,TRUE,no 
overcast,83,86,FALSE,yes 
rainy,70,96,FALSE,yes 
rainy,68,80,FALSE,yes
(以下中略)
Wekaで扱うデータは次のように設定します。
@relation [文字列]
これはデータセットの名前です。
分析上、特に重要なものではありませんので適当につけてください。
@attribute [属性名] [属性のタイプ]
属性タイプは大きく分けて数値型、名義型があります。
属性が数値の場合はreal(古い本には実数型はnumeric、整数値はintegerと使い分けよと書いている場合もありますが、
Weka3.4以上のバージョンでは数値型は全てrealにまとめることができます)、
名義型の場合はタイプの集合を{}で囲み、","で区切ったものを入れてください。
例えば、属性として年齢、性別を考えたい場合は
@attribute age real
@attribute sex {man, women}
となります。
最後の@attribute行には目的変数に該当する属性を入れます。
特にWekaではこのattribute最終行の属性名をclassとすることが多い(classにしないとエラーになる、という訳ではない)。
@data [@attribute一行目], [@attribute二行目], ……, [@attribute n行目]
上記のattributeに基づいて、実際のデータを入力していきます。
基づいて、というのは、attributeの数・タイプに合わせてデータを入力していくということです。
上記のweatherの例で言えば、attributeの数が5ですから、各データのカラムも5必ず入力しなければなりません。
また、attributeで型が数値に指定されている項では必ずdataも数値(英数字のみ。漢数字不可)で入力します。
attributeで型が文字列型の場合は文字列を入力します。
では、習うより慣れろということで、実際にデータを作ってみましょう(形式に慣れるためだけのデータであり、値そのものは適当です)。
ここでは、どういう人がそのOSを使うかという決定木を作りたいとします。
分析者は「OSの選択にはきっと性別と年齢と年収とパソコン歴の4つが関わっているに違いない」と考えるならば、
属性はその4つと、さらに目的変数であるclass(この場合OS)の計5つを指定します。
@relation SelectOS
@attribute sex {man, women}
@attribute age real
@attribute income {poverty, middle, rich}
@attribute year real
@attribute class {windows, mac, linux}
@data
man, 24, poverty, 5, windows
man, 31, middle, 10, linux
women, 27, middle, 3, mac
man, 53, rich, 20, linux
women, 22, middle, 1, mac
man, 29, middle, 7, windows
man, 23, poverty, 3, windows
man, 53, rich, 20, linux
man, 31, poverty, 6, linux
women, 25, rich, 3, windows
このようにデータを作成しました。
さて、ではこのデータをos.arffと名前付けして(拡張子に注意)
wekaで決定木を作成しましょう。
図17
図17から、どうもOS選択に年収とパソコン歴は関係ないようです。
年齢が29才より上の世代ではLinuxを、それ以下では男性はwindows、女性はmacを使っているようだという結果が出ました。
このデータは適当に作っただけですが、このようにWekaで決定木を作ることに成功しました。
データセットの作り方とWekaで決定木を作る方法をあなたはマスターしました。
これでデータマイニングを実際に実行することが可能です。
お疲れ様でした。
分析結果の意味を知ろう
決定木を作る際、様々な実行結果が表示されます。
あれの意味は何でしょうか?そして図16、17の決定木に表示されている数字は何を表しているのか?
最後にそれを学びましょう。ここまでやれば一通りのデータマイニングが可能です。
つまり、レポート作成して単位取って、就活でシンクタンク回って「データマイニング出来ますよ」
と法螺を吹いて回っても全くの嘘ではないと言えなくもないと言い切れぬような雰囲気があるようなないような、そんな感じです。
まずはわかりやすい決定木の方から。
図17をもう一度見ましょう。
age, sexは円で囲まれ、windows, mac, linuxは四角で囲まれています。
円で表されているのは属性であり、決定木の分岐を表しています。
四角で表されているのはクラスであり、決定木の葉を表しています。
ageから伸びた枝の上に>29と書いてあるのは、「age属性の数値が29より上であれば、こっちの枝に進む」ということです。
そしてwindows(linux)の右横に3.0(4.0)という数値が書かれているのは
「全データ中このクラスに属するモノが3(4)つある」ということです。
かなり気になるのがmacの右横、(3.0/1.0)という表示。
これは「このクラスには属するモノは3つある。けれど、そのうちの1つは間違った分類である」事を示しています。
先程作ったデータセットSelectOSをもう一度見直し、sex = womenの行だけ抜き取ってみましょう。
women, 27, middle, 3, mac
women, 22, middle, 1, mac
women, 25, rich, 3, windows
確かに、sex = women, class = macのクラスには1つ誤りがありますね。
次に、実行結果を見てみましょう。
weather.arffを例に取ります。
=== Run information ===
以下の欄はこういう状況で決定木を作りましたというだけの話なので省略。
=== Classifier model (full training set) ===
以下の欄はデータから生成した決定木を表していますが、これを見るより
Visualizeしたものを見た方が分かり易いのでここも省略。
問題はここからです。
=== Stratified cross-validation ===
=== Summary ===
Correctly Classified Instances 9 64.2857 %
正しく分類された数とその割合
Incorrectly Classified Instances 5 35.7143 %
誤って分類された数とその割合
Kappa statistic 0.186 
K統計量。判定者内一致度
Mean absolute error 0.2857
平均絶対誤差。予測精度。低いほど良い
Root mean squared error 0.4818
二乗平均平方根。変化量を統計的に評価する手法。予測精度。低いほど良い
Relative absolute error 60 %
Root relative squared error 97.6586 %
Total Number of Instances 14 
決定木を作るのに寄与したインスタンスの数
cross-varidationは交差確認法(交差検証法)と呼ばれる統計手法で、詳しい内容は難しいのでここでは扱いません。
Correctly Classified Instancesは正しく分類されたインスタンスの数と、それの全体との割合です。
Incorrectly Classified Instancesはの逆で、間違って分類されたインスタンスの数と全体との割合になります。
Kappa statisticはk統計量と呼ばれるもので、主観が入ってしまうような検定の場合、k人の検定結果を照らし合わせて、
照らし合わせた結果が等しいものであった場合のみ、その結果を採択するというように使います。
とりあえず「Correctly Classified Instancesが高ければ良い」と大雑把に覚えておきましょう。
=== Detailed Accuracy By Class ===
FP Rateは低い方が、それ以外は高い方が好ましい。
=== Confusion Matrix ===
a b   <-- classified as
7 2 | a = yes
3 2 | b = no
これは分類a(ここではyes)に9のインスタンスが属していることを示します。
そのうち、yesに属すべきインスタンスが7、noに属すべきインスタンスが2含まれています。
同じく、分類b(ここではno)にはbに属すべきnoインスタンスが2、aに属すべきインスタンスが3含まれています。
分類が正しく行われたかどうかは左肩から右下にかけての対角線を見ればよいことになります。
tips
1)データの書き方について
欠損値は?と入力する。コメントは%の後ろに書く。
2)散布図を表示出来る設定にしよう
図18
図18のChooseボタンの右の欄(J48と書いてあるところ周辺)をクリックすると図19が出てくる。
図19
デフォルトではFalseになっているsaveInstanceDataをTrueにすると、
決定木作成Visualize Treeで描画された木の葉(ノード)をクリックすると
図20のような散布図が表示されるようになる。
図20では赤い×が2つ右端に描かれているが、
これはX軸のoutlookがrainyで、Y軸のtemperatureが65,71のインスタンスが存在し、
なおかつClass colourの欄からわかるように赤色はplay:noであるから、
これらのインスタンスは天気:雨、温度(華氏表記?)65と71の場合はプレイしないと言うことが見て取れる。
図20
3)不要な属性をRemoveしよう
データweather.arffで決定木を作ってみると、木の生成にtemperatureが関わっていないことに気付いた。
と言うことは不要な属性だ。不要な属性が混ざっていると、解析の精度が下がる。Removeしよう。
Preprocessタブをクリックすると、画面中段左下にAttribute欄がある。図21参照。
図21
この欄には各属性が表示されており、クリックすると画面右下のヒストグラムが変化する。
ちなみに、このヒストグラムは各属性とクラスの関係を表している。
例えば、Weather.arffであれば、棒グラフの青い部分はyes、赤い部分はnoに属するインスタンスであることを示す。
さて、temperatureの左側のチェックボックスにチェックを入れて、
Attribute欄の下部にあるRemoveボタンをクリックするとRemove完了。
先程と同じ手順で決定木を作ってみると、結果が改善されていることがわかる。
Remove前処理結果
Remove後処理結果
このように、不要な属性や明らかに異常値を含むインスタンスを除去して処理結果を改善させることを
データクレンジング、データクリーニング等という。
4)WekaでCSVデータを利用してみよう
WekaではCSVファイルを読み込むこと、arffファイルをCSV形式にして出力することができる。
まず、arffファイルをCSV出力するには、
Preprocessタブ  画面右上のSaveボタンをクリック  ファイル形式選択でCSVを選択すればよい。
そうして出力されたファイルは次のようになっている。
outlook,temperature,humidity,windy,play 
sunny,85,85,FALSE,no 
sunny,80,90,TRUE,no 
overcast,83,86,FALSE,yes
以下略
ここから読み取れるように、CSV形式でWekaに読み込ませる場合は
属性を一行目に書き、その下の行から各インスタンスを記述していけばよいことがわかる。
記述の手間という点においてはCSV形式の方が扱いが楽な場合も多い。
CSV形式であればExcelや他のデータベースソフトを利用することも可能である。
なお、CSV形式の場合、6万行以上読み込むとエラーが出るらしい。
CSV形式では属性の型をしていない。
Wekaが内部で型を推測して処理するため、時間も掛かるし
データセット内に型を誤ったインスタンスが存在してもエラーを返さない場合がある。
出来ればWeka独自のarff形式でデータセットを作成しよう。
5)大文字、小文字の扱い
Wekaは大文字と小文字を区別する。
そのため、属性でsex {man, women}と宣言しておきながら
インスタンスの方でManやWOMENなどと記述するとエラーになる。
Weka入門 〜決定木とデータセットの作り方〜 in松村研
