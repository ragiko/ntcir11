残りのヒント
ヒント
1.まず、2週目前半の内容(事例集合Aを用いて配布資料の基礎編の図2に示されたような誤認識率と学習モデルの複雑度との関係を選択基準ごとに検証する)が完了しているかどうかを確認してください。
2.完了している場合は、配布資料の実践編に書いてある通りに、「枝刈り」の実装を開始します。枝刈りを実装するためには、以下を最初に実施してください。
2.1 ソースコードの冒頭の#defineの箇所に
#define MAXNODE 
31 //最大ノード数 = 2^MAXDEPTH - 1
を追加してください。この例では、決定木の最大深さMAXDEPTHを5にした場合の値です。最大ノード数は2のMAXDEPTH乗-1以上に設定してくださいネ。
2.2 ノードの構造体に以下の変数を追加してください。
double                         g;
//枝刈り基準値
3.次に枝刈り関連の関数群を理解しておきましょう。
3.1 SumSubNodes(Tnode *n)は、ノードnの下位にある判別ノード数を求めて、その値+1を返します。
3.2 SumIncorrectCases(Tnode *n)は、ノードnの下位にあるクラスノードに分類された事例の中から誤認識された事例数を返します。返り値はこのノードに対して枝刈りを行う前の誤認識率の計算に用います。
3.3 ComputeG(Tnode *n, int md)は、決定木をルートから下位の方向に辿って各判別ノードにて枝刈りの基準値g(n)を計算し、その値をノードの変数gに格納する関数です。
3.4 FindMinG(Tnode *n, double min_g)は、決定木をルートから下位の方向に辿って各判別ノードの持つ枝刈りの基準値の中から最小値を探し、その値を返します。
3.5 PruneNode(Tnode *n, double min_g)は、決定木をルートから下位の方向に辿って最小値の枝刈りの基準をもつ判別ノードに対して枝刈りを行います。ただし、最小値の枝刈りの基準をもつ判別ノードが複数ある場合は、すべてに対して枝刈りを行いますが、枝刈り回数は1回とみなします。
4.枝刈りの基準がもっとも小さい判別ノードから順番にルートまで枝刈りを行うサンプルをダウンロードし、これをコードの解読や実行などで理解してください。このコードは1週目の利得(平均情報量の最小化版)のサンプルに対してヒント2の定数・変数の追加、ヒント3の関数の追加、及びmain()の変更を行ったものです。実行結果はこれです。さて、枝刈りは何回実施すればよろしいでしょうか?
5.次は適切な枝刈りの回数を求めて、この回数で枝刈りを行う、配布資料の基礎編の3.2章のアルゴリズムを実装します。N-交差検証法の実装と同様、main()を変更すればいいわけです。一部欠けているmain関数のサンプルはこれです。これまで得た知識を用いてQ1,Q2,Q3箇所を自分で変更した後、ヒント4のサンプルと統合してください。参考のために、MAXDEPTH、 MAXNODE、WIDTH、及びNをそれぞれ5、31、0.1、及び10に設定したときの結果はこれです。これができましたら、これまで作成したプログラムにこの機能を追加(パラメタで3.2章のアルゴリズムの機能が指定できるように)してください。
6.最後に、配布資料の実践編に書いてある通りに、事例集合Bを用いて作成した決定木とそれに対して枝刈りを実施した決定木を「決定木の構造」及び未知事例としての事例集合Cに対する「誤認識率」の観点で選択基準ごとに比較してください。レポートの書き方については実践編の第二章(レポート提出要領)を必ず参考にしてください。
以上でお疲れ様!
残りのヒント
