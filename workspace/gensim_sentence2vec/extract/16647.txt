
このくらいまでは図から読み取れます。vol設定値と内部値の関係は簡単に解りますね。設定値×2+1です。
出力電圧も、内部値が4下がると半分になります。
ですので、出力電圧対内部値の式はこうなります。
出力電圧 = 2(n-31)/4
しかし、これら式を信じると、内部値が0の場合の出力電圧が0になりません。
しかも、設定値が0の場合、内部値が1となってしまします。
これは、データシート図からは読み取れませんし、それらしき記述も無いので実測してみました。
これがグラフの下の部分の波形を実際に取った物です。
ぱっと見でも、内部ボリューム値0の箇所が不自然に下に飛び出てることが解ると思います。
ここの電圧は、0V(正確には、DCオフセットが付くので発音停止時と同じ値)です。
また、波形は用意していないですが、エンベローブ時ではなく、ボリューム設定0の時の電圧も発音停止時と同じです。
つまり、ボリューム設定値0の場合は、例外として内部ボリューム値も0となり、内部ボリューム値の出力電圧は0となります。
まとめると、
・エンベローブ時の内部ボリュームは32段階。
・レジスタによるボリューム設定時の内部ボリューム値は、設定値×2+1。ただし、設定値0の場合は内部ボリューム値も0。
・出力電圧 対 内部ボリューム値の関係は、出力電圧 = 2(n-31)/4。ただし、内部ボリューム値0の場合は出力電圧は0。
と、なります。
分周比と発生周波数
トーンジェネレーターの出力周波数は、入力クロックfc(MSXの場合は3.579545MHz/2=1.79MHz)を16分周し、さらにその分周比を設定することになっています。
つまり、データシートによると、出力周波数ftと分周比TPとの関係は、
ft=fc/16/TP
となります。
つまり、TP=1を指定した場合、出力周波数は、入力クロック16clkで一周期(dutyは50%なので、H幅8clk)となります。
実測値もそうなり、TP=2を指定した場合、出力は32clkで一周期となりました。
ここで、TP=0を指定した場合、上記計算式は計算出来ないのですが、実際には波形は出力され、その周期は16clkとなりました。
つまり、TP=0とTP=1の場合は、同じ結果が出力されます。
ノイズ周波数の分周比も同様です。
これも、データシートより、ノイズ周波数fnと分周比NPとの関係は、
fn=fc/16/NP
となります。
ただし、ここでのノイズ周波数とは、ノイズ出力値の変化時間となり、実際にはノイズ周波数ではありません。
各設定値で設定をしている箇所を図に示すと、下図のようになります。
また、データシートによると、エンベローブ周期Tと分周比EPの関係は、
T=fc/256/EP
となります。
これもやはり、EP=1を指定した場合、一周期は256clkとなります。EP=2の場合、一周期は512clkです。
また、EP=0を指定した場合は、EP=1同様、256clkとなります。
ノイズジェネレーター出力波形
ノイズジェネレーターは、chAとchBでノイズを出力した場合、まったく同じ波形が現れます。
そのため、ノイズジェネレーターは1つしかないのことが確認出来ます。
また、生成されるノイズは、1と0の2値がランダムで変化しているだけで、アナログ量的(ボリューム)な変化はありません。
そのため、出力レベルはトーンのボリューム設定と全く同じになります。
ここでのランダム値の変化については、実測から下記のように求めることができました。
同じ周期のトーンとノイズを発生させ、左チャンネルのトーン、右チャンネルにノイズを録音しています。
実測waveと解析ツール一式 約6Mbyte
このwaveと解析ツール(という程の物でもない)を使って、wave解析を行うと、waveからランダムの数列を抽出できます。
で、抽出したテキストファイルの先頭行のまんなからへんと同じ文字列を検索すると、1025行目と2049行目でhitします。
そのあたりよく見比べて、どこがループ開始かを見極めると、131071周期の乱数列だということが解ります(1行128文字で改行してます)。
01101010011111011110001100110110100000101011111010110100010110100111010010111011000101110100111000101001011000000100111011001110
11100011101000110000000010100010011111010010011100110101111100001011001011000101011011011000100011111111000110000111110000010010
00110001101111100010000111011000011010000111001001101010000011110110001011000101110001011000101000001011000100101101011000111101
11001100000101100010100110101100010011011001100011101111010100000011010100010111001100010010100010100011110010010010000100111111
11101011100111111010010001001110101111001110001001010010000001111001111011100010010010110000011111110110011000111101110101000001
01100100010110101101110010111001111000110100010010000011010011111011001101100110111010111101011100100101010010001111100001111000
01100010001000100100011001100111110001010101001100001000000110100101101110011011101111000101110011010000101000101101010100100101
11000001111110100001100011101010100100000010000011110111011011000101100111111000101101001110000101110110000010101001110011010000
11000010110101001001010111000111111000100000001110000110111100000010011101000111011100010100000110000010010110010011011110110111
(先頭の一部分)
この数列に対して、131071周期なので17ビットカウントでループされているので、先頭18文字を切り出してみます。最後の1文字だけは別にします。
011010100111110111
つまり、これは、過去17回が「01101010011111011」というパターンの時、次に出る値は「1」になるという意味です。
同様に、2文字目から18文字を切り出して、
110101001111101111
として、過去17回が「11010100111110111」の時も、次に出る値は「1」になる、という統計ができます。
これを全データに対して行います。手作業じゃ無理なので、ツールの数列整理でできます。
で、この結果を論理圧縮すれば乱数生成式は導き出せるのですが、これそのままだとかなり大変なので、とりあえずソートしてみましょう。
DOSのsortコマンドで十分です。
すると、乱数生成論理は、bit13とbit16だけが関係していることはすぐ解ると思います。たぶん。
生成式も、bit16 xor bit13 xor 1となることが解るでしょう。
つまり、この乱数生成式をVHDL記述で書くならば、Xをstd_logic_vector(16 downto 0)と定義して、
X 
という記述で実現が可能です。このレジスタの生成周期は、分周比NPにより決定します。
以上により、ノイズジェネレーターの内部論理が推測できます。
※このページの内容は、裕之が独自に解析したものであり、また、その内容についての保証もありません。このページの内容について、GI、Microchip、YAMAHA等に質問をするという行為は絶対にしないで下さい。
感想、要望、バグ報告、その他何かありましたら、メールもしくは掲示板にてご連絡ください。

