
C++編(標準ライブラリ) 第2章 vector
'2010/9/18 「イテレータ」の説明を修正。
'2009/4/9 全面的に文章を修正・加筆。「容量に関すること」「生の配列との関連」「vector<bool>」を追加。
'2007/12/21 erase() の使い方について修正。
'2006/3/26 ソース中の誤りを修正。
'2005/5/3 「テンポラリバッファとしての利用」を追加。
'2005/4/10 シーケンスコンテナ、連想コンテナという用語を追加。
'2005/4/6 erase()の使い方について修正。
vectorとは
vectorは動的配列をテンプレートクラスで表現したものです。
動的配列なので、その要素数は必要なときに自動的に変更されます。
通常の配列は、宣言時に要素数を指定しなければなりませんが、vector を使えばその必要がなくなります。
要素数が自動的に変更されると書きましたが、vector はある程度の個数分の領域を事前に一括で確保しておき、
それが足りなくなったとき(新たに要素を追加しようとして、足りなかったとき)に、領域を拡張するのです。
STL に含まれる vector や list(第3章)のように、
データを管理するテンプレートクラスをコンテナと呼びます。
コンテナのうち、vector や list のように、要素が連続的に並ぶコンテナのことをシーケンスコンテナと呼びます。
また、set(第9章)や map(第10章)のように、
要素が常にソートされた状態を保つようなコンテナを連想コンテナと呼びます。
基本的な使い方
それでは、まずは使ってみましょう。
#include <vector>
#include <iostream>
int main()
{
using namespace std;
vector<int> array;  // int型の動的配列
int i;
// 10個の要素を追加していく
for( i = 0; i < 10; ++i )
{
array.push_back( i );
}
// 10個の要素を出力
for( i = 0; i < 10; ++i )
{
cout << array[i] << endl;
}
return 0;
}
vector は std という名前空間に含まれています。
vector をインスタンス化するときに、要素数を指定する必要はなく、冒頭に書いたように、必要に応じて動的に領域が拡張されます。
動的に拡張されるということは、vectorクラスの内部でメモリ確保を行っているので、
場合によっては、処理速度やメモリの断片化などの問題が起こるかも知れません。
そういったことが問題になる場合、コンストラクタに size_type型の引数を与えれば、それに従ってあらかじめ要素を確保してくれます。
vector<int> array( 1000 );  // 初期状態で 1000個分のメモリ空間を持つ int型の動的配列
この場合、要素はデフォルトコンストラクタで初期化されます。
そのため、要素の型が、引数無しで呼び出せるコンストラクタを持っていない場合、この方法での事前確保は行えません。
いずれにしても、大抵の場合、目的としているのは「要素を増やす時に動的確保が発生することを防ぐ」という部分にあるので、
デフォルトコンストラクタを呼び出すのは無駄です。
その場合、代わりの手段として reserve() を使います。
vector<int> array;  // 引数なし
array.reserve( 1000 );   // ここで 1000個分の領域を確保
reserve() は指定された数の要素をただちに確保します。
ただし、指定された数の通りに確保される保証はなく、それより多めに確保される可能性があります(コンパイラ次第)。
また、既に確保済みの要素数よりも少ない値を指定した場合は、何も起こりません。
縮小してくれる訳ではないので注意して下さい。
vector に要素を追加するには、専用のメンバ関数を使用します。
これにはpush_back()、insert() という2つの関数が用意されています。
push_back() は、動的配列の末尾に新しく要素を追加し、insert() は途中に追加します。
ただし、insert() はイテレータという新しい概念を理解しないと使えないので、とりあえず後に回します。
push_back() の方の使い方は簡単で、追加したい要素を引数に指定して呼び出すだけです。
要素を追加したとき、vectorクラスが内部的に持っているメモリが足りなければ、一括していくらかのメモリが確保されます。
メモリが足りている内は確保を行いません。
各要素へは []演算子を使ってアクセスできます。これは通常の配列と同じ動作です。
まだ確保していない要素を表す添字を使ってアクセスしてしまった場合の挙動も、通常の配列と同様で未定義になっています。
なお、vector が内部で確保したメモリ領域は、当然ながらデストラクタによって自動的に解放されます。
基本操作
続いて、もう少し機能を使った例を見てみましょう。
#include <vector>
#include <iostream>
int main()
{
using namespace std;
vector<int> array1;  // int型の動的配列
vector<int> array2;  // int型の動的配列
int i;
for( i = 0; i < 10; ++i )
{
array1.push_back( i );
array2.push_back( 9 - i );
}
if( array1 == array2 )  // ==演算子で比較
{
cout << "一致しました" << endl;
}
array2.clear();                 // clear()で全ての要素を削除する
cout << array1.size() << endl;  // size()で要素数取得
if( array2.empty() )            // empty()で空かどうか調べる
{
cout << "array2は空です" << endl;
}
for( i = 0; i < 10; ++i )
{
array1.pop_back();          // pop_back()で末尾の要素削除
}
return 0;
}
まず、オーバーロードされている演算子についてですが、 ==、!=、<、<=、>、>=、=、[] の各演算子があります。
==演算子と !=演算子は、2つの vector同士をまとめて比較します。
全ての要素が同じならば ==演算子の結果が真になります。!=演算子なら逆の結果になります。
<演算子などは、2つの vector の要素数による比較が行えます。
=演算子は、片方の vector の全要素を、もう一方の vector に代入します。
[]演算子は、先程登場したように、添字によるアクセスを行ないます。
clear() は、vector に含まれている全ての要素を削除します。
1つずつ削除したいときは、pop_back() や erase() を使います。
pop_back() は末尾の要素を削除します。これは戻り値として要素を返すようなことはしません。
erase() は、イテレータについて学ぶ必要があるので、後に回します。
size() は要素数を返します。
空かどうか調べる場合は string のときと同じく、empty() を使う方が効率がよくなります。
イテレータ
コンテナ内の要素を効率的にアクセスするための仕組みとして、イテレータ(反復子)というものがあります。
イテレータ自体にも種類がありますが(詳細は第12章を参照)、
今回はイテレータの解説ではなく vector の解説が主題なので、多くは触れません。
以下は、イテレータを使って vector内の要素をアクセスするプログラムです。
C++編(標準ライブラリ) 第2章 vector
