temray's colunm!
普段はなぞが多いテムレイの人たちが気になったことを適当に書き殴るコーナーです。読まない、読んでも本気にしない心構えが重要です。
* 
あけおめ。
オーバーサンプリングやダウンサンプリングというマルチレートデジタル信号処理の一部をなんとなく分かってきた所で応用編です。デジタルのディストーションとしてどこまで"アナログっぽさ"が出せるのか、試してみたくなりますもんね〜。
基幹となるのはやはりオーバーサンプリングによってしっかりエイリアスの処理がされた非線形テーブル。このテーブルには09/12に書いた様な折れ線ではなくてシグモイド関数を使います。(正確に言うとシグモイド関数を多項式で近似した式です。計算量を減らすためです。) それから前回書いたインターポレーションフィルタやデシメーションフィルタの構成をポリフェーズ構成というらしい。この資料に非常に分かりやすく図解してあった。この部分が波形歪みを生むのであとは線形なフィルターで実物に似せていく作業になるわけです。そんなわけでネットから見つけてきたBSSやらSnsAmpやらPrcoRatやらの回路図から定数を拾ってそれっぽく仕上げます。それがコレ。CPU負荷のことかはあまり考えてないので重いんですが一応VSTプラグインとして使える形にしました。ではdemoです。どうぞ。
ギター編:オリジナル/オーバードライブ
ドラム編:オリジナル/ヴァイナル風
…うーんまずまずじゃないでしょうか。一応の完成を見たのでこのテーマは終わり。そろそろ飽きたしね。次は何しよう。
追記:
kvrに登録されました。誰かポストしてくれたのね。ありがとさーん。
* 
実験オーバーシュート
前回はデジタルで非線形処理をするときにはオーバーサンプリングしないとエイリアスがね…ということだったんで、じゃあ実際動かしてミヨー!というのが今回。
色々調べて作ってみるとインターポレーションフィルタやデシメーションフィルタはFIRフィルタで構成すると計算量が少なめにできることが判明。
FIRはご存知の通り入力信号とフィルタ係数のコンボリューションをとると出力になるわけです。インターポレーションの場合、信号に0補間したものが入力だと最初からわかっているので、この0については係数と掛け算する必要がない。デシメーションフィルタも間引きしない、必要なサンプルについてのみコンボリューションを取ればいいので、計算量としてはどちらも元のサンプリングレートで同タップ数のFIRを動かすのと同じである。
というわけで4倍オーバーサンプリングしてからクリップ、ダウンサンプルした波形です。
ナイキスト周波数までの成分だけだとこんな感じの波形になるんですね〜。なるほど〜。
* 
デジタルディストーションの悩み
ノーフォローで突き進むこのコーナーももはや個人的メモ帳な感じですかね。今回はみんな大好きディストーションについてです。
いわゆる歪モノといわれるエフェクターはエレクトリックギターを弾く人なら
だいたいお世話になったことがあるでしょう。
こいつの基本原理は極めて簡単、入力がある一定以上のレベルになるとクリップするようになっていて、
あとはフィルターとの組み合わせということが多い。
コンパクトエフェクターを沢山そろえるのも大変なのでデジタル処理でうまいことシミュレーションできないかしら、
と考えるのが人情。そこで歪の肝であるクリップをソフトウェアで実装するとき一体何をするべきか、
現実的な負荷で実装を行うとしたらどうなるかちょっと考えてみました。
まず最初に思い浮かぶのが入力を非線形テーブルに通すこと。これは当然でしょう。
double clip(double input)
{
double output = input;
if(input > threshold){output = threshold;}
if(input < -threshold){output = -threshold;}
return output;
}
という感じの奴です。アナログのクリップの場合はこれで十分でしょう。
しかし、離散化された世界では不思議なことが起きます。
44.1k程度のサンプリング周波数でこのような非線形処理を行うと、
発生する周波数スペクトル成分の結構な量がサンプリング周波数の1/2を超えてしまいます。
要するにクリップした瞬間折り返しのエイリアスノイズが発生してしまうわけです。
デジタルエフェクターが出てきたころ、歪がデジタル臭いとか言われてたり、
アナログのクリップは心地よく歪むのにデジタルクリップは不快な音がするとかは、この辺の影響が大きいのかも。
コレを避けるためにはアンチエイリアス処理を施す必要が出てきます。
どういう方向で処理するかというとクリップ処理をしても
折り返しノイズが問題ないくらいの周波数で一度オーバーサンプリングし
クリップ処理を行い、そのあとで再びフィルタリングして元のサンプリング周波数にダウンサンプリングします。
アップサンプラインターポレーションフィルタクリップデシメーションフィルタダウンサンプラ
というブロックで実装しなきゃちゃんとクリップさせることは難しいように思います。
面倒臭いです。もっといい方法を誰か知ってたら教えて欲しい。。
* 
コンピュータの中の人
こんにちは。世の中のみなさん。正規表現っていうのをご存知だろうか。
ちょっと使う機会があったので簡単にメモっておくことにしました。
たとえば"t"で始まって"y"で終わる6文字の小文字アルファベットでできている文字列を表現したい。
なんてときにあなたならどうする?
という困った疑問にスマートに答えてくれる素敵君なのです。上の例だと
t[a-z]\{4\}y
という感じになる。
\を外すと
t[a-z]{4}y
という感じだ。ちょっとだけその法則が見えてきただろうか。
\はエスケープシーケンスという奴で、文字と命令を区別するために付けたりつけなかったり。
ようするに{が"{"という文字を表しているのか、文字数指定の括弧なのかを区別する為のもの。
この場合、tで始まって、aからzまでの文字が4文字あり、yで終わる文字列を示す。
"temray"や"taaaay"、"trrrty"はすべて該当するが"temry"や"temRay"は駄目。
代表的なものに
.
任意の一文字
*
一つ前の要素を0回以上連続する。
+
一つ前の要素を1回以上連続する。
この辺を組み合わせて…
.*
任意文字列(文字無しも可)。"."は任意の1文字。*は前の要素の0文字以上の連続
.+
任意文字列(1文字以上)。+は前の要素の1文字以上の連続。"..*"と等価
[]
文字の指定。[abc]だとa,b,cのいずれか一文字。[^abc]だとa,b,c以外のいずれか一文字。
[a-z]\{4\}だとaからzまでのいずれかの文字を4文字。[a-z][a-z][a-z][a-z]と等価。
それから
|
"どちらか"って言う意味の演算子
\(\)
優先されるグループを作る。
\(Mer|Ill\)cedes
だと"Mercedes"もしくは"Illcedes"にヒット。
?
前の要素はあってもなくても良い。
tem=?ray
だと"tem=ray"と"temray"にヒット。
\<\>
単語表現。これで囲まれた正規表現の両端は1個以上のスペースが必要。
\<temray>\とすると" temray "はヒットするが"temraytemray"はヒットしない。
ひとつ例題
<a +href=['"][^<>]*['"][^<>]*>
これはなんだろか?
column
