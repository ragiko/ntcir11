
[MPI-J]Chapter 2
Up:目次
Next:第3章 1対1通信
Previous:第1章 MPIの紹介
2章の翻訳は以下の人々が担当し、著作権を保持しています。
- 小西弘一
Copyright (C) 1996 Koichi Konishi
内容の改変をせず、上記の著作権表示を伴う限り、本文書を
複製および配布することを許可します。
著作権者および本翻訳プロジェクトの参加者は、この翻訳の使用に
基づくいかなる結果についても責任を負いません。
%% Mon Jun  3 21:23:10 EDT 1996
第2章
MPIの用語と規則
この章では、MPI文書全体で使用される表記上の用語と規則、行われた選択の
いくつか、およびそれらの選択の背後にある根拠について説明する。
2.1 文書の表記
根拠
インタフェースの仕様の中でおこなわれた設計上の選択の根拠は、
この文書全体を通して、この形式で提示される。
読者によっては、これらの節はとばすことにしようと思うかもしれないし、
インタフェースのデザインに興味のある読者は念入りに読もうと思うかもしれない。
(根拠の終わり)
ユーザーへのアドバイス
ユーザーに訴えたいことや使用法の説明については、
この文書全体を通して、この形式で提示される。
読者によっては、これらの節はとばすことにしようと思うかもしれないし、
MPIのプログラミングに興味のある読者は念入りに読もうと思うかもしれない。
(ユーザーへのアドバイスの終わり)
実装者へのアドバイス
主に実装者に対する注釈となることについては、この文書全体を通して、
この形式で提示される。読者によっては、これらの節はとばすことにしようと
思うかもしれないし、MPIの実装に興味のある読者は念入りに読もうと思うかも
しれない。
(実装者へのアドバイスの終わり)
#ifdef 訳注
may wish to skip ... may want to read ... の訳はしっくりきません。
#endif 訳注
2.2 手続きの仕様
MPI手続きの仕様は、言語に依存しない表記を使用して記述する。
手続き呼び出しの引数には、入力、出力、入出力の区別を示す。
これらの意味は以下の通りである。
入力と示した引数は、呼び出しにより使用されるが、
更新されることはない。
出力と示した引数は、呼び出しにより更新されるかもしれない。
入出力と示した引数は、呼び出しにより使用、更新の両方が行われる。
特別な場合が一つある。引数が不透明オブジェクトのハンドル(これらの用語
については2.4.1節で定義)であって、そのオブジェクトがその手続き呼び出
しで更新される場合、その引数は出力と示す。ハンドル自身は修正されな
いにも関わらずこのように示す。つまり、出力属性は、ハンドルの参照す
るものが更新されるということを示すために使うことがある。
MPIの定義は、入出力引数の使用をできる限り避けている。
このような使い方は、特にスカラー引数の場合、間違いの元になるからである。
MPIの関数では、ある引数が一つのプロセスでは入力として使用され、
別のプロセスでは出力として使用されることがよくある。このような引数は、
文法的には入出力引数であり、入出力と示す。しかし、
意味的には、1つの呼び出しで入力と出力の両方のために使用されることはない。
また、ある引数の値が一群のプロセスのうちの幾つかにとってのみ必要な場合
もよくある。あるプロセスにおいてある引数が意味をもたない場合は、
任意の値を引数として渡して構わない。
特に指定しない限り、出力または入出力の引数について、
同じMPI手続きに渡す他の引数を用いて別名をつけてはならない。
以下に示すのはC言語において引数に別名をつけた例である。
次のようなC言語の手続きを定義すると、
void copyIntBuffer( int *pin, int *pout, int len )
{   int i;
for (i=0; i<len; ++i) *pout++ = *pin++;
}
この手続きの以下のコードにおける呼び出しは、別名つきの引数を持つ。
int a[10];
copyIntBuffer ( a, a+3, 7);
C言語はこれを許可しているが、MPI手続きのこのような使い方は
特に指定しない限り、禁止する。
なお Fortran言語は、引数に別名をつけることを禁止している。
すべてのMPI関数の仕様は、最初に言語に依存しない表記によって示す。
そのすぐ下に、ANSI C言語版の関数を、その下にFortran77言語における
同じ関数を表示する。
2.3 意味に関する用語
MPI手続きについて説明する際、以下に示す、意味に関する用語を使用する。
最初の2つは通常、通信操作に対して用いる。
ノンブロッキング
操作が完了する前で、なおかつ呼び出しにおいて指定された(バッファなどの)
リソースをユーザーが再使用できるようになる前に、手続きから戻ることが
ありうる場合。
ブロッキング
手続きから戻り次第、呼び出しにおいて指定されたリソースを
ユーザーが再使用してよい場合。
ローカル
手続きの完了がそれを実行しているプロセスのみに依存する場合。
このような操作は、別のユーザープロセスとの通信を必要としない。
ノンローカル
操作を完了するために、別のプロセスでのなんらかのMPI手続きの実行が
必要かもしれない場合。このような操作は、別のユーザープロセスとの
通信を必要とするかもしれれない。
集団的
あるプロセスグループ中のすべてのプロセスが、その手続きを起動しなければ
ならない場合。
2.4 データ型
2.4.1 不透明オブジェクト
MPIは、システムメモリを管理する。システムメモリとは、ここでは、メッセー
ジのバッファリングや、さまざまなMPIオブジェクト(グループ、コミュニケー
タ、データ型など)の内部表現の格納に使われるメモリを指す。
このメモリにはユーザーが直接アクセスすることができず、
したがってここに格納されるオブジェクトは不透明である。
つまり、そのサイズと形状はユーザーには見えない。不透明オブジェクトは、
ユーザー領域にあるハンドルを通してアクセスする。
不透明オブジェクトを操作するMPI手続きには、そのオブジェクトを
アクセスするためのハンドル引数を渡す。
ハンドルは、MPI呼び出しでオブジェクトのアクセスに使うだけでなく、
そのまま代入したり比較したりすることもできる。
Fortran言語の場合、すべてのハンドルは整数型を持つ。C言語の場合、
オブジェクトの種類ごとに、異なるハンドル型が定義される。
これらは、代入および等価演算子をサポートする型でなければならない。
Fortran言語の場合、ハンドルは、システムテーブル中の不透明オブジェクト
のテーブルに対する添字として実現できる。C言語の場合は、同様の添字にす
るか、あるいはオブジェクトへのポインタにすることができる。他にも変わっ
たやり方はあるだろう。
不透明オブジェクトの割り当てと解放は各オブジェクト型に固有の呼
び出しによって行う。これらは各オブジェクトについて述べた節に挙がってい
る。これらの呼び出しは、対応する型のハンドル引数を受け取る。割り当て呼
び出しの場合、この引数はオブジェクトへの有効な参照値を返す出力引数
である。解放のための呼び出しでは、この引数はヌルハンドルを値
として戻る入出力引数である。MPIはヌルハンドル定数を各オブジェク
ト型ごとに一つ設ける。この定数と比較することにより、ハンドルが有効かど
うかを調べることができる。
解放処理の呼び出しは、ハンドルを無効にし、オブジェクトには、解放するべき
ものであることを示す印をつける。そのオブジェクトは、この呼び出しの後、
ユーザーからはアクセスできなくなる。しかしながらMPIはそのオブジェクト
をすぐに解放する必要はない。このオブジェクトに関わる(その解放処理の時
点で)保留中の操作は、正常に終了し、オブジェクトはその後に解放される。
MPI呼び出しは、ハンドルの値を変えることはない。例外として、オブジェク
トの割り当てや解放をおこなう呼び出しの場合、および3.12.4節の
MPI_TYPE_COMMIT呼び出しの場合がある。
ヌルハンドル引数をMPI呼び出しにおける入力引数とするのは、
関数を定義する文中で例外が明示されていない限り、間違った使い方である。
そのような例外は、WaitおよびTest呼び出しにおけるリクエストオブジェクト
のハンドル(3.7.3節および3.7.5節)のために設けてある。
それ以外でヌルハンドルを渡してよいのは、新しいオブジェクトを割り当て、
そのオブジェクトへの参照値をハンドルとして返す関数の場合に限られる。
不透明オブジェクトとそのハンドルは、オブジェクトを生成したプロセスでのみ
意味を持ち、別のプロセスに転送することはできない。
MPIでは、いくつかのあらかじめ定義された不透明オブジェクト、およびこれ
らのオブジェクトに対するあらかじめ定義された静的ハンドルが用意され
ている。このようなオブジェクトは消去してはならない。
根拠
この設計では、MPIデータ構造のために使う内部表現を隠してあるので、
C言語でもFortran言語でも同じような呼び出しの形式を使うことができる。
またこれらの言語における型に関する規則との矛盾も回避されており、
将来の機能拡張も簡単に行えるようになっている。ここで使用されている
不透明オブジェクトのメカニズムは、POSIX の Fortran 言語用
呼び出し形式の標準にゆるやかに沿ったものになっている。
ユーザー領域でハンドル、システム領域でオブジェクトという具合に明示的に
区別すると、メモリ領域を回収する解放呼び出しを、
ユーザープログラムの適切な場所で行えるようになる。
仮に、不透明オブジェクトがユーザー領域にあったならば、
そのオブジェクトを必要とする保留中の動作が完了する前に、
そのユーザ領域が有効である範囲の外に出ないよう非常に気を付けなければ
ならないだろう。
ここに示した設計では、オブジェクトに解放すべきものとして印をつける
ことができ、ユーザープログラムが上述の範囲外に出ることも可能で、
それでもオブジェクト自体は、保留中の動作が完了するまで解放されることはない。
ハンドルが代入や比較をサポートしなければならないと定めたのは、
そのような処理がよく行われるからである。これにより、可能な実現方法の
幅は狭くなった。これに替えて、ハンドルが任意の不透明な型であることを
許すという選択もありえた。この場合、代入と比較を行うための
ルーチンを導入しなければならなくなり、より複雑になるので、
この規定は採用されなかった。
(根拠の終わり)
ユーザーへのアドバイス
参照先のない参照値が間違ってできることがある。
これは、ユーザーがあるハンドルに別のハンドルの値を代入し、
そのあとこれらのハンドルに対応するオブジェクトを解放することによりできる。
逆に、あるハンドル変数を、それに対応するオブジェクトを解放する前に、
解放してしまうと、そのオブジェクトにはアクセスできなくなる
(これは、たとえばハンドルが、あるサブルーチン内のローカル変数であって、
関連するオブジェクトが解放される前にサブルーチンが終了する場合に起きる)。
不透明オブジェクトへの参照値の追加や削除は、
そのようなオブジェクトの割り当て、解放をおこなう
呼び出しに伴う場合を除き、ユーザーの責任で避けなければならない。
(ユーザーへのアドバイスの終わり)
実装者へのアドバイス
不透明オブジェクトの定義が意図するところでは、各不透明オブジェクトは
一つ一つ別のオブジェクトであり、このようなオブジェクトを割り当てる
呼び出しは、そのオブジェクトに必要なすべての情報をコピーする。
実装は、必要以上のコピーを避けるため、コピーを参照で置き換えてもよい。
たとえば、ユーザー定義データ型には、その構成要素のコピーを持たせる
代わりに、その構成要素への参照値を持たせてもよい。
MPI_COMM_GROUPの呼び出しは、コミュニケータに対応するグループの
コピーの代わりに、そのグループに対する参照値を返してもよい。
そのような場合、実装は、参照カウントを管理する必要があり、
またオブジェクトの割り当てと解放を、見かけ上オブジェクトが
コピーされているように見えるように行わなければならない。
(実装者へのアドバイスの終わり)
2.4.2 配列引数
MPI呼び出しで、不透明オブジェクトの配列またはハンドルの配列の引数が必
要になる場合もある。ハンドルの配列は普通の配列であって、そのエントリは
同じ型のオブジェクトに対するハンドルであり、その配列の中の連続した位置
に並んでいる。このような配列を使う場合は常に、有効なエントリの数を示す
ため長さを示す len 引数を添える必要がある(この数値が他から求められる
場合は除く)。有効なエントリは配列の前方寄りにあり、len はその個数を示
すが、これは、配列全体のサイズと同じでなくてもよい。他の配列引数でも同
じアプローチがとられる。
2.4.3 状態型
MPI手続きでは、さまざまな場所で状態型の引数を使用する。
このようなデータ型の値はすべて名前で識別され、
それについての操作は定義されていない。
たとえばMPI_ERRHANDLER_SETルーチンは状態型の引数を一つ取り、
これはMPI_ERRORS_ARE_FATAL、MPI_ERRORS_RETURNなどの値を持つ。
2.4.4 名前付き定数
MPI手続きは時に基本的な型の引数の特別な値に、特別な意味を割り当ててい
る。たとえばタグは1対1通信操作の整数値を取る引数であるが、これには特別
なワイルドカード値としてMPI_ANY_TAGがある。このような引数は、ある値域
を通常値としてとる。この値域は対応する基本データ型の値域の一部分である。特殊
な値(たとえばMPI_ANY_TAG)は、この通常値域の外になる。通常値域
は、環境問い合わせ関数を使用して問い合わせすることができる(第7節)。
MPIはまたあらかじめ定義された名前付き定数としてハンドルも提供する。た
とえば、MPI_COMM_WORLDは、起動時に存在していて互いに通信が可能な全プロ
セスを表すオブジェクトへのハンドルである。
すべての名前付き定数は、Fortran言語におけるMPI_BOTTOMを除き、初期化式
および代入の中で使用することができる。これらの定数は実行時に値が変わる
ことはない。定数ハンドルによってアクセスされる不透明オブジェクトはMPI
の初期化(MPI_INIT()呼び出し)からのMPI終了処理(MPI_FINALIZE()呼び出し)
までの間存在し、その間、値が変わることはない。
2.4.5 選択型
MPI関数は時に選択(または共用)データ型の引数を使用する。
いくつかの異なる呼び出しが、同じルーチンに対するものであるにも関わらず、
参照渡しによって、それぞれ違う型の実引数を渡すことがある。
このような引数を与えるためのメカニズムは、言語によって異なる。
Fortran言語の場合、本文書では<type>を使用して選択型変数を表現し、
C言語の場合は、(void *)を使用する。
2.4.6 アドレス型
いくつかのMPI手続きは、呼び出し側のプログラム内の絶対アドレスを示すア
ドレス型引数を使用する。このような引数のデータ型は整数型で、実行環境に
おける任意の有効なアドレスを保持するのに必要なサイズを持っている。
2.5 言語の呼び出し形式
この節では、MPIにおける言語の呼び出し形式一般についての規則と、
Fortran 77言語とANSI C言語についての個別の規則を定義する。
ここではさまざまなオブジェクトの表現、およびこの標準の表現に使用する
命名規則を定義する。実際の呼び出し方法については別の箇所で定義する。
Fortran 90言語用およびC++言語用の実装では、それぞれFortran 77言語と
ANSI C言語の呼び出し形式を使用するものと想定している。他の呼び出し形式
をFortran 90言語とC++言語について定義するには時期尚早と判断したものの、
現在の呼び出し形式をこのように設計したのは、将来採用し得るよりよい呼び
出し形式を定める試みを促すためであって、そのような試みをやめさせるため
ではない。
PARAMETER(引数) という言葉は、Fortran言語ではキーワードなので、ここ
では argument(引数)という言葉を使ってサブルーチンに渡す引数を表現す
る。C言語では普通これらは parameter と呼ばれるが、 C言語のプログラマは
argument という言葉(C言語ではこれには特定の意味はない)を理解できる
であろうから、それを当てにして、Fortran言語プログラマを不必要に混乱さ
せるのは避けることにした。
言語呼び出し形式に関する重要な問題で、この標準では扱っていないものがい
くつかある。この標準では、複数の言語間でのメッセージ通信の操作の可否に
ついては論じていない。多くの実装がそのような機能を持つこと、およびそ
のような機能がその実装の品質の証しになることが強く期待されている。
2.5.1 Fortran 77言語の呼び出し形式に関する事項
すべてのMPI名はMPI_という接頭辞を持ち、またすべての文字は大文字で
ある。プログラムは、この接頭辞MPI_で始まる変数や関数を宣言しては
ならない。この制約は名前の衝突を避けるために必要である。
すべてのMPI Fortran言語のサブルーチンには、最後の引数に返却コードを付ける。
いくつかのMPI操作は関数であり、これらには返却コード引数を持たない。
成功した場合の返却コード値はMPI_SUCCESSになる。その他の場合のエラーコードは
実装によって異なる。第7章を参照すること。
Fortran言語では、ハンドルは整数型で表現される。二値変数は、
論理型を持つ。
配列引数の添字は1から始まる。
特に明示されていない限り、MPI F77呼び出し形式は、ANSI標準のFortran77言語と
整合性を持つ。
いくつかの点ではこの標準はANSI Fortran77言語標準から外れている。
これらの例外はFortran言語コミュニティにおける普通の慣習に沿ったものである。
以下にそれらを挙げる。
MPIの識別子の表現文字としては、6文字ではなく、30文字を上限とする。
MPIの識別子では、最初の文字以降に下線を含んでいてよい。
選択型引数を持つMPIサブルーチンは、異なる型の引数で呼び出すことができる。
図2.1に例を示す。これは、Fortran言語標準が述べるところには違反しているが、
このような違反はごく普通に行われている。さもなければ、
それぞれのデータ型に対する個別のMPI_SENDを設けることになったであろう。
double precision a
integer b
..
call MPI_send(a,...)
call MPI_send(b,...)
図2.1 仮引数と実引数が一致しないルーチンの呼び出し例
必須事項ではないが、名前付きMPI定数(FORTRANでいうパラメータ)を
mpif.hというインクルードファイルの中に入れて提供することを強く奨める。
インクルードファイルをサポートしていないシステムでは、
実装は名前付き定数の値を明らかにするべきである。
ベンダーは、ユーザー定義型をサポートするFortran言語システムでは、
なるべくmpif.hファイルの中に型宣言を提供するよう努めてほしい。
できれば、MPI_ADDRESS型は定義するべきである。これはその実行環境において
アドレスを格納するのに必要なサイズを持った整数型である。
型の定義がサポートされていないシステムの場合、アドレスを表現するための
正しい種類の整数型を使用するのはユーザーの責任になる(つまり32ビット
マシンの場合4バイト長整数型(INTEGER*4)、64ビットマシンの場合8バイト長
整数型(INTEGER*8)、など)。
すべてのMPIの名前付き定数は、Fortran言語のパラメータ属性で宣言された実
体を使用できる、あらゆる場面で、使用することができる。この規則には、1
つだけ例外があり、MPI定数MPI_BOTTOM(3.12.2節)はバッファ引数としての
み使用することができる。
2.5.2 C言語呼び出し形式に関する事項
ANSI C言語宣言形式を使用する。すべてのMPI名は MPI_ という接頭辞を
持ち、あらかじめ定義された定数は全て大文字からなる名前を持ち。あらかじめ
定義された型や関数では、接頭辞のあとの文字が1文字だけ大文字になる。名前が
MPI_ という接頭辞で始まる変数や関数を、プログラムで宣言してはならない。
この制約は名前の衝突を避けるために必要である。
名前付き定数の定義、関数プロトタイプ、型定義は、
mpi.h という名のインクルードファイルの中にいれて提供しなければならない。
ほとんどすべてのC言語関数はエラーコードを返す。
成功した場合の返却コードはMPI_SUCCESSになるが、
エラーが起こった場合の返却コードは、実装によって異なる。
いくつかのC言語関数は値を返さず、そのためマクロとして実現することができる。
#ifdef 訳注
この、値を返さないCの関数が、何を指しているのか分かりません。
実際にある例外的な関数は MPI_Wtime と MPI_Wtick ですが、これらは
エラーコードの代わりに double の値を返します。返却コードを返さない
の間違いかもしれません。
#endif 訳注
不透明オブジェクトの各種類に対応するハンドルに対しては、それぞれ
別の型宣言が用意される。ポインタ型または整数型が使用される。
配列引数の添字は 0 から始まる。
論理フラグは整数で、値が0の場合偽、0以外の場合真を意味する。
選択型引数は、void*型のポインタである。
アドレス引数は、MPIで定義する型MPI_Aintである。この型は、
実装が対象とするアーキテクチャ上の任意の有効なアドレスを
保持するのに必要なサイズを持つintとして定義する。
すべての名前付きMPI定数は、C言語定数のように初期化の式または代入で
使用することができる。
2.6 プロセス
MPIプログラムは、自律的なプロセスで構成される。これらのプロセスは独自
のコードをMIMDスタイルで実行する。各プロセスによって実行されるコードは、
同一である必要はない。これらのプロセスは、MPIの通信プリミティブを呼び
出すことにより通信する。典型的には、各プロセスは独自のアドレス空間で実
行されるが、共有メモリに基づくMPIの実装もありえる。この文書で規定する、
並列プログラムの動作は、MPI呼び出しのみが通信に使用されることを前提と
している。MPIプログラムと他の通信手段(たとえば共有メモリ)との相互作
用については規定していない。
MPIは、それぞれのプロセスの実行モデルについては規定しない。プロセスは
逐次的かもしれないし、マルチスレッドになっていて、中で複数のスレッドが
並行して動作しているかもしれない。 MPI をスレッドセーフな(マルチスレッ
ド環境に対応した)ものにするため、十分な注意が払われており、明示され
ていない状態への依存を避けることによりこれを達成している。
MPIとスレッド群の間の相互作用は、以下のようになっていることが望ましい。
並行して実行するスレッド群はすべてMPI呼び出しを行うことが許され、呼び
出しはリエントラントであること。ブロッキングMPI呼び出しは、これを呼び
出したスレッドのみをブロックし、これにより別のスレッドのスケジューリン
グを可能にすること。
MPIは、MPIを用いる計算のためにプロセスを最初に割り当てること、およびそ
れらのプロセスと物理プロセッサの対応づけを指定することのためのメカニズムを
提供しない。このような処理をロード時や実行時に行うためのメカニズムはベンダ
が提供すると期待されている。このようなメカニズムは以下の事項の指定を可能に
する。すなわち、必要なプロセスの最初の個数、最初のプロセスがそれぞれ実
行するコード、およびプロセッサに対するプロセスの割り当てである。また現
提案では、プログラム実行時におけるプロセスの動的な作成や削除は提供され
ていない(プロセスの総数が固定されている)。ただし、そのような拡張をお
こなっても、矛盾が生じないことを意図してはいる。
最後に、プロセスは常に一グループ内での相対的なランク、つまり 0 ... 
グループサイズ - 1 までの範囲の連続する整数によって識別する。
2.7 エラー処理
MPIは、信頼性のあるメッセージ転送をユーザーに提供する。
送られるメッセージは、常に正しく受け取られるため、ユーザーが転送エラー、
タイムアウトその他のエラー状態についてチェックをおこなう必要はない。
いいかえれば、MPIには、通信システム内で発生するエラーを扱うメカニズムを
提供しない。
MPIの実装を信頼性のない下位のメカニズムの上に構築する場合、
ユーザをその信頼性のなさから隔離したり、回復不能なエラーを障害として
通知するのは、そのMPIサブシステムの実装者の仕事である。
可能な限り、このような障害は関連する通信呼び出しでエラーとして通知される。
同様にMPIそれ自身にはプロセッサの障害を処理するメカニズムはない。
7.2節で記述しているエラー処理機能は、回復不能なエラーの範囲を制限し、
またアプリケーション・レベルでのエラーからの回復処理を設計するために
使用できる。
とはいえ、MPIプログラムが間違っている可能性は当然ある。プログラムエ
ラーは、MPI呼び出しの引数が正しくない(送信操作のときに送信先が存在
しない、受信操作のときにバッファが小さすぎるなど)ときに発生しうる。こ
の種のエラーは、どのような実装においても起きるだろう。また、リソー
スエラーは、使用可能なシステム・リソース(保留中のメッセージ数、シス
テム・バッファ数など)の量をプログラムが超えたときに発生しうる。この種
のエラーが起きるかどうかは、システム内の使用可能なリソースの量およびリ
ソース割当てに使うメカニズムに依存する。品質の高い実装は、重要なリソー
スについては十分ゆとりのある上限を提供して、これに代表される移植性の問
題を軽減しようとするだろう。
ほとんど全てのMPI呼び出しでは、操作が正しく終了したことを示すコードを
返す。エラーが呼び出しの最中に発生した場合、可能な限り、MPI呼び出しは
エラーコードを返す。ある状況下、すなわちMPI関数が複数の別々の操作を完
了する可能性があって、したがっていくつかの独立したエラーを発生し得る場
合、MPI関数は複数のエラー・コードを返すことがありうる。特に指定しなけ
れば、MPIライブラリの実行中にエラーが見つかった場合、その並列計算は異
常終了する。しかしMPIは、ユーザーがこのデフォルト時の振舞いを変更して、
回復可能なエラーを処理するためのメカニズムを提供する。ユーザーは、エラー
はすべて致命的でないと指定して、MPI呼び出しが返すエラーコードをユーザー
自身で処理することができる。またユーザーはユーザー独自のエラー処理ルー
チンを用意することもできる。このルーチンは、MPI呼び出しが異常な状態で
戻ってくる場合には常に起動される。MPIエラー処理機能については、7.2節で
説明している。
エラーが発生したとき、MPI呼び出しが意味のあるエラーコードを返す機能は、
いくつかの要因によって制限される。MPIはある種のエラーは検出できないこ
とがある。また他の種のエラーについては、通常の実行モードで検出するには
コストがかかりすぎることもある。最後に、ある種のエラーでは天変地異
的に被害が大きいため、MPIが制御を整合のとれた状態で呼び出し側に返すこ
とができないこともある。
その他の微妙な問題として、非同期通信の性質によって発生するものがある。
つまり、MPI呼び出しは、その呼び出しが戻った後にも非同期的に継続する処
理を起動することがある。このため、その操作は正しく終了したことを示すコー
ドを返すが、そのあとでエラー例外を発生する、という可能性がある。同じ操
作に関連する呼び出し(たとえば、非同期操作が終了したことを確認する呼び
出し)がそのあとにある場合、この呼び出しに対応するエラー引数をエラーの
性質を示すために使用する。場合によっては、操作に関連するすべての呼び出
しが終了したあとにエラーが発生することがあり、そのためエラーの性質を示
すために使えるエラー値がないこともある(例えば、レディモードによる送信
でのエラー)。このようなエラーは、致命的なものとして扱わなければならな
い。その状態からユーザーが復旧するための情報を返すことができないからで
ある。
この文書では、MPI呼び出しでエラーが発生したあとの計算処理の状態を規定
していない。望ましい操作は、しかるべきエラーコードが返され、エラーの
影響が可能な限り狭い範囲に留められることである。例えば、エラーを起こし
た受信呼び出しが、メッセージ受信用に指定された領域を越える、受信側のメ
モリのいかなる部分をも書き換えることがない、という動作は非常に望ましい。
実装時には、この文書での仕様の範囲を超えて、MPI呼び出しのエラー定義を
意味のある方法でサポートしてもよい。たとえばMPIでは、対応する送信操作
と受信操作の間で厳密な型一致規則が規定されている。つまり浮動小数点変数
を送り、これを整数として受け取るのは間違いである。実装時には、これらの
型一致規則を越えて、このような場合に自動型変換を行ってもよい。このよう
な、規則に則らない操作に対しては、警告を出すのも役に立つであろう。
2.8 実装に関する事項
いくつかの領域において、MPIの実装が動作環境やシステムとやりとりするこ
とがある。MPIはいかなるサービス(入出力やシグナル処理など)の提供も義
務づけてはいないが、これらのサービスが使用できるのであれば、このような
動作を提供するよう強く提唱している。これは、同じサービスを提供するプラッ
トフォーム間の移植性を実現する上で、非常に重要な事項である。
2.8.1 基本ランタイム・ルーチンの独立性
MPIプログラムでは、以下のことが必要である。基本的な言語環境の一部であ
るライブラリルーチン(たとえばFortran言語のdateやwrite、ANSI C言語の
printfやmallocなど)が、MPI_INITとMPI_FINALIZEの間に実行される場合、そ
れらがそれぞれ独立に動作すること、およびそれらが完了するかどうかは同じ
MPIプログラム内の他のプロセスの動作には依存しないこと。
これは、操作が集団的な並列サービスを提供するライブラリルーチンの作成を
妨げるものではまったくない。しかしながら以下のプログラムは、
MPI_COMM_WORLDのサイズに関係なく、ANSI C言語環境で最後まで動作するものと
期待されている(実行ノードで入出力が行えることが前提)。
int rank;
MPI_Init( argc, argv );
MPI_Comm_rank( MPI_COMM_WORLD, &rank );
if (rank == 0) printf( "Starting program\n" );
MPI_Finalize();
同様のFortran 77言語プログラムも最後まで動作するものと期待される。
逆に、要求されないものの例としては、複数のタスクから呼び出されるとき、
これらのルーチンが特定の順序で動作すること、がある。たとえばMPIでは、
以下のプログラムからの出力がどうなるべきかもどうなるのが望ましいかも定
めない(ここでも実行ノードで入出力が行えることが前提)。
MPI_Comm_rank( MPI_COMM_WORLD, &rank );
printf( "Output from task rank %d\n", rank );
さらに、リソースの枯渇その他のエラーによって失敗した呼び出しは、ここで
要求している事項に違反するとは見なされない(ただしこれらは、正常終了し
なくてもよいだけで、終了する必要はある)。
2.8.2 POSIXシグナルとの相互作用
MPIは、UNIX環境で、シグナルを使用したプロセス間のやりとりについては指
定していないし、またMPI通信と関係しない他のイベントを使用するやりとり
についても規定しない。つまり、シグナルはMPIから見て特別な意味を持たず、
実装者は、シグナルが透過的になるようにMPIを実現するよう試みるべきであ
る。シグナルによって保留されたMPI呼び出しは、シグナルが処理されたあと、
処理を再開して完了するべきである。一般的に、MPIから見て検知可能である
か意味を持つかする処理状態は、MPI呼び出しによってのみ影響を受けるべき
である。
MPIをスレッドやシグナルと共に安全に使えるものにしようとすると、微妙な
影響がいろいろ出てくる。例えば UNIXシステムでは、SIGALRMのような捕捉可
能なシグナルのせいで、MPIルーチンがそのシグナルのないときと違う動作を
することがあってはならない。もちろん、シグナルハンドラがMPI呼び出しを
発行したり、MPIルーチンが動作している環境を変更したりする(たとえばす
べての使用可能メモリ領域を消費するなど)場合、MPIルーチンは、その状況
に対して適切に動作する必要がある(この場合で言えば、複数スレッド向け
MPI実装と同じ動作をするべきである)。
二つめの影響として、MPI呼び出しを実行するシグナルハンドラが、MPIの動作
を妨げることがあってはならないということがある。たとえば、シグナルハン
ドラの中で行われるいかなる種類のMPI受信もMPI実装の誤動作を引き起こし
てはならない。ただし、実装はシグナルハンドラ内でのMPI呼び出しを禁止
しても構わず、そのような使用を検出する必要はない。
MPIがSIGALRM、SIGFPE、SIGIOを使用しないことが非常に望ましい。実装はそ
のMPI実装が使用する全てのシグナルを明らかに文書で必ず示さなければ
ならない。この情報提供に適切な場所の一例は、MPIについての UNIX man ペー
ジである。
2.9 プログラム例
この文書中のプログラム例は、解説のみを目的としている。標準を規定するこ
とを意図したものではない。またプログラム例については、注意深いチェック
や検証がおこなわれているわけではない。
Up:目次
Next:第3章 1対1通信
Previous:第1章 MPIの紹介
[MPI-J]Chapter 2
