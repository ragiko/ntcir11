
特集
2004/05/18 21:30 更新
UNIX USER 2004年4月号「Linuxはハードウェアをどう認識するのか?」より転載:
Linuxハードウェア認識の基礎 (1/3)
Linux対応ハードウェアは増えつつあるものの、どのように設定し、またどうして自動で認識されるのであろうか? また認識されない場合はどのようにすればよいのか? トラブルシューティングの決め手となるこの知識を本特集でまとめていく。
INDEX Linuxハードウェア認識の基礎
1.  アプリケーションとハードウェア
2.  カーネルモジュールの読み込み
3.  モジュールの自動読み込み
4.  ハードウェアの情報
5.  コラム PCアーキテクチャのリソース
アプリケーションとハードウェア
PCにはさまざまなハードウェア(デバイス)が備わっており、それらハードウェアを利用するには、専用に書かれたソフトウェアが必要です。そのようなハードウェア制御を担当するソフトウェアを一般に(デバイス)ドライバと呼んでいます。
Linuxシステムの場合、ドライバはカーネル本体に組み込むか、利用時に動的に読み込むモジュールとして実装されています。たいていのディストリビューションでは、カーネル本体は基本的なドライバだけ組み込み、多くのドライバはモジュールとして実装されています(図1)。モジュールとして構成されることによって、カーネルメモリの節約や、カーネル本体を作り直すことがなく、ドライバを更新することが可能になります。
図1 アプリケーションとハードウェアのやり取り(クリックで拡大します)
ドライバの実体は、カーネルソースのdriversディレクトリ下にあります。その数は膨大で、カーネルソース全体の約半分がこのドライバ用のコードです(実行例1)。
実行例1 カーネルドライバのソース
[~/src/linux-2.6.3/drivers]
$ ls
Kconfig   char      isdn       nubus     scsi
Makefile  cpufreq   macintosh  oprofile  serial
acorn     dio       mca        parisc    tc
acpi      eisa      md         parport   telephony
atm       fc4       media      pci       usb
base      i2c       message    pcmcia    video
block     ide       misc       pnp       zorro
bluetooth ieee1394  mtd        s390
cdrom      input    net        sbus
$ du -s          drivers以下の容量
92268   .
$ du -s ..
217692  ..       カーネルソース全体容量
ハードウェアの操作ができる/dev
ハードウェアの操作は/devディレクトリに配置されてるデバイスファイルを通して行います。これはUNIX系OSの大きな特徴の1つであり、ファイルを扱う感覚で各デバイスを操作できます。デバイスファイルには対応するドライバ(モジュール)があり、デバイスファイル越しに渡された命令をドライバが解釈して適切なハードウェア操作を行います。
カーネル情報を参照できる/proc
カーネルに関わるさまざまな情報を取得できるのが/procファイルシステムです。/procディレクトリ以下にはさまざまなディレクトリ、ファイルがあり、それらファイルを参照することで、カーネルの情報を見ることができます。/procファイルシステムは、カーネル情報をファイルとして扱えるようにするもので、ファイルの実体はありません。
カーネルが認識したハードウェア情報もここから参照できます。
カーネルモジュールの読み込み
モジュールとして構成されたドライバは、カーネルに読み込まれないと利用できません。モジュールを読み込むには、insmodコマンドが利用されています(図2)。モジュールが読み込まれると、モジュールの構造情報(シンボル)が登録されます。モジュールも1つのプログラム(ELFバイナリ)であるため、その中身がどのようになっているか分からないと、ほかのプログラムから参照できません。
図2 モジュール(ドライバ)の組み込み(クリックで拡大します)
少し具体的に見てみましょう。実行例2は、モジュールlpを読み込み、そして削除したときの状態を調べています。 /proc/ksymsからは、外部に公開されたカーネルシンボルの情報を参照できます。lpが読み込まれていないときの状態を/tmp/nonlp.logに記録しておき、insmodで読み込み、読み込んだ後の状態を/tmp/lp.logに記録しています。この2ファイルを比較すると、4つのシンボルが登録されていることが分かります(出力の2行目は折り返しています)。
実行例2 動的なシンボル登録の確認
# cat /proc/ksyms > /tmp/nonlp.log
# insmod lp
Using /lib/modules/2.4.20-28.9smp/kernel/drivers/char/lp.o
# cat /proc/ksyms > /tmp/lp.log
# diff /tmp/non.log /tmp/lp.log
0a1,4
> df97b000 __insmod_lp_O/lib/modules/2.4.20-28.9smp/
kernel/drivers/char/lp.o_M3FE1F588_V132116 [lp]
> df97b060 __insmod_lp_S.text_L5491 [lp]
> df97c774 __insmod_lp_S.rodata_L60 [lp]
> df97d000 __insmod_lp_S.data_L276 [lp]
シンボルが登録され、初期化するとモジュールが利用できるようになります。初期化はシステムの資源(I/O)を割り当てることになるので、Linuxカーネルでは、できるだけ初期化を遅延する仕組みになっています。
現在読み込まれているモジュールを確認するにはlsmodコマンドを実行します。CD-RやUSB機器を利用しているとけっこうな数のモジュールが読み込まれていることが分かります。実際にお使いのPCでどのようなモジュールが読み込まれているか確かめてみましょう。
実行例3がその例です。右端にはそのモジュールがほかのモジュールに依存している状態が表示されます。sunrpcを読み込むのに、nfsdとlockdが必要(もしくは利用中)であることが分かります。
実行例3 読み込まれているモジュール
$ lsmod
Module Size Used by Tainted: P
msdos 8300 0 (autoclean)
nfsd 81104 8 (autoclean)
lockd 59536 1 (autoclean) [nfsd]
sunrpc 87516 1 (autoclean) [nfsd lockd]
:
:
デバイスを使用しなくなリ、不要となったモジュールはrmmodコマンドで削除できます。メモリなどシステム資源の節約に有効です。削除といってもカーネル空間からなくなるだけなので、再度insmodを実行すれば、そのデバイスは再び利用できます。実行例2のlpモジュールの作業後も、rmmodコマンドで削除すると、登録されたシンボルが削除されますので、確認してみてください。また、「rmmod -a」を実行すると、利用されていないモジュールを削除してくれます。
依存関係を解決するmodprobe
読み込み方法にはmodprobeを利用する方法もあります。モジュールに依存関係があり、複数のモジュールを読む込む必要がある場合は、modprobeがそれを調べ、必要なモジュールについてinsmodを実行します。通常はinsmodではなく、このコマンドを使っていくといいでしょう。
| 1 2 3 | 次のページ
[UNIX USER]
Copyright(C) 2010 SOFTBANK Creative Inc. All Right Reserved.
ITmedia エンタープライズ:Linuxハードウェア認識の基礎 (1/3)
