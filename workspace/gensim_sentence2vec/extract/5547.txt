
1.コマンドライン
Tclの文は、UNIXやMS-DOSのコマンドラインと同じ書式です。
例えばファイルをコピーする場合、コマンドがCOPY、元ファイル名が第1アーギュメント、コピーファイル名が第2アーギュメントです。
COPY AAA.DAT BBB.DAT
Tclスクリプトも先頭がコマンドで、そのあとにコマンドが必要とするアーギュメントが続きます。
下記の例ではsetがコマンドでvalと1がアーギュメントです。
(setコマンドは第1アーギュメントに変数名、第2アーギュメントに値を求める代入コマンドです。)
set val 1
コマンドとアーギュメントのセットはTclスクリプトの最小構成単位です。
アーギュメントをひとつも必要としないコマンドも当然許されます。
以降、コマンドとアーギュメントのセットをコマンドラインと呼びます。
2.ブランクとタブコードの機能(アーギュメント区切り)
ブランク及びタブコードは、コマンドとアーギュメント、及びアーギュメント間の区切りコードです。
つまりコマンド文字列と各アーギュメント文字列は、ブランクかタブで区切らなければならないということです。
連続したブランクやタブはひとつの区切りとして扱われます。
Cをはじめ、他のプログラミング言語はブランクやタブを無視しますが、Tclでは重要な役割を果たすことに注意してください。
3.改行コードとセミコロン文字の機能(コマンドライン区切り)
改行コード及びセミコロン文字は、コマンドラインの区切りコードです。
つまりコマンドラインを一行の中に何個も記述したい場合はセミコロンで区切ります。
set a 100; set b 200; set c 300
セミコロンがなくても改行コードがあればコマンドラインは完結します。
つまり1行にひとつのコマンドラインしか記述しない場合には必ずしもセミコロンが必要ではありません。
コメント行もコマンドラインのひとつです。
#がコメントコマンドであり、改行かセミコロンまでコメント文字とみなされます。
4.ダブルコーテーション引用符の機能(文字列)
ブランク、タブ、改行コードを含んだアーギュメントをコマンドに渡すにはで挟みます。 
set address "新潟県糸魚川市字印度"
下記の例では改行コードも含んだ文字列がコマンドに渡されます。つまりコマンドライン区切りコードとしての特殊機能が無効化されています。
set 景品 "
一等賞 自動車
二等賞 ふりかけ
"
は特殊記号ですので、コマンドに渡されるアーギュメントには含まれないことに注意してください。
また、" 
はアーギュメントの先頭に記述されている場合にのみ、上述の機能が働きます。
下記の例では、2つの"は文字としてコマンドにそのまま渡されます。アーギュメントの途中にあるからです。
set val aaaa"bbbb"
尚、後述の置換子は 内にあっても全て働きます。
5.$文字の機能(変数置換)
アーギュメントに記述された$文字は変数置換子です。$が先頭に付いた文字列は変数とみなされ、値に置換されてからコマンドに渡されます。
例えば、下例のコマンドラインがTclパーサーに渡されると、bは変数とみなされて、bの値が100であれば、setコマンドに渡されるアーギュメントはaと100になります。
set a $b
この置換は1回しか行われません。
つまりbの置換結果が$cであったとしても、cの置換は試まれずに$cの2文字がsetコマンドに渡されます。
6.ブランケット引用符 [ ]の機能(コマンド置換)
アーギュメントに記述された[ ]引用符はコマンド置換子です。
[ ]で挟まれた文字列はコマンドラインとみなされ、その実行結果がひとつのアーギュメントとしてコマンドに渡されます。
set a [expr 100 * 200 + 30]
上記のコマンドラインがTclパーサーに渡されると、[ ]ではさまれたコマンドラインの計算結果20030がsetコマンドに渡されます。これをコマンド置換と呼びます。
アーギュメント文字列中のいかなる位置にあってもコマンド置換機能は働きます。これはダブルコーテーション引用符と異なる性質です。
puts "Answer=[expr 10 * 4]"
また、[ ]に改行コードが含まれることも許されます。
[ ]はネスト(入れ子構造)も許されます。
7.\文字の機能(バックスラッシュシーケンス)
\文字はC/C++と同等のバックスラッシュシーケンス機能を持ちます。
例えば改行コードは \n 、水平タブコードは\tと記述できます。
これまで説明してきた置換子の前に\を付けるとそれらは単なる文字として扱われます。
set msg "\$をつけると変数置換が行われます" 
set msg "\[と\]で挟むとコマンド置換が行われます。"
8.ブレース引用符{ }の機能(置換抑制)
アーギュメントの前後に記述された{ }引用符は、中に含まれるあらゆる特殊文字の機能(置換機能)を無効化し、すべて単なる文字としてコマンドにそのまま渡します。¥文字もそのまま渡されます。
set a {[set b $c]}
上記のコマンドラインがTclパーサーに渡されると、{ }ではさまれた文字列がそのままsetコマンドにひとつのアーギュメントとして渡されます。それぞれ 
[ ] $ 
文字の特殊機能が奪われますので、コマンド置換も変数置換も行われないのです。
{ }は特殊記号ですので、コマンドに渡されるアーギュメントには含まれないことに注意してください。
また、{ }はアーギュメントの先頭と末尾に記述されている場合にのみ、上述の機能が働きます。これはダブルコーテーション引用符と同じであり、コマンド置換子とは異なる性質です。
下記の例では、{ } は文字としてコマンドにそのまま渡されます。
set val aaaa{bbbb}
9.式
プログラミング言語では、代入式や数値演算式などの式が言語仕様の中に組み込まれています。Tclにも式はありますが、これはTclが言語として提供しているものではなく、exprやifコマンドが提供しているものです。つまり式をアーギュメントとして受け付けるコマンドにのみC言語相当の数値演算式、論理演算式、関係演算式を記述することができます。
set a [expr $b * sin($c)]
ifコマンドなどの条件式アーギュメントには、文字列比較も数値比較と同じように記述できます。
if {($a/2)>10 && $b=="tokyo"} {......
式はオペランドと演算子の組み合わせで構成され、式のなかのブランクは無視されます。
演算子には算術演算子(-,!,*,/,%,+,-)・比較演算子(<,>,<=,>=,==,!=)・論理演算子(&&,||)・ビット演算子(&,|,^,<<,>>,~)・条件演算子((条件式)? 
a:b)があり、C言語と同機能です。
オペランドには整数や実数、及び数学関数を与えることができます。
数字関数はANSI/Cライブラリ関数が提供されています。
もちろん、数学関数の引数にも式を与えることができます。
expr 2*sin($x)
expr hypot($x2-$x1,$y2-$y1) + $z
10.定数
Tclが扱う定数は文字列定数のみですが、コマンドごとに様々な記述様式がサポートされています。
数値演算はexprコマンドが受け持ちますので、数値定数表記様式はexprコマンドが受け付ける様式を説明することになります。
整数は先頭の文字を0にすれば8進数、0xにすれば16進数として解釈されます。
実数では指数形式も指定可能です。
整数のみならば演算も結果も整数で求められます。
実数が含まれていれば実数で返されます。
11.変数の型
Tclパーサーが扱う変数の型は文字列だけです(サイズ自動拡張)。
しかし、各種コマンドはTclパーサーから渡された変数値を整数や実数、そして論理型として扱うことに注意してください。
つまり、変数の型はないけれど、データの型はコマンドごとにあるのです。
細かく言うとコマンドが内部で変換しているのです。
当然、整数を扱うコマンドに数字以外の文字列を渡してはエラーになります。
ただし、そのエラーはTclの文法エラーではなく、コマンドへのデータエラーであることを理解してください。
Tclはコマンド間のインターフェイスとして変数処理を提供しているので、その中身については干渉しないのです。
12.変数の名前
変数名には漢字も含めて全ての文字が使えます。
ただし$置換子によって置換されるとき、その名前に演算子や特殊記号が含まれていると、その前までが変数名として認識されてしまい、思わぬエラーが発生します。
例えば abc.def 変数への値セットは成功しますが、$abc.def 
として参照しようとすると $abc の置換になってしまいます。
この場合には、明示的に変数名を { }引用符で囲みます。
puts ${abc.def}
なるべく特殊文字は使わない様にするべきです。
なお、FreeSoftNet拡張のTclは変数名に漢字を使っても引用符で囲む必要はありませんが、純正Tclでは囲む必要があります。
13.変数のスコープと寿命
変数の型はコマンドに預けていますが、変数のスコープや変数の寿命はTclパーサーが管理しています。
変数のスコープにはグローバル変数、ローカル変数がサポートされています。
また名前空間内の変数もあります。
ローカル変数はプロシージャ(後述)内に作成され、終了すると自動的に削除されます。
グローバル変数は、変数にアクセスする前に宣言しておかなければなりません。
実際にメモリに作成されるのは、宣言された時ではなく、初めて値がセットされた時です。
したがって、値が設定されていない変数を参照するバグはありえません。
エラーとして検出されます。
全ての変数をunsetコマンドによって削除することが可能です。
これはTclの大きな特長です。
すべての変数がダイナミックに生成、削除できるオブジェクトになっています。
名前空間変数は、実質的にはグローバル変数ですが、いわゆる関数内のstatic変数のように扱える工夫がなされたものです。
グローバル変数の宣言はglobalコマンドで、名前空間変数の宣言はvariableコマンドで行います。
いずれの宣言もされずにプロシージャ内で使用される変数がローカル変数になります。
14.配列変数
配列変数は変数名に( )が付いている変数です。
例えばabc(1)などの変数です。
ただし、配列変数としての宣言や要素数を指定するコマンドはありません。
( )が付いた変数に値がセットされるときに配列変数として認識・登録されます。
同じ名前の配列変数と通常変数を同時に存在させることはできません。
例えば set abc 1 を実行した後に set abc(1) 1 
を実行するとエラーになります。
この逆も然りです。
つまり早いモノ順です。
配列変数の要素には文字列も使用できます。
またカンマ(,)やピリオド(.)などで要素を区切れば多次元配列になります。
set abc(a.b) 100
set abc(a.c) 200
set index c
puts $abc(a.$index)200が表示
要素数は自動拡張です。
配列オーバーは最も陥りやすいバグですが、Tclではあり得ません。
また、配列の要素をリストとして抽出したり、要素と値が繰り返されるリストから配列変数を作成するコマンドが提供されています。
下記の例では
人口密度(東京) 100
人口密度(埼玉) 60
人口密度(群馬) 30
の配列作成と値のセットを行い、その後に配列の要素をリストとして表示しています。
array set 人口密度 {
東京 100
埼玉 60
群馬 30
}
puts [array names 人口密度] "東京 埼玉 群馬"が表示される。
array setコマンドは、ダイナミックな構造体変数のような使い勝手を提供してくれます。
配列変数をグローバル変数として宣言したり削除するには変数名だけを与えます。
global 人口密度
unset 人口密度
15.リスト変数とリスト処理
Tclの特長にリスト処理があります。
リスト処理とは複数のデータの集まりを、あたかもひとつのデータのように処理することです。
リストデータが格納された変数をリスト変数と呼んだりしますが、リスト変数というものが他の変数と区別されて存在しているわけではありません。
この点が配列変数とは異なります。
リスト構造のデータが格納された変数を単にリスト変数と呼んでいます。
Tclのリストコマンドが扱うリストは極めてシンプルな構造です。
要素がブランク、タブコード、改行コードのいずれかで区切られてひとつの文字列になっている構造です。
ブランクやタブを含む要素は{ }引用符で囲まれています。
AAAA BBB {CCCC DDDD} EEEE
上記のリストには4つの要素があることになります。
また{ }引用符はリストを入れ子構造にするものであるとも言えます。
上の例で、3番目の要素を取り出すと CCCC DDDD 
が得られますが、この要素は更に2つの要素から成るリストとして扱うことができます。
実際にリストを扱う際には、上述の構造を意識する必要はありません。
リストを作成したり要素を抽出したりするリストコマンドが提供されています。
アーギュメントを要素としたリストを生成する
set LIST [list AAAA BBBB "CCCC DDDD" EEE]
リストからi番目の要素を取り出す
set Element [lindex $LIST $i]
リストの要素を順に変数elemに取り出してのループ処理
foreach elem $LIST {
puts $elem
}
リスト処理はCSV形式のデータを処理する場合などに重宝します。
また、SQL命令でデータベースから表データを抽出しての処理なども、簡潔かつ汎用的に記述することができます。
プロシージャ
プロシージャはTclスクリプトで作成されたコマンドのことです。
すでにTcl組み込まれているコマンドと同じように使えます。
プロシージャはprocコマンドで作成します。
値を返す場合はreturnコマンドを用います。
returnコマンドが書かれていなければ、最後に実行したコマンドの戻り値がプロシージャの戻り値になります。
proc プロシ−ジャ名 変数リスト Tclスクリプト
proc cal { a b c } {
return [expr ($a+$b)*$c]
}
【利用方法】set val [cal 10 20 300]
変数のアドレス渡し(upvar)
アーギュメントに変数名を与え、プロシージャがその変数に値をセットする方式(アドレス渡し)も用意されています。
プロシージャ内ではアーギュメントに渡されてきた変数名をupvarコマンドで内部変数にリンクさせてからアクセスするようにします。
proc cal {a b c answer} {
upvar $answer ans
set ans [expr ($a+$b)*$c]
}
【利用方法】cal 10 20 300 result
puts "答えは$result"
アーギュメントに渡す変数はあらかじめ存在していなくてもかまいません。
upvarコマンドが(呼び出し側に)作成してくれます。
リストコマンド
リスト処理とは、いくつもの値が1つに取りまとめられ、その集まりを1つの値として取り扱う処理です。
リストは特定の構造をもった文字列として表現されており、そのリストを生成したり、要素の挿入,削除,検索,置換などを行うのがリストコマンド群です。
※斜体は省略可能なアーギュメント。...は複数指定可能を示す。
concat  $list....
リストを結合して新しいリストを返す。
lappend  varName  
$val....
変数varNameに要素$val...を追加し結果のリストを返す。
lindex  $list  $index
リスト$listから$index番目の要素を取り出して返す。$indexは0から。
linsert $list $index $val 
...
リスト$listの$index番目の要素の前に全ての要素$val...を挿入したリストを返す。
list  $val....
すべての要素$val...を要素としたリストを返す(生成)。
llength $list
リスト$listの要素数を返す
lrange $list   $first  
$last
リスト$listの$first番目から$last番目までの連続要素をリストとして返す。
$lastに文字列endを与えると最後の要素までの指定となる。
先頭が0である。
lreplace $list  $first  $last  $val....
リスト$listの$first番目から$lastまでの連続要素をすべての要素$valで
置きかえ、新しいリストを返す。
lsearch  $switch $list  $pattern
リスト$listから、$switchであたえられたパターンマッチング方式で、
$patternに合致する最初の要素の順番を返す。
マッチング方式は-glob -exact -regexpの3種で、-globがデフォルト。
-exactは完全一致。
-regexpは正規表現規則。
-globはglob方式。
※glob,正規表現の解説はパターンマッチングを参照してください。
lsort $switch  -command  
$com   $direction  $list
リスト$listの要素をソートしたリストを返す。
$switchは-integer(整数) -ascii(文字) -real(実数)の3種。
-asciiがデフォルト。
$directionは方向スイッチで、-decreasingを指定すると降順となる。
join  $list  $joinString 
リスト$listの要素を$joinStringで結合した文字列を返す。
$joinStringのデフォルトはスペース。
split  $string  $splitChars
文字列$stringを、$splitCharsで区切られた文字列を要素としたリストを返す。
$splitCharsのデフォルトはブランク。
このコマンドは、joinコマンドと逆の関係にある。
実行例 Tclsh.exeで実際に実行してみてください。右が実行結果です。
set List [list bb aa cc {} dd ee]   bb aa cc {} dd ee
llength $List          6
lrange $List 2 end      cc {} dd ee
lsearch $List cc        2
lindex $List 4         dd
lappend List ff gg      bb aa cc {} dd ee ff gg
linsert $List 2 xx yy    bb aa xx yy cc {} dd ee ff gg
lsort $list           {} aa bb cc dd ee ff gg
lreplace $List 1 xx yy    bb xx yy cc {} dd ee ff
join $List -          bb-aa-cc--dd-ee-ee-gg
split "aa\tbb\tcc\t\tdd" \t  aa bb cc {} dd
制御コマンド
Tclマニュアル2/文法とコマンド
