
$SET(\0=Value)
$SET(\0=Value)
ローカル変数に値を代入する。左例では、\0 に "Value" の値を代入している。
$SET(\#=Value)
置換スタックに値を代入する
$SET(Global=Value)
グローバル変数に値を代入する
補足情報
制限
検索表現, 置換テキスト
フィルタの種類
全て
$SET(0=Value) のように \ を省略することが可能です。(本サイトでは省略した形で紹介しています)
$SET(0=\1) のように変数の値を代入することも出来ます。
$SETとOR関数と組み合わせると、条件別に動作を変えることが出来ます。
以下のフィルタは "abc" にマッチしたときに、"abc Matched!" に置換し、"xyz" にマッチしたときには消去します。
フィルタ
[Patterns]
Name = "Match ABC"
Active = TRUE
Limit = 256
Match = "abc$SET(0=abc Matched!)|xyz"
Replace = "\0"
$SETには1つ制限事項があり、ローカル変数がセットされた値は置換テキストで呼ばれるまで展開されません。
これは $SET(0=Proxo)$SET(0=\0mitron) のように再帰的に変数をセットすることが出来ないことを意味します。
上の例では、置換テキストで呼ばれたときには \0 = mitron となります。
この制限を切り抜けるためには、グローバル変数を扱う必要があります。
グローバル変数には以下の特徴があります。
変数に英数字の名前を付けられる (※英字で始まらなければなりません)
セットされたグローバル変数は、$GETによって他のフィルタからもアクセスできる
$SETで呼び出された時点で、値が格納される
$SETによってのみ、グローバル変数をセットできる
通信リクエストが終了した時点で、メモリから開放される
「$SETで呼び出された時点で、値が格納される」の特徴により、$SET(Global=Proxo)$SET(Global=$GET(Global)mitron) は意図通りに動作します。
グローバル変数はローカル変数と違い、リクエストが続いている間はメモリから解放されないので、ローカル変数よりも若干多くメモリを消費します。
任意のタイミングでグローバル変数を開放したいときには、$SET(Global=) で開放できます。
$SETの右辺はReplace欄と扱いが似ています。
エスケープしなければならない文字はReplace欄とほぼ同じという印象を抱いています。
(全く同じ可能性も少なからずあります。)
メタキャラクタ,マッチングコマンドの機能を維持し、有用と思われる文字
\t
タブ(HT) の1文字として扱う
\n
改行コード(LF) の1文字として扱う
\r
復帰コード(CR) の1文字として扱う
\0
ローカル変数として扱う
\#
置換スタックとして扱う
\@
置換スタック出力変数として扱う。\@は置換テキストでしか扱えないメタキャラクタだが、$SET内においては検索表現でも使用できる。$SET内で \@ を使用しても、置換スタックは空にならない。
\k
「現在の接続を切断」として扱い、置換テキストでセットされた変数を出力したときに効果を発揮する。\kは置換テキストでしか扱えないメタキャラクタだが、$SET内においては検索表現でも使用できる。
\
メタキャラクタの開始文字,エスケープ文字 として扱う。(例示の表記はエスケープとしてもメタキャラクタとしても機能しないため、不正な記述です。)
$GET
マッチングコマンド「$GET」として扱う
$DTM
マッチングコマンド「$DTM」として扱う
$FILE
マッチングコマンド「$FILE」として扱う
$UESC
マッチングコマンド「$UESC」として扱う。$UESCは置換テキストでしか扱えないコマンドだが、$SET内においては検索表現でも使用できる。
$ESC
マッチングコマンド「$ESC」として扱う。$ESCは置換テキストでしか扱えないコマンドだが、$SET内においては検索表現でも使用できる。
$WESC
マッチングコマンド「$WESC」として扱う。$WESCは置換テキストでしか扱えないコマンドだが、$SET内においては検索表現でも使用できる。
マッチングコマンドの機能を維持するが、あえて$SET内で使用する必要がない文字
$SET
マッチングコマンド「$SET」として扱う
$ALERT
マッチングコマンド「$ALERT」として扱う
$CONFIRM
マッチングコマンド「$CONFIRM」として扱う
$ADDLST
マッチングコマンド「$ADDLST」として扱う
$ADDLSTBOX
マッチングコマンド「$ADDLSTBOX」として扱う
$LOG
マッチングコマンド「$LOG」として扱う
$STOP
マッチングコマンド「$STOP」として扱う
$KEYCHK
マッチングコマンド「$KEYCHK」として扱う (※)
$IHDR
マッチングコマンド「$IHDR」として扱う (※)
$OHDR
マッチングコマンド「$OHDR」として扱う (※)
$RESP
マッチングコマンド「$RESP」として扱う (※)
$URL
マッチングコマンド「$URL」として扱う (※)
※$SETは必ず、「真」を返します。
$SET内で$URLなどのマッチングコマンドでテスト的な動作を行った場合、変則的な動作になります。
対象のマッチングコマンドが真を返すとき、後述の文字列がセットされる
対象のマッチングコマンドが偽を返すとき、後述の文字列はセットされないが、フィルタとしてはマッチする
この動作を利用する手もあるかもしれませんが、テスト動作を行うマッチングコマンドは$SETの外に置いた方が安全です。
逆に、$URL(http://abc.com/\0$SET(\1=http://xyz.com/\0)) のように、$SETを他のマッチングコマンドの内部に置く事には問題がありません。 
不審な挙動を示すマッチングコマンド
$LST
$LSTとして扱えないにも関わらず、後述の文字列がセットされなくなる
$TST
$TSTとして扱えないにも関わらず、後述の文字列がセットされなくなる
メタキャラクタ,マッチングコマンドの機能を失う文字
半角スペースの1文字として扱う
\s
"s" の1文字として扱う
\w
"w" の1文字として扱う
*
アスタリスク(*)の1文字として扱う
?
疑問符(?) の1文字として扱う
'
シングルクオート(') の1文字として扱う
"
ダブルクオート(") の1文字として扱う
|
縦線(|) の1文字として扱う
[
左大括弧([) の1文字として扱う
&
アンパサンド(&) の1文字として扱う
=
等号(=) の1文字として扱う
+
プラス(+) の1文字として扱う
$
ドルマーク($) の1文字として扱う。ドルマーク($) は後ろに機能するマッチングコマンドの記述がない場合に限り、エスケープしなくてもよい。
$AV
$AV の文字列として扱う
$AVQ
$AVQ の文字列として扱う
$NEST
$NEST の文字列として扱う
$INEST
$INEST の文字列として扱う
$CON
$CON の文字列として扱う
$TYPE
$TYPE の文字列として扱う
$RDIR
何も発生しない
$JUMP
何も発生しない
$USEPROXY
何も発生しない
$SETPROXY
何も発生しない
調査中
$ASK
調査中
$LOCK
調査中
$UNLOCK
調査中
$FILTER
調査中
エスケープしなければならない文字
\\
円記号 "\" の1文字として扱う
\(
左小括弧 "(" の1文字として扱う
\)
右小括弧 ")" の1文字として扱う
\$GET\(Global\)
"$GET(Global)" の文字列として扱う。ドルマーク($) は後ろに機能するマッチングコマンドの記述がある場合に限り、エスケープしなければならない。(※)
# 「括弧をエスケープしているため、ドルマーク($) をエスケープする必要はない」という見方もありますが、念のため。
マッチングコマンド - $SET
