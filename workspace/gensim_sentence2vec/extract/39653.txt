まじめに説明するとスゲー面倒ですし。
結論
UPDATE文を実行するときは、事前にSELECTした更新日時と、現在値を比較する。「更新日時」列はNOT NULL制約をつけといたほうがいい。NULLとの比較は相当厄介だ。  
同時実行制御は、要件になくても、まあやりなさい。
Oracle1.SELECT～FOR UPDATE WHERE ID=?でロック2.UPDATE～WHERE CURRENT OF cursorで更新。  
SQL Serverどうやったらいいんでしょうか…。
バッチなら、まあやらなくてもいいかもしれない。その場合、設計に制約を受けることになる。  
WHO列の「更新日時」を同時実行制御に使いなさい。  
画面側作成者が「面倒だ」といっても負けてはいけません。
競合が発生するケース
典型的なものだけ。
Aさんが画面を表示する。  
Aさんは昼飯を食いに行く。  
Bさんは昼休みも仕事をしている。  
Bさんが画面を表示する。  
Bさんが更新する。 ふー。これで昼飯を食いに行けるってもんだ。  
昼飯から帰ってきたAさんが更新する。  
昼飯から帰ってきたBさんは絶叫する。
やれやれ。Bさんの更新は上書きされて消えてしまう。昼休みも潰して仕事したのに。
楽観的というのはOptimisticの直訳ですね。こんな言い方をするのだから、悲観的(Pesimistic)もあります。悲観的なのはバッチ処理で使うときがあります。今回は説明しません。
何が楽観的なのかといえば、「まあ、競合することはほとんどないだろ」というのを前提にしているから(と思う)。ロックの仕組みはまともなデータベースなら必ずありますが、長時間(たとえば昼休み中)ロックしてしまうのは感心しません。サーバリソースも食います。Webベースだとリクエストごとに回線切れるモデルなので、悲観的モデルはうまく適合しません。
どうするかといえば、書き込む(更新)ときに、読み込んだ値と等しいかどうかチェックして、等しくなかったら「誰か他の人が更新した」と判断して、エラーメッセージを出すのです。「更新が競合しました。再度取得しなおしてください」とかなんとか。前掲の例でいえば、Aさんがはじかれるのです。
機械的にできそうな気もするのですが、機械的にするとDBMSやDB屋はとても無茶な方法を取るようになります。
そういうわけで、私は「更新列」を設計時に用意しておくのです。
SQL Serverの場合、RowVersion型(あるいはTimestamp型)の列を表ごとにつけておきます。本来は必要なものだけでいいのかもしれませんが、面倒なので全部につけてしまいます。RowVersion型は、UPDATEするたびに更新(まあインクリメント)される数値のようなものです。8バイトの数値です。どうしてこんな実装にしちゃったんでしょう。しかも昔はTimestamp型と呼んでいた。だれでもこの型は時刻関係のものを入れるもんだと連想するに決まってるでしょう。Sybaseはこんなのばっかりです。バカなんじゃないでしょうか。「名前なんてどうでもいい」と思っているのがミエミエです。
UPDATE文のWHERE句には、必ずおまじない(楽観的同時実行制御のための)が付きます。
UPDATE table_a SET qwe_name=@1
WHERE id_table_a=@2 AND tsequal(ts, @3)
tsが更新列。不思議な関数tseuqalが呼び出されていますが、これはタイムスタンプ値が異なるとエラーにするSQL Server固有の関数です(更新されないでエラーになる)。=で判定してしまうと、「成功。0行更新しました」とご機嫌に言われてしまうから。IDが間違っていたのか、タイムスタンプ列が違っていたのかが区別できないことになってしまうので。
しかし.NETではSqlTypesにrowversion型はないのだ
どうやら、Microsoftとしては使ってほしくはないらしい。MSDNからも、版が上がるたびに徐々に記述が減っていく。更新したい列全部をWHERE句に入れろ、というアプローチを推しているらしい。ADOや、ADO.NETのDataAdapterはこのアプローチです。しかしBLOBがあったらどうするんだ?! NULLは? もうめちゃくちゃ大変だし、UPDATEのトレースを取ると、ほとんど無関係な条件式でWHERE句が埋まっていることになる。
ちょっと試しにやってみることにする。その上で判断しよう。
SQL ServerのManagement Studioからテーブルを作ると、型のドロップダウンコンボからは”rowversion”が選べない。ないことになっている。timestampはある。timestamp型は、.NETの強烈に型指定されたデータセットに変換すると、byte[]になる。バッカヤロー。つまりはSQL Serverではrowversionは慎重に隠してあるし、ADO.NETでは、rowversion/timestamp型はNativeでサポートされないわけです。ADO.NETでは”RowVersion”と言えばDataTableの行の状態のことで。猛烈に「使うな」と言われている気分になるな。tsequal関数は、MSDNドキュメントには載っていません、ってよか、tsequalはSQL Server 2005で機能が削除されたらしい。「予約語」としてひっそりと残っているだけです。なんてことだ。MSDNのオプティミスティック同時実行制御サンプルは、すごくめんどうくさいのですが。
もうだめだな。timestamp型は使わない方がいいだろう。
全列の比較は歴史的に正しい方法ではありますが(ホスト屋の常識)、まちがっている! どれか一列だけで判定できるべきである。ホストの人はBLOB列なんてなかったからそれでいいのでしょうが、現代RDBにはあるんだよ。「楽観的同時実行制御」は、論文書けるくらいまで学術的な研究は済んでいるのだから、ANSIなどで標準化してもいいくらいなのです。本当にくだらない。DB屋はどうしても唯我独尊な発想が抜けませんね。
しかたない。全テーブルに機械的についているものと言えばID列とWHO列でしょう(これも標準化してもらいたい)。ここに「更新日時」があるのがフツーなので、それを使いましょう。
Oracleであれば、WHO列の「更新日時」でもまあ、だいたいいいでしょう。精度の問題です。全く同時の1秒以内に(DATE型はミリ秒まで精度あるが、Oracleには期待できないかもしれない)更新されることなんてないだろ、という戦略です。Oracleならカーソルが楽に使えるのでいい感じです。まずカーソルはIDで行を特定してロックする(これがなければIDの引数がおかしい / あるいはその行は物理削除された)、その行に対してUPDATEを発行する(WHERE句にカーソルを指定できる)。SELECTするカーソルにID条件を付け、UPDATE文に更新日時のWHERE条件を加えればいい。「0行更新」なら競合発生です。
しかしSQL Serverならどうすりゃいいのだ。一回LOCKしてからUPDATEするのか? SQL ServerにはFOR UPDATE構文なんてないんだぜ? カーソル使うのか? こんなに複雑なことをみんながやっているとは到底思えない。
PBT(SQL Server)のプロシージャを見てみると、こんな同時実行制御は何もしていないように見える。たぶん後勝ち更新でよいプロジェクトなのであるか、C#側(アプリケーション層)で行っているのでしょう。P-Plus(Oracle)のプロシージャを見ると、WHO列の更新日で同時実行制御しているようです。
同時実行制御はやりすぎ?
いや、そんなことはない。ホストの世界では常識以前です。しかし世間的にはあまり見かけないのも確かです。「～入門」には牧歌的なUPDATE文しか載っていないですし、たいていのDB解説には解説ばっかりで決定版の解決方法が載っていません。「楽観的同時実行制御」の文字列はよく見かけるようになったような気もするのですが、マネジメントが理解していないのか、「まあいいや」と思っているのか。みんな、理解していますか? あなたのプロジェクトではどう回避していますか? どうして私に教えてくれないの?
「普通そんなの起きないよ」。そうかもしれません。SQLインジェクションの時もあなたはそう言っていましたね。理解しないで解決できると思ったら大間違いだぜ?
ちなみにOracle Appsでは「行の内容全部を比較する」型の同時実行制御をしていました。Java(JDBC)にはこれをサポートするライブラリがないので、自作のヘンテコなツール(Rosetta)を使っていたな。このツールはロゼッタ・ストーンに刻まれた文字のような解読不能のJavaコードを吐き出す。結局Appsやってた時には誰も「同時実行制御のためのツールだ」と教えてはくれなかったけど。ADOとADO.NETは機能が用意されているし、たいていの書籍ではこの使い方が説明されています。すごいくだらないのです。NULLの扱いとかなんとか。そしてこの機能を使っている人を見たことがない。ADOもADO.NETも「行の内容全部を比較する」アプローチ。だから、行ごとにoldValueとnewValueが必要になる。カラムが6つくらいで全部バイト文字列ならそれでもいいのかもしれないが、カラム数80個、LOBがある、となったらどうすんの? SQLトレースは謎のWHERE文で埋め尽くされて読めなくなる。「必ずDataAdapterとDataTable使え」というのはなんだかなあ…。
ではどうする?
ウチで設計したDBスキーマなら、必ずWHO列が付いているでしょう。そこには「更新日時」列があることでしょう。これを使いましょう。
そして、プリミティブな更新操作はストアドプロシージャ経由になっているでしょう。DataAdapterとDataTableのあの複雑な更新メカニズムは使わずに。「UPDATE文なんてJavaコードに直書き。StringBuffer.appendの嵐」なんてことはないよね? UPDATE用のプロシージャ呼びだすよね?
プロシージャで標準化しておかないと、WHO列の更新日時なんて入れるの大変だもんな。Javaの人は平気で「更新日時」をクライアント時間とかで埋めてしまったりするのでびっくりするけど。クライアント時間とサーバ時間はよくずれる。DBサーバは本番環境でインターネットに普通つながらないし、ディレクトリにも参加しないケースが多いし、Firewallのあっち側に置かれてしまうケースが多い。機械的なサーバ間の時刻同期は難しい? Firewallにこのための穴を開けるんでしょうか。まあ、私は実運用はよく知らないです。
ウチの人ならStored Procedure使ってるよな? UPDATEプロシージャの引数に、「更新日時」を渡すんです。この「更新日時」は、はるか昔にSELECTしたときのものを渡すわけです。UPDATEのWHERE句に更新日時の一致チェックを入れましょう。同時実行制御はDBでやるんだぜ? ほかにどこでやるっていうんだ。
人が設計したDBスキーマなら、DB屋に「同時実行制御に対するプロジェクト方針(あるいは要件)を教えてください(設計時の標準化方針を教えてください)」と聞いてみよう。しかしこれは単なる嫌がらせにすぎない。逆ギレするか、責任放棄するはずだ。「そんな細かいことは実装で考えろ!」とか「どうしたらいいでしょう?」とかなんとか。怒鳴り声が必要になるのは、もちろんその主張が無茶だからですよ。怒鳴りつけるような形でしか存在できないはずです。責任放棄は「要件定義フェーズで考えてません」という声明ですので、もう「言わなきゃわかんない奴に言ってもわからない」を絵解きで表現されるでしょうなァ。
いまや雑誌やWebでは、全員が「楽観的同時実行制御」(とか楽観的ロックとか)いってますし、私でも知っている程度のことなのですが、それをどう実装していいのか、私にはよくわからんのです。社内現場の皆さんの知恵を共有していきたいところですね。
楽観的同時実行制御 »  ALT
