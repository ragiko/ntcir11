前回のMilkodeでの事例紹介では,Rubyでrroongaを使ってソースコード検索エンジンを実装している事例を紹介しました。Milkodeは全文検索エンジンを組み込むことにより,大量のファイルに対しても高速な検索を実現しています。rroongaを使った代表的なアプリケーションの1つです。プログラマにとってとても便利なアプリケーションなので,ぜひ使ってみてください。
前回はユーザ視点からのrroongaの紹介でしたが,今回は違った角度から紹介します。rroongaの歴史,大事にしていることについて説明します。
自分のアプリケーションで利用するプロダクトを検討するときに,プロダクトがどのような方向で作られているかを考慮していますか? 自分のアプリケーションが大事にしたいことをそのプロダクトでも大事にしているなら,相性がよいかもしれません。さて,rroongaはあなたが大事にしたいことを大事にしているでしょうか。
rroongaとは
rroongaはRubyで高速な全文検索機能を使うためのオープンソースソフトウェアです。groongaは全文検索サーバとしても全文検索ライブラリとしても使えますが,rroongaは全文検索ライブラリとして使っています。C言語で書かれたgroongaライブラリをRubyから使えるようにするモジュールがrroongaです。
他の多くの全文検索機能はサービスとして提供されていますが,rroongaはライブラリとして提供されています。これが大きな違いです。類似の構成はsqlite3 gemです。rroongaとsqlite3 gemを比べると,APIで使えるのでrroongaのほうがよりRubyらしく使えます。
ここでは同一プロセスで使うタイプと外部サーバにアクセスして使うタイプにわけています。ざっくりいうと,1台で完結するアプリケーションの場合は同一プロセスの方が便利で,そうでない場合は外部サーバのほうが便利です。「1台で完結する」とは,1台で扱えるデータの量であり,かつ,アプリケーションが1台のコンピュータ上で動けば十分ということです。同一プロセスモデルの良し悪しは機会があれば別の回に説明します。
ところで,この連載が「mroongaの事例紹介の回の次はmroongaについての解説」,「rroongaの事例紹介の回の次はrroongaについての解説」となっていることに気づいていたでしょうか? 同一プロセスモデルの良し悪しに興味のある方はぜひrroongaの事例紹介を執筆してください! 応募方法はこの記事の最後にあります。待っています!
話を戻すと,rroongaが全文検索機能をどのように提供しているかを他のソフトウェアと比べて説明しました。次は,rroongaの歴史,rroongaが大事にしていることを説明します。しかし,ちょっと待ってください。その前に別の大事なことを説明しないといけません。
rroongaの読み方
大事なこととは「rroonga」の読み方です。読み方を知らないと他の人に紹介もできませんからね。「rroonga」は「るるんが」と読みます。名前の由来は「Ruby」と「groonga」です。「Ruby」の「R」と「groonga」の「roonga」を組み合わせて「rroonga」です。
なお,「roonga」という名前がついたミドルウェアやライブラリは「ぐるんが族」や「ぐるんがファミリー」などと呼ぶことがあります。内部的に使われることがほとんどなので通常は目にすることはないでしょうが,もし目にしたときは「groonga」,「mroonga」,「rroonga」などのことを指していると認識してください。せっかくなのでこの記事の中で使ってみました。さて,次に出てきたときに覚えているでしょうか。
rroongaの読み方はわかりましたね。これからは「rroonga」と見たら「るるんが」と読んでください。
rroongaの歴史
rroongaの歴史を説明します。
SennaのRubyバインディング
groongaの前身がSennaだったということは第1回で紹介しました。実は,Sennaの頃にもRubyからSennaを使うためのモジュールがありました。そのモジュールには特に名前はついておらず,「SennaのRubyバインディング」などと呼ばれていました。
SennaのRubyバインディングはSWIGというツールを使って自動生成していました。SWIGはC/C++のヘッダーファイルを解析して,C/C++で提供している機能をRubyから使うためのコードを自動生成します。このため,SWIGを使えば少ない手間でRubyバインディングを作ることができました。しかし問題がありました。SWIGでCのヘッダーファイルを解析して作ったRubyバインディングは,RubyらしくないAPIになるのです。
Cのヘッダーファイルに対してSWIGを使うと,Cの関数とRubyのモジュール関数が1対1に対応するコードが出力されます。Rubyのクラスやメソッドは定義されません。これは,Cにはクラスやメソッドのための記法がないためです。SWIGはCのヘッダーファイルにある情報からだけではRubyのクラスやメソッドを定義することができません。そのため,「単にRubyからCの関数を呼べる」という低レベルのAPIだけができます。Rubyはオブジェクト指向スクリプト言語なので,この低レベルのAPIはとても使いにくいAPIです。
この問題を解決するために次のような工夫をしていました。
Cのヘッダーファイルを直接解析するのではなく,SWIG用の情報も加えて解析する
SWIGで作ったモジュール関数をRubyレベルでラップしてRubyらしいAPIを提供する
どちらもSWIGを使いながらRubyらしいAPIを提供するためによくやる工夫です。しかし,これらの工夫をしてもまだぎこちないAPIは残っていました。SennaのCのAPIを1つ1つRubyのメソッドに対応付ける作業はしなくてもよいのですが,代わりに,SWIGが自動で対応付けたRubyのモジュール関数をRubyらしいメソッドにラップしていく作業が必要になります。そのラップしていく作業でカバーしきれていない部分があったということです。
このことから,Rubyらしい使いやすいAPIを提供するなら,SWIGを使っても使わなくても手間はそれほど変わらないということがわかりました。そこで,rroongaではSWIGで自動生成することをやめて手で書くことにしました。groongaが提供している関数は2013年5月17日執筆時点で300ほどありますが,大きく増えるということはあまりありません。自動生成に比べて,手で書くと最初は大変です。しかし,API変更があまりないため,groongaの変更への追従はそれほど大きな負担ではありません。それよりも,よりRubyらしいAPIを提供できることが魅力です。
このような経緯で,rroongaは自動生成を使わずに「groongaのRubyバインディング」を実現しています。では,RubyらしいAPIとはどのようなAPIでしょうか。それは,後半で説明します。楽しみにしていてください。
2番目のぐるんが族
実は,rroongaの歴史はgroongaの歴史と同じくらい古いのです。
groongaは2009年3月13日に最初のバージョン0.0.2がリリースされました。rroongaは翌月の肉の日である4月29日に最初のバージョン0.0.1がリリースされました。第3回で紹介したmroongaよりも前です(mroongaは1年5ヶ月後の2010年8月19日に最初のバージョン0.1がリリースされています)。
rroongaは本当に初期の段階からgroongaと共に成長してきているのです。知っていましたか?
rroongaに改名した理由
rroongaは,リリース当時は「Ruby/groonga」という名前で,gem名も「groonga」でした。しかし,「groonga」という名前が入っているとgroonga本体なのかgroongaのRubyバインディングなのか紛らわしいという意見があり,ライブラリ名もgem名も「rroonga」になりました。これが,最初のリリースから1年経った2010年4月のことです。
groonga,mroongaと同じようにrroongaも名前を変えていますがいくつか違う点があります。
1つは名前を変えた経緯です。groongaやmroongaは開発側の意向で名前を変えていましたが,rroongaはユーザ側からの意見を参考に名前を変えました。そのため,ユーザ側は混乱しませんでした。
もう1つは移行の敷居が低かったことです。rroongaはgemでインストールすることがほとんどです。gemには「依存関係」という仕組みがあるため,それを使ってユーザが意識しなくてもrroongaへ移行できるようにしました。名前変更前のgem「groonga」の依存関係に名前変更後のgem「rroonga」を加えました。こうすることより,groonga gemをインストールすれば,最新版のrrooongaを使えます。
このような理由から,groonga,mroongaの名前変更に比べてrroongaへの名前変更は問題が少なかったです。むしろ「roonga」という名前になって統一感がでました。そのため,rroongaにとってはこの改名はよかったです。
これがrroongaの歴史です。どんな歴史をたどってきたか,イメージをつかめたでしょうか。
第5回 Rubyでサーバ要らずの高速全文検索! - rroongaの紹介:隔週連載groonga｜gihyo.jp … 技術評論社
