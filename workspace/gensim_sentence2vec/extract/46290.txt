
Cach&eacute; ObjectScript の使用法
Static Version
演算子と式
Cach&eacute; は、多様な演算子をサポートします。例えば、数学的な動作、論理比較などさまざまな動作を実行します。演算子は、最終的に値を評価する変数や他のエンティティである式に作用します。この章では、式とさまざまな ObjectScript 演算子を説明します。そのトピックは以下の通りです。
演算子と式の概要
算術演算子
論理比較演算子
文字列演算子
数値関係演算子
文字列関係演算子
パターン・マッチング
間接演算
演算子と式の概要
演算子とはシンボル文字で、対応するオペランドで実行する処理を指定するものです。各オペランドは、1 つ以上の式または式アトムから構成されます。演算子とその演算子に対応するオペランドを一緒に使用する場合、以下の形式になります。
[operand] 演算子 operand
演算子の中には、1 つのオペランドのみを使用する単項演算子があります。2 つのオペランドを使用するものは、2 項演算子と言います。
式は、演算子とそこで使用されるオペランドで構成されます。このような式は、オペランドに対する演算子の演算結果を生成します。式は、含まれる演算子タイプに基づいて分類されます。 
算術式は算術演算子を含み、オペランドを数値として解釈し、数値結果を算出します。
文字列式は文字列演算子を含み、オペランドを文字列として解釈し、文字列の結果を返します。
論理式は関係演算子と論理演算子を含み、論理演算子をオペランドとして解釈し、真 (0) あるいは偽 (0) のブーリアン値を返します。
ObjectScript には、以下の演算子があります。
ObjectScript 演算子
演算子
実行される演算
.
オブジェクトのプロパティあるいはメソッドへのアクセス
()
配列インデックスあるいは関数の引数呼び出し
+
加算 (2項)、正値 (単項)

減算 (2項)、負値 (単項)
*
乗算
/
除算
\
整数除算
**
べき乗
#
係数 (剰余)
_
連結
'
論理補数 (NOT)
=
等価テスト、代入
'=
非等価テスト
>
より大きい
'>
より大きくない (より小さい、あるいは等しい)
<
より小さい
'<
より小さくない (より大きい、あるいは等しい)
[
包含
]
追従
]]
前後関係
&&, &
論理 AND (&& は AND の簡易版)
||, !
論理 OR (|| は OR の簡易版)
@
間接演算
?
パターン・マッチ
詳細は、以下のセクションで説明しています。
演算子の優先順位
ObjectScript で演算子の評価順序は、必ず左から右です。したがって、式の演算は表示された順番で実行されます。これは、特定の演算子の優先順位が、他の演算子よりも高くなることがある他の言語と異なります。式で明示的に小括弧を使用して、特定の演算子を先に処理させることができます。
WRITE "1 + 2 * 3 = ", 1 + 2 * 3,!  // returns 9
WRITE "2 * 3 + 1 = ", 2 * 3 + 1,!  // returns 7
WRITE "1 + (2 * 3) = ", 1 + (2 * 3),!  // returns 7
WRITE "2 * (3 + 1) = ", 2 * (3 + 1),!  // returns 8
括弧と優先順位
式の評価の順序は、それぞれの式を対の小括弧で入れ子にして変更できます。小括弧は、囲んだ式 (算術式と関係式の両方) をグループ化し、Cach&eacute; ObjectScript が式で実行する演算の順序を制御します。以下の例を考えてみます。 
Set TorF = ((4 + 7) > (6 + 6)) // False (0)
Write TorF
上記では、小括弧で 4 と 7、および 6 と 6 を加算しているため、論理式は 11 > 12 となり、結果は偽になります。以下のコードと比較します。
Set Value = (4 + 7 > 6 + 6) // 7
Write Value
この場合、演算の優先順位は左から右になります。したがって、最初に 4 と 7 を加算します。その合計の 11 と 6 を比較し、11 は 6 より大きくなるため、論理演算の結果は 1 (真) になります。その後、1 に 6 を加算するため、結果は 7 になります。
優先順位により結果のタイプが異なることに注意してください。 上記の例で、最初の式の演算は最終的にブーリアン値を返し、2 番目の式は数値を返します。
以下の例では、複数レベルの入れ子を示します。
WRITE 1+2*3-4*5,!  // returns 25
WRITE 1+(2*3)-4*5,!  // returns 15
WRITE 1+(2*(3-4))*5,!  // returns -5
WRITE 1+(((2*3)-4)*5),!  // returns 11
内側の入れ子の式から 1 レベルずつ外側に進み、各レベルで左から右へと式が評価されます。
関数と優先順位
関数など、式のタイプにより式に影響を与える場合があります。以下の論理式を考えてみます。 
IF var1 = ($$ONE + (var2 * 5)) {
DO ^Test 
}
Cach&eacute; ObjectScript は、最初に var1、次に関数 $$ONE、次に var2 を評価します。その後、var2 を 5 倍し、最後に Cach&eacute; ObjectScript は、加算の結果が var1 の値に等しいかどうかをテストします。等しい場合、DO コマンドを実行して Test ルーチンを呼び出します。
別の例として、以下の論理式を考えてみます。 
SET var8=25,var7=23
IF var8 = 25 * (var7 < 24) {
WRITE !,"True" }
ELSE {
WRITE !,"False" }
この式は、var7 の値が 24 より小さいかどうかを比較し、その後、(真の場合は 1、偽の場合は 0 の) 結果を 25 倍します。最後に、その結果 (25 または0) が var8 の値に等しいかどうかをテストします。
式
ObjectScript 式は、値を算出するために評価される 1 つ以上の トークン です。最も単純な式は、リテラルあるいは変数です。
Set expr = 22
Set expr = "hello"
Set expr = x
配列、演算子、多くの ObjectScript 関数の 1 つを使用して、さらに複雑な式を記述できます。
Set expr = +x
Set expr = x + 22
Set expr = array(1)
Set expr = ^data("x",1)
Set expr = $Length(x)
式は、オブジェクト・プロパティ、インスタンス・メソッド呼び出し、クラス・メソッド呼び出しから構成されます。
Set expr = person.Name
Set expr = obj.Add(1,2)
Set expr = ##class(MyApp.MyClass).Method()
ルーチン呼び出しの前に $$ を置き、ObjectScript ルーチン呼び出しを式で直接実行できます。
Set expr = $$MyFunc^MyRoutine(1)
式は、返す値の種類で分類されます。
算術式 は算術演算子を含み、オペランドを数値として解釈し、数値結果を算出します。
Set expr = 1 + 2
Set expr = +x
Set expr = a + b
算術式で使用される文字列は、数値として評価されます (有効な数値がない場合は 0 となります)。また、単項加算演算子 (+) を使用すると、文字列値を数値に暗黙に変換します。
文字列式 は文字列演算子を含み、オペランドを文字列として解釈し、文字列の結果を返します。
Set expr = "hello"
Set expr = "hello" _ x
論理式 は関係演算子と論理演算子を含み、論理演算子をオペランドとして解釈し、真 (1) あるいは偽 (0) のブーリアン値を返します。
Set expr = 1 && 0
Set expr = a && b
Set expr = a > b
オブジェクト式 は、結果としてオブジェクト参照を生成します。
Set expr = object
Set expr = employee.Company
Set expr = ##class(Person).%New()
論理式
論理式は、論理演算子、数値関係演算子、文字列関係演算子 を使用します。式を評価し、真 (1)、偽 (0) のブーリアン値を返します。論理式は、通常、以下を使用します。 
IF コマンド 
$SELECT 関数 
後置条件式
論理演算子を含んでいる式の場合、Cach&eacute; ObjectScript は、すべてのオペランドを評価する前に論理値の結果が判明する場合にも、すべてのオペランドを評価します。 
以下のルーチンでは、最初の関数が偽を返すため、自動的に式全体の結果が偽になりますが、すべての関数を実行します。 
logexp ; comment
If $$one() & $$two() {
Write !,"Expression is TRUE." 
} Else {
Write !,"Expression is FALSE."
}
one() 
Write !,"one"
Quit 0
two()
Write !,"two"
Quit 1
代入
ObjectScript の SET コマンドは、代入演算子 ( = ) を併用して変数に値を代入します。代入コマンドの右側に式がきます。
Set value = 0
Set value = a + b
ObjectScript では、代入コマンドの左側にも特定の関数を使用できます。
Set pies = "apple,banana,cherry"
Write "Before: ",pies,!
// set the 3rd comma-delimited piece of pies to coconut
Set $Piece(pies,",",3) = "coconut"
Write "After: ",pies
算術演算子
算術演算子は、オペランドを数値として解釈し、数値結果を生成します。
単項プラス演算子 (+)
単項プラス演算子 (+) は、単一のオペランドを数値として解釈します。オペランドが文字列値を持つ場合、それを数値に変換します。無効な文字に遭遇するまで、文字列の文字を数値として順番に解析します。先行する文字列部が数値として有効な場合、それを返します。例えば以下のようになります。
Write + "32 dollars and 64 cents"        // 32
文字列の先頭に数値文字がない場合、単項プラス演算子は、オペランドをゼロとします。例えば以下のようになります。
Write + "Thirty-two dollars and 64 cents" // 0
単項プラス演算子は、数値に対して何も作用しません。正数または負数の符号も変更しません。例えば以下のようになります。
Set x = -23
Write " x: ", x,! // -23
Write "+x: ",+x,! // -23
単項マイナス演算子 (-)
単項マイナス演算子 (-) は、数値と解釈されるオペランドの符号を反転します。例えば以下のようになります。
Set x = -60
Write " x: ", x,! // -60
Write "-x: ",-x,! // 60
オペランドが文字列値を持つ場合、単項マイナス演算子はその文字列を数値として解釈し、符号を反転します。数値は、上記の単項プラス演算子と同様の方法で解釈されます。例えば以下のようになります。
Set x = -23
Write -"32 dollars and 64 cents" // -32
Cach&eacute; ObjectScript は、2 項算術演算子より単項マイナス演算子を優先します。最初に数値式を走査し、単項マイナス演算子を実行します。その後、式を計算し結果を算出します。
以下の例では、Cach&eacute; ObjectScript は文字列を検索し、数値 2 を検出するとそこで停止します。その後、単項マイナス演算子をその値に適用し、連結演算子 (_) を使用して、2 番目の文字列からの値 Rats を数値に結合します。
Write -"2Cats"_"Rats" // -2Rats
数値式の絶対値を返すには、$ZABS 関数を使用します。
加算演算子 (+)
加算演算子は、2 つの数値として解釈されるオペランドの和を算出します。この演算子も、オペランドの数値として先行する有効な数値文字をすべて使用し、オペランドの数値の和を算出します。
以下の例は、2 つの数値リテラルを加算します。
Write 2936.22 + 301.45 //  3237.67
以下の例は、2 つの定義済みローカル変数を加算します。
Set x = 4
Set y = 5
Write "x + y = ",x + y // 9
以下の例は、先行する数字を持つ 2 つのオペランドに対し文字列算術を実行し、その結果を加算します。
Write "4 Motorcycles" + "5 bicycles" // 9
以下の例は、数値として評価されるオペランドの先行ゼロが、演算子の結果に何も作用しないことを示します。
Write "007" + 10 // 17
減算演算子 (-)
減算演算子は、数値として解釈される 2 つのオペランドの差を算出します。この演算子も、オペランドの数値として先行する有効な数値文字をすべて解釈して、減算後の剰余を算出します。
以下の例は、2 つの数値リテラルを減算します。
Write 2936.22 - 301.45 // 2634.77
以下の例は、2 つの定義済みローカル変数を減算します。
Set x = 4
Set y = 5
Write "x - y = ",x - y // -1
以下の例は、先行する数字を持つ 2 つのオペランドに対し文字列算術を実行し、その結果を減算します。
Write "8 apples" - "4 oranges" // 4
オペランドが先行数値文字を持たない場合、Cach&eacute; ObjectScript は、その値をゼロと見なします。例えば以下のようになります。
Write "8 apples" - "four oranges" // 8
乗算演算子 (*)
二項乗算演算子は、数値として解釈される 2 つのオペランドの積を算出します。この演算子も、オペランドの数値として先行する有効な数値文字をすべて使用して、積を算出します。
以下の例は、2 つの数値リテラルを乗算します。
Write 9 * 5.5 // 49.5
以下の例は、2 つの定義済みローカル変数を乗算します。
Set x = 4
Set y = 5
Write x * y // 20
以下の例は、先行する数字を持つ 2 つのオペランドに文字列算術を実行し、その結果を乗算します。
Write "8 apples" * "4 oranges"  // 32
オペランドが先行数値文字を持たない場合、二項乗算演算子は、その値にゼロを割り当てます。
Write "8 apples"*"four oranges" // 0
除算演算子 (/)
二項除算演算子は、数値として解釈される 2 つのオペランドの除算結果を算出します。この演算子も、オペランドの数値として先行する有効な数値文字をすべて使用して、商を算出します。 
以下の例は、2 つの数値リテラルを除算します。
Write 9 / 5.5 // 1.636363636363636364
以下の例は、2 つの定義済みローカル変数を除算します。
Set x = 4
Set y = 5
Write x / y // .8
以下の例は、先行する数字を持つ 2 つのオペランドに文字列算術を実行し、その結果を除算します。
Write "8 apples" / "4 oranges"  // 2
オペランドが先行数値文字を持たない場合、二項除算演算子は、その値をゼロと見なします。例えば以下のようになります。
Write "eight apples" / "4 oranges" // 0
// "8 apples"/"four oranges" generates a <DIVIDE> error
上記の 2 番目の演算は無効です。ゼロによる数値の除算は許可されていないからです。Cach&eacute; ObjectScript は、<DIVIDE> エラー・メッセージを返します。
指数演算子 (**)
指数演算子は、右のオペランドを指数として左のオペランドをべき乗した値を算出します。左右のオペランドは、正あるいは負の数字、もしくは 0 になります。しかし、左のオペランドがゼロ (0) の場合、右のオペランドは正の数になります。ゼロを任意の正数でべき乗した結果はゼロですが、ゼロや負数をゼロ乗しようとすると、<ILLEGAL VALUE> エラーが生じます。
以下の例は、2 つの数値リテラルをべき乗します。
Write "9 ** 2 = ",9 ** 2,! // 81
Write "9 ** -2 = ",9 ** -2,! // .01234567901234567901
Write "9 ** 2.5 = ",9 ** 2.5,! // 242.9999999994422343
以下の例は、2 つの定義済みローカル変数をべき乗します。
Set x = 4, y = 3
Write "x ** y = ",x ** y,! // 64
以下の例は、文字列算術演算を実行します。指数演算子も、オペランドの値として先行する数値文字をすべて使用して、結果を算出します。
Write "4 apples" ** "3 oranges" // 64
オペランドが先行数値文字を持たない場合、指数演算子は、その値をゼロと見なします。
以下の例は、指数を使用した数値の平方根の算出方法です。
Write 256 ** .5 // 16
整数除算演算子 ( \ )
整数除算演算子は、左のオペランドを右のオペランドで除算した整数の結果を算出します。剰余を返さず、結果も丸めません。
以下の例は、2 つの整数オペランドを整数除算します。Cach&eacute; ObjectScript は、結果の小数部分を返しません。
Write "355 \ 113 = ", 355 \ 113 // 3
以下の例は、文字列算術演算を実行します。整数除算演算子も、オペランドの値として先行する数値文字をすべて使用して、整数の結果を算出します。
Write "8 Apples" \ "3.1 oranges" // 2
オペランドが先行数値文字を持たない場合、Cach&eacute; ObjectScript は、その値をゼロと見なします。整数をゼロで除算しようとすると、Cach&eacute; ObjectScript は <DIVIDE> エラーを生じます。
モジュロ演算子 (#)
モジュロ演算子は、数値として解釈される 2 つのオペランドにモジュロ演算の結果を算出します。2 つのオペランドが正の場合、モジュロ演算の結果は、右のオペランドで左のオペランドを整数除算した剰余です。
以下の例は、数値リテラルにモジュロ演算を実行し、その剰余を返します。
Write "37 # 10 = ",37 # 10,! // 7
Write "12.5 # 3.2 = ",12.5 # 3.2,! // 2.9
以下の例は、文字列算術演算を実行します。文字列の演算を行う場合、モジュロ演算子が適用される前に、文字列は数値に変換されます ("変数のタイプと変換" の章で説明されています)。したがって、以下の 2 つの式は同一です。
Write "8 apples" # "3 oranges",!  // 2
Write 8 # 3 // 2
Cach&eacute; は、先行数値文字のない文字列を 0 と解釈するため、このような右のオペランドは DIVIDE エラーを生じます。
論理比較演算子
論理比較演算子は、オペランド値を比較し、真 (1) か偽 (0) のブーリアン値を返します。
単項否定演算子 
単項否定演算子は、ブーリアン型オペランドの真理値を反転します。オペランドが真 (1) の場合、単項否定演算子は偽 (0) になります。オペランドが偽 (0) の場合、単項否定演算子は真 (1) になります。 
例えば、以下の文は偽 (0) の結果を返します。 
SET x=0
WRITE x
一方、以下の文は真 (1) を返します。 
SET x=0
WRITE 'x
比較演算子で単項否定演算子を使用すると、演算子が実行する演算の意味が反転します。事実上、演算の結果が反転されます。例えば、以下の文は偽 (0) の結果を返します。 
WRITE 3>5
しかし、以下の例は真 (1) の結果を表示します。 
WRITE 3'>5
論理演算子の優先順位
Cach&eacute; ObjectScript は、厳格に演算子を左から右へ評価するため、その他の演算子が関与する論理比較では、必要な優先順位を実現するために、演算をグループ化する括弧を使用する必要があります。例えば、以下のプログラムで真 (1) を返すために、二項論理和演算 (!) テストが要求されます。
SET x=1,y=0
WRITE x=1!y=0  // Returns FALSE, due to evaluation order
しかし、この論理比較を適切に実行するには、その他の演算を入れ子にする括弧を使用する必要があります。以下の例では、期待される結果が得られます。
SET x=1,y=0
WRITE (x=1)!(y=0)  // Returns TRUE as expected
二項論理積演算子 
二項論理積演算子は、オペランドの両方の値が真 (1) であるかどうかを判断します。オペランドが両方とも真の場合 (つまり、数値として計算した場合、ゼロ以外の値となる)、Cach&eacute; ObjectScript の値は、真 (1) になります。それ以外の場合、偽 (0) を返します。 
二項論理積演算子には、& と && という 2 つの形式があります。 
& 演算子は、両方のオペランドを評価し、いずれかのオペランドの値がゼロの場合、偽 (0) を返します。それ以外は真 (1) を返します。 
&& 演算子は、左のオペランドを評価し、そのオペランドの値がゼロの場合、偽 (0) を返します。左のオペランドが 0 ではない場合にのみ、右のオペランドを評価します。右のオペランドの評価がゼロの場合、偽 (0) を返します。それ以外は真 (1) を返します。 
以下の例は、2 つのゼロ以外のオペランドを真と評価して真 (1) を返します。 
Set A=-4,B=1
Write A&B // TRUE (1)
これは、1 を返します。
Set A=-4,B=1
Write A&&B // TRUE (1)
これは、1 を返します。
以下の例は、真と偽のオペランドをそれぞれ評価して偽 (0) を返します。 
Set A=1,B=0
Write "A = ",A,!
Write "B = ",B,!
Write "A&B = ",A&B,! // FALSE (0)
Set A=1,B=0
Write "A&&B = ",A&&B,! // FALSE (0)
上記は、両方とも偽 (0) を返します。
以下の例は、& 演算子と && 演算子の違いを示します。以下の例では、左のオペランドは偽 (0) と評価され、右のオペランドは定義されていません。この場合、& と && 演算子の結果が異なることに注意してください。
演算子は両方のオペランドを評価し、<UNDEFINED> エラーを生じます。&&
Kill B
Set A=0
Write A&B
&& 演算子は左のオペランドのみを評価し、偽 (0) を返します。
Kill B
Set A=0
Write A&&B // FALSE (0)
論理積否定演算 (NAND) 
以下に相当するいずれかの形式で、二項論理積演算子 (&) と単項否定演算子を併用して、論理積否定演算 (NAND) 演算を指定できます。 
operand '& operand 
'(operand & operand)
論理積否定演算は、両方のオペランドに適用された & 二項論理積演算の論理値を反転します。いずれかのオペランド、もしくは両方のオペランドが偽である場合、真 (1) を返します。両方のオペランドが真の場合、偽を返します。 
&& 二項論理積演算子の前に、単項否定演算子を付けることはできません。'&& という形式はサポートされていません。ただし、以下の形式はサポートされています。
'(operand && operand)
以下の例では、2 つの対応する論理積否定演算を実行します。各演算で、1 つの 偽 (0) と 1 つの真 (1) のオペランドが評価され、真 (1) の値が返されます。
Set A=0,B=1
Write !,A'&B   // Returns 1
Write !,'(A&B) // Returns 1
以下の例では、&& 二項論理積演算を実行することにより、論理積否定演算を実行した後、単項否定演算を使用して、結果を反転させます。&& 演算は、最初のオペランドをテストし、ブーリアン値が偽 (0) のため、&& は 2 番目のオペランドをテストしません。単項否定演算は、式が真 (1) を返すように、結果のブーリアン値を反転させます。
Set A=0
Write !,'(A&&B)   // Returns 1
二項論理和演算 
二項論理和演算子は、いずれか一方のオペランドが真の値を持つ場合、あるいは両方のオペランドが真 (1) の値を持つ場合、真 (1) を返します。二項論理和演算子は、両方のオペランドが偽 (0) の場合にのみ偽 (0) を返します。 
二項論理和演算には 2 つの形式、! (感嘆符) と || (2 本の垂直バー) があります。 
! 演算子は、両方のオペランドを評価し、両方のオペランドの値がゼロの場合、偽 (0) を返します。それ以外は真 (1) を返します。 
|| 演算子は、左のオペランドを評価します。左のオペランドの値がゼロ以外に評価された場合、右のオペランドを評価せずに真 (1) を返します。左のオペランドが 0 の場合にのみ、|| 演算子は、右のオペランドを評価します。右のオペランドがゼロの場合、偽 (0) を返します。それ以外は真 (1) を返します。
以下の例は、2 つの真の (ゼロではない) オペランドに二項論理和演算を実行し、真の結果を返します。 
Set A=5,B=7
Write "A!B = ",A!B,! 
Set A=5,B=7
Write "A||B = ",A||B,!
上記は、両方とも真 (1) を返します。
以下の例は、偽のオペランドと真のオペランドに二項論理和演算を実行し、真の結果を返します。 
Set A=0,B=7
Write "A!B = ",A!B,!
Set A=0,B=7
Write "A||B = ",A||B,!
上記は、両方とも真 (1) を返します。
以下の例は、2 つの偽のオペランドを評価し、偽の結果を返します。 
Set A=0,B=0
Write "A!B = ",A!B,!
Set A=0,B=0
Write "A||B = ",A||B,!
上記は、両方とも偽 (0) を返します。
論理和否定演算 (NOR) 
論理和否定演算 (NOR) は、以下に相当するいずれかの形式で、!二項論理和演算子と単項否定演算子を併用して記述できます。 
operand '! operand
'(operand ! operand)
論理和否定演算は、両方のオペランドが偽の場合、真 (1) の結果を返します。どちらか一方のオペランドが真の場合、あるいは両方のオペランドが真の場合、偽 (0) の結果を返します。 
|| 二項論理和演算子の前に、単項否定演算子を付けることはできません。'|| という形式はサポートされていません。ただし、以下の形式はサポートされています。
'(operand || operand)
以下の論理和否定演算の例は、2 つの偽のオペランドを評価して、真の結果を返します。
Set A=0,B=0
Write "A'!B = ",A'!B   // Returns 1
Set A=0,B=0
Write "'(A!B) = ",'(A!B)   // Returns 1
以下の論理和否定演算の例は、1 つの真のオペランドと 1 つの偽のオペランドを評価して、偽の結果を返します。
Set A=0,B=1
Write "A'!B = ",A'!B   // Returns 0
Set A=0,B=1
Write "'(A!B) = ",'(A!B)   // Returns 0
以下の論理和否定演算の例では、左のオペランドを評価し、その結果が真 (1) なので、右のオペランドを評価しません。単項否定演算は、式が偽 (0) を返すように、結果のブーリアン値を反転させます。
Set A=1
Write "'(A||B) = ",'(A||B)   // Returns 0
文字列演算子
文字列演算子は、オペランドを文字列として解釈し、文字列値を返します。単一の文字列演算子は、二項結合演算子 (_) です。 
二項結合演算子 
二項結合演算子を使用して、文字列リテラル、式、変数を結合します。以下の形式をとります。 
operand_operand
二項結合演算子は、右のオペランドを左のオペランドの後ろに結合させた文字列を結果として返します。二項結合演算子は、そのオペランドを特に解釈せず、文字列値として処理します。 
以下の例は、2 つの文字列を結合します。 
Write "High"_"chair"
上記は、Highchair を返します。
以下の例は、2 つの数値リテラルと文字列を結合します。 
Write 609_"-"_24
これは、609-24 を返します。
以下の例は、2 つの文字列と NULL 文字列を結合します。 
Set A="ABC"_""_"DEF" 
Write A
これは、ABCDEF を返します。
NULL 文字列は、文字列の長さに影響しないため、無数の NULL 文字列を文字列に結合できます。 
数値関係演算子 
文字列関係演算子と数値関係演算子という、2 種類の関係演算子があります。数値関係演算子は、オペランドの数値を使用してブーリアン値の結果を返します。
二項より小さい関係演算子 
二項より小さい関係演算子は、左のオペランドが右のオペランドより数値的に小さいかどうかをテストします。Cach&eacute; ObjectScript は、両方のオペランドを数値的に評価して、左のオペランドが右のオペランドより数値的に小さい場合、真 (1) のブーリアン値を返します。左のオペランドが右のオペランドと数値的に等しい、または大きい場合、偽 (0) のブーリアン値を返します。例えば以下のようになります。 
Write 9 < 6
これは、0 を返します。
Write 22 < 100
これは、1 を返します。
二項より大きい関係演算子 
二項より大きい関係演算子は、左のオペランドが右のオペランドより数値的に大きいかどうかを判断します。Cach&eacute; ObjectScript は、2 つのオペランドを数値的に評価し、左のオペランドが右のオペランドより大きい場合、真 (1) を返します。左のオペランドが右のオペランドと数値的に等しい、または小さい場合、偽 (0) の論理値を返します。例えば以下のようになります。 
Write 15 > 15
これは、0 を返します。
Write 22 > 100
これは、0 を返します。
以上関係演算子 
以下のようにして、以上関係演算子を記述できます。
二項より大きい関係演算子 (>) と等値演算子 (=) を結合します。2 つの演算子のどちらかが TRUE を返す場合、これらの演算子の組み合わせによって TRUE が返されます。
二項より小さい関係演算子 (<) に単項否定演算子 (') を使用します。共に使用する 2 つの演算子は、二項より小さい関係演算子の真理値を反転します。
Cach&eacute; ObjectScript は、左のオペランドが右のオペランドより数値的に大きい、または等しい場合、真 (1) の結果を返します。左のオペランドが右のオペランドよりも数値的に小さい場合、偽 (0) の結果を返します。 
以下のいずれかの方法で、以上関係演算を記述できます。
operand_A >= operand_B
operand_A '< operand_B
'(operand_A < operand_B)
以下関係演算子 
以下のようにして、以下関係演算子を記述できます。
二項より小さい関係演算子 (<) と等値演算子 (=) を結合します。2 つの演算子のどちらかが TRUE を返す場合、これらの演算子の組み合わせによって TRUE が返されます。
二項より大きい関係演算子 (>) に単項否定演算子 () を使用します。共に使用する 2 つの演算子は、二項より大きい関係演算子の論理値を反転します。
Cach&eacute; ObjectScript は、左のオペランドが右のオペランドより数値的に小さい、または等しい場合に真 (1) の結果を返します。左のオペランドが右のオペランドよりも数値的に大きい場合、偽 (0) の結果を返します。 
以下のいずれか方法で、以下関係演算を記述できます。
operand_A <= operand_B
operand_A '> operand_B
'(operand_A > operand_B)
以下の例は、以下関係演算で 2 つの変数をテストします。両方の変数の値が等しいため、結果は真となります。 
Set A="55",B="55" 
Write A'>B
これは、1 を返します。
文字列関係演算子
文字列関係演算子は、オペランドを文字列として解釈してブーリアン値の結果を返します。文字列関係演算子は、否定論理演算子 (') を先頭に付けて、論理結果を反転することができます。 
二項等値演算子 
二項等値演算子は、2 つのオペランドが文字列として等しいかを判断します。二項等値演算子を 2 つの文字列で実行すると、Cach&eacute; ObjectScript は、2 つのオペランドの文字順序が同一で、スペースを含め他の異なる文字を持たない同一の文字列の場合に真 (1) を返します。 それ以外の場合は偽 (0) を返します。例えば以下のようになります。 
Write "SEVEN"="SEVEN"
上記は、真 (1) を返します。
二項等値演算子は、どちらのオペランドも数値的に解釈しません。例えば、以下の文は、2 つのオペランドが数値的には等価ですが、偽 (0) を返します。 
Write "007"="7"
上記は、偽 (0) を返します。
両方のオペランドが数値である場合、二項等値演算子を使用して、数値的に等しいかどうかを判断できます。例えば以下のようになります。 
Write 007=7
上記は、真 (1) を返します。
また、単項プラス演算子を使用して、強制的に数値変換を実行できます。例えば以下のようになります。 
Write +"007"="7"
上記は、真 (1) を返します。
不等関係演算 
不等関係演算は、単項否定演算子と二項等値演算子を併用して指定できます。以下の 2 通りの方法で、不等関係演算を記述できます。 
operand '= operand
'(operand = operand)
不等関係演算は、二項等値演算子を両方のオペランドに適用した場合の論理値を反転します。2 つのオペランドが等しくない場合、結果は真 (1) となります。2 つのオペランドが等しい場合、結果は偽 (0) となります。 
二項包含関係演算子 
二項包含関係子は、右のオペランドの一連の文字が、左の文字の部分文字列であるかを判断します。左のオペランドが、右のオペランドの文字列を含んでいる場合、結果は真 (1) となります。左のオペランドが、右のオペランドの文字列を含んでいない場合、結果は偽 (0) となります。右のオペランドが NULL 文字列の場合、結果は常に真となります。 
以下の例は、L の文字列が S の文字列を含むかどうかを判断します。L は S を含んでいるため、結果は真 (1) となります。 
Set L="Steam Locomotive",S="Steam"
Write L[S
上記は、真 (1) を返します。
以下の例は、P の文字列が S の文字列を含むかどうかを判断します。文字列中の文字の並びが異なるため (P はピリオド、S は感嘆符を持つ)、結果は偽 (0) となります。 
Set P="Let's play.",S="Let's play!"
Write P[S
上記は、偽 (0) を返します。
非包含演算 
非包含演算は、以下のいずれかの等価形式で、二項包含関係演算子と単項否定演算子を使用して記述できます。 
operand A '[ operand B
'(operand A [ operand B) 
非包含演算は、オペランド A がオペランド B の文字列を含まない場合に真を返し、オペランド B の文字列を含む場合は偽を返します。 
Set P="Beatles", S="Mick Jagger"
Write P'[S
これは、1 を返します。
二項後続関係演算子 
二項後続関係演算子は、ASCII 文字順序で、左のオペランドの文字が右のオペランドの文字の後に来るかどうかを判断します。二項後続関係演算子は、両方の文字列が、それぞれの最左端の文字から始まるものとします。このテストは、以下のいずれかの場合に終了します。 
左のオペランドの中に、対応する右のオペランドの文字と異なる文字が発見された場合 
いずれかのオペランドに、比較する文字がない場合 
Cach&eacute; ObjectScript は、左のオペランドで、対応する右のオペランドと異なる最初の文字が、高い ASCII 値を持つ場合 (つまり、左のオペランドの文字が、右のオペランドの文字よりも ASCII 文字順で後に来る場合)、真の値を返します。右のオペランドが左のオペランドより短いが、文字は等しい場合も、Cach&eacute; ObjectScript は真の値を返します。 
Cach&eacute; ObjectScript は、以下のいずれかの条件が当てはまる場合、偽の値を返します。 
左のオペランドで、対応する右のオペランドと異なる最初の文字が、低い ASCII 値を持つ場合 
左のオペランドが右のオペランドと同一の場合 
左のオペランドが右のオペランドと同一であるが、長さが短い場合 
以下の例は、文字列 LAMPOON が、ASCII 文字順で文字列 LAMP の後に来るかどうかを判断します。結果は真です。 
Write "LAMPOON"]"LAMP"
上記は、真 (1) を返します。
以下の例は、B の文字列が A の文字列の後に来るかどうかを判断します。ASCII 文字順では、BO が BL の後に来るため結果は真です。 
Set A="BLUE",B="BOY" 
Write B]A
上記は、真 (1) を返します。
非後続演算 
非後続演算は、以下のどちらかの等価形式で、二項後続関係演算子と単項否定演算子を使用して記述できます。 
operand A ']operand B 
'(operand A ] operand B) 
非後続演算は、両方のオペランドのすべての文字が同一である場合、あるいはオペランド A で、対応する B のオペランドと異なる最初の文字が低い ASCII 値を持つ場合、真の値を返します。また、オペランド A で、対応するオペランド B と異なる最初の文字が高い ASCII 値を持つ場合、偽の値を返します。 
以下の例では、CDE の C は ABC の A の後ろに来るため、結果は偽となります。 
Write "CDE"']"ABC",!
Write '("CDE"]"ABC")
上記は、偽 (0) を返します。
二項前後関係演算子 
二項前後関係演算子は、左のオペランドが、数値添え字順に右のオペランドの前か、後ろに順番になっているかを判定します。数値照合順では、NULL 文字列は最初に位置し、その後に正規の数の負数、ゼロ、整数と続き、最後に非数字の値がきます。 
二項前後関係演算子は、第 1 オペランドが、第 2 オペランドの前か、後ろに順番になっている場合に真 (1) を、そうでない場合に偽 (0) を返します。例えば以下のようになります。 
Write 122]]2
上記は、真 (1) を返します。
Write "LAMPOON"]]"LAMP"
上記は、真 (1) を返します。
非前後関係演算 
非前後関係演算は、以下のいずれかの等価形式でも、二項後続関係演算子と共に単項否定演算子を使用して記述できます。 
operand A ']] operand B
'(operand A ]] operand B)
オペランド A がオペランド B と同一である場合、あるいはオペランド B が、オペランド A の後ろにソートされている場合、Cach&eacute; ObjectScript は、真の値を返します。オペランド A がオペランド B の後ろにソートされている場合、偽の値を返します。 
パターン・マッチング
パターン・マッチング演算子は、左オペランドの文字パターンが、その右オペランドのパターンと正確に一致しているかどうかを判断します。
以下の例は、文字列 ssn に有効な米国社会保証番号 (数字 3 桁、ハイフン、数字 2 桁、ハイフン、数字 4 桁) が含まれているかどうかをテストします。
Set Match = SSN ?3N1"-"2N1"-"4N
? 演算子の後に空白を置かないことに注意してください。パターン内の空白は引用符内の文字列に置く必要があり、パターンの一部として解釈されます。
パターン・マッチング演算の一般的な形式は以下の通りです。
operand?pattern
operand
パターンをテストしたい文字列です。
pattern
1 つ以上の patatoms (パターン要素) の列、あるいは 1 つ以上の patatoms の列を評価する間接指定の参照のいずれかになります。
patatom は、以下のいずれかになります。
repcount patcharacter
repcount stringliteral
repcount alternation
repcount
リピート・カウント  インスタンス数に一致します。repcount は、数字かピリオド文字 (.) を評価できます。任意の繰り返し回数を指定するには、ピリオドを使用します。
patcharacter
パターン・コード
stringliteral
2 重引用符で囲まれた文字列リテラル
alternation
パターン要素の列の組で、そこから選択してオペランド文字列のゼグメントとパターン・マッチングします (パターン指定で論理 OR 機能を提供します)。
特定の文字や文字列を比較したい場合、二重引用符で囲んだ文字列リテラルをパターンで使用します。他の状況では、Cach&eacute; ObjectScript が提供する特殊なパターン・コードを使用します。以下の表は、使用可能なパターン・コードとその意味です。
パターン・マッチ・コード
コード
意味
A
52 個の大文字・小文字のすべての ASCII 英文字 (A から Z と a から z) と一致
C
33 個の ASCII 制御文字 (ASCII コードの 0 から 31 までと 127) のいずれとも一致
E
テキスト内の文字のいずれとも一致
L
26 個の小文字の ASCII 英文字 (a から z) のいずれとも一致
N
10 個の ASCII 数字 (0 から 9) のいずれとも一致
P
33 個の ASCII 句読点文字 (ASCII コードの 32 から 47、58 から 64、91 から 96、および 123 から 126) のいずれとも一致
U
26 個の大文字の ASCII 英字 (A から Z) のいずれとも一致
ZFWCHARZ
日本語の全角文字セット (ASCII コードの 12447、12448 を除く 12354 から 12542 まで) のいずれとも一致
ZHWKATAZ
日本語の半角かな文字セット (ASCII コードの 65393 から 65439) のいずれとも一致
パターン・コードには、大文字と小文字の区別がありません。したがって、大文字と小文字のいずれでも指定できます。例えば、?5N と ?5n は等価です。
パターン・マッチング演算子は、パターンがオペランドの文字パターンに一致した場合に真 (1) の結果を返します。また、一致しなかった場合は偽 (0) の結果を返します。
パターン・マッチング演算子は、二項包含関係演算子 ([) とは異なります。二項包含関係演算子は、左辺のオペランドの部分文字列が右辺のオペランドと一致する場合も、真 (1) を返します。また、二項包含関係式は、パターン・マッチング演算子で使用できる一連のオプションを提供しません。二項包含関係式では、単一の文字列のみ右辺のオペランドで使用できます。 特殊コードは使用できません。
例えば、変数 var2 が値 abc を持つ場合、以下のパターン・マッチング式を考えてみます。
Set match = var2?2L
var2 は、2 つではなく 3 つの小文字を持っているため、match は偽 (0) の結果を返します。
パターン・マッチングの範囲は、以下を指定して拡張できます。
パターンの繰り返し回数
複数パターン
組み合わせパターン
不確定パターン
交互パターン
パターンの繰り返し回数の指定
以下の形式で、目的のオペランドで実行する pattern の回数範囲を決定します。
n.n
1 番目の n は繰り返し範囲の下限を、2 番目の n は上限を定義します。
例えば、変数 var3  に、文字列 ABABAB が含まれているとします。以下の例で、1.4 は AB の繰り返しが 1 回から 4 回あると認識されていることを示します。
Set match = var3?1.4"AB"
この式は、var3 が AB の繰り返しを 3 回しか含んでいない場合でも、真 (1) の結果を返します。
別の例として、以下の式を考えてみます。
Set match = var3?1.6A
この式は、var3 に 1 個から 6 個までの大文字の英文字を持っているかどうかをチェックします。var3 が 7 文字以上の文字、または何も持っていない場合にのみ、偽 (0) の結果を返します。
どちらか一方の n を省略すると、Cach&eacute; ObjectScript は既定値を提供します。1 番目の n の既定値はゼロ (0) です。2 番目の n の既定値は任意の値です。以下の例を考えてみます。
Set match = var3?1."AB"
この例は、var3 が、パターン文字列 AB を少なくとも一度繰り返している限り、真 (1) を返します。
複数パターンの指定
複数パターンを定義するには、任意の長さで n とパターンを組み合わせます。以下の例を考えてみます。
Set match = date?2N1"/"2N1"/"2N
この式は、mm/dd/yy 形式で日付値をチェックします。文字列 4/ 27/98 は、月の数字が 1 桁であるため偽 (0) を返します。1 桁の月と 2 桁の月の両方を検出するには、以下のように変更します。
Set match = date?1.2N1"/"2N1"/"2N
1 番目のパターン・マッチング (1.2N) は、1 桁または 2 桁の数字を受け取ります。前述のように、繰り返し回数の範囲を定義するため、オプションの小数点 (.) を使用します。
組み合わせパターンの指定
以下の形式を使用して、組み合わせパターンを定義します。
PatternPattern
パターンの組み合わせを使用して、最初の pattern と 2 番目の pattern の内容が、目的のオペランドに対しチェックされます。例えば、以下の式を考えてみます。
Set match = value?3N.4L
この式は、3 桁の数字の後ろに、0 から 4 つの小文字の英字が続いているかどうかのパターンをチェックします。目的のオペランドにパターンの組み合わせと同じものが 1 つ含まれている場合にのみ真 (1) を返します。例えば、文字列 345gfij は一致しますが、345gfij276hkbc は一致しません。
不定回パターンの指定
以下の形式を使用して、不定回パターンを指定します。
.pattern
不定回パターンを使用して、目的のオペランドは、pattern の繰り返しをチェックします。繰り返しの数は (ゼロ回を含め) 指定されません。例えば、以下の式を考えてみます。
Set match = value?.N
この式は、目的のオペランドがゼロもしくは 1 つ以上の数字を含み、その他のタイプの文字を含まない場合、真 (1) を返します。
交互パターンの指定 (論理 OR)
交互パターンは、複数のパターン列中の 1 列を使用して、オペランド文字列の特定セグメントにパターン・マッチングを指定する場合に使用します。パターン・マッチングに論理 OR 機能を追加するため、使用するパターンを単純にします。
交互パターンの構文は、以下の通りです。
( patatom sequence {, patatom sequence }...)
したがって、以下のパターンは、val に文字 A が 1 回出現する、あるいは文字 B が 1 回出現する場合に真 (1) を返します。
Set match = value?1(1"A",1"B")
交互パターンは、以下のパターン・マッチング式のように入れ子にできます。
Set match = value?.(.(1A,1N),1P)
例えば、電話番号の妥当性を検証したい場合、少なくとも 3 桁目と 4 桁目の間にハイフン (-) のある 7 桁の電話番号が必要です。例えば以下のようになります。
nnn-nnnn
また、電話番号に 3 桁の市外局番がある場合、小カッコで囲む、あるいはハイフンで残りの番号から区別する必要があります。例えば以下のようになります。
(nnn) nnn-nnnn
nnn-nnn-nnnn
以下のパターン・マッチング式は、電話番号の 3 つの有効な形式を示します。
Set match = phone?3N1"-"4N
Set match = phone?3N1"-"3N1"-"4N
Set match = phone?1"("3N1") "3N1"-"4N
交互パターンを使用しない場合には、次の複合ブーリアン式が、あらゆる形式の電話番号の妥当性を確認するために必要となります。
Set match = 
(
(phone?3N1"-"4N) || 
(phone?3N1"-"3N1"-"4N) || 
(phone?1"("3N1") "3N1"-"4N)
)
交互パターンを使用する場合、電話番号の妥当性を検証するために、以下の単一のパターンが必要です。
Set match = phone?.1(1"("3N1") ",3N1"-")3N1"-"4N
この例の交互パターンでは、電話番号の市外局番部分を、1"("3N1")" または 3N1"-" のいずれかで表現することできます。0 から 1 の交互カウント範囲は、オペランドphone が、0 または 1 のエリア・コードを持てることを示します。
1 より大きい反復カウントを持つ交互パターンは、使用できるパターンの組み合わせを多く生成できます。以下の交互パターンは、例で示されている文字列と一致する以外に、26 通りの 3 文字の文字列と一致します。
Set match = "CAT"?3(1"C",1"A",1"T")
不足パターンの使用法
パターン・マッチングにより、文字列の一部しか一致しない場合、偽 (0) の結果を返します。つまり、パターンを比較する場合、比較される文字列が余ってはいけないことを示します。以下の式は、パターンの最後の R が一致しないため、偽 (0) を返します。
Set match = "RAW BAR"?.U1P2U
パターンの複数解釈
オペランドを比較する際に、1 つのパターンに複数の解釈が可能な場合があります。例えば、以下の式は 2 通りの解釈ができます。
Set match = "/////A#####B$$$$$"?.E1U.E
最初の .E が部分文字列の ///// と一致し、1U は A と一致し、2番目の .E は部分文字列の #####B$$$$$ と一致します。
最初の .E が部分文字列は /////A##### と、1U は B と一致し、2番目の .E は部分文字列の .E と一致します。
少なくとも式の 1 つの解釈が真 (1) である場合、式の値は真となります。
非マッチ演算
非マッチング演算は、パターン・マッチング演算子と共に単項否定演算子を使用して記述できます。
'(operand?pattern)
非マッチ演算は、パターン・マッチングの真理値を反転します。オペランドの文字がパターンと一致しない場合、非マッチ演算は真 (1) を返します。パターンがオペランドの文字のすべてに一致する場合、非マッチ演算は偽 (0) を返します。
間接演算
Cach&eacute; ObjectScript の間接演算子 (@) は、変数に間接的に値を割り当てることができます。間接演算とは、コマンド行、コマンド、コマンド引数の一部あるいはすべてを、データ・フィールドの内容で、実行時にダイナミックに置換する手段です。Cach&eacute; は、関連するコマンドを実行する前に、置換を実行します。
間接演算は、Cach&eacute; オブジェクト・ドット構文と併用してはいけません。ドット構文は、実行時ではなくマクロ・コンパイル時に構文解析されるためです。
間接演算は、他の方法より能率的かつ汎用的にコーディングできますが、必ずしも使用する必要はありません。XECUTE コマンドなど他の方法を使用して、間接演算と同様の機能を常に実行できます。
間接演算は、明らかに便利な場合にのみ使用します。間接演算は、Cach&eacute; がコンパイル・フェーズの間ではなく、実行時に必要な評価を実行するため、性能に影響を与えます。また、複雑な間接演算を使用する場合、明確なコードを記述する必要があります。間接演算は、コード解析を複雑にする場合があるからです。
間接演算は、添え字間接演算の場合を除いて、間接演算子 (@) で指定され、以下の形式になります。
@variable
variable は、置換する値を取得する変数を識別します。変数は配列ノードです。
以下のルーチンは、間接演算がその右側にある変数全体の値を参照することを示します。 
indir ; gsm;11:37 PM 13 Jun 2000
Set x = "a"
Set x(3) = "b"
;The next line will do b, NOT a(3)
DO @x(3)
Quit
a(i)
Write !,"At a"
Quit
b 
Write !,"At b"
Quit
Cach&eacute; には、以下の 5 つの間接演算があります。 
名前間接演算 
パターン間接演算 
引数間接演算 
添え字間接演算 
$TEXT 引数間接指定 
@ 変数が発生するコンテキストによって、実行する間接演算が異なります。各間接演算の説明を以下に示します。
間接演算は、ドット構文には使用できません。ドット構文が実行時ではなく、コンパイル時に構文解析されるためです。 
名前間接演算 
名前間接演算では、間接演算は、変数名、行ラベル、ルーチン名を評価します。Cach&eacute; は、変数の内容をコマンド実行前に要求された名前に置換します。
名前付き変数を参照するために間接演算を使用する場合、間接演算の値は、必要な添え字すべてを含め、完全なグローバル変数名またはローカル変数名にする必要があります。以下の例では、Cach&eacute; は変数 B に 6 を設定します。
Set Y = "B",@Y = 6
行ラベルを参照するために間接演算を使用する場合、間接演算の値は、構文的に有効な行ラベルにする必要があります。以下の例では、Cach&eacute; は D を以下のように設定します。
N が 1 の場合、行ラベルの値は FIG 
N が 2 の場合、行ラベルの値は GO 
その他の場合の値は STOP 
その後、Cach&eacute; は D に与えられた値のラベルに制御を渡します。 
B Set D = $SELECT(N = 1:"FIG",N = 2:"GO",1:"STOP")
; ...
LV GoTo @D
ルーチン名を参照するために間接演算を使用する場合、間接演算の値は、構文的に有効なルーチン名である必要があります。以下の例では、名前間接演算を GOTO コマンドで使用し、適切なサブルーチン名を渡します。実行時、変数 loc の内容が、要求されている名前に置換されます。
間接演算子が省略された場合、Cach&eacute; は <NOLINE> エラー・メッセージを返します (あるいは、存在する場合は loc というラベルに移動します)。
Start
Read !,"Enter choice (1, 2, or 3): ",num
Set loc = "Choice"_num 
GoTo @loc
Quit
Choice1
; ...
Choice2
; ...
Choice3
; ...
名前間接演算は、名前の値のみを置換できます。以下の例で、2 番目の Set コマンドはコンテキストが原因で、エラー・メッセージを返します。等号の右側の式を評価する際、Cach&eacute; は @var1 を数値ではなく、変数名に対する間接参照と解釈します。 
Set var1 = "5"
Set x = @var1*6
正確に実行するには、上述を以下のように修正します。 
Set var1 = "var2",var2 = 5
Set x = @var1*6
パターン間接演算 
パターン間接演算は、特殊な形式の間接演算です。間接演算子はパターン・マッチを置換します。間接演算の値は、有効なパターンの必要があります。(パターン・マッチに関しては、"パターン・マッチング" で説明されています)。パターン間接演算は、可能性のあるパターンを複数選択し、それらを単一のパターンとして使用する場合に特に役立ちます。 
以下の例では、間接演算をパターン・マッチングに使用し、郵便番号 (ZIP) が有効かどうかを判断します。コードは、5 桁 (nnnnn) あるいは 9 桁 (nnnnnnnnn) のいずれかです。
最初の Set コマンドは、5 桁のパターンを設定します。次の Set コマンドは、9 桁のパターンを設定します。この 2 番目の Set コマンドは、後置条件式 ($LENGTH(zip) = 10) が真 (0 以外) の場合、つまり、ユーザが 9 桁を入力した場合にのみ実行されます。 
Getzip 
Set pat = "5N"
Read !,"Enter your ZIP code (5 or 9 digits): ",zip
Set:($LENGTH(zip)=10) pat = "5N1""-""4N"
IF zip'?@pat { 
Write !,"Invalid ZIP code"
GoTo Getzip
}
パターン・マッチングに間接演算を使用すると、アプリケーション中で使用するパターンをローカライズするのに便利です。この場合、パターンを別の変数に格納し、その後、実際のパターン・テスト中にそれらを間接演算で参照します(これは、名前間接演算の例でもあります)。このようなアプリケーションを移植するには、パターン変数自身を変更するだけで済みます。 
引数間接演算 
引数間接演算では、間接演算は、1 つ以上のコマンド引数を評価します。一方、名前間接演算は、引数の一部のみを適用します。 
この違いを理解するには、以下の例と "名前間接演算" の例を比較してください。
Start 
Set rout = "^Test1"
Read !,"Enter choice (1, 2, or 3): ",num
Set loc = "Choice"_num_rout 
GoTo @loc
Quit
この場合の引数間接演算の例は、@loc が引数を完全な形式 (すなわち、label^routine) で提供します。名前間接演算の例では、@loc は引数の一部分のみ提供します (エントリ・ポイントが、別のルーチンではなく、現在のルーチンに存在する label 名)。
以下の 2 番目の SET コマンドは名前間接演算 (引数、変数名の一部のみ) の例であり、一方、3 番目の SET コマンドは、引数間接演算 (引数全体) の例です。 
Set a = "var1",b = "var2 = 3*4"
Set @a = 5*6
Set @b
Write "a = ",a,!
Write "b = ",b,!
添え字間接演算 
添え字間接演算は、名前間接演算の拡張形式です。添え字間接演算では、間接演算の値はローカルあるいはグローバルの配列ノード名の必要があります。また、他の間接演算とは構文的に異なります。添え字間接演算は、以下の 2 つの間接演算子を使用します。 
@array@(subscript)  
^client というグローバル配列で、最初のレベルのノードにはクライアント名、2 番目にはクライアントの番地、3 番目にはクライアントの市区町村、都道府県、郵便番号が含まれていると想定します。配列の最初のレコードにその 3 つのノードを出力するには、以下の形式で Write コマンドを使用します。 
Write !,^client(1),!,^client(1,1),!,^client(1,1,1)
実行すると、このコマンドは以下のように出力します。 
John Jones
42 Arnold St.
Boston, MA 02745
レコードの範囲を設定する場合 (例えば、最初から 10 個)、WRITE コマンドが FOR ループ内で実行されるようにコードを変更します。以下はその例です。 
FOR i = 1:1:10 {
Write !,^client(i),!,^client(i,1),!,^client(i,1,1)}
FOR ループを実行するたびに変数 i は 1 ずつ増加し、その変数を使用して、出力される次のレコードを選択します。 
この例は、前述の例よりも一般的ですが、配列名と出力レコード数の両方を明示的に指定する点で特殊です。 
以下のように添え字間接演算を使用して、このコードをさらに一般的な形に変更し、ユーザが、3 つのノード・レベルに名前、町名、および都市情報を格納している任意の配列 (グローバルまたはローカル) から、一定範囲のレコードをリストできるようにします。 
Start
Read !,"Output Name, Street, and City info.",!
Read !,"Name of array to access: ",name
Read !,"Global or local (G or L): ",gl
Read !,"Start with record number: ",start
Read !,"End with record number: ",end
IF (gl["L")!(gl["l") {Set array = name}
ELSEIF (gl["G")!(gl["g") {Set array = "^"_name}
Set x = 1,y = 1
FOR i = start:1:end {DO Output}
Quit
Output Write !,@array@(i)
Write !,@array@(i,x)
Write !,@array@(i,x,y)
Quit
Output サブルーチン中の WRITE コマンドは、添え字間接演算を使用して、要求されている配列およびレコード範囲を参照します。
添え字間接演算の評価で、間接演算のインスタンスが、添え字のないグローバルまたはローカルの変数を参照する場合、間接演算の値は、変数名、および小カッコを含めた 2 番目の間接演算子の右側のすべての文字になります。
$TEXT 引数間接指定
名前から分かるように、$TEXT 引数間接演算は、$TEXT 関数の引数のコンテキスト内でのみ使用されます。間接演算の値は、有効な $TEXT 引数である必要があります。 
$TEXT 引数間接演算は、主に、同じ結果を返す間接演算を複数の形式で記述しないために使用されます。例えば、ローカル変数 LINE に "START^MENU" のエントリ参照が含まれている場合、行ラベルとルーチン名に対し名前間接演算を使用して、行テキストを取得できます。以下がその例です。 
Set LINETEXT = $TEXT(@P(LINE,"^",1)^@P(LINE,"^",2))
以下のように $TEXT 引数間接演算を使用して、より単純な方法で同じ結果を返すことができます。 
Set LINETEXT = $T(@LINE)
Copyright
&copy; 1997-2006, InterSystems Corp.
Build: Cach&eacute; v5.1 (826U-0)
Last updated: 2006-03-03 01:52:44
Source: GCOS_operators.xml
演算子と式
