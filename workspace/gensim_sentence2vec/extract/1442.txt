
2.画像処理基礎
2−1.エッジ処理
画像のフォーマットに関しては理解できたでしょうか?次は画像処理の基礎について説明していきます.まずは画像のエッジを抽出するプログラムを作りましょう.
比較的簡単なエッジ抽出方法が Sobel オペレータです.Sobel オペレータは局所積和演算でグラジエントの強度(微分値)を求める方法で,
に対して, で強度が求まります.また, でエッジの方向を求めることができます.
さて,いきなり難しい話になったので,分かりやすく1次元に一桁の数字が並んでいる場合で考えましょう.エッジとは急に色の変わるところです.例えば,111111999999 というデータの並びがあったとします,1 と 9 の境界がエッジです.それは分かりますね.
それではエッジを機械的に見つける方法を考えてみましょう.分かりましたか?そうです,自分の両隣の数字を見比べればいいわけです.両端には隣がないので無視して 0 にするとして,さきほどのデータの右隣と左隣の差をとっていきましょう.
はい,000008800000 になりますね.見事に値の大きいところがエッジになってます.では,123213897969 ならどうでしょうか?これも両端は 0 にして両隣の差を取っていくと,020217610100 となります.値の大きなところがエッジです.でも先ほどのデータのように綺麗な数字ではないのでこのままではどこがエッジか分かりにくいです.
そこでこれ以上の数字をエッジにするという値を決めましょう.この場合なら 5 以上をエッジと決めれば良さそうです.エッジを分かりやすくするには,処理したデータの 5 以上の値を 9 にして,5 以下のデータを 0 にしてみましょう.000009900000 となります.この 5 のことを閾値(しきいち)と呼び,最後の処理を閾値処理といいます.良く出てくる言葉なので覚えておきましょう.
ここで,両隣の差を取るというのは次の局所演算を行うことに相当します.
つまり,赤い画素に対して両隣の差を取るというのは,左の画素をマイナス 1 倍したものと右の画素を 1 倍したものを足し合わせることと同じです.さて,話を簡単にするために 1 次元で説明しました.これを 2 次元平面に拡張したのが,Sobel オペレータです.ここまでが理解できたら,もう一度上から読み直してみて下さい.
下のプログラムは肝心の Sobel オペレータの部分が抜けています.
#include <stdio.h>
#include <stdlib.h>
//ppm ファイルを読み込む関数(画像サイズは640×480のみ対応)
int ppm_read(char *filename, unsigned char *pimage){
FILE *fp;
if((fp=fopen(filename,"rb"))==NULL){
printf("ファイル%sが開けません\n",filename);
exit(-1);
}
fscanf(fp,"P6\n640 480\n255\n"); //ヘッダを読み飛ばす
fread(pimage,sizeof(char),640*480*3,fp);
fclose(fp);
return 0;
}
//pgm ファイルを書き込む関数(画像サイズは640×480のみ対応)
int pgm_write(char *filename, unsigned char *pimage){
FILE *fp;
fp=fopen(filename,"wb");
fprintf(fp,"P5\n640 480\n255\n");
fwrite(pimage,sizeof(char),640*480,fp);
fclose(fp);
return 0;
}
main(){
unsigned char *image; //取り込む画像
unsigned char *edge; //エッジ画像
int x,y;
int fx,fy; //オペレータグラジエントの強度
FILE *fp;
image = malloc(sizeof(char)*640*480*3); //メモリの確保
edge = malloc(sizeof(char)*640*480);
ppm_read("aist.ppm", image); //ファイルの読み込み
for(y=1;y500) *(edge+640*y+x) = 0x00; //閾値より大きいところは黒
else *(edge+640*y+x) = 0xff; //それ以外は白
}
}
pgm_write("edge.pgm", edge); //ファイルの書き込み
free(image); //メモリの開放
free(edge);
}
まず, pgm について説明しておきます.unsigned char *edge; は edge = malloc(sizeof(char)*640*480); で 640×480 分の配列しか用意していません.これは,edge をグレースケールの画像で表現しているためです.グレースケールの場合はヘッダが P5 となり,拡張子は通常 pgm (portable graymap) となりますが,ppm のままでも特に問題はありません.
次に,ファイルからポインタに画像を読み込む関数と画像を書き込む関数を main の外に出しました.これらの関数に関しては後のプログラムでも使います.ただ,プログラムの簡単化のために画像サイズが 640×480 で固定だとか,# のコメントに対応できていないなどの問題があることは覚えておいて下さい.
それでは,まず aist.ppm をダウンロードして,絵の確認をしてから演習に取り掛かってください.
演習2−1
上のプログラムを完成させよう.
閾値を色々と変えて処理してみよう.
最適な閾値を自動で探すプログラムを考えてみよう.(余力のある人向き)
画像研究入門
