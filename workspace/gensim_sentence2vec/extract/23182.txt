C++11は、2011年時点で最新のプログラミング言語 C++ のISO標準 ISO/IEC 14882:2011 の略称である。規格の策定中は2009年中の標準化を目指していたため、C++0x という仮称で呼ばれていた。後継は C++14。
ISO/IEC 14882:2003 (C++03) に代わるものとして、2011年8月12日にISOによって承認された[4]。コア言語への機能追加や標準C++ライブラリの拡張を施し、 C++TR1 ライブラリの大部分を(数学的特殊関数ライブラリを除いて)取り込んでいる。
標準策定の方針[編集]
C++ への修正はコア言語と標準ライブラリの双方に及ぶ。
委員会は、新規格の個別の要素の策定に際して次のような方針をとった。
C++98 との、さらに可能であれば C との一貫性および互換性を維持すること。
新機能の実現方法として、コア言語の拡張よりも標準ライブラリの拡張を優先すること。
プログラミングの技法を発展させうるような変更を優先すること。
特定のアプリケーションにのみ有効な機能を導入するよりも、システムやライブラリの設計が容易になるような改良を行うこと。
従来の型安全でない技法に対して、より安全な代替を提供すること。
ハードウェアと密接に動作する能力と効率を向上すること。
現実的問題に対する適切な解決法を用意すること。
ゼロ・オーバーヘッド原則 (ある機能を使用するためのサポートは、その機能を使用しない場合は影響を及ぼさない) を実践すること。
上級者向けの機能を削ることなく、C++の学習や指導が簡単になるようにすること。
初心者はプログラマ人口の多くを占める。また、多くの初心者は自身が習得した一部の言語機能に拘泥しがちであり、知識を広げようとはしない。従って、初心者への配慮は重要であると考えられた[1]。また、C++の言語仕様の大きさ(アプリケーションやプログラミング・スタイルの多様性も含む) を考えると、どれだけ長い経験を積んだプログラマも新しいプログラミングパラダイムの前では未経験者になり得ることから重要な配慮であると言える。
C++ コア言語への拡張[編集]
C++ コア言語の特筆すべき改良点には、マルチスレッドのサポートや、ジェネリックプログラミングのサポート、一様な初期化構文やパフォーマンス向上等が挙げられる。
このページでは、コア言語の機能拡張や変更点を、実行時パフォーマンス向上、ビルド時パフォーマンス向上、使いやすさの向上、全く新しい機能の4つに分けて説明する。機能によっては複数の項目に該当するが、最もよく当てはまる項目で述べることとする。
コア言語の実行時パフォーマンス向上[編集]
以下の機能は、主に何らかのパフォーマンス向上を狙ったものである。スピードの向上とメモリ効率の改善の両方が含まれる。
右辺値参照とムーブコンストラクタ[編集]
C++03以前は、一時変数 (代入演算子の右側に置かれることから、右辺値と呼ばれる) に変更を加えるのは意味がないものと考えられており、関数に参照として渡す場合にはconst T&型としてしか渡すことができなかった。しかし、場合によっては変更できるほうが都合のよいこともあった。例えば所有権の移動(ムーブ)である。
C++11 では、右辺値参照と呼ばれる新たな参照型 T&& が追加された。これにより、右辺値を変更可能なまま関数に渡すことができ、右辺値からのムーブを実現できる。
例えば、std::vector は内部的には C スタイル配列のサイズ付きのラッパである。従来は、std::vector の一時変数が生成されたとき、新たな std::vector を生成してそこに全ての右辺値データをコピーしないといけなかった。コピーの後、一時変数は破壊され、内容は削除される。
右辺値参照があれば、std::vector への右辺値参照を取る std::vector の「ムーブコンストラクタ」を用いることで、単に右辺値から配列へのポインタを取り出してコピーし、空のオブジェクトを残す、ということが実現できる。この場合、配列のコピーは起こらず、空の一時変数を破壊してもメモリの破壊は起こらない。仮にstd::vector にムーブコンストラクタがない場合、通常通りにコピーコンストラクタが const std::vector<>& として呼ばれる。ムーブコンストラクタがある場合、ムーブコンストラクタが呼ばれ、メモリの割り当てが回避できる。
標準ライブラリにムーブコンストラクタが記述されていれば、既存のコードは変更を加えることなく右辺値参照のメリットを享受することができる。std::vectorの一時変数を返す関数は、明示的にstd::vector&&に変更する必要はない。なぜなら、一時変数は自動的に右辺値であるとみなされるからである。
安全上の理由から、右辺値参照として宣言された名前つきの変数をそのまま右辺値として関数に渡すことはできない(そのような変数は左辺値となる)。std::move() を明示的に呼び出すことで、この制限を回避できる。
右辺値参照の文言の特性と左辺値参照 (通常の参照) の文言の若干の修正により、右辺値参照を使って完全な関数転送を開発者が提供できるようになる。可変長引数テンプレートと組み合わせ、関数テンプレートから、決まった型の引数を取る別の関数へと引数を転送できる。これは、コンストラクタ引数の転送に最も有用であり、引数に基づいて自動的に的確なコンストラクタを呼ぶようなファクトリ関数の生成に使用できる。
一般化された定数式[編集]
C++ には既に定数式が存在している。定数式とは、3 + 4 のように、常に同じ結果を返し副作用の無いものである。定数式はコンパイラの最適化の対象となり、多くの場合コンパイル時に演算が行われ、プログラム中にはその結果のみが格納される。また、C++ の仕様中でも、多くの箇所で定数式の使用が必要となる。配列の定義にも要素数として定数式が必要であるし、列挙子の値にも必要である。
しかし、関数呼び出しやオブジェクトコンストラクタが出現すると、定数式ではなくなる。単純な例を挙げると:
C++11 - Wikipedia
