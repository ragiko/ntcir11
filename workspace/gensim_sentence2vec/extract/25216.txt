
このサンプルでは、Windows Communication Foundation (WCF) ランタイムをカスタマイズして、永続性インスタンス コンテキストを有効にする方法を示します。
バッキング ストアとして、SQL Server 2005 (この場合は SQL Server 2005 Express) を使用します。
ただし、カスタム ストレージ機構にアクセスする方法も示します。
このサンプルには、WCF のチャネル レイヤとサービス モデル レイヤの両方の拡張が含まれています。
したがって、実装の詳細に進む前に基になる概念を理解する必要があります。
永続性インスタンス コンテキストは、現実のケースでも頻繁に起こりうるものです。
たとえば、ショッピング カート アプリケーションには、買い物を中断しても別の日に再開できる機能が用意されています。
そのため、ショッピング カートに翌日アクセスすると、元のコンテキストが復元されます。
接続が切断されている間、ショッピング カート アプリケーション (サーバー上) はショッピング カートのインスタンスを保持しないことに注意してください。
その代わり、状態を永続的なストレージ メディアに保持し、復元されたコンテキストの新しいインスタンスを構築するときにこの状態を使用します。
したがって、同じコンテキストに対してサービスを提供できるサービス インスタンスは、以前のインスタンスと同じではありません (つまり、メモリ アドレスが同じではありません)。
永続性インスタンス コンテキストは、コンテキスト ID をクライアントとサービス間で交換するための簡単なプロトコルによって可能になります。
このコンテキスト ID はクライアント上で作成され、サービスに転送されます。
サービス インスタンスが作成されると、サービス上のランタイムは、永続ストレージ (既定では SQL Server 2005 のデータベース) 上で永続化されている、このコンテキスト ID に対応する状態を読み込もうとします。
利用できる状態がない場合は、新しいインスタンスに既定の状態が設定されます。
サービス実装は、カスタム属性を使用してサービス実装の状態を変更する操作の詳細を指定し、ランタイムがその操作を呼び出した後にサービス インスタンスを保存できるようにします。
前の説明から、目標を達成するための手順は大きく次の 2 つに分けられます。
ネットワークに出力されるメッセージを、コンテキスト ID が含まれるように変更します。
サービス側のローカル動作を変更して、カスタムのインスタンス化ロジックを実装します。
この一覧の前者の手順は、カスタム チャネルとして実装され、チャネル レイヤにフックされる、ネットワーク上のメッセージに影響します。
後者の手順が影響を及ぼすのは、サービスのローカル動作だけです。したがって、いくつかのサービス拡張ポイントを拡張することによって実装できます。
以降のセクションでは、こうしたそれぞれの拡張について説明します。
最初に、チャネル レイヤの拡張について考えます。
カスタム チャネルを記述する最初の手順として、チャネルの通信構造を決定します。
新しいワイヤ プロトコルを導入する際には、チャネルはチャネル スタック内の他のほとんどすべてのチャネルに対応する必要があります。
そのため、すべてのメッセージ交換パターンをサポートする必要があります。
ただし、チャネルの中心的な機能は通信構造に関係なく同じです。
具体的には、コンテキスト ID をクライアント側からメッセージに書き込み、サービス側からこのメッセージのコンテキスト ID を読み取って上位レベルに渡します。
そのため、すべての永続性インスタンス コンテキスト チャネルの実装に対して抽象基本クラスとして動作する、DurableInstanceContextChannelBase クラスが作成されます。
このクラスには、共通ステート マシンの管理機能と保護された 2 つのメンバが含まれ、これによってコンテキスト情報をメッセージに適用したり、メッセージからコンテキスト情報を読み取ったりします。
これら 2 つのメソッドは、IContextManager 実装を使用して、メッセージへのコンテキスト ID の書き込みと、メッセージからのコンテキスト ID の読み取りを行います (IContextManager は、すべてのコンテキスト マネージャのコントラクトの定義に使用されるカスタム インターフェイスです)。チャネルは、このコンテキスト ID を、カスタム SOAP ヘッダーか HTTP クッキー ヘッダーのどちらかに含めることができます。各コンテキスト マネージャの実装は、ContextManagerBase クラスを継承します。このクラスには、すべてのコンテキスト マネージャについての共通機能が含まれています。このクラスの GetContextId メソッドは、コンテキスト ID をクライアント側で生成する際に使用されます。コンテキスト ID が最初に生成されると、このメソッドはこれをテキスト ファイルに保存します。テキスト ファイルの名前は、リモート エンドポイント アドレスによって作成されます (通常の URI に含まれる、ファイル名として無効な文字は、@ 文字に置き換えられます)。コンテキスト ID が後で同じリモート エンドポイントで必要になると、このメソッドは適切なファイルが存在するかどうかをチェックします。ファイルが存在する場合は、コンテキスト ID を読み取って返します。存在しない場合は、新しく生成されたコンテキスト ID を返してこれをファイルに保存します。既定の構成では、これらのファイルは現在のユーザーの一時ディレクトリ内にある ContextStore ディレクトリにあります。ただし、この場所はバインディング要素を使用して構成できます。コンテキスト ID の転送に使用される機構は構成可能です。HTTP クッキー ヘッダーか、またはカスタム SOAP ヘッダーのどちらかに記述できます。カスタム SOAP ヘッダーに記述する場合は、このプロトコルを HTTP 以外のプロトコル (TCP や NamedPipes など) で使用できます。これらの 2 つのオプションは、MessageHeaderContextManager と HttpCookieContextManager という名前の 2 つのクラスに実装されます。これらのクラスはどちらも、コンテキスト ID をメッセージに適切に書き込みます。たとえば MessageHeaderContextManager クラスでは、WriteContext メソッドにより SOAP ヘッダーにコンテキスト ID が書き込まれます。
永続性インスタンス コンテキスト
