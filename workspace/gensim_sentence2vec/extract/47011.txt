C言語では、ヒープ領域に配列のメモリ領域を確保するときに malloc 関数を使います。 このとき、配列の最大要素数を指定しなければならず、その最大要素数を超える要素を配列に格納したいときは、realloc 関数を使って、最大要素数を拡張しなければなりません。
必要になったら realloc 関数を呼ぶだけなら簡単ですが、配列の先頭アドレスが変わってしまうため、新たな問題が発生します。 それは、配列の中の要素を指すポインタは、一時的にしか使えないということです。
配列の3番目の要素のアドレスは、配列の先頭アドレスに、要素のサイズ×2を足した値になりますが、その値を、配列の3番目の要素を指すポインタに格納してしまうと、realloc して配列の先頭アドレスが変わったときに、ポインタが指す要素にアクセスしようとすると、メモリ・アクセス例外が発生してしまいます。
これを回避するには、配列の3番目の要素を指すものを、配列番号にすることです。 そうすれば、realloc して配列の先頭アドレスが変わったとしても、配列の3番目の要素を指す配列番号=2を使って、配列の先頭アドレスに、要素のサイズ×2を足せば、要素を指すアドレスとして正しいものになります。
ただ、配列番号を使ってアクセスすると、要素のサイズ×配列番号という掛け算を CPU が行わなければならないのですが、少し工夫すれば、掛け算が不要になり、速く処理ができるようになります。
それは、オフセットです。 配列の3番目の要素を指すオフセットは、要素のサイズ×2という値です。 つまり、オフセットとは、掛け算した後の値ということになります。 配列の3番目の要素のアドレスは、配列の先頭アドレス+オフセットになり、足し算なので高速です。
ちなみに、要素のサイズが、2の n 乗であれば、配列番号であっても、CPU は掛け算ではなくシフト演算という高速な処理が行えるようになりますが、オフセットであれば、要素のサイズが2の n 乗でなくても高速になります。
そもそも、realloc 関数を必要とする配列ではなく、リスト構造を使えば、要素を指すポインタが使えるため、もっと高速になると考えられますが、配列やリストの中にあるそれぞれの要素をすべて辿っていく処理は、キャッシュのミスヒットが起きやすいため、少し遅くなるでしょう。 おそらく、キャッシュのミスヒットより、加算の方が高速だと思いますが、CPU によると思うので、そこまで拘るのであれば、ベンチマークを計測するとよいでしょう。
Snap Note 開発記 from ソフトウェアデザイン館 Sage Plaisir 21:realloc する C言語の可変長配列の要素を指すオフセット - livedoor Blog(ブログ)
