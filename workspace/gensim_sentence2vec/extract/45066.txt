URIはユニークとなっていますが、操作の内容がHTTPメソッドで表現されていません。本来であればDELETEメソッドを使用すべきですが、GETメソッドが使用されています。つまりRESTfulなサービスではありません。
どのアーキテクチャがより適切であるかというのは、プロジェクトの要件や特性、ポリシーによって変わるものなので、一概に言うことは出来ません。重要なのは、いままさに構築しようとしている対象のシステムが、どのアーキテクチャスタイルに則るのかを規定、理解し推進することです。RESTfulを目指していたはずが、いつのまにかREST-RPCハイブリッドになっていたなんてことがないように。
※1: 名著「RESTful Webサービス」の著者らによって提言された造語です。
2. RESTの誤解
前述した通り、RESTはあくまでそのアーキテクチャスタイルのことを指しています。そのため誤解や誤った実装を見逃してしまうことも多々あります。実装したアプリケーションは動作しているわけですから。
よくある誤解として以下のものがあります。
送受信するHTTPデータはXMLでなくてはならない
そんなことはありません。WWWもRESTスタイルアーキテクチャの一形態です。エンティティボディ(送受信するメッセージ)は、HTMLでも単なる文字列でもCSV形式のデータでもJSON形式のデータでも何でも良いのです。XMLが利用されることが一般的なだけです。「XMLやHTTPを使った」、「XMLなどをレスポンスとして」、「XMLを直接操作する」といった表現で解説されている情報が多く、これが誤解を招いています ※2。
※2: 「や、など」といった言葉は読み手に想像を任せていますから。
SOAPより軽いWebサービス仕様
SOAPとRESTは同じ天秤で量れるものではありません。SOAPは多くの仕様(WS-*で表現されるもの)を含んでおり、『Webサービスという枠組みの中』に存在するものです。一方、RESTはHTTP上でのみ成立する『Webという枠組みの中』に存在するものです。
(誤解を恐れずに)単に『Webサービスを実現するもの』と捉えれば、確かにRESTはSOAPより軽量ではありますが、RESTは非同期メッセージングなどの複雑な処理は得意としません。むしろ複雑な処理はSOAPの方が得意でしょう。これはそもそもの対象(目指しているもの)が違うからです。 
SOAPの対抗となるAPI仕様
先述しましたが、RESTはAPIを提供するためのものではありません。『REST API』ですとか、『SOAP/REST』と表現しているサイトが多いから誤解が生じるのだと私は思います。『REST Style HTTP API』と理解すれば決してSOAPの対抗ではないことがわかります。
4つの統一インタフェースではエンタープライズシステムに不十分ではないか
HTTPはドキュメント指向であり、かつRESTはステート(リソースの状態)を公開するものです。ステートを変更するためには、たった4種類の統一インタフェースでも充分なのです。
プログラムからはSOAP Webサービスの方が簡単に接続できる
SOAPを用いたWebサービスの場合、Visual StudioなどのIDEが生成するプロキシがSOAPの複雑な部分を隠蔽してくれるため、単なるメソッド呼び出し(RPC)のように簡単に接続することが出来ます。
しかし、この『簡単さ』がクセ者で、『簡単』であるが故に、アプリケーション開発者はプロキシの動作やSOAPの重量なコストのことなど気にも留めずに「SOAP Webサービス」を多用し始めます。SOAP Webサービスをむやみに多用しているシステムにおいて、テスト工程で初めて性能問題が顕在化し、結果大きな手戻りが生じるというのはよく聞く話です。
一方RESTスタイルで接続する場合は、接続ユーティリティの実装やインタフェースの規定といった開発コストはあるものの、接続コストはSOAP接続より圧倒的に低く、原理的には単純です。また、統一インタフェース(GET/POST/PUT/DELETE)を意識することで、サービスの粒度が適度に保たれますので、過剰に遅い処理が生じるリスクも低くなります。
3. RESTの誤った実装
RESTスタイルのアーキテクチャを採用する際、以下のような誤った実装に陥りがちなので注意が必要です。
何でもGET、何でもPOST
現在のHTML仕様ではGETとPOSTしかサポートしていないために※3、この2つの方法しか馴染みがないのが一般的です。ですが、RESTではクライアントを特定していません。ブラウザの場合もあるでしょうし、独自のクライアントアプリケーションの場合もあるでしょうし、他システムの場合もあるでしょう。
何でもかんでもGETとPOSTで代用しようとすると、実際にサーバー側で行われる処理が分かり難くなると同時にHTTPの仕様を無視することになり、結果的にRESTとは程遠いものとなります。
なぜ『何でもGET』、『何でもPOST』に陥ってしまうのでしょうか。
何でもGET
URIが全ての情報を含んでいるので実装が簡単だから
特定のURIをブラウザに入力すれば容易にテストが行えるから
何でもPOST
GETはURIの長さに制約があるのでいつか溢れてしまうが、POSTには制約がないから(もしくはGETの制約に比べると緩いから)
フォームデータや検索条件などをPOSTで送信した経験があるから
これらは現実的な発想にも思えますが、好意的に解釈してもRESTとは言えません。では今現在、ブラウザをクライアントとする場合どのようにしたら良いのでしょうか?
非RESTスタイルを採用する箇所を局所化する
各ページにJavaScriptを埋め込み、リクエスト送信時に適切なHTTPメソッドに置き換える
弊社が2008年に参画したプロジェクトでは、フロントサーバーとバックエンドサーバーの連携をRESTスタイルで実現するというアーキテクチャを採用しました(1.の方式)。クライアントとフロントサーバーとのやり取りは旧態依然のGETとPOSTのみですが、こうすることでHTML4の仕様上の制約を受けるのはフロントサーバーのみとなり、バックエンドサーバーは影響を受けません。
プロジェクト発足当初から、「10年使えるシステムにしたい」という顧客要望があったため、HTML4の制約を受ける箇所を局所化し、全体に影響を及ぼさないようにしました。
※3: 2010年9月勧告予定のHTML5では、PUTとDELETEもサポートされる予定です。
HTTPステータスコードの無視
HTTP仕様では、処理の結果はステータスコードで表現することとなっていますが、これを無視したシステムを作ることも出来ます。
例えば、常に200(OK)が返ってくるけれども、HTTPレスポンスの内容によっては「成功」の場合もあり、「リソースが見つからない」の場合もあり、「サーバーエラー」の場合もあったりすることが出来ます。つまり、処理の結果はレスポンスのエンティティボディに含み、クライアントはエンティティボディの内容によって結果を判断します。
これには次のような欠点があります。
エンティティボディを解析してみないと、成功したのかエラーが発生したのか判断出来ず、常に解析処理が必要となるため極めて非効率
サービス仕様(システム独自のエラーコード)を詳細に理解していないと、エラー原因が直感的に理解出来ない
他システムと連携することになった場合、独自の仕様を相手側に強く意識させてしまうので、相手側のアーキテクチャを歪めてしまう可能性がある
RESTスタイルのアーキテクチャであるならば、サーバー側の処理結果はHTTPステータスコードで表現すべきです。HTTP仕様には豊富なステータスコードが用意されており、ほとんどの場合はそれで事足りるはずです※4。もちろん詳細なエラーコードが必要な場合もあるでしょう。その場合は、詳細なエラーコードはエンティティボディに含め、おおまかな処理結果をステータスコードで表現するのが良いです。決して、処理が失敗しているのに200を返してはいけません。 
※4: どうしても既存のHTTPステータスでは表現出来ない場合には、システム独自のHTTPステータスを定義しても良いと思います。ただし、独自定義だということをきちんと明確にしておくべきです。
HTTPステータスコードの誤用
HTTPステータスコードには仕様として多くのものが定義されています。200(OK), 201(Created), 204(No Content), 404(Not Found), 409(Conflict), 500(Internal Server Error)などがあります。
例えば、会員情報を登録するサービス仕様があったとしましょう。
RESTful Web Services より良いWebインタフェースの構築と分散型システム連携:第2回:REST導入における勘所 ～誤った導入をしないために～ | 豆蔵ソフト工学ラボ
