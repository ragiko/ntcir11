このコラムは、共通言語ランタイム (CLR) 機能のしくみよりは、むしろ自由に使用できる機能の効率的な使用方法に焦点を当てています。当然ながら、適切なデータ構造とアルゴリズムの選択は、プログラマが行う最も一般的かつ重要な意志決定の 1 つです。間違った選択は、成功するか失敗するかを左右し、ほとんどの場合は、高パフォーマンスと劣悪なパフォーマンスの差異が生じます。多くの場合、並列プログラミングはパフォーマンスの向上を目的としており、通常ではシリアル プログラミングより困難であることを考えると、成功するためにはこの選択は非常に重要です。
このコラムでは、再利用可能な 9 つのデータ構造とアルゴリズムについて説明します。これらは多くの並列プログラムに共通のものであり、独自の .NET ソフトウェアに簡単に適合させることができます。すべての例には、コードが付属しています。これらは完全に強化、テスト、およびチューニングされたコードではありませんが、正常に実行できる状態にあります。リストはすべてを網羅しているわけではありませんが、いくつかの一般的なパターンを表しています。多くの例は、他の例に基づいて構築されていることがおわかりになるでしょう。
最初に説明しておかなければならないことがあります。Microsoft® .NET Framework には、同時実行に関するいくつかの既存プリミティブがあります。このコラムで独自のプリミティブの構築方法を説明しますが、既存のプリミティブは、ほとんどの状況に十分に適しています。ここでは単に、代替のプリミティブも検討してみる価値があることを示したいと思います。また、これらの技法の動作を確認することで、並列プログラミングに関する全般的な知識を高めることができます。ただし、このコラムの読者は既存プリミティブについての基礎知識があることを前提にしています。詳細については、2005 年 8 月発行の MSDN® Magazine に掲載された Vance Morrison の「マルチスレッド アプリケーションについて開発者が知っておかなければならないこと」を参照してください。
セマフォは、さまざまな理由から、並列プログラミングでよく知られているデータ構造の 1 つです。それはセマフォが、コンピュータ科学において、1960 年代のオペレーティング システム設計までさかのぼる長い歴史があるという理由からではありません。セマフォは、カウント フィールドを持つデータ構造であり、put および take (それぞれ P および V と呼ばれることが多い) という 2 つの操作をサポートします。put 操作はセマフォのカウントを 1 ずつインクリメントし、take は 1 ずつデクリメントします。セマフォのカウントが 0 になると、後続の take 操作は、並列に実行される put によってカウントが 0 以外になるまでブロック (待機) します。put と take は、どちらもアトミックで同時実行に適した操作であり、これらの操作は互いにシリアル化されます。Windows® には優れたカーネルがあり、Win32® はセマフォ オブジェクトをサポートします (CreateSemaphore と関連 API を参照してください)。これらは、System.Threading.Semaphore クラスを使用して .NET Framework で公開されています。Mutex と Monitor がサポートするクリティカル領域は、多くの場合、0 と 1 を切り替えるカウントを持つ特殊なセマフォ (つまり、バイナリ セマフォ) として位置付けられています。
"リバース セマフォ" のようなものがあれば、非常に便利な場合があります。ときには、カウントが 0 になるまで待機するようなデータ構造が必要な場合もあります。単一の "マスタ" スレッドが n 個の "従属" スレッドの実行を制御し、全スレッドの処理が完了するまで待機するような fork と join の並列実行は、データを並列に処理するプログラミングでよく使われます。この場合、リバース セマフォが手元にあると非常に便利です。ほとんどの場合、スレッドをアクティブ化してカウントを変更するのは避けたいものです。そのため、カウントが減っていく構造のことをカウントダウン "ラッチ" と呼ぶことにします。ラッチは、一度シグナルされた状態に設定されると、その状態を維持します (これはラッチによく関連付けられるプロパティです)。残念ながら、このようなデータ構造は、Windows にも .NET Framework にも存在しません。ただし、さいわいにも、このデータ構造は簡単に作成できます。
カウントダウン ラッチを作成するには、カウンタを n に初期化し、たとえば、デクリメント操作をロックで囲むか、Interlocked.Decrement を呼び出すことによって、従属タスクがそれぞれの処理を完了したときに各タスクがアトミックに 1 ずつデクリメントするように構成します。こうすると、take 操作を使用せずにスレッドをデクリメントでき、カウンタが 0 になるのを待機できます。スレッドがアクティブになると、ラッチに n 個のシグナルが登録されていることを認識します。この条件に対する while (count != 0) などのスピン (ループ) 処理を実行するのではなく、スレッドを待機させてブロックすることが通常では得策です。ただし、この場合は、イベントを使用する必要があります。図 1 は、簡単な CountdownLatch タイプの例です。
CLR Inside Out: 9 Reusable Parallel Data Structures and Algorithms
