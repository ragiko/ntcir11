Evernote サービスのパフォーマンスを最大限にするため、サードパーティアプリとサービスに対して帯域制限を設けました。このページでは、帯域制限自体の概要および制限がどのように実施されるのか、帯域制限に達した際のエラー処理に関するベストプラクティスについてご説明します。
帯域制限の概要
サンドボックスおよび製品版どちらの場合も、サードパーティアプリは API キーで識別されます。さらにエンドユーザのリクエストはユーザの認証情報で識別されます。帯域制限は Evernote API に対して API キーごと、ユーザごと、時間枠ごとに適用されます。つまりサードパーティアプリが個々のユーザに対して特定の 1 時間枠にできる呼び出しが API によって制限されるということです。
仮にボブというユーザが存在しない偽の(Evernote と連携する)アプリを使い、この偽アプリがボブのアカウントに対して Evernote API リクエストを連続して行ったとします。この API リクエストが Evernote の設定する 1 時間以内の帯域制限を超過すると、時間以内の以降すべての API リクエストは Evernote API の例外処理をもたらします。(詳細については後ほど説明します。)
だからといってボブが Evernote データにアクセスできないわけではありません。単に 1 時間の残りの時間、制限がリセットされるまでの間、偽アプリはリクエストを送れなくなるということです。ボブが自分の Evernote データにアクセスするために使っている他のアプリとサービスからは(上限に達してしまわない限り)すべてアクセス可能なままです。
帯域制限を設けた背景
既にご説明したとおり、この制限の主な目的はデベロッパーとユーザが自分の Evernote アカウント内のデータにアクセスする際に応答速度の早いインターフェースを提供することです。API に対するリクエストは 1 回ごとに計算コストが発生するため、Evernote 社にとってもデベロッパーパートナーにとっても、可能な限りこのコストを最小限に抑えることが最善策と言えます。
帯域制限を設置することで、API リクエストを効率よく利用するインテグレーションの開発を促進するため、サードパーティデベロッパーにも利点があります。
帯域制限の実施・処理
帯域制限は、authenticationToken パラメータを受けるものすべて、認証された API 呼び出しすべてに適用されます。帯域制限に達した後リクエストがあると、RATE_LIMIT_REACHED エラーコードとともに EDAMSystemException が返されます。また rateLimitDuration 属性が EDAMSystemException インスタンスに設定されます。この値は、そのユーザと API キーの組み合わせが次の API リクエストができるまでに経過する必要のある時間を秒数を表します。
この条件は的確に処理することが重要です。ほとんどの場合、ユーザは帯域制限という概念を知らないため、自分のリクエストがなぜうまくいかなかったのか理解できない場合が多いかもしれません。問題のリクエストがユーザのアカウント内の何かを変更(例えば NoteStore.createNote など)するためのものである場合、連携アプリは rateLimitDuration で示された秒数が経過し、リクエストを再送できるようになるまでこのようなリクエストを待ち行列に入れる方が望ましいでしょう。
サンドボックス版と製品版の違い
唯一の違いは、サンドボックスの場合、接続しているアプリが許可されたリクエスト数を上回っても、呼び出しをしたアプリがリクエストが拒否されてから再試行できるまで、最大でも 15 秒しか待つ必要がない点です。サンドボックス版も製品版アプリと同じ例外処理を受け、EDAMUserException インスタンスに関連した rateLimitDuration 属性が適切に設定されます。これにより、デベロッパーは 1 時間の間隔をあけることなく API とやり取りができ、帯域制限例外をテスト・処理できます。
帯域制限の適用日
新規 API キーに対する帯域制限は、2013 年 8 月 14 日から適用されます。既に製品版で有効化されている既存の API キーに対する帯域制限は、2013 年 11 月 18 日から適用されます。
帯域制限を超過してしまう主な原因
API キーの帯域制限を不要に超過してしまう原因と考えられるいくつかの例を以下に挙げます:
幾度にもわたる API 呼び出し失敗の再試行: Evernote との連携では、例外処理で返されたエラーコードに注意を払い、異なる種類の例外処理を個々に処理することが特に重要です。具体的に言うと、アプリが API から EDAMSystemException を受け取ったら、問題は API 自体のエラーではなく、アプリのリクエストにあることがわかります。
変更のポーリング: 現在のユーザアカウントが変更された際に通知を受ける方法のひとつに NoteStore.getSyncState の定期的な呼び出しがありますが、このタイプのポーリングを行なっているサードパーティデベロッパーの方は代わりに Web フックを使ってユーザアカウント内のノートが変更されたら通知されるように設定する方法もご検討下さい。
非効率なアルゴリズム: アプリが各 API リクエストを最大限に活かせるようにしましょう。例えば NoteStore.getNote を使った単一のノートの取得やノート全体(関連する Resource を含む)の取得なら、NoteStore.getNote リクエスト時に任意の withResourcesData フラグを設定してみて下さい。これにより Resource ごとに NoteStore.getResource を呼び出す(つまり Resource ごとに 1 つの API リクエストが発生する)のでなく、ノートに含まれるすべての Resource データがひとつのレスポンスで受け取れます。
Initial Sync Boost
サードパーティによる連携アプリケーションのうち、全て (あるいはほとんど) のユーザデータをローカルに維持、同期するものは、一番最初の同期の際に帯域制限を超過する可能性が少なくありません (一度に多くのデータを取得する必要があるため)。そこで、このような状況を避けることができるよう、一時的に帯域制限の上限を緩和させる「Initial Sync Boost」と呼ばれるメカニズムが実装されています。この上限の緩和は新規の認証トークンが発行されてから24時間のみ有効です。その期間が過ぎると、帯域制限は通常の状態に戻ることに注意してください。
Initial Sync Boost は、ユーザデータを同期するアプリケーションを対象に実装されていますが、それぞれの API キーに対してデフォルトでは有効になっていません。新規のAPIキー取得の際に指定するか、もしくは、プロダクション環境での API キーの有効化の際にご依頼ください。この機能はデベロッパートークンでは利用できません。
お問い合わせ
帯域制限の仕組みやご自身の連携機能の実装に関して具体的な質問がある方は、Evernote デベロッパーサポートまでご連絡下さい。
帯域制限 - Evernote Developers
