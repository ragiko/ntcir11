R 言語の実行制御フロー  &dagger;
R は多くの計算機言語と同じような Algol 風制御命令のセットをもつが、より柔軟である。
実行文 expr は単純実行文でも、(波括弧で括った)複合実行文(同一行に並べるにはセミコロンで区切る)でもよい。
繰り返し for  &dagger;
書式 (ループ範囲 range の各要素 arg に対して expr を実行 )
for(arg in range) expr
注意:for ループは一般に実行速度を遅くするボトルネックになりやすい。またコードが長くなり勝ちである。apply 関数ファミリの使用や、特にベクトル・行列・配列の成分ごとのループは専用高速関数が用意されているのでその使用を考える。
ループ範囲にベクトルを取る(基本)
> x = 1:4
> for (i in x) cat(i,"\n")
1
2
3
4
ループ範囲に文字ベクトルを取る
> x = c("a", "b", "1", "2")
> for (i in x) cat(i,"\n")
a
b
1
2
ループ範囲に行列を取る(実際はベクトルとしてアクセス)
> x = matrix(1:4, c(2,2))
> for (i in x) cat(i, "\n")
1
2
3
4
ループ範囲に配列を取る(実際はベクトルとしてアクセス)
> x=array(1:8, c(2,2,2))
> for (i in x) cat(i, "\n")
1
2
3
4
5
6
7
8
ループ範囲にリストを取る
> x = list("a", 1:4, 3) 
> for (i in x) cat(i, "\n")
a
1 2 3 4
3
ループ範囲は最初に与えられたもので実行される。実行文中でループ変数を変更しても影響をうけない。
> for (i in 1:4) {i <- i+2; cat(i, "\n")}
3
4
5
6 # i=1,2,3,4 で4回実行されている
> x=1:4
> for (i in x) {x[i] <- i+10; cat(i,"\n")}
1
2
3
4 # 実行文中での範囲変数 x の変更はループ範囲を変更しない
> x
[1] 11 12 13 14 # x 自身は変更される
## next はループを一回パスする
> for (i in 1:3) 
+ for (j in 1:3) {if (j==2) next; cat(i, j, "\n")}}
1 1
1 3
2 1
2 3
3 1
3 3
## すべての x 中の i, j, k  (i, j, k は異なる) に関する三重和
for (i in x) {
for (j in x[-i]) {
for (k in x[-c(i,j)]) {
.....................
}}}
## または
for (i in x) {
for (j in x) { 
if (i==j) next
for (k in x) {
if (k==i || k==j) next 
.........................................
}}}
(重複の無い)数値ベクトルから長さ 3 の組み合わせをループ
> temp <- function(x){
+ x <- sort(x)    # ソートしておかないとまずい
+ for (i in x)
+ for (j in x[x>i])
+ for (k in x[x>j])
+ cat(i,j,k,"\n")}
> temp(1:4)
1 2 3
1 2 4
1 3 4
2 3 4
> temp(runif(4))
0.151133 0.223455 0.264883
0.151133 0.223455 0.993983
0.151133 0.264883 0.993983
0.223455 0.264883 0.993983
for を使わない方法,重複があってもよいし,ソートも不要
> (x <- runif(4)); t(combn(4, 3, function(i) x[i]))
[1] 0.2769620 0.2577154 0.7625690 0.1760667
[,1]      [,2]      [,3]
[1,] 0.2769620 0.2577154 0.7625690
[2,] 0.2769620 0.2577154 0.1760667
[3,] 0.2769620 0.7625690 0.1760667
[4,] 0.2577154 0.7625690 0.1760667
条件実行 if, if else  &dagger;
# condがTRUEのとき、exprを実行する。
if (cond) expr
# condがFALSEのとき、alt.exprを実行する。
if (cond) cons.expr else alt.expr
# if else 構文は入れ子にできる。
if (cond1) expr1
else if (cond2) expr2
else expr3
# if else 構文は値を返す。if (x < 0) y <- NA else y <- sqrt(x) と同じ。
x <- 1; y <- if (x < 0) NA else sqrt(x)
注意:ifelse(cond, expr1, expr2) 関数は if(cond) expr1 else expr2 構文を簡略化したもの
簡略化したものではない!!
> x <- -3:3
> (a <- ifelse(x < 0, NA, sqrt(x)))
[1]       NA       NA       NA 0.000000 1.000000 1.414214 1.732051
警告メッセージ: 
In sqrt(x) :  計算結果が NaN になりました 
> (b <- if(x < 0) NA else sqrt(x))
[1] NA
警告メッセージ: 
In if (x < 0) NA else sqrt(x) :
条件が長さが2以上なので,最初の一つだけが使われます 
RプログラミングTips大全 - RjpWiki
