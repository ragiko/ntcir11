OLAP DML計算式
式は計算式として保存できます。多くの場合、式の使いやすさと記憶領域の節約のために計算式を定義します。式の計算式を定義すると、式を示す計算式の名前を使用できます。Oracle OLAPでは、計算式のデータは変数に保存せず、要求されるたびに、実行時にデータを計算します。
計算式を作成する前に、最初に計算式オブジェクトを定義する際に式を指定するか、または計算式オブジェクトを定義した後に計算式の式を指定するかを次のように決定します。
最初に計算式オブジェクトを定義する際に式を指定するには:
DEFINE FORMULA文を発行して、計算式オブジェクトを定義します。定義に式を含めます。datatypeまたはdimensions引数の値は指定しないでください。
(オプション)COMPILE文を発行して、計算式をコンパイルします。
計算式をアナリティック・ワークスペースの中で永続化する場合は、UPDATE文およびCOMMIT文を順に実行して、計算式を保存します。
計算式オブジェクトを定義した後に計算式の式を指定するには:
DEFINE FORMULA文を発行して、計算式オブジェクトを定義します。datatypeまたはdimensions引数の値を指定し、式自体の値は指定しないでください。
CONSIDER文を発行して計算式を現行の定義にし、さらにEQ文を発行して計算式の式を指定します。
(オプション)COMPILE文を発行して、計算式をコンパイルします。
計算式をアナリティック・ワークスペースの中で永続化する場合は、UPDATE文およびCOMMIT文を順に実行して、計算式を保存します。
たとえば、次のような計算式を定義してドルの売上高を計算できます。
DEFINE dollar.sales FORMULA units * price
TRACEを使用すると、計算式をデバッグできます。
OLAP DMLモデルの概要
OLAP DMLモデルは、変数またはディメンション値に結果を割当て可能な、相互に関連する一連の方程式です。たとえば、財務モデルでは、gross.marginまたはnet.incomeなどの特定の明細項目に値を割り当てることができます。
gross.margin = revenue - cogs
代入文がデータをディメンション値に割り当てるか、またはその計算でディメンション値を参照する場合、ディメンションベースの方程式と呼ばれます。ディメンションベースの方程式は、ディメンション自体は参照せず、ディメンションの値のみを参照します。そのため、モデルにディメンションベースの方程式が含まれている場合、モデルの先頭でDIMENSION文を使用し、それらの各ディメンションの名前を指定する必要があります。
モデルにディメンションベースの方程式が含まれている場合、モデルを実行する際にソリューション変数の名前を指定する必要があります。ソリューション変数は、データのソースであるとともにモデルの方程式の代入ターゲットでもあります。この変数により、ディメンションベースの方程式で使用される入力データが保持され、計算された結果はソリューション変数の指定された値に格納されます。たとえば、lineディメンションに基づく財務モデルを実行する場合、ソリューション変数としてactualを指定できます。
ディメンションベースの方程式により、財務モデリングに柔軟性が提供されます。モデルを解決するまでモデリング変数を指定する必要がないため、actual変数、budget変数、またはlineによってディメンション化された任意の変数で同じモデルを実行できます。
モデルは非常に複雑になる場合があります。次のことができます。
1つのモデルを別のモデルに含めます(「モデルのネスト」を参照)。
異なる時間間隔からのデータを使用します(「過去および将来の時間間隔からのデータの使用」を参照)。
連立方程式を解決します(「連立方程式の解決」を参照)。
異なるシナリオのモデルを作成します(「複数のシナリオのモデリング」を参照)。
モデルの作成
OLAP DMLモデルを作成するには、次の手順を実行します。
DEFINE MODELコマンドを発行して、プログラム・オブジェクトを定義します。
モデルに仕様を追加するMODELコマンドを発行して、実行する処理を指定します。
モデルをコンパイルします(「モデルのコンパイル」を参照)。
(オプション)必要な場合は、モデル・オプションの設定を変更します(「モデル・オプション」のリストを参照)。
モデルを実行します(「モデルの実行」を参照)。
モデルをデバッグします(「モデルのデバッグ」を参照)。
モデルをアナリティック・ワークスペースの中で永続化する場合は、UPDATEコマンドおよびCOMMITコマンドを順に実行して、モデルを保存します。
モデルの作成の例は、例10-57「モデルの作成」を参照してください。
モデルのネスト
MODELコマンド内でINCLUDE文を使用して、1つのモデルを別のモデルに含めることができます。INCLUDE文を含むMODELコマンドは、親モデルと呼ばれます。含められているモデルは、ベース・モデルと呼ばれます。INCLUDE文をベース・モデルで使用することにより、モデルをネストできます。たとえば、モデルmyModel1がモデルmyModel2を含み、モデルmyModel2がモデルmyModel3を含むことが可能です。ネストしたモデルは階層形式になります。この例では、myModel1が一番上の階層になり、myModel3がルートになります。
モデルにINCLUDE文が含まれる場合、DIMENSION文を含めることはできません。親モデルは、含まれる階層のルート・モデルのDIMENSION文からそのディメンションを継承します(存在する場合)。前述の例では、モデルmyModel1およびmyModel2は、どちらもモデルmyModel3のDIMENSION文からそのディメンションを継承します。
INCLUDE文により、モジュール・モデルの作成が可能になります。特定の方程式が複数のモデルで共通している場合、それらの方程式を独立したモデルに配置して、必要に応じてそのモデルの他のモデルに含めることができます。
さらに、INCLUDE文によりwhat-if分析が容易になります。実験的なモデルでは、ベース・モデルから方程式を流用し、それを選択的に新しい方程式に置き換えることが可能です。what-if分析をサポートするには、モデルで方程式を使用して以前の方程式をマスクします。以前の方程式は、同じモデルまたはそれに含まれているモデルにあります。マスクされた方程式は実行されず、モデルのMODEL.COMPRPTレポートにも表示されません。
ディメンション・ステータスおよびモデル方程式
ディメンション値にデータを割り当てる代入文がモデルに含まれている場合、ディメンションは一時的にその値に制限され、計算を実行してディメンションの初期ステータスをリストアします。
たとえば、モデルには次の文が含まれる場合があります。
DIMENSION line
gross.margin = revenue - cogs
モデルを実行する際にソリューション変数としてactualを指定すると、次のコードが構成され、実行されます。
PUSH line
LIMIT line TO gross.margin
actual = actual(line revenue) - actual(line cogs)
POP line
モデルでソリューション変数を使用することにより、このような自動的なコード構成が行われるため、単純なモデル方程式で複雑な計算を実行できます。たとえば、明細項目データは、lineによってディメンション化されたactual変数に格納されます。ただし、明細項目の詳細データは、detail.lineという名前のディメンションを持つdetail.dataという変数に格納される場合があります。
各詳細項目に関連する明細項目を指定するlineとdetail.line間のリレーションが、アナリティック・ワークスペースに含まれる場合、次のようなモデル方程式を記述できます。
revenue = total(detail.data line)
expenses = total(detail.data line)
detail.lineとline間のリレーションは、詳細データを適切な明細項目に集計するために自動的に使用されます。モデルの実行時に構成されるコードにより、適切な合計が確実にlineディメンションの各値に割り当てられます。たとえば、revenue項目の方程式が計算される際、lineは一時的にrevenueに制限され、TOTALファンクションはlineのrevenue値に対する詳細項目の合計を返します。
計算式、モデル、集計および割当て
