RS 復号器は誤りと消失の両方を訂正できます。受信機は、与えられた符号語の中に最も信頼性の低いシンボルを識別すると消失を生成できます。受信機がシンボルを消去する場合、そのシンボルをゼロで置換し、復号器にフラグを渡して、そのシンボルは有効なコード シンボルではなく、消失であることを伝えます。
また符号器は、その出力から特定のパリティ シンボルが常に除去されたパンクチャを生成できます。復号器はパンクチャのパターンを認識し、パンクチャ位置にゼロを挿入し、これらのシンボルを消失として扱います。復号器は符号器が生成したパンクチャと受信機が生成した消失を、復号化する場合と同様に扱います。
パンクチャは誤り訂正能力を多少低下させますが、符号化率をより柔軟にするメリットがあります。短縮コードは、同じ復調器入力 Eb/N0 の場合、誤り訂正性能を低下させることなく同一の符号化率の柔軟性を維持します。パンクチャは符号語からパリティ シンボルを除去することで、短縮化は符号語からメッセージ シンボルを除去することであることに注意してください。
受信機が生成する消失を使用した復号化このデモは 64-QAM 変調器スキームと協調して動作する (63,53) RS 符号を示します。このコードは (63-53)/2 = 5 個の誤りを訂正できるため、その代替として (63-53) = 10 個の消失を訂正することもできます。復調された各符号語に対して、受信機は判定境界に最も近い判定領域内のシンボルを検索して、最も信頼性の低いシンボルを 6 個決定します。そしてこれらのシンボルを消去します。まず、モデル RSCodingErasuresExampleRSCodingErasuresExample を開きます。
消失のみを使用したシミュレーションと可視化次にシステム シミュレーション パラメーターを以下のように定義します。RS_TsUncoded = 1;               % Sample time (s)
RS_n = 63;                      % Codeword length
RS_k = 53;                      % Message length
RS_MQAM = 64;                   % QAM order
RS_numBitsPerSymbol = ...       % 6 bits per symbol
log2(RS_MQAM);
RS_sigPower = 42;               % Assume points at +/-1, +/-3, +/-5, +/-7
RS_numErasures = 6;             % Number of erasures
RS_EbNoUncoded = 15;            % In dB符号化されていない Eb/N0 を 15 dB として、システムをシミュレートします。しかし、RS 符号器によって追加された冗長シンボルのため、符号化された Eb/N0 は減少します。また、Random Integer Generator の出力におけるサンプル時間 1 秒に対応して、モデルの各フレーム期間は 53 秒で一定に維持されます。さらに、63 個のシンボルは 53 秒のフレーム時間全体での出力であるため、RS 符号器の出力におけるシンボル時間は、符号化率のファクターだけ減少します。AWGN Channel ブロックではこれを考慮するために次のパラメーターを使用します。RS_EbNoCoded = RS_EbNoUncoded + 10*log10(RS_k/RS_n);
RS_TsymCoded = RS_TsUncoded * (RS_k/RS_n);受信機は、判定境界に最も近い、符号語あたり 64 個の QAM シンボルを検索して、どのシンボルを消去するか決定します。受信機は最も信頼性の低いコード シンボル 6 個を除去し、これにより、RS Decoder が符号語あたり (10-6)/2 = 2 個の誤りを訂正できるようになります。システムをシミュレートし、受信されたシンボルと消去されたシンボルを示します。
消失とパンクチャを使用したシミュレーションRS Decoder は、受信機が生成した消失の復号化を行う他に、符号器が生成したパンクチャを訂正できます。この 2 つのケースで復号化アルゴリズムは同一ですが、パンクチャと消失の符号語あたりの合計はコードの誤り訂正能力の 2 倍を超えることはできません。消失とパンクチャの両方に対して復号化を実行する次のモデルを考えてみましょう。符号器ブロックと復号器ブロックの両方で、同じパンクチャ ベクトルを指定します。この例では、各符号語から 2 つのシンボルをパンクチャします。ベクトル値 "1" はパンクチャしていないシンボルを表し、値 "0" はパンクチャされたシンボルを表します。一方、消失ベクトルでは、値 "1" は消去されたシンボルを表し、値 "0" は消去されていないシンボルを表します。符号語の長さが前の例と異なるため、AWGN Channel ブロックのパラメーターのいくつかは若干異なっています。このブロックではサイズの違いを考慮するため次のコードを使用します。RS_EbNoCoded = RS_EbNoUncoded + 10*log10( RS_k / (RS_n - RS_numPuncs) );
RS_TsymCoded = RS_TsUncoded * ( RS_k / (RS_n - RS_numPuncs) );モデル RSCodingErasuresPunctExample.mdl をシミュレートし、RS Decoder ブロックから 1000 個の誤りを収集します。パンクチャのため、符号器から出力する信号の次元は 61 行 1 列になります。パンクチャを使用しないモデルでは 63 行 1 列です。Create Erasures Vector サブシステムも、61 行 1 列の消失ベクトルを作成する場合にサイズの違いを考慮しなければなりません。モデル RSCodingErasuresPunctExampleRSCodingErasuresPunctExample を開きます。
消失、パンクチャ、および短縮を使用したリード・ソロモン符号化 - MATLAB & Simulink - MathWorks 日本
