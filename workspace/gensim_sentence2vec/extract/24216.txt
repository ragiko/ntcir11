オドメトリなどを使うことを考えると,sin,cosなどの三角関数を実装する必要がある.
SHなどの浮動小数点演算ユニットを持たない組み込みコントローラを用い,
1～10msec周期でオドメトリを実行するには高速な三角関数の実装が必須です.
そこで,本稿ではテーブル引きとテイラー展開を用いた三角関数の実装をまとめる.
公式
準備として以下に本稿を読むに必要な数学知識をまとめる.
三角関数の公式
以下のような公式が知られている.
正弦関数のテイラー展開
ある定数値,と十分近い値に対し,以下のような近似式が成立する.
は大きくなるほど,誤差が大きくなる点に注意しよう.
定義域の制限
テーブルを使って三角関数を求めることを考えよう.
より細かい分解能でテーブル用意すれば,精度は向上する.
しかし,使用するROMの容量が増大する問題がある.
そこで,三角関数の定義域を制限し,不要なテーブルを用意しないことを考える.
より,
高速な関数を用意すれば,加法演算1回で高速な関数を用意することができる.
より,の場合のみを考えればよい.
さらに,より,の場合のみテーブルを用意すればよい.
以上より,の範囲で関数のテーブルを用意すれば十分なことが分かる.
たとえば,
の値をあらかじめテーブルとして用意する.そして,のように,もっとも引数に近い値のテーブル値を近似値として出力すれば良い.
本稿で紹介した手法で,作成するテーブルの規模は小さくすることが出来た.
しかし,計算精度とテーブル規模に関するトレードオフ問題は回避できていないことが分かる.
テイラー展開を使ったテーブル値の補正
前節では,のように,
テーブルの量子化幅に満たない部分を無視する近似を行っていた.
そこで,量子化幅は0に近いことに注目する.
より,をテーブルで求め,この近似式に代入すれば,テーブルを引くだけよりかは高精度で演算を行うことができる.
ただし,をテーブル引きだけで求めるためには,任意のテーブルの引数に対し,がテーブルの引数として用意されている必要がある.
これは,がテーブルの引数として用意されており,分割幅が一定であることと等価である.
多角形近似
テイラー展開を使った補正近似の他に,多角形近似による補正が考えられる.
幾何的に考えると,理論上はテイラー展開の方が優位なはず.そのうち検討.
固定小数点方式で計算
三角関数の計算では,極端に大きい数や小さい数を扱わない.
そのため,固定小数点方式(プログラミングの小ネタ#固定小数点方式で解説)で演算を行うことが考えられる.
採用した場合,double演算は浮動小数点方式から固定小数点方式への変換部分のみで必要となる.
実装
本稿では,SH7147のような,int型の演算は十分早いが,double型の演算がきわめて遅いプロセッサを想定したコーディングを行う.
たとえば,int型の演算が10回増えようが,double型の演算が1回でも減れば計算量の削減とみなす.
以下は128分割テーブルの場合の実装である.
テーブルデータの作成
以下のようにしてテーブルを作る.
#include <stdio.h>
#include <math.h>
#define TABLEBUNKATU 128
main(){
FILE *fp;
int i;
double sintable[TABLEBUNKATU];//table[0]=0rad,table[127]=M_PI/2の128分割テーブル
fp=fopen("res.txt","w");
for(i = 0;i < TABLEBUNKATU;i++)
sintable[i]=sin(i*M_PI/2/(TABLEBUNKATU-1));
fprintf(fp,"double sintable[%d]={\n",TABLEBUNKATU,sintable[i]);
for(i = 0;i < TABLEBUNKATU;i++){
if(i!=TABLEBUNKATU-1)
fprintf(fp,"%lf,",sintable[i]);
else
fprintf(fp,"%lf};\n",sintable[i]);
if(i%10==9)fprintf(fp,"\n");
}
fclose(fp);
return 0;
}
テーブルを引くだけの実装
前節のプログラムで作られたテーブルを用い,以下のように三角関数を実装することができる.
#include <stdio.h>
#include <math.h>
const double sintable[128]={
0.000000,0.012368,0.024734,0.037097,0.049454,0.061803,0.074143,0.086471,0.098786,0.111087,
0.123370,0.135634,0.147877,0.160098,0.172295,0.184465,0.196606,0.208718,0.220798,0.232844,
0.244854,0.256827,0.268761,0.280654,0.292503,0.304308,0.316066,0.327776,0.339436,0.351044,
0.362598,0.374097,0.385538,0.396921,0.408243,0.419502,0.430697,0.441826,0.452888,0.463881,
0.474802,0.485651,0.496425,0.507124,0.517745,0.528287,0.538748,0.549126,0.559421,0.569630,
0.579752,0.589785,0.599728,0.609579,0.619337,0.629000,0.638567,0.648036,0.657406,0.666676,
0.675843,0.684908,0.693867,0.702720,0.711466,0.720103,0.728630,0.737045,0.745348,0.753536,
0.761610,0.769566,0.777405,0.785125,0.792725,0.800204,0.807561,0.814793,0.821901,0.828884,
0.835739,0.842467,0.849066,0.855535,0.861873,0.868079,0.874153,0.880093,0.885898,0.891567,
0.897101,0.902497,0.907754,0.912873,0.917853,0.922692,0.927390,0.931946,0.936359,0.940629,
0.944755,0.948737,0.952574,0.956265,0.959809,0.963207,0.966457,0.969560,0.972514,0.975320,
0.977976,0.980482,0.982839,0.985045,0.987101,0.989006,0.990759,0.992361,0.993811,0.995109,
0.996254,0.997248,0.998088,0.998776,0.999312,0.999694,0.999924,1.000000};
double mysin(double x){//128は分割数-1,254は(分割数-1)*2,508は(分割数-1)*4の置き換え
int i;
int sgn=1;
if(x>0)i=(int)(x*254/M_PI+0.5);//四捨五入を行っておく.
else   i=(int)(x*254/M_PI-0.5);//単なる切捨てだと精度が半分になってしまう.
if(i<0){i=-i;sgn=0;}
i%=508;//127*4,複数回回転を除去
if(i>254){i=508-i;sgn=1-sgn;}//定義域を第一,第二象限に制限
if(i>127)i=254-i;//定義域を第一象限に制限
if(sgn)return sintable[i];
return -sintable[i];
}
double mycos(double x){
return mysin(x+M_PI/2);
}
main(){
int i;
puts("引数,sin真値,sin近似,cos真値,cos近似,sin誤差,cos誤差");
for(i = -10;i < 10;i++)
printf("%+lf,%+lf,%+lf,%+lf,%+lf,%+lf,%+lf\n",i*M_PI*2/360*50
,sin(i*M_PI*2/360*50),mysin(i*M_PI*2/360*50),cos(i*M_PI*2/360*50),mycos(i*M_PI*2/360*50)
,sin(i*M_PI*2/360*50)-mysin(i*M_PI*2/360*50),cos(i*M_PI*2/360*50)-mycos(i*M_PI*2/360*50));
}
254/M_PIを定数として別に保持しておけば,
mysin関数はdouble演算を2回のみ行うことがわかる.
このプログラムの実行結果を以下に示す.真値とテーブル引きの間では,最大0.005程度の誤差がおこることが分かる.
引数,sin真値,sin近似,cos真値,cos近似,sin誤差,cos誤差
-8.726646,-0.642788,-0.638567,-0.766044,-0.761610,-0.004221,-0.004434
-7.853982,-1.000000,-1.000000,+0.000000,-0.000000,+0.000000,+0.000000
-6.981317,-0.642788,-0.638567,+0.766044,+0.761610,-0.004221,+0.004434
-6.108652,+0.173648,+0.172295,+0.984808,+0.982839,+0.001353,+0.001969
-5.235988,+0.866025,+0.861873,+0.500000,+0.496425,+0.004152,+0.003575
-4.363323,+0.939693,+0.936359,-0.342020,-0.339436,+0.003334,-0.002584
-3.490659,+0.342020,+0.339436,-0.939693,-0.936359,+0.002584,-0.003334
-2.617994,-0.500000,-0.496425,-0.866025,-0.861873,-0.003575,-0.004152
-1.745329,-0.984808,-0.982839,-0.173648,-0.172295,-0.001969,-0.001353
-0.872665,-0.766044,-0.761610,+0.642788,+0.638567,-0.004434,+0.004221
+0.000000,+0.000000,+0.000000,+1.000000,+1.000000,+0.000000,+0.000000
+0.872665,+0.766044,+0.761610,+0.642788,+0.638567,+0.004434,+0.004221
+1.745329,+0.984808,+0.982839,-0.173648,-0.172295,+0.001969,-0.001353
+2.617994,+0.500000,+0.496425,-0.866025,-0.861873,+0.003575,-0.004152
+3.490659,-0.342020,-0.339436,-0.939693,-0.936359,-0.002584,-0.003334
+4.363323,-0.939693,-0.936359,-0.342020,-0.339436,-0.003334,-0.002584
+5.235988,-0.866025,-0.861873,+0.500000,+0.496425,-0.004152,+0.003575
+6.108652,-0.173648,-0.172295,+0.984808,+0.982839,-0.001353,+0.001969
+6.981317,+0.642788,+0.638567,+0.766044,+0.761610,+0.004221,+0.004434
+7.853982,+1.000000,+1.000000,+0.000000,+0.000000,+0.000000,+0.000000
本質的には[三角関数のテーブル引きによる高速化]とあまり変わらない.
テイラー展開を用いた補間をする場合
以下に1次のテイラー展開でテーブル値を補間した実装例を示す.
#include <stdio.h>
#include <math.h>
const double sintable[128]={
0.000000,0.012368,0.024734,0.037097,0.049454,0.061803,0.074143,0.086471,0.098786,0.111087,
0.123370,0.135634,0.147877,0.160098,0.172295,0.184465,0.196606,0.208718,0.220798,0.232844,
0.244854,0.256827,0.268761,0.280654,0.292503,0.304308,0.316066,0.327776,0.339436,0.351044,
0.362598,0.374097,0.385538,0.396921,0.408243,0.419502,0.430697,0.441826,0.452888,0.463881,
0.474802,0.485651,0.496425,0.507124,0.517745,0.528287,0.538748,0.549126,0.559421,0.569630,
0.579752,0.589785,0.599728,0.609579,0.619337,0.629000,0.638567,0.648036,0.657406,0.666676,
0.675843,0.684908,0.693867,0.702720,0.711466,0.720103,0.728630,0.737045,0.745348,0.753536,
0.761610,0.769566,0.777405,0.785125,0.792725,0.800204,0.807561,0.814793,0.821901,0.828884,
0.835739,0.842467,0.849066,0.855535,0.861873,0.868079,0.874153,0.880093,0.885898,0.891567,
0.897101,0.902497,0.907754,0.912873,0.917853,0.922692,0.927390,0.931946,0.936359,0.940629,
0.944755,0.948737,0.952574,0.956265,0.959809,0.963207,0.966457,0.969560,0.972514,0.975320,
0.977976,0.980482,0.982839,0.985045,0.987101,0.989006,0.990759,0.992361,0.993811,0.995109,
0.996254,0.997248,0.998088,0.998776,0.999312,0.999694,0.999924,1.000000};
double mysin(double x){//128は分割数-1,254は(分割数-1)*2,508は(分割数-1)*4の置き換え
int sinindex;
int cosindex;
int cossgn=0;
int sinsgn=0;
double gosa;
double s,c;
if(x>0)sinindex=(int)(x*254/M_PI+0.5);//四捨五入を行っておく.
else   sinindex=(int)(x*254/M_PI-0.5);//単なる切捨てだと精度が半分になってしまう.
cosindex=sinindex+127;
gosa=x-sinindex*M_PI/254;
if(sinindex<0){sinindex=-sinindex;sinsgn=1;}
if(cosindex<0){cosindex=-cosindex;cossgn=1;}
sinindex%=508;//127*4,複数回回転を除去
cosindex%=508;//127*4,複数回回転を除去
if(sinindex>254){sinindex=508-sinindex;sinsgn=1-sinsgn;}//定義域を第一,第二象限に制限
if(cosindex>254){cosindex=508-cosindex;cossgn=1-cossgn;}//定義域を第一,第二象限に制限
if(sinindex>127)sinindex=254-sinindex;//定義域を第一象限に制限
if(cosindex>127)cosindex=254-cosindex;//定義域を第一象限に制限
if(sinsgn)s=-sintable[sinindex];
else      s= sintable[sinindex];
if(cossgn)c=-sintable[cosindex];
else      c= sintable[cosindex];
return s+gosa*c;
}
double mycos(double x){
return mysin(x+M_PI/2);
}
main(){
int i;
puts("引数,sin真値,sin近似,cos真値,cos近似,sin誤差,cos誤差");
for(i = -10;i < 10;i++)
printf("%+lf,%+lf,%+lf,%+lf,%+lf,%+lf,%+lf\n",i*M_PI*2/360*50
,sin(i*M_PI*2/360*50),mysin(i*M_PI*2/360*50),cos(i*M_PI*2/360*50),mycos(i*M_PI*2/360*50)
,sin(i*M_PI*2/360*50)-mysin(i*M_PI*2/360*50),cos(i*M_PI*2/360*50)-mycos(i*M_PI*2/360*50));
}
254/M_PIを定数として別に保持しておけば,
mysin関数はdouble演算を6回行うことがわかる.
このプログラムの実行結果を以下に示す.真値とテーブル引きの間では,最大0.00001程度の誤差がおこることが分かる.
このように,劇的な精度の向上が確認できた.
なお,テイラー展開を2次で打ち切ると,double演算が9回になるものの,誤差が0になった.(printfで表示できる限界まで正確になる)
引数,sin真値,sin近似,cos真値,cos近似,sin誤差,cos誤差
-8.726646,-0.642788,-0.642797,-0.766044,-0.766056,+0.000010,+0.000011
-7.853982,-1.000000,-1.000000,+0.000000,+0.000000,+0.000000,+0.000000
-6.981317,-0.642788,-0.642797,+0.766044,+0.766056,+0.000010,-0.000011
-6.108652,+0.173648,+0.173649,+0.984808,+0.984808,-0.000001,-0.000000
-5.235988,+0.866025,+0.866032,+0.500000,+0.500004,-0.000007,-0.000004
-4.363323,+0.939693,+0.939696,-0.342020,-0.342021,-0.000003,+0.000001
-3.490659,+0.342020,+0.342021,-0.939693,-0.939696,-0.000001,+0.000003
-2.617994,-0.500000,-0.500004,-0.866025,-0.866032,+0.000004,+0.000007
-1.745329,-0.984808,-0.984808,-0.173648,-0.173649,+0.000000,+0.000001
-0.872665,-0.766044,-0.766056,+0.642788,+0.642797,+0.000011,-0.000010
+0.000000,+0.000000,+0.000000,+1.000000,+1.000000,+0.000000,+0.000000
+0.872665,+0.766044,+0.766056,+0.642788,+0.642797,-0.000011,-0.000010
+1.745329,+0.984808,+0.984808,-0.173648,-0.173649,-0.000000,+0.000001
+2.617994,+0.500000,+0.500004,-0.866025,-0.866032,-0.000004,+0.000007
+3.490659,-0.342020,-0.342021,-0.939693,-0.939696,+0.000001,+0.000003
+4.363323,-0.939693,-0.939696,-0.342020,-0.342021,+0.000003,+0.000001
+5.235988,-0.866025,-0.866032,+0.500000,+0.500004,+0.000007,-0.000004
+6.108652,-0.173648,-0.173649,+0.984808,+0.984808,+0.000001,-0.000000
+6.981317,+0.642788,+0.642797,+0.766044,+0.766056,-0.000010,-0.000011
+7.853982,+1.000000,+1.000000,+0.000000,+0.000000,+0.000000,+0.000000
sh7147に実装してみたところ,
テーブル引きのみだと実行時間を100usec以下に抑えることができた.
テイラー展開による補正を加えると100usec以上の計算時間がかかった.
美しいコーディング
ロボット工作研究室wikiに美しいコード例があります.
付録
マクローリン展開(テイラー展開の系)
十分小さなに対し,以下のような近似式が成立する.
参考文献
外部リンク
[三角関数のテーブル引きによる高速化]
[三角関数]
[サルでも分かるCORDICアルゴリズム]「計算速度は早くはないのだが,非常に小規模な電子回路にハードウェア的に組み込めるため,関数電卓や組み込みICチップなどに好んで使われる」アルゴリズムだそうです.
三角関数の高速化 - マイクロマウス委員会関西支部
