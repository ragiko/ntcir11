
ヘッダーをスキップ
Oracle Database SQLリファレンス10g リリース2(10.2)B19201-01
目次
索引
2 Oracle SQLの基本要素
この章では、Oracle SQLの基本要素に関する参照情報を説明します。これらの要素は、SQL文の最も単純な構成ブロックです。したがって、第10章〜第19章で説明されている文を使用する前に、この章で説明する概念を理解しておく必要があります。
この章では、次の内容を説明します。
データ型
リテラル
書式モデル
NULL
コメント
データベース・オブジェクト
スキーマ・オブジェクト名および修飾子
スキーマ・オブジェクトの構文およびSQL文の構成要素
データ型
Oracleデータベースが処理する値は、それぞれデータ型を持ちます。値のデータ型は、固定されたプロパティの集合をその値に対応付けます。このプロパティに応じて、Oracleは、あるデータ型の値を別のデータ型の値と区別して扱います。たとえば、NUMBERデータ型の値は加算できますが、RAWデータ型の値は加算できません。
表またはクラスタを作成する場合、各列にデータ型を指定する必要があります。プロシージャまたはストアド・ファンクションを作成する場合は、その各引数にデータ型を指定する必要があります。データ型によって、各列が含むことができる値のドメイン、または各引数が持つことができる値のドメインが決まります。たとえば、DATE列は、2月29日(うるう年を除く)、2または'SHOE'という値を格納できません。列に入る値は、その列のデータ型を受け継ぎます。たとえば、DATE列に'01-JAN-98'を挿入すると、Oracleはそれが有効な日付に変換されることを確認してから、文字列'01-JAN-98'をDATE値として扱います。
Oracleデータベースには、多くの組込みデータ型、およびデータ型として使用できるいくつかのユーザー定義型のカテゴリがあります。Oracleのデータ型の構文については、次の構文図で示します。この項は、次の4つの項にわかれています。
Oracleの組込みデータ型
ANSI、DB2、SQL/DSのデータ型
ユーザー定義型
Oracleが提供する型
データ型の比較規則
データ変換
データ型はスカラーまたは非スカラーです。スカラー型は、アトム値を持ちますが、非スカラー型(コレクションともいう)は一連の値を持ちます。ラージ・オブジェクト(LOB)は、スカラー型の特別な形で、バイナリまたは文字データのラージ・スカラー値を表しています。LOBはサイズが大きいため、他のスカラー型には影響しないいくつかの制限事項があります。これらの制限事項については、関連するSQL構文を参照してください。
Oracleプリコンパイラによって、埋込みSQLプログラムで他のデータ型が区別されます。このようなデータ型は、外部データ型と呼ばれ、ホスト変数に対応付けられています。組込みデータ型およびユーザー定義型を外部データ型と混同しないでください。Oracleによる外部データ型と組込み型またはユーザー定義データ型の間の変換など、外部データ型の詳細は、『Pro*COBOLプログラマーズ・ガイド』および『Pro*C/C++プログラマーズ・ガイド』を参照してください。
datatypes::=
画像の説明
Oracle_built_in_datatypes::=
画像の説明
Oracle組込みデータ型の詳細は、「Oracleの組込みデータ型」を参照してください。
character_datatypes::=
画像の説明
number_datatypes::=
画像の説明
long_and_raw_datatypes::=
画像の説明
datetime_datatypes::=
画像の説明
large_object_datatypes::=
画像の説明
rowid_datatypes::=
画像の説明
次に、ANSIがサポートしているデータ型について示します。また、「ANSI、DB2、SQL/DSのデータ型」に、ANSIがサポートしているデータ型をOracle組込みデータ型にマップする方法を示します。
ANSI_supported_datatypes::=
画像の説明
Oracle_supplied_types::=
画像の説明
expression_filter_typeの詳細は、「Expression Filter型」を参照してください。次に、Oracleが提供するその他の型を示します。
any_types::=
画像の説明
任意型の詳細は、「任意型」を参照してください。
XML_types::=
画像の説明
XML型の詳細は、「XML型」を参照してください。
spatial_types::=
画像の説明
空間型の詳細は、「空間型」を参照してください。
media_types::=
画像の説明
still_image_object_types::=
画像の説明
メディア型の詳細は、「メディア型」を参照してください。
Oracleの組込みデータ型
次の表にOracle組込みデータ型の概要を示します。構文要素については、前の項の構文を参照してください。データ型のコードは、Oracleデータベースが内部的に使用します。DUMPファンクションによって、列またはオブジェクト属性のデータ型コードが戻されます。
表2-1    組込みデータ型の概要 
コード 
データ型 
説明 
1 
VARCHAR2(size [BYTE | CHAR]) 
最大長がsizeバイトまたはsize文字の可変長文字列。最大サイズは4000、最小サイズは1です。VARCHAR2には、sizeを指定する必要があります。
BYTEは、列がバイト長セマンティクスを持つことを示し、CHARは、列がキャラクタ・セマンティクスを持つことを示します。 
1 
NVARCHAR2(size) 
最大長がsize文字の可変長Unicode文字列。バイト数は、AL16UTF16エンコードの場合はsizeの2倍まで、UTF8エンコードの場合はsizeの3倍までです。最大サイズは、各国語キャラクタ・セット定義(上限4000バイト)によって決定されます。NVARCHAR2には、sizeを指定する必要があります。 
2 
NUMBER[(precision [, scale]]) 
精度p、位取りsを持つ数。精度pには1〜38の値を指定できます。位取りsには-84〜127の値を指定できます。 
8 
LONG 
最大2GB(231から1を引いたバイト数)の可変長文字データ。下位互換性のために提供されています。 
12 
DATE 
紀元前4712年1月1日〜紀元9999年12月31日までの日付を指定します。デフォルトの書式は、NLS_DATE_FORMATパラメータによって明示的に決まるか、またはNLS_TERRITORYパラメータによって暗黙的に決まります。サイズは7バイトに固定されています。このデータ型には、YEAR、MONTH、DAY、HOUR、MINUTEおよびSECONDの日時フィールドがあります。秒の小数部とタイムゾーンはありません。 
21 
BINARY_FLOAT 
32ビットの浮動小数点数。このデータ型には、長さを示すバイトを含め、5バイトが必要です。 
22 
BINARY_DOUBLE 
64ビットの浮動小数点数。このデータ型には、長さを示すバイトを含め、9バイトが必要です。 
180 
TIMESTAMP [(fractional_seconds)] 
日付の年、月、日および時刻の時、分、秒の値。fractional_seconds_precisionは、SECOND日時フィールドの小数部の桁数です。fractional_seconds_precisionの有効範囲は、0〜9です。デフォルトは6です。デフォルトの書式は、NLS_DATE_FORMATパラメータによって明示的に決まるか、またはNLS_TERRITORYパラメータによって暗黙的に決まります。サイズは、精度によって7〜11バイトの長さで変化します。このデータ型には、YEAR、MONTH、DAY、HOUR、MINUTEおよびSECONDの日時フィールドがあります。秒の小数部はありますが、タイムゾーンはありません。 
181 
TIMESTAMP  [(fractional_seconds)] WITH TIME ZONE 
タイムゾーンによる時差などのすべてのTIMESTAMPの値。fractional_seconds_precisionは、SECOND日時フィールドの小数部の桁数です。有効範囲は0〜9です。デフォルトは6です。デフォルトの書式は、NLS_DATE_FORMATパラメータによって明示的に決まるか、またはNLS_TERRITORYパラメータによって暗黙的に決まります。サイズは13バイトに固定されています。このデータ型には、YEAR、MONTH、DAY、HOUR、MINUTE、SECOND、TIMEZONE_HOURおよびTIMEZONE_MINUTEの日時フィールドがあります。秒の小数部と明示的なタイムゾーンがあります。 
231 
TIMESTAMP  [(fractional_seconds)] WITH LOCAL TIME ZONE 
TIMESTAMP WITH TIME ZONEのすべての値。ただし、次に示す例外があります。
データベースへの格納時、データがデータベースのタイムゾーンに正規化されている場合。
データの検索時、ユーザーがセッションのタイムゾーンでデータを検索する場合。
デフォルトの書式は、NLS_DATE_FORMATパラメータによって明示的に決まるか、またはNLS_TERRITORYパラメータによって暗黙的に決まります。サイズは、精度によって7〜11バイトの長さで変化します。 
182 
INTERVAL YEAR  [(year_precision)] TO MONTH 
年および月で期間を格納。year_precisionは、YEAR日時フィールドの桁数です。有効範囲は0〜9です。デフォルトは2です。サイズは5バイトに固定されています。 
183 
INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds)] 
日、時、分および秒で期間を格納。
day_precisionは、DAY日時フィールドの最大桁数です。有効範囲は0〜9です。デフォルトは2です。
fractional_seconds_precisionは、SECONDフィールドの小数部の桁数です。有効範囲は0〜9です。デフォルトは6です。
サイズは11バイトに固定されています。 
23 
RAW(size) 
長さsizeバイトのバイナリ・データ。最大サイズは2000バイトです。RAW値には、sizeを指定する必要があります。 
24 
LONG RAW 
最大2GBの可変長バイナリ・データ。 
69 
ROWID 
表の行のアドレスを一意に表すBASE64文字列。主に、ROWID疑似列によって戻される値のためのデータ型です。 
208 
UROWID [(size)] 
索引構成表の行の論理アドレスを表すBASE64文字列。オプションのsizeは、UROWID型の列のサイズです。最大サイズおよびデフォルトは4000バイトです。 
96 
CHAR [(size [BYTE | CHAR])] 
長さsizeバイトの固定長文字データ。最大サイズは2000です。デフォルトおよび最小サイズは1です。
BYTEおよびCHARは、VARCHAR2と同じセマンティクスを持ちます。 
96 
NCHAR[(size)] 
長さsize文字の固定長文字データ。バイト数は、AL16UTF16エンコードの場合はsizeの2倍まで、UTF8エンコードの場合はsizeの3倍までです。最大サイズは、各国語キャラクタ・セット定義(上限2000バイト)によって決定されます。デフォルトおよび最小サイズは1です。 
112 
CLOB 
シングルバイト・キャラクタまたはマルチバイト・キャラクタを含むキャラクタ・ラージ・オブジェクト。固定幅および可変幅のキャラクタ・セットがサポートされます。両方のキャラクタ・セットでデータベース・キャラクタ・セットを使用します。最大サイズは、4GBから1を引いたバイト数にデータベース・ブロック・サイズを掛けた値です。 
112 
NCLOB 
Unicodeキャラクタを含むキャラクタ・ラージ・オブジェクト。固定幅および可変幅のキャラクタ・セットがサポートされます。両方のキャラクタ・セットでデータベース各国語キャラクタ・セットを使用します。最大サイズは、4GBから1を引いたバイト数にデータベース・ブロック・サイズを掛けた値です。各国語キャラクタ・セットのデータを格納します。 
113 
BLOB 
バイナリ・ラージ・オブジェクト。最大サイズは、4GBから1を引いたバイト数にデータベース・ブロック・サイズを掛けた値です。 
114 
BFILE 
データベース外に保存された大きなバイナリ・ファイルへロケータを格納。データベース・サーバー上に存在する外部LOBへのバイト・ストリームI/Oアクセスを可能にします。最大サイズは4GBです。 
次の項では、Oracleデータベースに格納されるOracleデータ型について説明します。これらのデータ型をリテラルとして指定する方法については、「リテラル」を参照してください。
文字データ型
文字データ型を使用すると、単語や自由形式のテキストなど、データベース・キャラクタ・セットまたは各国語キャラクタ・セットの文字(英数字)を格納できます。文字データ型は、他のデータ型より制限が少ないため、プロパティも少なくなります。たとえば、文字データ型の列は、すべての英数字の値を格納できますが、NUMBER型の列が格納できるのは数値のみです。
文字データは、7ビットASCIIやEBCDICなど、データベース作成時に指定されたキャラクタ・セットの1つに対応しているバイト値で文字列に格納されます。Oracleデータベースは、シングルバイトのキャラクタ・セットとマルチバイトのキャラクタ・セットの両方をサポートします。
次のデータ型が、文字データに対して使用されます。
CHARデータ型
NCHARデータ型
NVARCHAR2データ型
VARCHAR2データ型
文字データ型をリテラルとして指定する方法については、「テキスト・リテラル」を参照してください。
CHARデータ型
CHARデータ型は、固定長の文字列を指定します。Oracleでは、CHAR列に格納される値がすべてsizeで指定した長さを持つように調整されます。列の長さより短い値を挿入すると、列の長さにあわせるため、その値の後に空白が埋め込まれます。列に対して長すぎる値を挿入しようとすると、Oracleはエラーを戻します。
CHAR列のデフォルトの長さは1バイトで、この許容最大値は2000バイトです。CHAR(10)列には、1バイトの文字列を挿入できますが、この文字列は10バイトまで空白埋めされてから格納されます。
CHAR列を持つ表を作成する場合、デフォルトでは列の長さはバイト単位になります。BYTE修飾子は、デフォルトと同じです。CHAR修飾子(たとえば、CHAR(10 CHAR))を使用すると、列の長さは文字単位になります。技術的ないい方をすると、文字は、データベース・キャラクタ・セットのコード・ポイントです。サイズは、データベース・キャラクタ・セットによって異なりますが、1バイトから4バイトです。BYTEおよびCHAR修飾子は、NLS_LENGTH_SEMANTICSパラメータ(デフォルトはバイト・セマンティクス)で指定したセマンティクスを上書きします。パフォーマンス上の理由から、長さセマンティクスの設定にはNLS_LENGTH_SEMANTICSパラメータを使用し、このパラメータを上書きする必要があるときにのみBYTEおよびCHAR修飾子を使用することをお薦めします。
異なるキャラクタ・セットを持つデータベース間で適切にデータを変換するには、CHARデータが正しい書式の文字列で構成されていることを確認してください。キャラクタ・セット・サポートの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
参照:
比較セマンティクスについては、「データ型の比較規則」を参照してください。 
NCHARデータ型
NCHARデータ型はUnicodeのみのデータ型です。NCHAR列を持つ表を作成する場合、列の長さを文字単位で指定します。使用する各国語キャラクタ・セットは、データベースを作成するときに指定します。
列の最大長は、各国語キャラクタ・セットの定義によって決まります。NCHAR文字データ型の幅指定は、文字数を示します。許容最大列サイズは2000バイトです。
列の長さより短い値を挿入すると、列の長さにあわせるため、その値の後に空白が埋め込まれます。CHAR値をNCHAR列に挿入することや、NCHAR値をCHAR列に挿入することはできません。
次の例では、表pm.product_descriptionsのtranslated_description列と各国語キャラクタ・セットの文字列を比較します。
SELECT translated_description FROM product_descriptions
WHERE translated_name = N'LCD Monitor 11/PM';
Unicodeデータ型のサポートの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
NVARCHAR2データ型
NVARCHAR2データ型はUnicodeのみのデータ型です。NVARCHAR2列を持つ表を作成する場合、保持できる最大の文字数を指定します。Oracleでは、列の最大長を超えないかぎり、各値を指定されたとおりに正確に列に格納します。
列の最大長は、各国語キャラクタ・セットの定義によって決まります。NVARCHAR2文字データ型の幅指定は、文字数を示します。許容最大列サイズは4000バイトです。Unicodeデータ型のサポートの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
VARCHAR2データ型
VARCHAR2データ型は、可変長の文字列を指定します。VARCHAR2列を作成する場合、保持できるデータの最大バイト数または最大文字数を指定します。Oracleでは、列の最大長を超えないかぎり、各値を指定されたとおりに正確に列に格納します。最大長を超える値を挿入しようとすると、Oracleはエラーを戻します。
VARCHAR2列には最大長を指定する必要があります。保存される文字列の実際の長さは0(ゼロ)にできますが、最大長は1バイト以上にする必要があります。CHAR修飾子(たとえば、VARCHAR2(10 CHAR))を使用すると、バイトではなく、文字で最大長を指定できます。技術的ないい方をすると、文字は、データベース・キャラクタ・セットのコード・ポイントです。CHARおよびBYTE修飾子は、NLS_LENGTH_SEMANTICSパラメータ(デフォルトはバイト)の設定を上書きします。パフォーマンス上の理由から、長さセマンティクスの設定にはNLS_LENGTH_SEMANTICSパラメータを使用し、このパラメータを上書きする必要があるときにのみBYTEおよびCHAR修飾子を使用することをお薦めします。VARCHAR2データの最大長は4000バイトです。Oracleは、非空白埋め比較セマンティクスを使用してVARCHAR2値を比較します。
異なるキャラクタ・セットを持つデータベース間で適切にデータを変換するには、VARCHAR2データが正しい書式の文字列で構成されていることを確認してください。キャラクタ・セット・サポートの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
参照:
比較セマンティクスについては、「データ型の比較規則」を参照してください。 
VARCHARデータ型
VARCHARデータ型は、使用しないでください。かわりにVARCHAR2データ型を使用してください。現在、VARCHARデータ型はVARCHAR2データ型と同じ意味で使用されていますが、VARCHARデータ型は、異なる比較セマンティクスで比較される別の可変長文字列のデータ型に変更される予定です。
数値データ型
Oracleデータベースの数値データ型は、正と負の固定小数点数と浮動小数点数、0(ゼロ)、無限大、および操作の未定義の結果である値(非数値、つまりNAN)を格納します。数値データ型をリテラルとして指定する方法については、「数値リテラル」を参照してください。
NUMBERデータ型
NUMBERデータ型は、0(ゼロ)と、絶対値が1.0×10-130以上1.0×10126未満の範囲にある正と負の固定小数点数を格納します。1.0×10126以上の絶対値を持つ算術式を指定した場合、Oracleはエラーを戻します。NUMBERの各値は1〜22バイトである必要があります。
次の書式で固定小数点数を指定できます。
NUMBER(p,s)
それぞれの意味は、次のとおりです。
pは精度(precision)、つまり有効桁数(10進)の合計です。最上位有効桁は最も左側のゼロ以外の桁で、最下位有効桁は最も右側の桁です。Oracleは、100進数で20桁までの精度で数値の移植性を保証します。これは小数点の位置によって39桁(10進)または40桁(10進)になります。
sは位取り(scale)、つまり小数点から最下位有効桁までの桁数です。位取りの有効範囲は-84〜127です。
位取りが正の場合は、小数点の右側にある桁数で最下位有効桁を含んだ桁数になります。
位取りが負の場合、小数点の左側にある桁数です。この場合は最下位有効桁を含みません。位取りが負の場合、実際のデータは整数部分の右から指定された桁数のみ丸められるため、最下位有効桁は小数点の左側になります。たとえば、(10,-2)と指定すると100の位まで丸められます。
e表記を使用する場合、位取りは通常、精度よりも大きくなります。位取りが精度より大きい場合、精度は小数点の右側にある最大有効桁数を示します。たとえば、NUMBER(4,5)として定義された列は、小数点の後の最初の桁が0(ゼロ)である必要があり、小数点以下5桁を超える値はすべて丸められます。
入力に対する特別な整合性チェックとして、固定小数点数列の位取りと精度を指定することをお薦めします。位取りと精度を指定しても、すべての値が固定長に強制されるわけではありません。値が精度の有効範囲を超えると、Oracleはエラーを戻します。値が位取りの有効範囲を超えると、Oracleはその値を丸めます。
次の書式で整数を指定できます。
NUMBER(p)
これは、精度がpで、位取りが0の固定小数点数です(NUMBER(p,0)と同じです)。
次の書式で浮動小数点を指定できます。
NUMBER 
精度および位取りを指定しない場合、最大の範囲および精度をOracleの数値に指定したことになります。
参照:
「浮動小数点数」 
表2-2に、異なる精度および位取りを使用したOracleのデータの格納方法を示します。
表2-2    精度および位取りの格納 
実際のデータ 
指定する精度と位取り 
格納されるデータ 
123.89 
NUMBER 
123.89 
123.89 
NUMBER(3) 
124 
123.89 
NUMBER(6,2) 
123.89 
123.89 
NUMBER(6,1) 
123.9 
123.89 
NUMBER(3) 
精度を超える 
123.89 
NUMBER(4,2) 
精度を超える 
123.89 
NUMBER(6,-2) 
100 
.01234 
NUMBER(4,5) 
.01234 
.00012 
NUMBER(4,5) 
.00012 
.000127 
NUMBER(4,5) 
.00013 
.0000012 
NUMBER(2,7) 
.0000012 
.00000123 
NUMBER(2,7) 
.0000012 
1.2e-4 
NUMBER(2,5) 
0.00012 
1.2e-5 
NUMBER(2,5) 
0.00001 
浮動小数点数
浮動小数点数は、最初の桁から最後の桁までの任意の位置に小数点を置くことも、小数点を省略することもできます。指数は、数字の後に増加する桁数を表すときに、オプションで使用されます(たとえば、1.777 e-20)。小数点以下の桁数に制限はないため、浮動小数点数に対して位取りは指定できません。
2進浮動小数点数とNUMBERでは、Oracleデータベースによる内部的な値の格納方法が異なります。NUMBERの場合、値は10進精度を使用して格納されます。NUMBERでサポートされる範囲内および精度内のすべてのリテラルは、NUMBERとして正確に格納されます。これは、リテラルが10進精度(0〜9)を使用して表されるためです。2進浮動小数点数は、2進精度(0および1)を使用して格納されます。このような格納スキームでは、10進精度を使用したすべての値を正確に表すことができません。値を10進精度から2進精度に変換するときに発生するエラーは、その値を2進精度から10進精度に戻すときには発生しない場合が多くあります。リテラル0.1はその一例です。
Oracleデータベースでは、浮動小数点数専用の2種類の数値データ型を提供しています。
BINARY_FLOAT
32ビットの単精度浮動小数点数データ型です。このデータ型の各値には、長さを示すバイトを含め、5バイトが必要です。
BINARY_DOUBLE
64ビットの倍精度浮動小数点数データ型です。このデータ型の各値には、長さを示すバイトを含め、9バイトが必要です。
NUMBER列では、浮動小数点数は10進精度を持ちます。BINARY_FLOAT列またはBINARY_DOUBLE列では、浮動小数点数は2進精度を持ちます。2進浮動小数点数では、特殊な値である無限大およびNaN(非数値)がサポートされます。
表2-3に示す制限内で、浮動小数点数を指定できます。浮動小数点数を指定する書式については、「数値リテラル」を参照してください。
表2-3    浮動小数点数の制限 
値 
BINARY_FLOAT 
BINARY_DOUBLE 
正の最大有限値 
3.40282E+38F 
1.79769313486231E+308 
正の最小有限値 
1.17549E-38F 
2.22507485850720E-308 
OracleデータベースはANSIのデータ型であるFLOATもサポートします。次の構文書式のいずれかを使用して、このデータ型を指定します。
FLOAT
FLOAT(n)
数値nは、値に格納できる精度のビット数を示します。nの値は、1〜126の範囲で指定します。2進精度から10進精度に変換するには、nに0.30103を乗算します。10進精度から2進精度に変換するには、10進精度に3.32193を乗算します。2進精度の126桁は、10進精度の38桁とほぼ等しくなります。
IEEE754への規格準拠
Oracleの浮動小数点データ型の実装は、2進浮動小数点算術の規格である電気電子学会(IEEE)754-1985(IEEE754)規格に準拠しています。新しいデータ型は次の点でIEEE754に準拠しています。
SQLファンクションSQRTは平方根を実装します。「SQRT」を参照してください。
SQLファンクションREMAINDERは余りを実装します。「REMAINDER」を参照してください。
算術演算子が準拠しています。「算術演算子」を参照してください。
比較演算子が準拠しています。ただし、NaNと比較する場合は除きます。Oracleは、NaNが他のすべての値より大きいとみなし、NaNとNaNは等しいと評価します。「浮動小数点条件」を参照してください。
変換演算子が準拠しています。「変換ファンクション」を参照してください。
デフォルトの丸めモードがサポートされています。
デフォルトの例外処理モードがサポートされています。
特殊な値であるINF、-INFおよびNaNがサポートされています。「浮動小数点条件」を参照してください。
BINARY_FLOATおよびBINARY_DOUBLEの値を整数値のBINARY_FLOATおよびBINARY_DOUBLEに丸める方法として、SQLファンクションROUND、TRUNC、CEILおよびFLOORが提供されています。
BINARY_FLOATおよびBINARY_DOUBLEを10進値に、10進値をBINARY_FLOATおよびBINARY_DOUBLEに丸める方法として、SQLファンクションTO_CHAR、TO_NUMBER、TO_NCHAR、TO_BINARY_FLOAT、TO_BINARY_DOUBLEおよびCASTが提供されています。
新しいデータ型は次の点ではIEEE754に準拠していません。
-0は+0に強制変換されます。
NaNとの比較はサポートされていません。
すべてのNaN値は、BINARY_FLOAT_NANまたはBINARY_DOUBLE_NANのいずれかに強制変換されます。
デフォルト以外の丸めモードはサポートされていません。
デフォルト以外の例外処理モードはサポートされていません。
数値の優先順位
数値データ型をサポートする操作で、操作の引数が様々なデータ型を持つ場合、Oracleが使用するデータ型は、数値の優先順位によって判断されます。数値の優先順位が最も高いデータ型はBINARY_DOUBLEであり、その次がBINARY_FLOAT、最後がNUMBERとなります。したがって、複数の数値に対する操作では、次のようになります。
オペランドのいずれかがBINARY_DOUBLEの場合、Oracleは操作の実行前に、すべてのオペランドを暗黙的にBINARY_DOUBLEに変換しようとします。
オペランドにBINARY_DOUBLEはないが、いずれかがBINARY_FLOATの場合、Oracleは操作の実行前に、すべてのオペランドを暗黙的にBINARY_FLOATに変換しようとします。
それ以外の場合は、Oracleは操作の実行前に、すべてのオペランドをNUMBERに変換しようとします。
暗黙的な変換が必要な場合に変換に失敗すると、操作は実行されません。暗黙的な変換の詳細は、表2-10「暗黙的な型変換のマトリックス」を参照してください。
他のデータ型のコンテキストでは、数値データ型の優先順位は、日時データ型と期間データ型よりも低く、文字データ型とその他のすべてのデータ型よりも高くなります。
LONGデータ型
LONG列には、2GB(231)から1を引いたバイト数までの可変長の文字列を格納できます。LONG列には、多くの点でVARCHAR2列と同じ特長があります。LONG列を使用すると、長いテキスト文字列を格納できます。LONG値の長さは、ご使用のコンピュータで利用できるメモリーによって制限される場合もあります。LONGリテラルは、「テキスト・リテラル」の説明のような形式になります。
LONG列を持つ表は作成しないでください。かわりに、LOB列(CLOB、NCLOBまたはBLOB)を使用してください。LONG列は、下位互換性のためにサポートされています。
既存のLONG列もLOB列に変換することをお薦めします。LOB列は、LONG列ほど制限は多くありません。LOB機能はリリースごとに拡張されていますが、LONG機能は最近のリリースでは変更されていません。LONG列からLOB列への変換については、「ALTER TABLE」の「modify_col_properties」および「TO_LOB」を参照してください。
SQL文の中の次の場所でLONG列を参照できます。
SELECT構文のリスト
UPDATE文のSET句
INSERT文のVALUES句
LONG値を使用する場合には、次の制限があります。
表には複数のLONG列を含めることはできません。
LONG属性を持つオブジェクトは作成できません。
LONG列は、WHERE句または整合性制約では指定できません(NULLおよびNOT NULL制約は除く)。
LONG列に索引を付けることはできません。
LONGデータは正規表現では指定できません。
ストアド・ファンクションはLONG値を戻すことはできません。
LONGデータ型を使用して、PL/SQLプログラム・ユニットの変数または引数を宣言できます。ただし、そのプログラムは、SQLからコールできません。
単一のSQL文に指定する、すべてのLONG列、更新された表、ロックされた表は、同一データベース上にある必要があります。
LONG列およびLONG RAW列は、分散型のSQL文で使用できません。また、レプリケートできません。
LONGとLOBの両方の列を持つ表では、1つのSQL文で両方に4000バイトより大きいデータをバインドすることはできません。ただし、いずれか片方にバインドすることは可能です。
また、LONG列はSQL文の次のような部分では使用できません。
GROUP BY句、ORDER BY句、CONNECT BY句またはSELECT文にあるDISTINCT演算子
SELECT文の一意演算子
CREATE CLUSTER文の列リスト
CREATE MATERIALIZED VIEW文のCLUSTER句
SQL組込みファンクション、式または条件
GROUP BY句を含む問合せのSELECT構文のリスト
UNION、INTERSECTまたはMINUS集合演算子によって結合されている副問合せまたは問合せのSELECT構文のリスト
CREATE TABLE ...AS SELECT文のSELECT構文のリスト
ALTER TABLE ... MOVE文
INSERT文の副問合せのSELECT構文のリスト
トリガーでは、LONGデータ型は次のように使用されます。
トリガー内のSQL文で、データをLONG列に挿入できます。
LONG列のデータをCHARやVARCHAR2などの制約があるデータ型に変換できる場合は、トリガー内のSQL文でLONG列を参照できます。
トリガー内の変数は、LONGデータ型を使用して宣言できません。
::NEWと:OLDはLONG列で使用できません。
Oracle Call Interfaceを使用して、データベースからLONG値の一部を検索できます。
参照:
『Oracle Call Interfaceプログラマーズ・ガイド』 
日時および期間データ型
日時データ型には、DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONEおよびTIMESTAMP WITH LOCAL TIME ZONEがあります。日時データ型の値は、「日時」とも呼ばれます。期間データ型には、INTERVAL YEAR TO MONTHおよびINTERVAL DAY TO SECONDがあります。期間データ型の値は、「期間」とも呼ばれます。日時値と期間値をリテラルとして表す方法の詳細は、「日時リテラル」および「期間リテラル」を参照してください。
日時および期間はいずれもフィールドで構成されます。これらのフィールドの値は、データ型の値によって決まります。表2-4に、日時フィールド、および日時と期間の有効な値を示します。
日時データのDML操作で正しい結果を得るには、組込みSQLファンクションDBTIMEZONEおよびSESSIONTIMEZONEで問い合せることによって、データベースおよびセッションのタイムゾーンを確認します。タイムゾーンを手動で設定していない場合、Oracleデータベースは、オペレーティング・システムのタイムゾーンをデフォルトで使用します。オペレーティング・システムのタイムゾーンがOracleで有効でない場合は、Oracleは、協定世界時(UTC)(以前のグリニッジ標準時)をデフォルトの値として使用します。
表2-4    日時フィールド、および日時と期間の値 
日時フィールド 
日時に有効な値 
期間に有効な値 
YEAR 
-4712〜9999(0を除きます) 
正または負のすべての整数 
MONTH 
01〜12 
0〜11 
DAY 
01〜31(現在のNLSカレンダ・パラメータに従ったMONTHおよびYEARの値の範囲内) 
正または負のすべての整数 
HOUR 
00〜23 
0〜23 
MINUTE 
00〜59 
0〜59 
SECOND 
00〜59.9(n)(「9(n)」は秒の小数部の精度。DATEには適用されません) 
00〜59.9(n)(「9(n)」は秒の小数部の期間の精度) 
TIMEZONE_HOUR 
-12〜14(この範囲は夏時間の変更を保存します。DATEまたはTIMESTAMPには適用されません。 
適用なし 
TIMEZONE_MINUTE
(表の後の注意を参照) 
00〜59(DATEまたはTIMESTAMPには適用されません) 
適用なし 
TIMEZONE_REGION 
V$TIMEZONE_NAMESデータ・ディクショナリ・ビュー内のTZNAME列を問い合せます。DATEまたはTIMESTAMPには適用されません。すべてのタイムゾーン地域のリストは、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
適用なし 
TIMEZONE_ABBR 
V$TIMEZONE_NAMESデータ・ディクショナリ・ビュー内のTZABBREV列を問い合せます。DATEまたはTIMESTAMPには適用されません。 
適用なし 
注意: TIMEZONE_HOURおよびTIMEZONE_MINUTEの両方を指定すると、+|- hh:mmの形式(-12:59から+14:00までの値を使用)で、1つにまとめて解釈されます。.NETのAPIにタイムゾーン値を指定する方法の詳細は、『Oracle Data Provider for .NET開発者ガイド』を参照してください。
DATEデータ型
DATEデータ型は、日付および時刻の情報を格納するために使用します。日付および時刻の情報は、文字データ型および数値データ型で表現できますが、DATEデータ型には特別に対応付けられているプロパティがあります。各DATE値には、世紀、年、月、日、時、分および秒の情報が格納されます。
DATE値をリテラルに指定するか、文字値や数値をTO_DATEファンクションによって日付値に変換できます。これらの方法でのDATE値の表し方の例は「日時リテラル」を参照してください。
ユリウス日の使用方法
ユリウス日は、紀元前4712年1月1日から経過した日数です。ユリウス日によって共通の基準で日付を算定できます。日付ファンクションTO_DATEとTO_CHARで日付書式モデル「J」を使用して、OracleのDATE値とユリウス日の間で変換を行うことができます。
注意:
Oracleデータベースでは、ユリウス日の計算に天文学方式を使用しています。この方式では、紀元前4713年は-4712として計算されます。これに対し、歴史学方式では、紀元前4713年は-4713として計算されます。Oracleのユリウス日を、歴史学方式で計算した値と比較する場合には、紀元前の日付に365日の違いがあることに注意してください。詳細は、http://aa.usno.navy.mil/faq/docs/millennium.htmlを参照してください。 
デフォルトの日付値は次のように決まります。
年は現在の年で、SYSDATEで戻されます。
月は現在の月で、SYSDATEで戻されます。
日は01、つまり月の最初の日になります。
時、分、秒はすべて0です。
これらのデフォルト値は、次の例(5月に発行)のように、日付が指定されていない場合に日付値を要求する問合せで使用されます。
SELECT TO_DATE('2005', 'YYYY') FROM DUAL;
TO_DATE('
---------
01-MAY-05
例
次の文では、1997年1月1日をユリウス日で戻します。
SELECT TO_CHAR(TO_DATE('01-01-1997', 'MM-DD-YYYY'),'J')
FROM DUAL;
TO_CHAR
--------
2450450
参照:
DUAL表については、「DUAL表からの選択」を参照してください。 
TIMESTAMPデータ型
TIMESTAMPデータ型は、DATEデータ型の拡張機能です。DATEデータ型の年、月および日に加えて、時、分および秒の値を格納します。このデータ型は、正確な時刻の値の格納に有効です。TIMESTAMPデータ型は、次のように指定します。
TIMESTAMP [(fractional_seconds_precision)] 
fractional_seconds_precisionには、オプションで、Oracleが格納する桁数を、SECOND日時フィールドの小数部まで指定します。このデータ型の列を作成する場合、0〜9の値を指定できます。デフォルトは6です。
参照:
文字データのTIMESTAMPデータへの変換については、「TO_TIMESTAMP」を参照してください。 
TIMESTAMP WITH TIME ZONEデータ型
TIMESTAMP WITH TIME ZONEは、タイムゾーン・オフセットを値に含むTIMESTAMPの変形です。タイムゾーン・オフセットは、ローカルの時刻とUTC(時および分)との差異です。このデータ型は複数の地域にまたがる日時情報の収集および評価に有効です。
TIMESTAMP WITH TIME ZONEデータ型は、次のように指定します。
TIMESTAMP [(fractional_seconds_precision)] WITH TIME ZONE
fractional_seconds_precisionには、オプションで、Oracleが格納する桁数を、SECOND日時フィールドの小数部まで指定します。このデータ型の列を作成する場合、0〜9の値を指定できます。デフォルトは6です。
参照:
Oracleのタイムゾーン・データの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
夏時間のサポートについては、「夏時間のサポート」および表2-19「XMLFormatオブジェクトの属性」を参照してください。
文字データのTIMESTAMP WITH TIME ZONEデータへの変換は、「TO_TIMESTAMP_TZ」を参照してください。
ERROR_ON_OVERLAP_TIMEセッション・パラメータについては、「ALTER SESSION」を参照してください。
TIMESTAMP WITH LOCAL TIME ZONEデータ型
TIMESTAMP WITH LOCAL TIME ZONEは、タイムゾーン・オフセットを値に含むTIMESTAMPのもう1つの変形です。これは、TIMESTAMP WITH TIME ZONEとは異なり、データベースに格納されるデータはデータベース・タイムゾーンに対して正規化され、タイムゾーン・オフセットは列データの一部として格納されません。ユーザーがデータを検索すると、Oracleはユーザーのローカル・セッション・タイムゾーンのデータを戻します。タイムゾーン・オフセットは、ローカルの時刻とUTC(時および分)との差異です。このデータ型は、2層アプリケーションでクライアント・システムのタイムゾーンの日時情報を表示する場合に有効です。
TIMESTAMP WITH LOCAL TIME ZONEデータ型は、次のように指定します。
TIMESTAMP [(fractional_seconds_precision)] WITH LOCAL TIME ZONE
fractional_seconds_precisionには、オプションで、Oracleが格納する桁数を、SECOND日時フィールドの小数部まで指定します。このデータ型の列を作成する場合、0〜9の値を指定できます。デフォルトは6です。
参照:
Oracleのタイムゾーン・データの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
データ型の使用例は、『Oracle Databaseアプリケーション開発者ガイド-基礎編』を参照してください。文字データのTIMESTAMP WITH LOCAL TIME ZONEデータへの変換は、「CAST」を参照してください。
INTERVAL YEAR TO MONTHデータ型
INTERVAL YEAR TO MONTHは、YEARおよびMONTH日時フィールドを使用して期間を格納します。このデータ型は、年および月の値のみが重要な場合に、2つの日時の値の正確な違いを表す場合に有効です。
INTERVAL YEAR TO MONTHは、次のように指定します。
INTERVAL YEAR [(year_precision)] TO MONTH
year_precisionは、YEAR日時フィールドの桁数です。year_precisionのデフォルト値は2です。
期間値をリテラルとして指定すると、高い柔軟性が得られます。期間値をリテラルとして指定する方法の詳細は、「期間リテラル」を参照してください。期間の使用例は、「日時および期間の例」を参照してください。
INTERVAL DAY TO SECONDデータ型
INTERVAL DAY TO SECONDは、日付、時、分および秒で期間を格納します。このデータ型は、2つの日時の値の正確な違いを表す場合に有効です。
このデータ型は、次のように指定します。
INTERVAL DAY [(day_precision)] 
TO SECOND [(fractional_seconds_precision)]
それぞれの意味は、次のとおりです。
day_precisionは、DAY日時フィールドの桁数です。有効範囲は0〜9です。デフォルトは2です。
fractional_seconds_precisionは、SECOND日時フィールドの小数部の桁数です。有効範囲は0〜9です。デフォルトは6です。
期間値をリテラルとして指定すると、高い柔軟性が得られます。期間値をリテラルとして指定する方法の詳細は、「期間リテラル」を参照してください。期間の使用例は、「日時および期間の例」を参照してください。
日時および期間の演算
日付(DATE)、タイムスタンプ(TIMESTAMP、TIMESTAMP WITH TIME ZONEおよびTIMESTAMP WITH LOCAL TIME ZONE)および期間(INTERVAL DAY TO SECONDおよびINTERVAL YEAR TO MONTH)データに対して、様々な演算処理を実行できます。Oracleは、次の規則に基づいて結果を計算します。
日付およびタイムスタンプ値の演算処理ではNUMBER定数を使用できますが、期間値では使用できません。Oracleは、タイムスタンプ値を内部的に日付値に変換し、日時の演算で使用されるNUMBER定数と期間式を日数として解析します。たとえば、SYSDATE+ 1は明日です。SYSDATE -7は1週間前です。SYSDATE + (10/1440)は10分後です。SYSDATEからemployeesサンプル表のhire_date列を引くと、各従業員が雇用されてから経過した日数が戻ります。日付値またはタイムスタンプ値の乗算や除算はできません。
Oracleは、BINARY_FLOATオペランドおよびBINARY_DOUBLEオペランドを暗黙的にNUMBERに変換します。
各DATE値には時刻コンポーネントが含まれるため、多くの場合、日付操作の結果には小数部が含まれます。この小数部は、日を単位として表されています。たとえば、1.5日は36時間です。小数部は、DATEデータの一般的な操作を行うOracle組込みファンクションによっても戻されます。たとえば、MONTHS_BETWEENファンクションは、2つの日付の間の月数を戻します。結果の小数部は、月(1か月は31日)を単位として表されます。
1つのオペランドがDATE値または数値である場合(タイムゾーンおよび小数部コンポーネントのいずれも含まない場合)、次のようになります。
Oracleは、他方のオペランドを暗黙的にDATEデータに変換します。(ただし、数値と期間を掛けて期間を戻す乗算を行う場合は除きます。)
他方のオペランドがタイムゾーン値を持つ場合、Oracleは戻り値でセッション・タイムゾーンを使用します。
他方のオペランドが小数部の値を持つ場合、その小数部の値は失われます。
DATEデータ型専用に設計された組込みファンクションにタイムスタンプ値、期間値または数値を渡すと、OracleはDATE値以外の値を暗黙的にDATE値に変換します。DATEへの暗黙的な変換を実行するファンクションの詳細は、「日時ファンクション」を参照してください。
Oracleは、すべてのタイムスタンプの演算をUTC時間で実行します。TIMESTAMP WITH LOCAL TIME ZONEでは、Oracleは、日時の値をデータベース・タイムゾーンからUTCに変換し、演算を実行した後にデータベース・タイムゾーンに変換しなおします。TIMESTAMP WITH TIME ZONEでは、日時の値は常にUTCであるため、変換は必要ありません。
表2-5に、日時の演算処理のマトリックスを示します。ダッシュはサポートされていない処理を表します。
表2-5    日時の演算のマトリックス 
オペランドおよび演算子 
DATE 
TIMESTAMP 
INTERVAL 
数値 
DATE 
- 
- 
- 
- 
+  
- 
- 
DATE 
DATE 
-  
DATE 
DATE 
DATE 
DATE 
*  
- 
- 
- 
- 
/  
- 
- 
- 
- 
TIMESTAMP 
- 
- 
- 
- 
+  
- 
- 
TIMESTAMP 
- 
-  
INTERVAL 
INTERVAL 
TIMESTAMP 
TIMESTAMP 
*  
- 
- 
- 
- 
/  
- 
- 
- 
- 
INTERVAL 
- 
- 
- 
- 
+  
DATE 
TIMESTAMP 
INTERVAL 
- 
-  
- 
- 
INTERVAL 
- 
*  
- 
- 
- 
INTERVAL 
/  
- 
- 
- 
INTERVAL 
数値 
- 
- 
- 
- 
+  
DATE 
DATE 
- 
指定なし 
-  
- 
- 
- 
指定なし 
*  
- 
- 
INTERVAL 
指定なし 
/  
- 
- 
- 
指定なし 
例
期間値の式を開始時間に追加できます。order_date列を持つサンプル表oe.ordersについて考えます。次の文は、order_date列の値に30日を加算します。
SELECT order_id, order_date + INTERVAL '30' DAY FROM orders;
夏時間のサポート
Oracleデータベースは、指定したタイムゾーン地域に、夏時間が適用されているかを自動的に判断し、それに応じてローカル時刻の値を戻します。日時の値は、境界を除いたすべての指定した地域において、夏時間が適用されているかをOracleが判断するために有効です。夏時間の開始または終了時に、境界が発生します。たとえば、米国の太平洋地域では、夏時間の開始時、時刻は午前2時から午前3時に変更されます。午前2時と午前3時の間の1時間は存在しません。夏時間の終了時、時刻は午前2時から午前1時に変更されます。午前1時と午前2時の間の1時間は繰り返されます。
このような境界を解決するために、OracleはTZRおよびTZD書式要素を使用します。詳細は、表2-19を参照してください。TZRは、日時の入力文字列でタイムゾーン地域を表します。たとえば、Australia/North、UTC、Singaporeなどです。TZDは、夏時間情報を含むタイムゾーン地域の略称書式です。たとえば、米国/太平洋標準時はPST、米国/太平洋夏時間はPDTなどです。TZRおよびTZD書式要素の値を表示するには、V$TIMEZONE_NAMES動的パフォーマンス・ビューのTZNAMEおよびTZABBREV列に問合せを実行してください。
夏時間機能には、タイムゾーン地域名が必要です。地域名は、2つのタイムゾーン・ファイルに格納されます。デフォルトのタイムゾーン・ファイルは、すべてのタイムゾーンを含む完全な(大きい)ファイルです。その他のタイムゾーン・ファイルは、パフォーマンスを最大にするために一般的なタイムゾーンのみを含む小さなファイルです。必要なタイムゾーンが小さなファイルに存在している場合に、パフォーマンスを最大にするには、環境変数ORA_TZFILEを使用して小さいファイルへのパスを指定する必要があります。環境変数ORA_TZFILEの設定方法の詳細は、『Oracle Database管理者ガイド』を参照してください。両方のファイルに含まれるすべてのタイムゾーン地域名のリストは、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
参照:
書式要素の詳細は、「日時書式モデル」を参照してください。また、「ERROR_ON_OVERLAP_TIME」セッション・パラメータの説明も参照してください。
Oracleのタイムゾーン・データの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
動的パフォーマンス・ビューの詳細は、『Oracle Databaseリファレンス』を参照してください。
日時および期間の例
次の例では、日時および期間データ型の宣言方法を示します。
CREATE TABLE time_table (
start_time      TIMESTAMP,
duration_1      INTERVAL DAY (6) TO SECOND (5),
duration_2      INTERVAL YEAR TO MONTH);
start_time列は、TIMESTAMP型です。TIMESTAMPの暗黙的な小数部の精度は6です。
duration_1列は、INTERVAL DAY TO SECOND型です。DAYフィールドの最大桁数は6です。また、小数部の最大桁数は5です(その他のすべての日時フィールドの最大桁数は2です)。
duration_2列は、INTERVAL YEAR TO MONTH型です。各フィールド(YEARおよびMONTH)の値の最大桁数は2です。
期間データ型には書式モデルはありません。そのため、これらの表示を調整するには、EXTRACTなどの文字ファンクションを結合させて要素を連結させる必要があります。たとえば、次の例では、hr.employeesとoe.orders表にそれぞれ問合せを行い、期間出力の書式を"yy-mm"から"yy years mm months"に、および"dd-hh"から"dddd days hh hours"
に変更します。    
SELECT last_name, EXTRACT(YEAR FROM (SYSDATE - hire_date) YEAR TO MONTH )
|| ' years '
|| EXTRACT(MONTH FROM (SYSDATE - hire_date) YEAR TO MONTH )
|| ' months'  "Interval"
FROM employees ;
LAST_NAME                 Interval
------------------------- --------------------
King                      17 years 11 months
Kochhar                   15 years 8 months
De Haan                   12 years 4 months
Hunold                    15 years 4 months
Ernst                     14 years 0 months
Austin                    7 years 11 months
Pataballa                 7 years 3 months
Lorentz                   6 years 3 months
Greenberg                 10 years 9 months
. . .
SELECT order_id,
EXTRACT(DAY FROM (SYSDATE - order_date) DAY TO SECOND )
|| ' days '
|| EXTRACT(HOUR FROM (SYSDATE - order_date) DAY TO SECOND )
|| ' hours' "Interval"
FROM orders;
ORDER_ID Interval
---------- --------------------
2458 2095 days 18 hours
2397 2000 days 17 hours
2454 2048 days 16 hours
2354 1762 days 16 hours
2358 1950 days 15 hours
2381 1823 days 13 hours
2440 2080 days 12 hours
2357 2680 days 11 hours
2394 1917 days 10 hours
2435 2078 days 10 hours
. . .
RAWデータ型とLONG RAWデータ型
RAWデータ型とLONG RAWデータ型のデータは、Oracleデータベースによって解析されません(異なるシステム間でデータを移動するときには変換されません)。これらのデータ型は、バイナリ・データまたはバイト列に使用されます。たとえば、LONG RAWは、図形、音声、文書、またはバイナリ・データの配列の格納に使用できますが、解析方法は用途によって異なります。
LONG RAW列をバイナリLOB(BLOB)へ変換することをお薦めします。LOB列は、LONG列ほど制限は多くありません。詳細は、「TO_LOB」を参照してください。
RAWは、VARCHAR2と同様に可変長データ型ですが、Oracle Net(ユーザー・セッションとインスタンスを接続します)およびインポート/エクスポート・ユーティリティは、RAWまたはLONG RAWデータの転送時に文字変換を行いません。これに対し、Oracle Netおよびインポート/エクスポートは、データベース・キャラクタ・セットとユーザー・セッションのキャラクタ・セット(ALTER SESSION文のNLS_LANGUAGEパラメータで設定します)が異なる場合に、CHAR、VARCHAR2およびLONGデータをこれら2つのキャラクタ・セット間で自動的に変換します。
RAWデータまたはLONG RAWデータとCHARデータ間で、データを自動的に変換するときに、バイナリ・データは16進数で表されます。1つの16進文字で4ビットのRAWデータを表します。たとえば、ビット列が11001011で表示される1バイトのRAWデータは、CBとして表示または入力されます。
ラージ・オブジェクト(LOB)・データ型
組込みLOBデータ型のBLOB、CLOB、NCLOB(内部ファイルに格納)およびBFILE(外部ファイルに格納)には、構造化されていない大きいデータ(text、image、video、spatial dataなど)を格納できます。BLOB、CLOBおよびNCLOBデータの最大サイズは、4GBから1を引いたバイト数にLOB記憶域のCHUNKパラメータの値を掛けた値です。データベースの表領域が標準のブロック・サイズで、LOB列を作成したときにLOB記憶域のCHUNKパラメータのデフォルト値を使用した場合には、前述の値は4GBから1を引いた値にデータベース・ブロック・サイズを掛けた値に等しくなります。BFILEデータの最大サイズは、232バイトから1を引いた値ですが、この最大サイズはオペレーティング・システムによって制限される場合があります。
表を作成するときに、LOB列またはLOBオブジェクト属性に、オプションで表に指定したものとは異なる表領域および記憶特性を指定できます。
LOB列には、インラインLOB値(データベース内)またはアウトラインLOB値(データベース外)を参照できるLOBロケータが含まれています。表からLOBを選択すると、実際にはLOBのロケータが戻され、LOB値全体は戻されません。LOBに対するDBMS_LOBパッケージとOracle Call Interface(OCI)の操作は、これらのロケータを介して行われます。
LOBは、LONG型およびLONG RAW型と似ていますが、次の点で異なります。
LOBは、オブジェクト型(ユーザー定義のデータ型)の属性に指定できます。
LOBロケータは、表の列に格納されます。実際のLOB値は、表の列に格納される場合と格納されない場合があります。BLOB、NCLOBおよびCLOBの値は、別々の表領域に格納されます。BFILEデータは、サーバー上の外部ファイルに格納されます。
LOB列にアクセスしたときに戻されるのはロケータです。
LOBの最大サイズは、4GBから1を引いたバイト数にデータベース・ブロック・サイズを掛けた値です。BFILEデータの最大サイズは、232バイトから1を引いた値ですが、この最大サイズはオペレーティング・システムによって制限される場合があります。
LOBでは、効果的かつランダムなピース単位のデータ・アクセスおよび操作が可能です。
1つの表内に2つ以上のLOB列を定義できます。
NCLOBの例外を除いて、1つのオブジェクトに1つ以上のLOB属性を定義できます。
LOBバインド変数を宣言できます。
LOB列とLOB属性を選択できます。
1つ以上のLOB列または1つ以上のLOB属性を持つオブジェクトが含まれている新しい行を挿入したり、既存の行を更新できます。更新操作では、内部LOB値をNULL、つまり空に設定したり、LOB全体をデータに置き換えられます。BFILEは、NULLに設定したり、別のファイルを指すように設定できます。
LOB行と列の交差部またはLOB属性を、別のLOB行と列の交差部またはLOB属性を使用して更新できます。
LOB列またはLOB属性が含まれている行を削除できます(これによってLOB値も削除されます)。BFILEの場合、実際のオペレーティング・システム・ファイルは削除されません。
INSERT文またはUPDATE文を発行するだけで、インラインLOB列(データベースに格納されているLOB列)またはLOB属性(データベースに格納されているオブジェクト型列の属性)の行にアクセスして移入することができます。
LOB列の制限事項:
LOB列には、次の制限事項があります。
LOB列は主キー列として指定できません。
Oracleデータベースでは、リモートLOBのサポートは制限されています。LOB列のcreate table as selectおよびinsert/update as selectは実行できます。
次に例を示します。
CREATE TABLE t AS SELECT * FROM table1@remote_site;
INSERT INTO t SELECT * FROM table1@remote_site;
UPDATE t SET lobcol = (SELECT lobcol FROM table1@remote_site);
INSERT INTO table1@remote_site SELECT * from local_table;
UPDATE table1@remote_site SET lobcol = (SELECT lobcol FROM local_table);
DELETE FROM table1@remote_site <WHERE clause involving non_lob_columns>
この例のように構成された文では、スタンドアロンLOB列のみがSELECT構文のリストで指定できます。
SQLファンクションおよびDBMS_LOB APIは、リモートLOB列での使用がサポートされていません。たとえば、次の文はサポートされています。
CREATE TABLE AS SELECT clob_col FROM tab@dbs2; 
ただし、次の文はサポートされていません。
CREATE TABLE AS SELECT DBMS_LOB.SUBSTR(clob_col) from tab@dbs2; 
さらに、リモートCLOBまたはBLOBに文字またはバイナリ・バッファを挿入でき、リモートCLOBまたはBLOBを文字またはバイナリ・バッファに選択できます。次にPL/SQLでの例を示します。
SELECT clobcol1, type1.blobattr INTO varchar_buf1, raw_buf2 FROM
table1@remote_site;
INSERT INTO table1@remotesite (clobcol1, type1.blobattr) VALUES varchar_buf1,
raw_buf2;
この構文のみが、リモート表でLOBを含む構文としてサポートされています。その他の使い方はサポートされていません。
クラスタには、キー列または非キー列としてLOBを含めることができません。
次のデータ構造は、一時インスタンスとしてのみサポートされます。これらのインスタンスをデータベース表に格納することはできません。LOB型の
VARRAY
LOB型を含む任意の型の
VARRAY(LOB属性を持つオブジェクト型など) 
問合せのORDER BY句、GROUP BY句または集計ファンクションでLOB列を指定できません。
SELECT ... DISTINCT文、SELECT ... UNIQUE文または結合でLOB列を指定できません。ただし、列のオブジェクト型にMAPまたはORDERファンクションが定義されている場合は、SELECT ... DISTINCT文、またはUNIONまたはMINUS集合演算子を使用する問合せで、オブジェクト型列のLOB属性を指定することはできます。
ANALYZE ... COMPUTE文またはANALYZE ... ESTIMATE文でLOB列を指定できません。
LOBセグメントの初期(INITIAL)エクステントは、3つ以上のデータベース・ブロックを含んでいる必要があります。
UPDATE DMLトリガーを作成する場合、LOB列はUPDATE OF句で指定できません。
LOB列は索引キーの一部として指定できません。ただし、ドメイン索引の索引タイプ指定では、LOB列を指定できます。また、Oracle Textでは、CLOB列に索引を定義できます。
INSERT ... AS SELECT操作では、4000バイトのデータまでLOB列および属性にバインドできます。
LONGとLOBの両方の列を持つ表では、1つのSQL文で両方に4000バイトより大きいデータをバインドすることはできません。ただし、いずれか片方にバインドすることは可能です。
注意:
DMLトリガーを指定した表で、OCI関数またはDBMS_LOBルーチンを使用してLOB列の値またはオブジェクト型列のLOB属性を変更する場合、データベースはDMLトリガーを起動しません。 
参照:
これらのインタフェースおよびLOBの詳細は、『Oracle Database PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス』および『Oracle Call Interfaceプログラマーズ・ガイド』を参照してください。
LONG列からLOB列への変換については、「ALTER TABLE」のmodify_col_propertiesおよび「TO_LOB」を参照してください。
BFILEデータ型 
BFILEデータ型を使用すると、Oracleデータベース外のファイル・システムに格納されているバイナリ・ファイルLOBにアクセスできます。BFILE列または属性には、サーバーのファイル・システム上のバイナリ・ファイルに対するポインタとして機能する、BFILEロケータが格納されます。ロケータには、ディレクトリ名とファイル名が保持されます。
BFILENAMEファンクションを使用すると、実表のデータに影響を与えずにBFILEのファイル名およびパスを変更できます。この組込みSQLファンクションの詳細は、「BFILENAME」を参照してください。
バイナリ・ファイルLOBは、トランザクションには関係なく、リカバリができません。ファイルの統合性と耐久性を提供しているのは基本にあるオペレーティング・システムです。BFILEデータの最大サイズは、232バイトから1を引いた値ですが、この最大サイズはオペレーティング・システムによって制限される場合があります。
データベース管理者は、外部ファイルが存在し、Oracleのプロセスがファイルに対するオペレーティング・システムの読取り権限を持っていることを確認する必要があります。
BFILEデータ型を使用すると、サイズが大きいバイナリ・ファイルの読取り専用のサポートが有効になります。この場合、ファイルを修正またはレプリケートすることはできません。Oracleでは、ファイル・データにアクセスするためのAPIが提供されています。ファイル・データにアクセスするために使用する主なインタフェースは、DBMS_LOBパッケージとOracle Call Interface(OCI)です。
参照:
LOBの詳細は、『Oracle Databaseアプリケーション開発者ガイド-ラージ・オブジェクト』および『Oracle Call Interfaceプログラマーズ・ガイド』を参照してください。また、「CREATE DIRECTORY」も参照してください。 
BLOBデータ型 
BLOBデータ型は、構造化されていないバイナリ・ラージ・オブジェクトを格納するために使用します。BLOBオブジェクトは、キャラクタ・セットのセマンティクスを持たないビットストリームとして考えることができます。BLOBオブジェクトには、4GBから1を引いたバイト数にLOB記憶域のCHUNKパラメータの値を掛けた値のサイズまでのバイナリ・データを格納できます。データベースの表領域が標準のブロック・サイズで、LOB列を作成したときにLOB記憶域のCHUNKパラメータのデフォルト値を使用した場合には、前述の値は4GBから1を引いた値にデータベース・ブロック・サイズを掛けた値に等しくなります。
BLOBオブジェクトでは、トランザクションが完全にサポートされます。SQL、DBMS_LOBパッケージまたはOracle Call Interface(OCI)を介して行った変更は、すべてトランザクションに反映されます。BLOB値の操作は、コミットおよびロールバックできます。ただし、1つのトランザクションのPL/SQLまたはOCI変数をBLOBロケータに保存し、そのロケータを別のトランザクションまたはセッションで使用することはできません。
CLOBデータ型 
CLOBデータ型は、シングルバイトおよびマルチバイト・キャラクタ・データを格納するために使用します。固定幅および可変幅のキャラクタ・セットがサポートされます。両方のキャラクタ・セットでデータベース・キャラクタ・セットを使用します。CLOBオブジェクトには、4GBから1を引いたバイト数にLOB記憶域のCHUNKパラメータの値を掛けた値のサイズまでの文字データを格納できます。データベースの表領域が標準のブロック・サイズで、LOB列を作成したときにLOB記憶域のCHUNKパラメータのデフォルト値を使用した場合には、前述の値は4GBから1を引いた値にデータベース・ブロック・サイズを掛けた値に等しくなります。
CLOBオブジェクトでは、トランザクションが完全にサポートされます。SQL、DBMS_LOBパッケージまたはOracle Call Interface(OCI)を介して行った変更は、すべてトランザクションに反映されます。CLOB値の操作は、コミットおよびロールバックできます。ただし、1つのトランザクションのPL/SQLまたはOCI変数をCLOBロケータに保存し、そのロケータを別のトランザクションまたはセッションで使用することはできません。
NCLOBデータ型 
NCLOBデータ型は、Unicodeデータを格納するために使用します。固定幅および可変幅のキャラクタ・セットがサポートされます。両方のキャラクタ・セットで各国語キャラクタ・セットを使用します。NCLOBオブジェクトには、4GBから1を引いたバイト数にLOB記憶域のCHUNKパラメータの値を掛けた値のサイズまでの文字テキスト・データを格納できます。データベースの表領域が標準のブロック・サイズで、LOB列を作成したときにLOB記憶域のCHUNKパラメータのデフォルト値を使用した場合には、上記の値は4GBから1を引いた値にデータベース・ブロック・サイズを掛けた値に等しくなります。
NCLOBオブジェクトでは、トランザクションが完全にサポートされます。SQL、DBMS_LOBパッケージまたはOCIを介して行った変更は、すべてトランザクションに反映されます。NCLOB値の操作は、コミットおよびロールバックできます。ただし、1つのトランザクションのPL/SQLまたはOCI変数をNCLOBロケータに保存し、そのロケータを別のトランザクションまたはセッションで使用することはできません。
参照:
Unicodeデータ型のサポートについては、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
ROWIDデータ型
データベース内の各行にはアドレスがあります。疑似列ROWIDを問い合せることによって、行のアドレスを調べることができます。この疑似列の値は、各行のアドレスを表す文字列で、文字列のデータ型はROWIDです。また、ROWIDデータ型を持つ実際の列を含む表やクラスタを作成することもできます。Oracleデータベースでは、このような列の値が有効なROWIDであることは保証されません。ROWID疑似列の詳細は、第3章「疑似列」を参照してください。
制限ROWID 
Oracle8以降、Oracle SQLでは、パーティション表、索引、および表領域関連のデータ・ブロック・アドレス(DBA)を明確かつ効果的にサポートするために、ROWIDの拡張形式が採用されています。
Oracle7以前のリリースでは、ROWIDは制限ROWIDと呼ばれます。制限ROWIDの書式は次のとおりです。
block.row.file
それぞれの意味は、次のとおりです。
blockは、行を含むデータ・ファイルのデータ・ブロックを識別する16進文字列です。この文字列の長さは、オペレーティング・システムによって異なります。
rowは、データ・ブロック内の行を識別する4桁の16進文字列です。ブロック内の最初の行は0になります。
fileは、行を含むデータ・ファイルを識別する16進文字列です。最初のデータ・ファイルは1になります。この文字列の長さは、オペレーティング・システムによって異なります。
拡張ROWID 
ユーザー列に格納される拡張ROWIDデータ型には、制限ROWIDのデータに加え、データ・オブジェクト番号が含まれます。データ・オブジェクト番号は、すべてのデータベース・セグメントに割り当てられる識別番号です。データ・オブジェクト番号は、データ・ディクショナリ・ビューのUSER_OBJECTS、DBA_OBJECTSおよびALL_OBJECTSから取り出すことができます。同じセグメントを共有するオブジェクト(たとえば、同じクラスタ内のクラスタ化された表など)には、同じオブジェクト番号が付けられます。
拡張ROWIDは、基本となる64という値で格納され、文字A〜Z、a〜z、0〜9、プラス記号(+)およびスラッシュ(/)を含めることができます。拡張ROWIDは直接利用できません。拡張ROWIDの内容を解析するには、提供されているパッケージDBMS_ROWIDを使用します。パッケージ・ファンクションを使用すると、制限ROWIDから直接利用できる情報、および拡張ROWIDに固有の情報が取り出され、提供されます。
参照:
DBMS_ROWIDパッケージで使用できるファンクション、およびこのファンクションの使用方法については、『Oracle Database PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス』を参照してください。 
互換性と移行 
制限形式のROWIDは、旧リリースとの互換性を保つために今回のリリースでもサポートされていますが、すべての表で拡張形式のROWIDが戻されます。
参照:
互換性と移行の問題については、『Oracle Databaseアップグレード・ガイド』を参照してください。 
UROWIDデータ型 
データベース内の各行にはアドレスがあります。ただし、物理アドレスまたは永続アドレス以外のアドレス、またはOracleデータベースが生成したものでないアドレスがある行を持つ表もあります。たとえば、索引構成表の行のアドレスは索引リーフに格納され、移動できます。外部キー表のROWID(たとえば、ゲートウェイを介してアクセスされるDB2)は、標準のOracle ROWIDではありません。
Oracleでは、ユニバーサルROWID(UROWID)を使用して索引構成表および外部キー表のアドレスを格納します。索引構成表には、論理UROWIDがあり、外部キー表には外部キーUROWIDがあります。いずれのタイプのUROWIDも、(ヒープ構成表の物理ROWIDのように)ROWID疑似列に格納されます。
Oracleは、表の主キーに基づいて論理ROWIDを作成します。論理ROWIDは、主キーが変更されないかぎり、変更されません。索引構成表のROWID疑似列はUROWIDデータ型です。この疑似列には、ヒープ構成のROWID疑似列と同様に(SELECT ... ROWID文を使用して)アクセスできます。索引構成表のROWIDを格納する場合、表にUROWID型の列を定義し、この列にROWID疑似列の値を取り込みます。
注意:
ヒープ構成表には物理ROWIDがあります。データ型がUROWIDの列をヒープ構成表に指定しないことをお薦めします。 
参照:
ユニバーサルROWIDの詳細は、『Oracle Database概要』を参照してください。データベースの行のアドレスの詳細は、「ROWIDデータ型」を参照してください。 
ANSI、DB2、SQL/DSのデータ型 
表とクラスタを作成するSQL文では、ANSIデータ型、およびIBM社の製品SQL/DSとDB2のデータ型も使用できます。Oracleでは、Oracleデータベースのデータ型の名前と異なるANSIまたはIBMのデータ型の名前を認識し、列のデータ型の名前として記録します。その後、次の表に示す変換に基づいて、Oracleのデータ型で列データを格納します。
表2-6    Oracleデータ型に変換されるANSIデータ型 
ANSI SQL Datatype 
Oracleデータ型 
CHARACTER(n) 
CHAR(n)  
CHAR(n)  
CHARACTER VARYING(n) 
CHAR VARYING(n)  
VARCHAR(n)  
NATIONAL CHARACTER(n) 
NATIONAL CHAR(n) 
NCHAR(n)  
NCHAR(n)  
NATIONAL CHARACTER VARYING(n) 
NATIONAL CHAR VARYING(n) 
NCHAR VARYING(n)  
NVARCHAR2(n)  
NUMERIC(p,s) 
DECIMAL(p,s)  (a) 
NUMBER(p,s)  
INTEGER 
INT 
SMALLINT  
NUMBER(38)  
FLOAT  (b)
DOUBLE PRECISION  (c)
REAL  (d) 
NUMBER  
注意:
NUMERICデータ型およびDECIMALデータ型では、固定小数点数のみを指定できます。これらのデータ型では、sのデフォルトは0です。
FLOATデータ型は、2進精度bを持つ浮動小数点数です。このデータ型のデフォルトの精度は、126桁の2進精度(38桁の10進精度)です。
DOUBLE PRECISIONデータ型は126桁の2進精度を持つ浮動小数点数です。
REALデータ型は63桁の2進精度(18桁の10進精度)を持つ浮動小数点数です。
表2-7    Oracleデータ型に変換されるSQL/DSとDB2のデータ型 
SQL/DSとDB2データ型 
Oracleデータ型 
CHARACTER(n) 
CHAR(n) 
VARCHAR(n) 
VARCHAR(n) 
LONG VARCHAR(n) 
LONG 
DECIMAL(p,s) (a) 
NUMBER(p,s) 
INTEGER
SMALLINT 
NUMBER(38) 
FLOAT (b) 
NUMBER 
注意:
DECIMALデータ型では、固定小数点数のみを指定できます。このデータ型では、sのデフォルトは0です。
FLOATデータ型はbの2進精度を持つ浮動小数点数です。このデータ型のデフォルト精度は126桁の2進精度(38桁の10進精度)です。
次のSQL/DSとDB2のデータ型には、対応するOracleデータ型がありません。次のデータ型を持つ列は定義しないでください。
GRAPHIC
LONG VARGRAPHIC
VARGRAPHIC
TIME
データ型がTIMEであるデータは、Oracleの日時データとしても表現できます。
参照:
このマニュアルのデータ型の説明を参照してください。 
ユーザー定義型
ユーザー定義のデータ型は、Oracle組込みデータ型とその他のユーザー定義のデータ型を、アプリケーション内のデータの構造と動作をモデル化するオブジェクト型の構築ブロックとして使用します。次の項で、ユーザー定義型の様々なカテゴリを説明します。
参照:
Oracle組込みデータ型の詳細は、『Oracle Database概要』を参照してください。
ユーザー定義型の作成方法については、「CREATE TYPE」および「CREATE TYPE BODY」を参照してください。
ユーザー定義型の使用方法については、『Oracle Databaseアプリケーション開発者ガイド-基礎編』を参照してください。
オブジェクト型 
オブジェクト型とは、実社会エンティティ(たとえば、発注書など)を抽象化し、アプリケーション・プログラムで処理できるようにしたものです。1つのオブジェクト型は、次の3種類のコンポーネントを持つスキーマ・オブジェクトです。
名前 - スキーマ内でオブジェクト型を一意に識別するためのものです。
属性 - 組込み型またはその他のユーザー定義型です。属性は、実社会エンティティの構造をモデル化します。
メソッド - PL/SQLで記述され、データベースに格納されるファンクションまたはプロシージャ、あるいはCやJavaなどの言語で記述され、外部に格納されるファンクションまたはプロシージャのことです。メソッドは、アプリケーションが実社会エンティティに対して実行できる操作を実装します。
REFデータ型 
オブジェクト識別子(キーワードOIDで表される)を使用することによって、オブジェクトを一意に識別し、他のオブジェクトまたはリレーショナル表からそのオブジェクトを参照できます。REFと呼ばれるデータ型のカテゴリが、そのような参照を表します。REFデータ型は、オブジェクト識別子のコンテナです。REF値は、オブジェクトへのポインタとなります。
REF値が、存在しないオブジェクトを指している場合、そのREFはDANGLING(参照先がない)状態であるといいます。DANGLING状態のREFは、NULLであるREFと異なります。REFがDANGLING状態であるかどうかを確認するには、条件IS [NOT] DANGLINGを使用します。たとえば、列型がcustomer_typ(属性cust_emailを持つ)を指しているREFであるcustomer_ref列があるとします。このcustomer_ref列を含むオブジェクト・ビューoc_orders(サンプル・スキーマoe内)は、次のように指定します。
SELECT o.customer_ref.cust_email
FROM oc_orders o 
WHERE o.customer_ref IS NOT DANGLING;
VARRAY 
配列とは、順序付けられたデータ要素の集合です。ある特定の配列のすべての要素は、同じデータ型です。各要素には索引があります。索引は、各要素の配列内での位置に対応する番号です。
配列内の要素数は、その配列のサイズを表します。Oracleの配列は可変サイズであるため、VARRAYと呼ばれます。VARRAYを宣言する場合は、最大サイズを指定する必要があります。
VARRAY宣言時に領域は割り当てられません。VARRAYでは、次のような型を定義します。
リレーショナル表の列のデータ型
オブジェクト型属性
PL/SQLの変数、パラメータ、またはファンクションの戻り型
通常、Oracleは、1つの配列オブジェクトをインライン形式でその行の他のデータと同じ表領域に、またはアウトライン形式でLOBに格納します。この形式は配列オブジェクトのサイズによって決まります。ただし、VARRAYに個別の記憶特性を指定する場合、Oracleはこれをサイズに関係なくアウトライン形式で格納します。VARRAYの格納方法の詳細は、「CREATE TABLE」の「varray_col_properties」を参照してください。
ネストした表 
ネストした表は、順序付けられていない要素の集合を表現します。その要素は、組込み型またはユーザー定義型です。ネストした表は、単一列の表として表示できます。ネストした表がオブジェクト型の場合、オブジェクト型のそれぞれの属性を表す複数列の表としても表示できます。
ネストした表の定義では、領域は割り当てられません。ネストした表では、次のものを宣言するための型を定義します。
リレーショナル表の列のデータ型
オブジェクト型属性
PL/SQLの変数、パラメータ、またはファンクションの戻り型
ネストした表が、リレーショナル表内の列型として使用される場合、またはオブジェクト表の基礎となるオブジェクト型の属性として使用される場合、Oracleは、ネストした表のすべてのデータを単一表に格納し、その単一表を、ネストした表を囲むリレーショナル表またはオブジェクト表に対応付けます。
Oracleが提供する型 
Oracleは、組込み型またはANSIがサポートする型が不十分な場合に、新しい型を定義するためのSQLに基づくインタフェースを提供します。これらの型の動作は、C/C++、JavaまたはPL/SQLで実装されます。Oracleデータベースは、入出力、異機種間でのクライアント側の新しいデータ型へのアクセス、およびアプリケーションとデータベース間のデータ転送のための最適化で必要な下位レベルのインフラストラクチャ・サービスを自動的に提供します。
これらのインタフェースは、ユーザー定義(またはオブジェクト)型の作成に使用できます。また、Oracleが有効なデータ型を作成するときに使用します。このようなデータ型のいくつかはサーバーで提供され、横方向の幅広いアプリケーション領域(任意型など)および縦方向の固有アプリケーション領域(空間型など)の両方に役立ちます。
Oracleが提供する型については、次の項で説明します。また、それらの型の実装および使用に関するドキュメントの参照先も示します。
任意型
XML型
空間型
メディア型
任意型 
任意型は、実際の型が不明なプロシージャ・パラメータおよび表の列の柔軟性が高いモデリングを提供します。これらのデータ型によって、型の記述、データ・インスタンスおよびその他のSQL型の一連のデータ・インスタンスを動的にカプセル化し、アクセスできます。これらの型を構成およびアクセスするには、OCIおよびPL/SQLインタフェースを使用します。
ANYTYPE
この型には、任意の名前のあるSQL型または名前のない一時型の型の記述を含めることができます。
ANYDATA
この型には、指定した型のインスタンスをデータおよび型の記述とともに含めることができます。ANYDATAは、表の列のデータ型として使用できます。また、このデータ型によって、単一列に異機種間の値を格納できます。ユーザー定義型と同様に、SQL組込み型の値も格納できます。
ANYDATASET
この型には、指定した型の記述およびその型の一連のデータ・インスタンスを含めることができます。ANYDATASETは、柔軟性が必要なプロシージャ・パラメータのデータ型として使用できます。ユーザー定義型と同様に、SQL組込み型のデータ・インスタンスの値も格納できます。
参照:
ANYTYPE、ANYDATAおよびANYDATASET型の詳細は、『Oracle Database PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス』を参照してください。 
XML型
eXtensible Markup Language(XML)は、World Wide Web Consortium(W3C)によって開発された、構造化されたデータおよび構造化されていないデータをWebで表示するための標準書式です。Universal Resource Identifiers(URI)は、WebページなどのWeb上のリソースを識別します。Oracleは、データベース自体に格納されるデータにアクセスするためにDBUriRef型と呼ばれるURIのクラスと同様に、XMLおよびURIデータを処理するための型を提供します。また、データベースから外部および内部URIに格納およびアクセスする新しい型のセットを提供します。
XMLType
Oracleが提供するこの型は、データベースでのXMLデータの格納および問合せに使用します。XMLTypeは、XPath式を使用したXMLデータへのアクセス、抽出および問合せに使用するメンバー・ファンクションを持ちます。XPathは、XML文書をトラバースするためにW3Cによって開発された別の規格です。OracleのXMLTypeファンクションは、W3Cの多数のXPath式をサポートします。また、Oracleは、既存のリレーショナルまたはオブジェクト・リレーショナル・データからXMLType値を作成するためのSQLファンクションおよびPL/SQLパッケージのセットを提供します。
XMLTypeはシステム定義型であるため、ファンクションの引数として、あるいは表またはビューの列のデータ型として使用できます。また、XMLTypeの表およびビューも作成できます。表にXMLType列を作成する場合は、XMLデータをCLOB列またはオブジェクトと関連付けて格納するように選択できます。
また、スキーマを登録し(DBMS_XMLSCHEMAパッケージを使用)、登録したスキーマに適合する表または列を作成できます。この場合、デフォルトでは、XMLデータは基礎となるオブジェクト・リレーショナル列に格納されますが、スキーマ・ベースのデータであっても、CLOB列に格納するように指定できます。
XMLType列の問合せおよびDMLは、格納メカニズムとは関係なく、同様に動作します。
参照:
XMLType列の使用方法については、『Oracle XML DB開発者ガイド』を参照してください。 
URIデータ型
Oracleは、継承階層で関連するURI型のファミリ(URIType、DBUriType、XDBUriTypeおよびHTTPUriType)を提供します。URITypeはオブジェクト型であり、その他はURITypeのサブタイプです。URITypeはスーパータイプであるため、この型の列を作成し、DBUriTypeまたはHTTPUriType型のインスタンスをこの列に格納できます。
HTTPUriType
HTTPUriTypeを使用すると、外部のWebページまたはファイルのURLを格納できます。Oracleは、Hypertext Transfer Protocol(HTTP)を使用して、これらのファイルにアクセスします。
XDBUriType
XDBUriTypeを使用すると、表の任意のURIType列に埋込み可能なURIとして、ドキュメントをXMLデータベース階層に展開できます。XDBUriTypeは、URLで構成されています。URLは、参照先のXML文書の階層名と、XPath構文を表すオプションのフラグメントで構成されています。フラグメントとURL部分は、シャープ記号(#)で区切ります。次に、XDBUriTypeの例を示します。
/home/oe/doc1.xml
/home/oe/doc1.xml#/orders/order_item
DBUriType
DBUriTypeを使用すると、データベース内のデータを参照するDBUriRef値を格納できます。この場合、データベースの内部または外部に格納されたデータを参照し、常にデータにアクセスできます。
DBUriRef値は、データベース内のデータを参照するために、XPathのような表現を使用します。データベースをXMLツリーに想定すると、表、行および列がXML文書の要素です。たとえば、サンプルの人材のユーザーhrは次のようにXMLツリーで表します。
<HR> 
<EMPLOYEES> 
<ROW> 
<EMPLOYEE_ID>205</EMPLOYEE_ID> 
<LAST_NAME>Higgins</LAST_NAME> 
<SALARY>12000</SALARY> 
.. <!-- other columns --> 
</ROW> 
... <!-- other rows --> 
</EMPLOYEES> 
<!-- other tables..--> 
</HR> 
<!-- other user schemas on which you have some privilege on..--> 
DBUriRefは、この仮想XML文書のXPath式です。したがって、従業員番号205の従業員のSALARY値をEMPLOYEES表で参照するには、DBUriRefを次のように記述します。
/HR/EMPLOYEES/ROW[EMPLOYEE_ID=205]/SALARY 
このモデルを使用すると、CLOB列またはその他の列に格納されたデータを参照し、それらのデータを外部のURLとして外部の世界へ公開できます。
URIFactoryパッケージ
Oracleは、URITypeの様々なサブタイプのインスタンスを作成し、戻すことができるURIFactoryパッケージも提供します。このパッケージは、URL文字列を分析し、URLの種類(HTTP、DBUriなど)を識別し、サブタイプのインスタンスを作成します。DBUriインスタンスを作成する場合は、URLの先頭に接頭辞/oradbを付ける必要があります。たとえば、URIFactory.getURI('/oradb/HR/EMPLOYEES')によってDBUriTypeインスタンスが作成され、URIFactory.getUri('/sys/schema')によってXDBUriTypeインスタンスが作成されます。
参照:
オブジェクト型および型の継承については、『Oracle Databaseアプリケーション開発者ガイド-オブジェクト・リレーショナル機能』を参照してください。
提供される型およびその実装については、『Oracle XML Developer's Kitプログラマーズ・ガイド』を参照してください。
Oracle Advanced QueuingでのXMLTypeの使用については、『Oracle Streamsアドバンスト・キューイング・ユーザーズ・ガイドおよびリファレンス』を参照してください。
空間型
Oracle Spatialは、位置情報アプリケーション、地理情報システム(GIS)・アプリケーションおよびジオイメージング・アプリケーションのユーザーが、空間データ管理をより簡単かつ自然に行えるように設計されています。一度空間データをOracleデータベースに格納すると、そのデータの操作や取得を簡単に行うことができ、データベースに格納された他のすべてのデータと関連付けることもできます。次のデータ型は、Oracle Spatialをインストールしている場合にのみ使用できます。
SDO_GEOMETRY
空間オブジェクトのジオメトリの記述は、ユーザー定義の表の単一行およびオブジェクト型SDO_GEOMETRYの単一列に格納されます。SDO_GEOMETRY型の列を含むすべての表は、表に対して一意の主キーを定義する別の列を持つ必要があります。このような表は、ジオメトリ表と呼ばれる場合があります。
SDO_GEOMETRYオブジェクト型の定義は、次のとおりです。
CREATE TYPE SDO_GEOMETRY AS OBJECT (
sgo_gtype        NUMBER, 
sdo_srid         NUMBER,
sdo_point        SDO_POINT_TYPE,
sdo_elem_info    SDO_ELEM_INFO_ARRAY,
sdo_ordinates    SDO_ORDINATE_ARRAY);
SDO_TOPO_GEOMETRY 
この型はトポロジ・ジオメトリを記述します。この記述は、ユーザー定義の表の単一行およびオブジェクト型SDO_GEOMETRYの単一列に格納されます。
SDO_TOPO_GEOMETRYオブジェクト型の定義は、次のとおりです。
CREATE TYPE SDO_TOPO_GEOMETRY AS OBJECT (
tg_type          NUMBER, 
tg_id            NUMBER,
tg_layer_id      NUMBER,
topology_id      NUMBER);
SDO_GEORASTER
GeoRasterオブジェクト・リレーショナル・モデルでは、ラスター・グリッドまたはイメージ・オブジェクトは、ユーザー定義の表の単一行およびオブジェクト型SDO_GEORASTERの単一列に格納されます。このような表は、GeoRaster表と呼ばれます。
SDO_GEORASTERオブジェクト型の定義は、次のとおりです。
CREATE TYPE SDO_GEORASTER AS OBJECT (
rasterType      NUMBER,
spatialExtent   SDO_GEOMETRY,
rasterDataTable VARCHAR2(32),
rasterID        NUMBER,
metadata        XMLType);
参照:
空間データ型の完全な実装および使用のガイドラインは、『Oracle Spatialユーザーズ・ガイドおよびリファレンス』、『Oracle Spatialトポロジおよびネットワーク・データ・モデル』および『Oracle Spatial GeoRaster』を参照してください。 
メディア型 
Oracle interMediaは、マルチメディア・データを記述するために、JavaまたはC++クラスに類似したオブジェクト型を使用します。これらのオブジェクト型のインスタンスは、メタデータおよびメディア・データを含む属性とメソッドで構成されます。interMediaのデータ型は、ORDSYSスキーマで作成されます。パブリック・シノニムがすべてのデータ型に対して存在するため、スキーマ名を指定せずにアクセスできます。
参照:
これらの型の実装および使用のガイドラインは、『Oracle interMediaリファレンス』を参照してください。 
ORDAudio
ORDAUDIOオブジェクト型は、オーディオ・データの格納および管理をサポートします。
ORDImage
ORDIMAGEオブジェクト型は、イメージ・データの格納および管理をサポートします。
ORDImageSignature
ORDImageSignatureオブジェクト型は、イメージ・データの色、テクスチャ、および形の情報の簡潔な表現をサポートします。
ORDVideo
ORDVIDEOオブジェクト型は、ビデオ・データの格納および管理をサポートします。
ORDDoc
ORDDOCオブジェクト型は、オーディオ、イメージ、ビデオ・データなどすべての種類のメディア・データの格納および管理をサポートします。この型は、すべてのメディアを単一列に格納する場合に使用します。
次のデータ型は、ISO-IEC 13249-5 Still Image規格(一般にSQL/MM StillImageと呼ばれる)に準拠しています。
SI_StillImage
SI_StillImageオブジェクト型は、高さ、幅、フォーマットなどの固有のイメージ特性を持つデジタル・イメージを表します。
SI_Color
SI_Colorオブジェクト型は、色の値をカプセル化します。
SI_AverageColor
SI_AverageColorオブジェクト型は、イメージの平均の色によってそのイメージを特徴付けます。
SI_ColorHistogram
SI_ColorHistogramオブジェクト型は、RAWイメージのサンプルによって表示される色の相対頻度によって、イメージを特徴付けます。
SI_PositionalColor
イメージをn×m個の四角形に分割すると考えた場合、SI_PositionalColorオブジェクト型は、その四角形の最も重要なn×m個の色によってイメージを特徴付けます。
SI_Texture
SI_Textureオブジェクト型は、繰り返し出現している項目のサイズ(粗さ)、輝度の変化(コントラスト)および主な方向(方向性)によってイメージを特徴付けます。
SI_FeatureList
SI_FeatureListオブジェクト型は、前述したオブジェクト型(SI_AverageColor、SI_ColorHistogram、SI_PositionalColorおよびSI_Texture)が表すイメージの特徴のうち最大4つの特徴を含むリストです。各特徴は、重み付けされます。
Expression Filter型
Oracle Expression Filterを使用すると、アプリケーション開発者は、ユーザーの目的のデータを表す条件式を管理および評価できます。Expression Filterには、次のデータ型が含まれます。
Expression
Expression Filterは、Expressionと呼ばれる仮想データ型を使用して、条件式をデータベース表のデータとして管理および評価します。Expression Filterでは、VARCHAR2列に属性セットを割り当てることで、この列からExpressionデータ型の列を作成します。この割当てによって、列に格納された式の妥当性を確認するデータ制約が有効になります。
Expressionデータ型でEVALUATE演算子を使用して条件を定義すると、列に格納された式をデータに対して評価できます。Enterprise Editionを使用している場合は、Expressionデータ型の列にExpression Filter索引を定義して、EVALUATE演算子によって問合せを処理することもできます。
参照:
Expression Filterの詳細は、『Oracle Databaseアプリケーション開発者ガイド - Rules ManagerおよびExpression Filter』を参照してください。 
データ型の比較規則 
ここでは、Oracleデータベースが各データ型の値を比較する方法について説明します。
数値 
大きい値は小さい値よりも大きいとみなされます。すべての負の数は、0(ゼロ)およびすべての正の数より小さいとみなされます。したがって、-1は100より小さく、-100は-1より小さいとみなされます。
浮動小数点値NaN(非数値)は、その他の数値よりも大きく、NaNとは等しいとみなされます。
参照:
比較セマンティクスの詳細は、「数値の優先順位」および「浮動小数点数」を参照してください。 
日付値 
後の日付は前の日付よりも大きいとみなされます。たとえば、29-MAR-1997(1997年3月29日)に相当する日付は05-JAN-1998(1998年1月5日)に相当する日付よりも小さく、05-JAN-1998 1:35pm(1998年1月5日午後1時35分)に相当する日付は05-JAN-1998 10:09am(1998年1月5日午前10時9分)に相当する日付よりも大きいとみなされます。
文字値 
文字値は、次のいずれかの比較セマンティクスを使用して比較されます。
空白埋め比較セマンティクス
非空白埋め比較セマンティクス
ここでは、これらの比較セマンティクスについて説明します。
空白埋め比較セマンティクス
2つの値の長さが異なる場合、Oracleはまず短い方の値の最後に空白を追加して、2つの値が同じ長さになるようにします。次に、その2つの値を、最初に異なる文字まで1文字ずつ比較します。最初に異なる文字の位置で、大きい方の文字を持つ値の方が大きいとみなされます。2つの値に異なる文字がない場合、その2つの値は等しいとみなされます。この規則では、2つの値の後続空白数のみが異なる場合、その2つの値は等しいとみなされます。Oracleでは、比較する両方の値が、CHARデータ型、NCHARデータ型、テキスト・リテラルのいずれかの式の場合、またはUSERファンクションの戻り値の場合のみ空白埋め比較セマンティクスを使用します。
非空白埋め比較セマンティクス
Oracleは、2つの値を、最初に異なる文字まで1文字ずつ比較します。最初に異なる文字の位置で、大きい方の文字を持つ値の方が大きいとみなされます。長さが異なる2つの値を短い方の値の最後まで比較して、すべて同じ文字だった場合、長い方の値が大きいとみなされます。同じ長さの2つの値に異なる文字がない場合、その2つの値は等しいとみなされます。Oracleでは、比較する片方または両方の値がVARCHAR2データ型またはNVARCHAR2データ型の場合、非空白埋め比較セマンティクスを使用します。
これらの異なる比較セマンティクスを使用して2つの文字値を比較した場合、その結果が異なることもあります。次の表に、それぞれの比較セマンティクスを使用して5組の文字を比較した結果を示します。通常、空白埋め比較と非空白埋め比較の結果は同じです。表に示されている最後の比較では、空白埋め比較と非空白埋め比較の違いが明確になっています。
空白埋め比較 
非空白埋め比較 
'ac' > 'ab' 
'ac' > 'ab' 
'ab' > 'a  ' 
'ab' > 'a ' 
'ab' > 'a'  
'ab' > 'a'  
'ab' = 'ab' 
'ab' = 'ab' 
'a    ' = 'a'  
'a    ' > 'a'  
単一文字 
Oracleは、データベース・キャラクタ・セットで指定された数値に従って各文字を比較します。第1の文字の数値が第2の文字の数値よりも大きい場合、第1の文字は第2の文字よりも大きいとみなされます。Oracleは、空白はどの文字よりも小さいとみなします。これは、ほぼすべてのキャラクタ・セットでいえることです。
次に、一般的なキャラクタ・セットを示します。
7ビットASCII(情報交換用米国標準コード)
EBCDICコード(拡張2進化10進コード)
ISO 8859/1(国際標準化機構)
JEUC日本語拡張UNIX
ASCIIとEBCDICのキャラクタ・セットの一部を表2-8と表2-9に示します。大文字と小文字は同じではありません。キャラクタ・セットの照合順番は、特定の言語の言語順序と一致しない場合があります。
表2-8    ASCIIキャラクタ・セット 
記号 
10進値 
記号 
10進値 
空白 
32 
; 
59 
! 
33 
< 
60 
" 
34 
= 
61 
# 
35 
> 
62 
$ 
36 
? 
63 
% 
37 
@ 
64 
& 
38 
A-Z 
65-90 
' 
39 
[ 
91 
( 
40 
\ 
92 
) 
41 
] 
93 
* 
42 
^ 
94 
+ 
43 
_ 
95 
, 
44 
' 
96 
- 
45 
a-z 
97-122 
. 
46 
{ 
123 
/ 
47 
| 
124 
0-9 
48-57 
} 
125 
: 
58 
~ 
126 
表2-9    EBCDICキャラクタ・セット 
記号 
10進値 
記号 
10進値 
空白 
64 
% 
108 
¢ 
74 
_ 
109 
. 
75 
> 
110 
< 
76 
? 
111 
( 
77 
: 
122 
+ 
78 
# 
123 
| 
79 
@ 
124 
& 
80 
' 
125 
! 
90 
= 
126 
$ 
91 
" 
127 
* 
92 
a-i 
129-137 
) 
93 
j-r 
145-153 
; 
94 
s-z 
162-169 
ÿ 
95 
A-I 
193-201 
- 
96 
J-R 
209-217 
/ 
97 
S-Z 
226-233 
オブジェクト値 
オブジェクト値は、MAPとORDERの2つの比較ファンクションのいずれかを使用して比較されます。どちらのファンクションでもオブジェクト型インスタンスは比較されますが、両者は別のものです。これらのファンクションは、他のオブジェクト型と比較するオブジェクト型の一部として指定される必要があります。
参照:
MAPメソッドとORDERメソッド、およびこれらのメソッドが戻す値の詳細は、「CREATE TYPE」を参照してください。 
VARRAYとネストした表 
ネストした表の比較の詳細は、「比較条件」を参照してください。
データ型の優先順位
Oracleでは、データ型の優先順位によって、暗黙的にデータ型を変換するかどうかを判断します(次の項を参照)。Oracleデータ型の優先順位は、次のとおりです。
日時および期間データ型
BINARY_DOUBLE
BINARY_FLOAT
NUMBER
文字データ型
その他のすべての組込みデータ型
データ変換 
一般に、式には異なるデータ型の値を含めることができません。たとえば、式では10に5を掛けた値に'JAMES'を加えることはできません。ただし、Oracleでは値をあるデータ型から別のデータ型へ変換する場合の、暗黙的な変換と明示的な変換をサポートしています。
暗黙的なデータ変換と明示的なデータ変換 
次の理由から、暗黙的な変換または自動変換ではなく、明示的な変換を指定することをお薦めします。
明示的なデータ型変換ファンクションを使用すると、SQL文がわかりやすくなります。
暗黙的なデータ型変換(特に列値のデータ型が定数に変換される場合)は、パフォーマンスに悪影響を及ぼす可能性があります。
暗黙的な変換はその変換が行われるコンテキストに依存し、どんな場合でも同様に機能するとはかぎりません。たとえば、日時値からVARCHAR2型へ値を暗黙的に変換すると、NLS_DATE_FORMATパラメータに指定されている値によっては、予期しない年が戻される場合があります。
暗黙的な変換のアルゴリズムは、ソフトウェア・リリースやOracle製品の変更によって変更されることがあります。明示的な変換を指定しておくと、その動作は将来的にも確実になります。
暗黙的なデータ変換 
あるデータ型から別のデータ型への変換が意味を持つ場合、Oracleデータベースは値を自動的に変換します。文字データ型への暗黙的な変換はこれらのルールに従います。
表2-10に、Oracleの暗黙的な変換のマトリックスについて示します。この表は、変換の方向または変換されるコンテキストにかかわらず、すべての可能な変換を示します。詳細は、表の後の説明を参照してください。
表2-10    暗黙的な型変換のマトリックス 
CHAR 
VARCHAR2 
NCHAR 
NVARCHAR2 
DATE 
DATETIME/
INTERVAL 
NUMBER 
BINARY_FLOAT 
BINARY_DOUBLE 
LONG 
RAW 
ROWID 
CLOB 
BLOB 
NCLOB 
CHAR 
-- 
X 
X 
X 
X 
X 
X 
X 
X 
X 
X 
-- 
X 
X 
X 
VARCHAR2 
X 
-- 
X 
X 
X 
X 
X 
X 
X 
X 
X 
X 
X 
-- 
X 
NCHAR 
X 
X 
-- 
X 
X 
X 
X 
X 
X 
X 
X 
X 
X 
-- 
X 
NVARCHAR2 
X 
X 
X 
-- 
X 
X 
X 
X 
X 
X 
X 
X 
X 
-- 
X 
DATE 
X 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
DATETIME/ INTERVAL 
X 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
X 
-- 
-- 
-- 
-- 
-- 
NUMBER 
X 
X 
X 
X 
-- 
-- 
-- 
X 
X 
-- 
-- 
-- 
-- 
-- 
-- 
BINARY_FLOAT 
X 
X 
X 
X 
-- 
-- 
X 
-- 
X 
-- 
-- 
-- 
-- 
-- 
-- 
BINARY_DOUBLE 
X 
X 
X 
X 
-- 
-- 
X 
X 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
LONG 
X 
X 
X 
X 
-- 
X 
-- 
-- 
-- 
-- 
X 
-- 
X 
-- 
X 
RAW 
X 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
X 
-- 
-- 
-- 
X 
-- 
ROWID 
-- 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
CLOB 
X 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
X 
-- 
-- 
-- 
-- 
X 
BLOB 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
X 
-- 
-- 
-- 
-- 
NCLOB 
X 
X 
X 
X 
-- 
-- 
-- 
-- 
-- 
X 
-- 
-- 
X 
-- 
-- 
次に示す規則に従って、Oracleデータベースは、暗黙的なデータ型変換を実行する方向を確立します。
INSERTおよびUPDATE操作中に、Oracleは変更する列のデータ型に値を変換します。
SELECT FROM操作中に、Oracleは列からターゲット変数の型にデータを変換します。
数値と文字値を比較する場合、Oracleは文字データを数値に変換します。
文字値またはNUMBERの値と浮動小数点数の値の間では、変換が正確に行われない場合があります。これは、文字型およびNUMBERでは10進精度で数値が示されるのに対し、浮動小数点数では2進精度が使用されているためです。
CLOB値をVARCHAR2などの文字データ型に変換する場合、またはBLOBをRAWデータに変換する場合、変換するデータがターゲットのデータ型より大きいと、データベースはエラーを戻します。
BINARY_FLOATからBINARY_DOUBLEへの変換は正確に行われます。
BINARY_DOUBLEの値がBINARY_FLOATでサポートされている精度のビット数よりも多いビット数を使用している場合、BINARY_DOUBLEからBINARY_FLOATへの変換は正確に行われません。
DATEの値と文字の値を比較する場合、Oracleは文字データをDATEに変換します。
SQLファンクションまたは演算子に不当なデータ型の引数を指定して使用する場合、Oracleはその引数を正当なデータ型に変換します。
代入を実行する場合、Oracleは等号(=)の右側の値を左側の代入ターゲットのデータ型に変換します。
連結中に、Oracleは非文字データ型をCHARまたはNCHARに変換します。
文字データ型と非文字データ型に対する演算処理および比較中に、Oracleはすべての文字データ型を数値、日付またはROWIDのいずれかの適切なデータ型に変換します。CHAR/VARCHAR2とNCHAR/NVARCHAR2の演算処理では、OracleはNUMBERに変換します。
CHARとVARCHAR2、NCHARとNVARCHAR2の比較では、異なるキャラクタ・セットが必要な場合があります。このような場合のデフォルトの変換の方向は、データベース・キャラクタ・セットから各国語キャラクタ・セットです。表2-11に、異なるキャラクタ・タイプ間での暗黙的な変換の方向を示します。
ほとんどのSQL文字ファンクションは、CLOBをパラメータとして指定できます。また、OracleはCLOBと文字型間で暗黙的な変換を実行します。このため、CLOBを使用できないファンクションは、暗黙的な変換を使用してCLOBを受け入れます。このような場合、Oracleはファンクションが起動される前にCLOBをCHARまたはVARCHAR2に変換します。CLOBが4000バイトより大きい場合、Oracleは最初の4000バイトのみをCHARに変換します。
表2-11    異なるキャラクタ・タイプの変換方向 
CHARへ 
VARCHAR2へ 
NCHARへ 
NVARCHAR2へ 
CHARから 
-- 
VARCHAR2 
NCHAR 
NVARCHAR2 
VARCHAR2から 
VARCHAR2 
-- 
NVARCHAR2 
NVARCHAR2 
NCHARから 
NCHAR 
NCHAR 
-- 
NVARCHAR2 
NVARCHAR2から 
NVARCHAR2 
NVARCHAR2 
NVARCHAR2 
-- 
コレクションなどのユーザー定義型は暗黙的に変換できないため、CAST ... MULTISETを使用して明示的に変換する必要があります。
暗黙的なデータ変換の例
テキスト・リテラルの例
テキスト・リテラル'10'はCHARデータ型です。次の文のように数式で使用すると暗黙的にNUMBERデータ型に変換されます。
SELECT salary + '10'
FROM employees;
文字値および数値の例
条件で文字値とNUMBER型の値を比較する場合、NUMBER型の値は文字値に変換されず、文字値が暗黙的にNUMBER型の値に変換されます。次の文では、'200'が暗黙的に200に変換されます。
SELECT last_name
FROM employees 
WHERE employee_id = '200';
日付の例
次の文では、Oracleがデフォルトの日付書式'DD-MON-YY'を使用して、'03-MAR-97'をDATE値に暗黙的に変換します。
SELECT last_name
FROM employees 
WHERE hire_date = '03-MAR-97';
ROWIDの例
次の文では、Oracleがテキスト・リテラル'AAAGH6AADAAAAFGAAN'をROWID値に暗黙的に変換します。(ROWIDはデータベース内で一意のため、この例を使用するには、データベースの実際のROWIDを知る必要があります)。
SELECT last_name
FROM employees
WHERE ROWID = 'AAAGH6AADAAAAFGAAN';
明示的なデータ変換 
SQL変換ファンクションを使用すると、データ型の変換を明示的に指定できます。表2-12に、値をあるデータ型から別のデータ型に明示的に変換するSQLファンクションを示します。
Oracleが暗黙的なデータ型変換を行うことができる場合には、LONGおよびLONG RAWの値を指定できません。たとえば、ファンクションや演算子を含む式では、LONGとLONG RAWの値を使用できません。LONGデータ型およびLONG RAWデータ型の制限については、「LONGデータ型」を参照してください。
表2-12    明示的な型の変換 
CHAR、VARCHAR2、NCHAR、NVARCHAR2 
NUMBERへ 
Datetime/Intervalへ 
RAWへ 
ROWIDへ 
LONG、LONG RAW 
CLOB、NCLOB、BLOB 
BINARY_FLOATへ 
BINARY_DOUBLEへ 
CHAR、VARCHAR2、NCHAR、NVARCHAR2から 
TO_CHAR(文字)
TO_NCHAR(文字) 
TO_NUMBER 
TO_DATE
TO_TIMESTAMP
TO_TIMESTAMP_TZ
TO_YMINTERVAL
TO_DSINTERVAL 
HEXTORAW 
CHARTO=ROWID 
-- 
TO_CLOB
TO_NCLOB 
TO_BINARY_FLOAT 
TO_BINARY_DOUBLE 
NUMBERから 
TO_CHAR(数値)
TO_NCHAR(数値) 
-- 
TO_DATE
NUMTOYM- INTERVAL
NUMTODS- INTERVAL 
-- 
-- 
-- 
-- 
TO_BINARY_FLOAT 
TO_BINARY_DOUBLE 
Datetime/ Intervalから 
TO_CHAR(日付)
TO_NCHAR(日時) 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
RAWから 
RAWTOHEX
RAWTONHEX 
-- 
-- 
-- 
-- 
-- 
TO_BLOB 
-- 
-- 
ROWIDから 
ROWIDTOCHAR 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
LONG/LONG RAWから 
-- 
-- 
-- 
-- 
-- 
-- 
TO_LOB 
-- 
-- 
CLOB、NCLOB、BLOBから 
TO_CHAR
TO_NCHAR 
-- 
-- 
-- 
-- 
-- 
TO_CLOB
TO_NCLOB 
-- 
-- 
CLOB、NCLOB、BLOBから 
TO_CHAR
TO_NCHAR 
-- 
-- 
-- 
-- 
-- 
TO_CLOB
TO_NCLOB 
-- 
-- 
BINARY_FLOATから
TO_CHAR(文字)
TO_NCHAR(文字) 
TO_NUMBER 
-- 
-- 
-- 
-- 
-- 
TO_BINARY_FLOAT 
TO_BINARY_DOUBLE 
BINARY_DOUBLEから 
TO_CHAR(文字)
TO_NCHAR(文字) 
TO_NUMBER 
-- 
-- 
-- 
-- 
-- 
TO_BINARY_FLOAT 
TO_BINARY_DOUBLE 
参照:
すべての明示的な変換ファンクションの詳細は、「変換ファンクション」を参照してください。 
リテラル 
リテラルと定数値という用語の意味は同じで、固定データ値のことです。たとえば、'JACK'、'BLUE ISLAND'および'101'はすべて文字リテラルです。文字リテラルは、一重引用符で囲みます。一重引用符を付けることで、Oracleは文字リテラルとスキーマ・オブジェクト名を区別します。
この項では、次の内容を説明します。
テキスト・リテラル
数値リテラル
日時リテラル
期間リテラル
多くのSQL文とファンクションでは、文字リテラルと数値リテラルを指定する必要があります。式と条件の一部として、リテラルを指定できます。文字リテラルは'text'の表記法を、各国文字リテラルはN'text'の表記法を、数値リテラルはリテラルのコンテキストに応じてintegerまたはnumberの表記法を使用して指定できます。これらの表記法の構文については、次の項で説明します。
Datetime(日時)またはInterval(期間)のデータ型をリテラルとして指定する場合は、データ型に含まれているオプションの精度を考慮する必要があります。Datetime(日時)およびInterval(期間)のデータ型をリテラルとして指定する場合の例は、「データ型」の関連する項を参照してください。
テキスト・リテラル 
このマニュアルの他の箇所で、式、条件、SQLファンクションおよびSQL文の各構文に示されている'string'に値を指定するときには、必ずこのテキスト・リテラルの表記法を使用してください。このマニュアルでは、テキスト・リテラル、文字リテラルおよび文字列は同じ用語として使用しています。テキスト、文字、文字列リテラルは必ず一重引用符で囲まれています。構文にcharが使用されている場合、テキスト・リテラルを指定するか、または文字データに変換する他の式(たとえば、hr.employees表のlast_name列)を指定します。構文にcharがある場合、一重引用符で囲む必要はありません。
テキスト・リテラルの構文は次のとおりです。
text::=
画像の説明
ここで、Nまたはnは、各国語キャラクタ・セット(NCHARまたはNVARCHAR2データ)を使用してリテラルを指定します。デフォルトでは、この表記法を使用して入力したテキストは、サーバーで使用するときにデータベースのキャラクタ・セットによって各国語キャラクタ・セットに変換されます。テキスト・リテラルをデータベースのキャラクタ・セットに変換しているときにデータの消失を避けるためには、環境変数ORA_NCHAR_LITERAL_REPLACEにTRUEを設定してください。このように設定することで、 n'を透過的に内部で置き換え、SQLの処理中にテキスト・リテラルを保持します。
参照:
N付き引用符で表されたリテラルの詳細は、『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
構文の上の方のブランチでは、次のようになります。
cは、データベース・キャラクタ・セットの任意の要素です。リテラル内の一重引用符(')の前には、エスケープ文字を付ける必要があります。リテラル内で一重引用符を表すには、一重引用符を2つ使用します。
' 'は、テキスト・リテラルの始まりと終わりを示す2つの一重引用符です。
構文の下の方のブランチでは、次のようになります。
Qまたはqは、代替引用メカニズムが使用されることを示します。このメカニズムを使用すると、様々なデリミタをテキスト文字列に使用できます。
一番外側の' 'は、開始のquote_delimiterの前と、終了のquote_delimiterの後に付ける2つの一重引用符です。
cは、データベース・キャラクタ・セットの任意の要素です。cで構成されるテキスト・リテラル内に引用符(")を含めることができます。また、一重引用符が直後に付かないquote_delimiterも含めることができます。
quote_delimiterは、空白、タブおよび改行文字を除く、任意のシングルバイト文字またはマルチバイト文字です。quote_delimiterには一重引用符も使用できます。ただし、quote_delimiterがテキスト・リテラル自体に使用されている場合は、一重引用符を直後に付けないようにしてください。
開始のquote_delimiterが[、{、<または(のいずれかである場合、終了のquote_delimiterも対応する]、}、>または)である必要があります。それ以外の場合は常に、開始および終了のquote_delimiterは同じ文字である必要があります。
テキスト・リテラルは、次のようにCHARデータ型とVARCHAR2データ型の両方のプロパティを持ちます。
式と条件の中のテキスト・リテラルは、OracleによってCHARデータ型として扱われ、空白埋め比較セマンティクスで比較されます。
テキスト・リテラルの最大長は4000バイトです。
有効なテキスト・リテラルの例を次に示します。
'Hello'
'ORACLE.dbs'
'Jackie''s raincoat'
'09-MAR-98'
N'nchar literal'
代替引用メカニズムを使用した場合の、有効なテキスト・リテラルの例を次に示します。
q'!name LIKE '%DBMS_%%'!'
q'<'So,' she said, 'It's finished.'>'
q'{SELECT * FROM employees WHERE last_name = 'Smith';}'
nq'Ô ü1234 Ô'
q'"name like '['"'
参照:
「空白埋め比較セマンティクス」 
数値リテラル
固定小数点数および浮動小数点数を指定するには、数値リテラルの表記法を使用します。
整数リテラル 
このマニュアルの他の箇所で、式、条件、SQLファンクションおよびSQL文に示されているinteger(整数)に値を指定するときには、必ずこの表記法を使用してください。
integer(整数)の構文は次のとおりです。
integer::=
画像の説明
digitは、0、1、2、3、4、5、6、7、8、9のいずれかです。
整数は最大38桁の精度を記憶できます。
有効なinteger(整数)の例を次に示します。
7
+255
NUMBERおよび浮動小数点リテラル
このマニュアルの他の箇所で、式、条件、SQLファンクションおよびSQL文に示されているnumberまたはn(数)に値を指定するときには、必ずこれらの表記法を使用してください。
number(数)の構文は次のとおりです。
number::=
画像の説明
それぞれの意味は、次のとおりです。
+または-は、正の値または負の値を示します。符号を指定しない場合、デフォルトは正の値です。
digitは、0、1、2、3、4、5、6、7、8、9のいずれかです。
eまたはEは、数が科学表記法で指定されることを示します。Eの後の数字が指数を示します。指数は-130〜125の範囲で指定します。
fまたはFは、数が32ビットの2進浮動小数点数(BINARY_FLOAT型)であることを示します。
dまたはDは、数が64ビットの2進浮動小数点数(BINARY_DOUBLE型)であることを示します。
f(F)およびd(D)を省略すると、数はNUMBER型になります。
接尾辞f(F)およびd(D)は、浮動小数点数リテラルでのみサポートされます。文字列ではNUMBERに変換されるため、サポートされません。たとえば、OracleがNUMBERを想定している場合に、文字列'9'を使用すると、文字列は数字の9に変換されます。ただし、文字列'9f'を使用すると、変換は行われず、エラーが戻されます。
NUMBER型の数値は、最大38桁の精度を記憶できます。NUMBER、BINARY_FLOATまたはBINARY_DOUBLEで提供される精度以上の精度がリテラルに必要な場合、値は切り捨てられます。リテラルの範囲がNUMBER、BINARY_FLOATまたはBINARY_DOUBLEでサポートされる範囲を超える場合、エラーが発生します。
初期化パラメータNLS_NUMERIC_CHARACTERSを使用してピリオド(.)以外の小数点文字を設定している場合は、'text'の表記法で数値リテラルを指定する必要があります。この場合、Oracleは自動的にテキスト・リテラルを数値に変換します。
注意:
この表記法は、浮動小数点数リテラルでは使用できません。 
たとえば、NLS_NUMERIC_CHARACTERSパラメータでカンマを小数点文字に設定している場合、数値5.123は次のように指定します。
'5,123'
参照:
「ALTER SESSION」および『Oracle Databaseリファレンス』を参照してください。 
有効なNUMBERリテラルの例を次に示します。
25
+6.34
0.5
25e-03
-1
有効な浮動小数点数リテラルの例を次に示します。
25f
+6.34F
0.5d
-1D
値を数値リテラルとして表現できない場合は、次の浮動小数点リテラルを使用することもできます。
リテラル 
意味 
例 
binary_float_nan 
IS NAN条件がtrueであるBINARY_FLOAT型の値 
SELECT COUNT(*) FROM employees WHERE TO_BINARY_FLOAT(commission_pct)!= BINARY_FLOAT_NAN;     
binary_float_infinity 
単精度の正の無限大 
SELECT COUNT(*) FROM employees WHERE salary < BINARY_FLOAT_INFINITY;     
binary_double_nan 
IS NAN条件がtrueであるBINARY_DOUBLE型の値 
SELECT COUNT(*) FROM employees WHERE TO_BINARY_FLOAT(commission_pct)!= BINARY_FLOAT_NAN;     
binary_double_infinity 
倍精度の正の無限大 
SELECT COUNT(*) FROM employees WHERE salary < BINARY_FLOAT_INFINITY;     
日時リテラル 
Oracleデータベースは、DATE、TIMESTAMP、TIMESTAMP WITH TIME ZONEおよびTIMESTAMP WITH LOCAL TIME ZONEの4つの日時データ型をサポートしています。
日付リテラル
DATE値を文字列リテラルに指定するか、文字値や数値をTO_DATEファンクションによって日付値に変換できます。Oracleデータベースが文字列リテラルのかわりにTO_DATE式を受け入れるのは、DATEリテラルの場合だけです。
DATE値をリテラルに指定する場合は、グレゴリオ暦を使用する必要があります。次の例に示すように、ANSIのリテラルを指定できます。
DATE '1998-12-25'
ANSIの日付リテラルは、時刻部分を含みません。また、'YYYY-MM-DD'という書式で指定する必要があります。また、次のように、Oracleの日付値を指定できます。
TO_DATE('98-DEC-25 17:30','YY-MON-DD HH24:MI')
OracleのDATE値のデフォルトの日付書式は、初期化パラメータNLS_DATE_FORMATで指定します。この例は、日付としての2桁の数、月の名前の省略形、年の下2桁および24時間表記の時刻を含む日付書式です。
デフォルト日付書式の文字値が日付式で使用されると、Oracleは自動的にそれらを日付値に変換します。
日付値を指定する場合に時刻コンポーネントを指定しないと、デフォルト時刻の真夜中(24時間表記では00:00:00、12時間表記では12:00:00)が採用されます。日付値を指定する場合に日付を指定しないと、デフォルト日付である現在の月の最初の日が採用されます。
OracleのDATE列には、常に、日付フィールドと時刻フィールドが含まれます。したがって、DATE列を問い合せる場合は、問合せで時刻フィールドを指定するか、またはDATE列の時刻フィールドが真夜中に設定されていることを確認する必要があります。そうでない場合、Oracleは、正しい結果を戻さない場合があります。時刻フィールドを真夜中に設定するには、TRUNC(日付)ファンクションを使用します。また、問合せに、等価性や非等価性の条件のかわりに大/小条件を含めることもできます。
次の例では、数値列row_numおよびDATE列datecolを持つ表my_tableがあると想定します。
INSERT INTO my_table VALUES (1, SYSDATE);
INSERT INTO my_table VALUES (2, TRUNC(SYSDATE));
SELECT * FROM my_table;
ROW_NUM DATECOL
---------- ---------
1 03-OCT-02
2 03-OCT-02
SELECT * FROM my_table
WHERE datecol = TO_DATE('03-OCT-02','DD-MON-YY');
ROW_NUM DATECOL
---------- ---------
2 03-OCT-02
SELECT * FROM my_table
WHERE datecol > TO_DATE('02-OCT-02', 'DD-MON-YY');
ROW_NUM DATECOL
---------- ---------
1 03-OCT-02
2 03-OCT-02
DATE列の時刻フィールドが真夜中に設定されている場合は、前述の例に示すように、DATE列に対して問い合せるか、DATEリテラルを使用して問い合せることができます。
SELECT * FROM my_table WHERE datecol = DATE '2002-10-03';
ただし、DATE列が真夜中以外の値を含む場合、正しい結果を得るためには、問合せで時刻フィールドを排除する必要があります。次に例を示します。
SELECT * FROM my_table WHERE TRUNC(datecol) = DATE '2002-10-03';
Oracleは、問合せの各行にTRUNCファンクションを適用します。これによって、データの時刻フィールドが真夜中である場合、パフォーマンスが向上します。時刻フィールドを真夜中に設定するには、挿入および更新時に次のいずれかの操作を行います。
TO_DATEファンクションを使用して、時刻フィールドをマスクします。
INSERT INTO my_table VALUES 
(3, TO_DATE('3-OCT-2002','DD-MON-YYYY'));
DATEリテラルを使用します。
INSERT INTO my_table VALUES (4, '03-OCT-02');
TRUNCファンクションを使用します。
INSERT INTO my_table VALUES (5, TRUNC(SYSDATE));
日付ファンクションSYSDATEは、現在のシステムの日付および時刻を戻します。CURRENT_DATEファンクションは、現在のセッションの日付を戻します。SYSDATE、TO_*日時ファンクションおよびデフォルト日付書式の詳細は、「日時ファンクション」を参照してください。
TIMESTAMPリテラル
TIMESTAMPデータ型は、年、月、日、時、分、秒、および秒の小数部の値を格納します。TIMESTAMPをリテラルに指定する場合、fractional_seconds_precision値には最大9桁を指定できます。次に例を示します。
TIMESTAMP '1997-01-31 09:26:50.124'
TIMESTAMP WITH TIME ZONEリテラル
TIMESTAMP WITH TIME ZONEデータ型は、タイムゾーン・オフセットを含むTIMESTAMPの変形です。TIMESTAMP WITH TIME ZONEをリテラルに指定する場合、fractional_seconds_precision値には最大9桁を指定できます。次に例を示します。
TIMESTAMP '1997-01-31 09:26:56.66 +02:00'
2つのTIMESTAMP WITH TIME ZONE値がUTCで同じ時刻を表す場合は、データに格納されたTIME ZONEオフセットにかかわらず、同一であるとみなされます。次に例を示します。
TIMESTAMP '1999-04-15 8:00:00 -8:00'
前述の例文は次の例文と同じです。
TIMESTAMP '1999-04-15 11:00:00 -5:00'
つまり、太平洋標準時の午前8時は、東部標準時の午前11時と同じです。
UTCオフセットをTZR(タイムゾーン地域)書式要素に置換できます。次の例では、前述の例と同じ値を持ちます。
TIMESTAMP '1999-04-15 8:00:00 US/Pacific'
夏時間に切り替えられる境界のあいまいさを排除するには、TZRおよび対応するTZD書式要素の両方を使用します。次の例では、前述の例が確実に夏時間の値を戻します。
TIMESTAMP '1999-10-29 01:30:00 US/Pacific PDT'
タイムゾーン・オフセットは日時式を使用して表記することもできます。
SELECT TIMESTAMP '1999-10-29 01:30:00' AT TIME ZONE 'US/Pacific' FROM DUAL;
参照:
詳細は、「日時式」を参照してください。 
ERROR_ON_OVERLAP_TIMEセッション・パラメータをTRUEに設定しておくと、TZD書式要素を追加しなかったために日時値があいまいな場合、Oracleはエラーを戻します。パラメータをFALSEに設定しておくと、Oracleはあいまいな日時を、指定した地域の標準時刻として解析します。
TIMESTAMP WITH LOCAL TIME ZONEリテラル
TIMESTAMP WITH LOCAL TIME ZONEデータ型は、TIMESTAMP WITH TIME ZONEとは異なり、データベースに格納されるデータはデータベースのタイムゾーンに正規化されます。タイムゾーン・オフセットは、列データの一部として格納されません。TIMESTAMP WITH LOCAL TIME ZONEにはリテラルはありません。他の有効な日時リテラルを使用してこのデータ型の値を示してください。次の表には、TIMESTAMP WITH LOCAL TIME ZONE列に値を挿入するときに使用できる一部の書式と、問合せによって戻される対応する値を示します。
INSERT文の中で指定する値 
問合せによって戻される値 
'19-FEB-2004'  
19-FEB-2004.00.00.000000 AM 
SYSTIMESTAMP  
19-FEB-04 02.54.36.497659 PM 
TO_TIMESTAMP('19-FEB-2004', 'DD-MON-YYYY'));  
19-FEB-04 12.00.00.000000 AM 
SYSDATE  
19-FEB-04 02.55.29.000000 PM 
TO_DATE('19-FEB-2004', 'DD-MON-YYYY'));  
19-FEB-04 12.00.00.000000 AM 
TIMESTAMP'2004-02-19 8:00:00 US/Pacific');  
19-FEB-04 08.00.00.000000 AM 
指定した値に時刻コンポーネントがない場合(明示的または暗黙的に)、デフォルトの午前0時の値が戻されます。
期間リテラル
期間リテラルは期間を指定します。年および月、または日付、時間、分および秒の違いを指定できます。Oracleデータベースは、YEAR TO MONTHおよびDAY TO SECONDの2種類の期間リテラルをサポートします。各リテラルは先行フィールドを含み、後続フィールドを含むこともあります。先行フィールドは、計測する日付または時刻の基本単位を定義します。後続フィールドは、考慮する基本単位の最小増分値を定義します。たとえば、YEAR TO MONTH期間では、最も近い月に対する年との期間が考慮されます。DAY TO MINUTE期間では、最も近い分に対する日との期間が考慮されます。
数値形式の日付データがある場合、NUMTOYMINTERVALまたはNUMTODSINTERVAL変換ファンクションを使用して、数値データを期間値へ変換できます。
期間リテラルは、主に分析ファンクションとともに使用します。
参照:
「分析ファンクション」、「NUMTODSINTERVAL」、「NUMTOYMINTERVAL」および『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。 
INTERVAL YEAR TO MONTH
次の構文を使用して、YEAR TO MONTH期間リテラルを指定します。
interval_year_to_month::=
画像の説明
それぞれの意味は、次のとおりです。
'integer [-integer]'には、リテラルの先行フィールドおよびオプションの後続フィールドの整数値を指定します。先行フィールドがYEARで、後続フィールドがMONTHの場合、MONTHフィールドの整数値の範囲は0〜11です。
precisionは、先行フィールドの桁数です。先行フィールド精度の有効範囲は0〜9で、デフォルトは2です。
先行フィールドの制限事項:
後続フィールドを指定する場合は、その桁数を先行フィールドの桁数より少なく設定する必要があります。たとえば、INTERVAL '0-1' MONTH TO YEARは無効です。
次のINTERVAL YEAR TO MONTHリテラルは、intervalが123年2か月であることを示しています。
INTERVAL '123-2' YEAR(3) TO MONTH
このリテラルの他の書式の例を次に示します。省略バージョンも含みます。
期間リテラルの書式 
説明 
INTERVAL  '123-2' YEAR(3) TO MONTH 
123年2か月のintervalを示します。先行フィールド精度がデフォルトの2桁より大きい場合、その精度を指定してください。 
INTERVAL '123' YEAR(3) 
123年0か月のintervalを示します。 
INTERVAL '300' MONTH(3) 
300か月のintervalを示します。 
INTERVAL '4' YEAR 
INTERVAL '4-0' YEAR TO MONTHへマップし、4年を示します。 
INTERVAL '50' MONTH 
INTERVAL '4-2' YEAR TO MONTHへマップし、50か月(4年2か月)を示します。 
INTERVAL '123' YEAR 
デフォルト精度は2ですが、123が3桁のため、エラーを戻します。 
あるINTERVAL YEAR TO MONTHリテラルを別のリテラルに加算または減算して、新しいINTERVAL YEAR TO MONTHリテラルを作成できます。次に例を示します。
INTERVAL '5-3' YEAR TO MONTH + INTERVAL'20' MONTH = 
INTERVAL '6-11' YEAR TO MONTH
INTERVAL DAY TO SECOND
次の構文を使用して、DAY TO SECOND期間リテラルを指定します。
interval_day_to_second::=
画像の説明
それぞれの意味は、次のとおりです。
integerは日数を指定します。ここで指定した値の桁数が先行精度で指定した桁数より大きい場合、Oracleはエラーを戻します。
time_exprには、HH[:MI[:SS[.n]]]、MI[:SS[.n]]またはSS[.n]書式で時間を指定します(ここで、nは秒の小数部を指定します)。nの桁数が、fractional_seconds_precisionで指定した数より多い場合、nはfractional_seconds_precision値で指定した数に丸められます。先行フィールドがDAYの場合にのみ、1桁の整数および1つの空白の後にtime_exprを指定できます。
leading_precisionは、先行フィールドの桁数です。有効範囲は0〜9です。デフォルトは2です。
fractional_seconds_precisionは、SECOND日時フィールドの小数部の桁数です。有効範囲は1〜9です。デフォルトは6です。
先行フィールドの制限事項:
後続フィールドを指定する場合は、その桁数を先行フィールドの桁数より少なく設定する必要があります。たとえば、INTERVAL MINUTE TO DAYは無効です。このため、SECONDが先行フィールドの場合、期間リテラルは後続フィールドを持つことができません。
後続フィールドの有効範囲は次のとおりです。
HOUR: 0〜23
MINUTE: 0〜59
SECOND: 0〜59.999999999
様々なINTERVAL DAY TO SECONDリテラルの書式の例を次に示します。省略バージョンも含みます。
期間リテラルの書式 
説明 
INTERVAL  '4 5:12:10.222'  DAY TO SECOND(3) 
4日5時間12分10.222秒を示します。 
INTERVAL '4 5:12' DAY TO MINUTE 
4日5時間12分を示します。 
INTERVAL '400 5' DAY(3) TO HOUR 
400日5時間を示します。 
INTERVAL '400' DAY(3)  
400日を示します。 
INTERVAL '11:12:10.2222222' HOUR TO SECOND(7) 
11時間12分10.2222222秒を示します。 
INTERVAL '11:20' HOUR TO MINUTE 
11時間20分を示します。 
INTERVAL '10' HOUR 
10時間を示します。 
INTERVAL '10:22' MINUTE TO SECOND 
10分22秒を示します。 
INTERVAL '10' MINUTE 
10分を示します。 
INTERVAL '4' DAY 
4日を示します。 
INTERVAL '25' HOUR  
25時間を示します。 
INTERVAL '40' MINUTE 
40分を示します。 
INTERVAL '120' HOUR(3) 
120時間を示します。 
INTERVAL '30.12345' SECOND(2,4)  
30.1235秒を示します。精度は4のため、秒の小数部'12345'は'1235'に丸められます。 
DAY TO SECOND期間リテラルを別のDAY TO SECOND期間リテラルに加算または減算できます。次に例を示します。
INTERVAL'20' DAY - INTERVAL'240' HOUR = INTERVAL'10-0' DAY TO SECOND
書式モデル
書式モデルは、文字列に格納される日時データや数値データの書式を記述する文字リテラルです。書式モデルによってデータベース内に格納された値の内部表現は変更されません。文字列を日付または数値に変換する場合、書式モデルによって、Oracleデータベースによる文字列の変換方法が決まります。SQL文では、書式モデルをTO_CHARファンクションやTO_DATEファンクションの引数として使用して、次の書式を指定できます。
Oracleがデータベースから値を戻す場合に使用する書式
Oracleがデータベースに格納するために指定した値の書式
次に例を示します。
'17:45:29'の日時書式モデルは、'HH24:MI:SS'です。
'11-Nov-1999'の日時書式モデルは、'DD-Mon-YYYY'です。
'$2,304.25'の数値書式モデルは、'$9,999.99'です。
日時および数値書式モデルの要素のリストは、表2-17「FX書式モデル修飾子による文字データと書式モデルの一致」および表2-19「XMLFormatオブジェクトの属性」を参照してください。
いくつかの書式の値は、初期化パラメータの値によって決まります。これらの書式要素によって戻される文字は、初期化パラメータNLS_TERRITORYを使用して暗黙的に指定することもできます。デフォルト日付書式をセッションごとに変更するには、ALTER SESSION文を使用します。
参照:
これらのパラメータの値の変更については、「ALTER SESSION」を参照してください。書式モデルの使用例は、「書式モデルの例」を参照してください。
「TO_CHAR(日時)」、「TO_CHAR(数値)」、および「TO_DATE」を参照してください。
これらのパラメータの詳細は、『Oracle Databaseリファレンス』および『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。
この項の後半では、次の使用方法について説明します。
数値書式モデル
日時書式モデル
書式モデルの修飾子
数値書式モデル
次のファンクションで数値書式モデルを使用できます。
NUMBER、BINARY_FLOATまたはBINARY_DOUBLEデータ型の値をVARCHAR2データ型の値に変換するTO_CHARファンクション
CHARデータ型またはVARCHAR2データ型の値をNUMBERデータ型の値に変換するTO_NUMBERファンクション
CHARおよびVARCHAR2式をBINARY_FLOATまたはBINARY_DOUBLEの値に変換するTO_BINARY_FLOATファンクションおよびTO_BINARY_DOUBLEファンクション
すべての数値書式モデルでは、数値が指定された有効桁数に丸められます。小数点左の有効桁数が書式で指定された桁数より多い場合、シャープ記号(#)が値のかわりに戻されます。通常、このイベントは、TO_CHARファンクションを制限的な数値書式文字列で使用して、丸め処理が行われた場合に発生します。
正のNUMBERの値が非常に大きく、指定の書式で表せない場合、無限大記号(~)が値のかわりに戻されます。同様に、負のNUMBERの値が非常に小さく、指定の書式で表せない場合、負の無限大記号(-~)が戻されます。
BINARY_FLOATまたはBINARY_DOUBLEの値がCHARまたはNCHARに変換される場合、無限大またはNaN(非数値)のいずれかが入力されると、Oracleは常に値のかわりにシャープ記号を戻します。
数値書式要素
数値書式モデルは、1つ以上の数値書式要素で構成されます。次の表に、数値書式モデルの要素とその例を示します。
数値書式モデルに書式要素MI、SまたはPRが指定されないかぎり、負の戻り値の先頭には自動的に負の符号が付けられ、正の戻り値の先頭には空白が付けられます。
表2-13    数値書式要素 
要素 
例 
説明 
,(カンマ) 
9,999 
指定した位置にカンマを戻します。1つの数値書式モデルに複数のカンマを指定できます。
制限事項: 
数値書式モデルは、カンマ要素で始めることはできません。
数値書式モデルでは、カンマを小数点文字やピリオドの右側に指定できません。
. (ピリオド) 
99.99 
指定した位置に小数点(ピリオド(.))を戻します。
制限事項: 1つの数値書式モデルには1つのピリオドのみ指定できます。 
$ 
$9999 
値の前にドル記号を付けて戻します。 
0 
0999
9990 
先行0(ゼロ)を戻します。
後続0(ゼロ)を戻します。 
9 
9999 
正の値の場合は先頭に空白を埋め込み、負の値の場合は先頭に負の符号を埋め込んで、指定の桁数にしてから値を戻します。
固定小数点数の整数部分の場合、先行0(ゼロ)に対して空白を戻します。ただし、値0(ゼロ)に対しては0(ゼロ)を戻します。 
B 
B9999 
整数部が0(ゼロ)の場合、書式モデル内の0(ゼロ)にかかわらず、固定小数点数の整数部に対して空白を戻します。 
C 
C999 
指定した位置にISO通貨記号(NLS_ISO_CURRENCYパラメータの現在の値)を戻します。 
D 
99D99 
指定した位置に小数点文字(NLS_NUMERIC_CHARACTERパラメータの現在の値)を戻します。デフォルトはピリオド(.)です。
制限事項: 1つの数値書式モデルには1つの小数点文字のみ指定できます。 
EEEE 
9.9EEEE 
科学表記法で値を戻します。 
G 
9G999 
指定した位置に桁区切り(NLS_NUMERIC_CHARACTERパラメータの現在の値)を戻します。1つの数値書式モデルに複数の桁区切りを指定できます。
制限事項: 数値書式モデルにおいて、桁区切りは小数点文字やピリオドの右側に指定できません。 
L 
L999 
指定した位置にローカル通貨記号(NLS_CURRENCYパラメータの現在の値)を戻します。 
MI 
9999MI 
負の値の後に負の符号(-)を戻します。
正の値の後に空白を戻します。
制限事項: 書式要素MIは、数値書式モデルの最後の位置にのみ指定できます。 
PR 
9999PR 
山カッコ<>の中に負の値を戻します。
正の値の前後に空白を付けて戻します。
制限事項: 書式要素PRは、数値書式モデルの最後の位置にのみ指定できます。 
RN
rn 
RN
rn 
大文字のローマ数字で値を戻します。
小文字のローマ数字で値を戻します。
値は1〜3999の整数となります。 
S 
S9999
9999S 
負の値の前に負の符号(-)を戻します。
正の値の前に正の符号(+)を戻します。
負の値の後に負の符号(-)を戻します。
正の値の後に正の符号(+)を戻します。
制限事項: 書式要素Sは、数値書式モデルの最初または最後の位置にのみ指定できます。 
TM 
TM 
テキストの最小値です。できるだけ少ない文字数を10進数で戻します。この要素は、大文字と小文字を区別しません。
デフォルトはTM9です。デフォルトでは、戻り値が64文字を超えないかぎり、固定表記法で文字数を戻します。戻り値が64文字を超える場合、Oracleデータベースは自動的に科学表記法で文字数を戻します。
制限事項: 
この要素の前に他の要素を指定することはできません。
この要素の後には、1つの9、Eまたはeのみを指定できます。ただし、これらを組み合せて指定することはできません。次の文は、エラーを戻します。
SELECT TO_CHAR(1234, 'TM9e') FROM DUAL; 
U 
U9999 
指定した位置にユーロまたは他の第2通貨記号(NLS_DUAL_CURRENCYパラメータの現在の値)を戻します。 
V 
999V99 
値を10のn乗にして戻します(必要に応じて数値を丸めます)。ここで、nはVの後の9の数です。 
X 
XXXX
xxxx 
指定の桁数の16進数値を戻します。指定した値が整数でない場合、Oracleデータベースはその値を整数に丸めます。
制限事項: 
この要素は、正の値または0(ゼロ)のみを受け入れます。負の値の場合、エラーを戻します。
この要素の前には、0(先行0(ゼロ)を戻す)またはFMのみを指定できます。その他の要素の場合、エラーを戻します。0(ゼロ)またはFMをXと同時に指定しないと、戻り値の前に常に空白が1つ追加されます。
表2-14に、異なるnumberと'fmt'に対して次の問合せを行った場合の結果を示します。
SELECT TO_CHAR(number, 'fmt')
FROM DUAL;
表2-14    数値変換の結果 
数値 
'fmt' 
結果 
-1234567890 
9999999999S 
'1234567890-' 
0 
99.99 
'   .00' 
+0.1 
99.99 
'   .10' 
-0.2 
99.99 
'  -.20' 
0 
90.99 
'  0.00' 
+0.1 
90.99 
'  0.10' 
-0.2 
90.99 
' -0.20' 
0 
9999 
'    0' 
1 
9999 
'    1' 
0 
B9999 
'     ' 
1 
B9999 
'    1' 
0 
B90.99 
'     ' 
+123.456 
999.999 
' 123.456' 
-123.456 
999.999 
'-123.456' 
+123.456 
FM999.009 
'123.456' 
+123.456 
9.9EEEE 
' 1.2E+02' 
+1E+123 
9.9EEEE 
' 1.0E+123' 
+123.456 
FM9.9EEEE 
' 1.2E+02' 
+123.45 
FM999.009 
'123.45' 
+123.0 
FM999.009 
'123.00' 
+123.45 
L999.99 
'          $123.45' 
+123.45 
FML999.99 
'$123.45' 
+1234567890 
9999999999S 
'1234567890+' 
日時書式モデル
次のファンクションで日時書式モデルを使用できます。
デフォルト書式以外の書式の文字値を日時値に変換するTO_*日時ファンクション(TO_CHAR、TO_DATE、TO_TIMESTAMP、TO_TIMESTAMP_TZ、TO_YMINTERVALおよびTO_DSINTERVAL)
デフォルト書式以外の書式の日時値を文字列に変換する(たとえば、アプリケーションから日付を出力する)TO_CHARファンクション
日時書式モデルの合計長は最大22文字です。
デフォルト日時書式は、初期化パラメータNLS_DATE_FORMATで明示的に指定することも、初期化パラメータNLS_TERRITORYで暗黙的に指定することもできます。デフォルト日時書式をセッションごとに変更するには、ALTER SESSION文を使用します。
参照:
NLSパラメータの詳細は、「ALTER SESSION」および『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
日時書式要素 
日時書式モデルは、表2-19「XMLFormatオブジェクトの属性」に示す、1つ以上の日時書式要素で構成されます。
入力書式モデルの場合、同じ書式項目は2回指定できません。また、類似した情報を表す書式項目を組み合せることもできません。たとえば、'SYYYY'と'BC'を同一の書式文字列内で使用することはできません。
表2-19に示すとおり、日時書式要素には、TO_*日時ファンクションで使用できないものもあります。
日時書式要素FF、TZD、TZH、TZMおよびTZRは、タイムスタンプおよび期間書式モデルでは使用できますが、元のDATE書式モデルでは使用できません。
多くの場合、日時書式要素は一定の長さになるまで空白が埋め込まれます。詳細は、「FM」を参照してください。
日付書式要素における大文字 
戻される日付値では、その大文字と小文字は対応する書式要素の表記に従います。たとえば、日付書式モデル「DAY」は「MONDAY」、「Day」は「Monday」、「day」は「monday」を生成します。
日時書式モデルにおける句読点と文字リテラル 
日付書式モデルでは、次の文字を指定できます。
ハイフン、スラッシュ、カンマ、ピリオド、コロンなどの句読点
文字リテラル(二重引用符で囲みます)
これらの文字は、戻り値の中で書式モデルに指定された位置と同じ位置に現れます。
表2-15    日時書式要素 
要素 
TO_*日時ファンクションで指定できるか 
説明 
-/,.;:"text"     
はい 
結果に取り込まれる句読点とテキスト。 
ADA.D.     
はい 
ピリオド付き/なしで西暦を示します。 
AMA.M.     
はい 
ピリオド付き/なしで午前を示します。 
BCB.C.     
はい 
ピリオド付き/なしで紀元前を示します。 
CCSCC     
いいえ 
世紀。
4桁で表した年の下2桁が01〜99(01および99を含む)の場合、世紀はその年の上2桁より1つ大きくなります。
4桁で表した年の下2桁が00の場合、世紀はその年の上2桁と同一になります。
たとえば、2002は21を戻し、2000は20を戻します。 
D     
はい 
曜日(1〜7)。 
DAY     
はい 
曜日。9文字分の長さまで空白が埋め込まれます。 
DD     
はい 
月における日(1〜31)。 
DDD     
はい 
年における日(1〜366)。 
DL     
はい 
OracleデータベースのDATE書式の拡張である長い日付書式の値(NLS_DATE_FORMATパラメータの現在の値)を戻します。日付コンポーネント(曜日、月番号など)は、NLS_TERRITORYおよびNLS_LANGUAGEパラメータに応じて表示されます。たとえば、AMERICAN_AMERICAロケールでは、これは書式'fmDay, Month dd, yyyy'を指定することと同じです。GERMAN_GERMANYロケールでは、書式'fmDay, dd. Month yyyy'を指定することと同じです。
制限事項: この書式はTS要素とのみ指定できます。その場合は空白で区切ります。 
DS     
はい 
短い日付書式の値を戻します。日付コンポーネント(曜日、月番号など)は、NLS_TERRITORYおよびNLS_LANGUAGEパラメータに応じて表示されます。たとえば、AMERICAN_AMERICAロケールでは、これは書式'MM/DD/RRRR'を指定することと同じです。ENGLISH_UNITED_KINGDOMロケールでは、書式'DD/MM/RRRR'を指定することと同じです。
制限事項: この書式はTS要素とのみ指定できます。その場合は空白で区切ります。 
DY     
はい 
曜日の省略形。 
E     
いいえ 
時代名の略称(日本、台湾、タイ)。 
EE     
いいえ 
時代名の完全名称(日本、台湾、タイ)。 
FF [1..9]     
はい 
小数部。基数は出力されません(基数文字の追加には、X書式要素を使用します)。戻される日時の値の小数部の桁数を指定するには、FFの後に、1〜9の数字を使用します。数字を指定しない場合は、日時データ型に指定された精度またはデータ型のデフォルトの精度が使用されます。
例: 'HH:MI:SS.FF'
SELECT TO_CHAR(SYSTIMESTAMP, 'SS.FF3') from dual; 
FM     
はい 
前後に空白を付けずに値を戻します。
参照: この書式モデル修飾子の詳細は、Oracle Database SQLリファレンスを参照してください。 
FX     
はい 
文字データと書式モデルが完全に一致する必要があります。
参照: この書式モデル修飾子の詳細は、Oracle Database SQLリファレンスを参照してください。 
HH     
はい 
時間(1〜12)。 
HH12     
いいえ 
時間(1〜12)。 
HH24     
はい 
時間(0〜23)。 
IW     
いいえ 
ISO規格に基づく、年における週(1〜52または1〜53)。 
IYYIYI     
いいえ 
それぞれISO年の下3桁、2桁、1桁。 
IYYY     
いいえ 
ISO規格に基づく4桁の年。 
J     
はい 
ユリウス日。紀元前4712年1月1日から経過した日数。「J」を付けて指定する数値は、整数にしてください。 
MI     
はい 
分(0〜59)。 
MM     
はい 
月(01~12、1月 = 01)。 
MON     
はい 
月の名前の省略形。 
MONTH     
はい 
月の名前。9文字分の長さまで空白が埋め込まれます。 
PMP.M.     
いいえ 
ピリオド付き/なしで午前を示します。 
Q     
いいえ 
年の四半期(1、2、3、4;1月〜3月=1)。 
RM     
はい 
ローマ数字で表した月(I〜XII;1月=I)。 
RR     
はい 
2桁のみを使用して、21世紀に20世紀の日付を格納できます。
参照: RR日時書式要素の詳細は、Oracle Database SQLリファレンスを参照してください。 
RRRR     
はい 
年を丸めます。4桁または2桁で入力できます。2桁の場合、RRの場合と同様の結果が戻ります。年を4桁で入力すると、この処理は行われません。 
SS     
はい 
秒(0〜59)。 
SSSSS     
はい 
午前0時から経過した秒(0〜86399)。 
TS     
はい 
短い時刻書式の値を戻します。時刻コンポーネント(時、分など)は、NLS_TERRITORYおよびNLS_LANGUAGE初期化パラメータに応じて表示されます。
制限事項: この書式はDL要素またはDS要素とのみ指定できます。その場合は空白で区切ります。 
TZD      
はい 
夏時間の情報。TZDの値は、夏時間の情報を持つタイムゾーン文字列の省略形です。TZRで指定した地域と対応している必要があります。
例: PST(米国/太平洋標準時)、PDT(米国/太平洋夏時間) 
TZH     
はい 
タイムゾーンの時間(TZM書式要素を参照)。
例: 'HH:MI:SS.FFTZH:TZM' 
TZM     
はい 
タイムゾーンの分(TZH書式要素を参照)。
例: 'HH:MI:SS.FFTZH:TZM' 
TZR     
はい 
タイムゾーン地域の情報。値は、データベースでサポートされるタイムゾーン地域である必要があります。
例: US/Pacific 
WW     
いいえ 
年における週(1〜53)。第1週はその年の1月1日で始まり、1月7日で終了します。 
W     
いいえ 
月における週(1〜5)。第1週はその月の1日で始まり、7日で終了します。 
X     
はい 
ローカル基数文字。
例: 'HH:MI:SSXFF' 
Y,YYY     
はい 
指定した位置にカンマを付けた年。 
YEARSYEAR     
いいえ 
フルスペルで表した年。Sを指定すると紀元前の日付の先頭に負の符号(-)が付けられます。 
YYYYSYYYY     
はい 
4桁で表した年。Sを指定すると紀元前の日付の先頭に負の符号(-)が付けられます。 
YYYYYY     
はい 
それぞれ年の下3桁、2桁、1桁。 
書式文字列に句読点文字がある日付文字列に英数字がある場合、Oracleはエラーを戻します。たとえば、次の書式文字列はエラーを戻します。
TO_CHAR (TO_DATE('0297','MM/YY'), 'MM/YY')
日時書式要素およびグローバリゼーション・サポート 
いくつかの日時書式要素の機能は、Oracleデータベースを使用している国および言語に依存します。たとえば、次の日時書式要素は、フルスペルで値が戻されます。
MONTH
MON
DAY
DY
BC、AD、B.C.またはA.D.
AM、PM、A.M.またはP.M.
これらの値を戻す言語は、初期化パラメータNLS_DATE_LANGUAGEによって明示的に指定することも、初期化パラメータNLS_LANGUAGEによって暗黙的に指定することもできます。日時書式要素YEARとSYEARによって戻される値は常に英語です。
日時書式要素Dは、曜日の数(1〜7)を戻します。この数が1である曜日は、初期化パラメータNLS_TERRITORYによって暗黙的に指定されます。
参照:
グローバリゼーション・サポートの初期化パラメータの詳細は、『Oracle Databaseリファレンス』および『Oracle Databaseグローバリゼーション・サポート・ガイド』を参照してください。 
ISO標準日付書式要素 
Oracleは、ISO規格に従った日時書式要素IYYY、IYY、IY、IおよびIWによって戻される値を計算します。これらの値と日時書式要素YYYY、YYY、YY、YおよびWWによって戻される値の相違点については、『Oracle Databaseグローバリゼーション・サポート・ガイド』の「グローバリゼーション・サポート」の章を参照してください。
RR日時書式要素
RR日時書式要素は、YY日時書式要素に似ていますが、20世紀以外の日付値を格納する場合の柔軟性が優れています。RR日時書式要素によって、現在が21世紀でも、年の下2桁を指定するだけで、20世紀の日付を格納できます。
YY日時書式要素でTO_DATEファンクションを使用した場合、日付値は常に現在の年と同じ上2桁で戻されます。そのかわりにRR日時書式要素を使用した場合、年に指定した2桁の数と現在の年の下2桁の数によって戻り値の世紀が変化します。
したがって、次のようになります。
指定された2桁の年が00〜49の場合
現在の年の下2桁が00〜49であれば、戻される年は、現在の年と同じ上2桁を持ちます。
現在の年の下2桁が50〜99であれば、戻される年の上2桁は、現在の年の上2桁より1多くなります。
指定された2桁の年が50〜99の場合
現在の年の下2桁が00〜49であれば、戻される年の上2桁は、現在の年の上2桁より1少なくなります。
現在の年の下2桁が50〜99であれば、戻される年は、現在の年と同じ上2桁を持ちます。
次に、RR日時書式要素の特長を具体的に説明します。
RR日時書式の例
次の問合せが、1950年〜1999年の間に発行されるとします。
SELECT TO_CHAR(TO_DATE('27-OCT-98', 'DD-MON-RR') ,'YYYY') "Year"
FROM DUAL;
Year
----
1998
SELECT TO_CHAR(TO_DATE('27-OCT-17', 'DD-MON-RR') ,'YYYY') "Year"
FROM DUAL; 
Year
----
2017
次の問合せが、2000年〜2049年の間に発行されるとします。
SELECT TO_CHAR(TO_DATE('27-OCT-98', 'DD-MON-RR') ,'YYYY') "Year"
FROM DUAL; 
Year
----
1998 
SELECT TO_CHAR(TO_DATE('27-OCT-17', 'DD-MON-RR') ,'YYYY') "Year"
FROM DUAL; 
Year
----
2017
発行される年(2000年の前後)にかかわらず、問合せが同じ値を戻していることに注目してください。RR日時書式要素によって、年の上2桁が異なっても同じ値を戻すSQL文を記述できます。
日時書式要素の接尾辞 
表2-16に、日時書式要素に付加できる接尾辞を示します。
表2-16    日付書式要素の接尾辞 
接尾辞 
意味 
要素の例 
値の例 
TH 
序数 
DDTH 
4TH 
SP 
フルスペルで表した数 
DDSP 
FOUR 
SPTHまたはTHSP 
フルスペルで表した序数 
DDSPTH 
FOURTH 
日時書式要素の接尾辞の注意事項:
これらの接尾辞を1つでも日時書式要素に付加した場合、戻り値は常に英語です。
日時の接尾辞は出力書式設定にのみ有効です。データベースに日付を挿入するためには使用できません。
書式モデルの修飾子 
TO_CHARファンクションの書式モデルで修飾子FMとFXを使用して、空白の埋め方および書式検査を制御できます。
修飾子は書式モデルに複数指定できます。この場合、後の修飾子は前の修飾子の効果を逆にします。第1の修飾子は、それに後続するモデル部分に対して有効になり、第2の修飾子が指定されると、その後のモデル部分で無効になります。第3の修飾子が指定されると、その後のモデル部分で再び有効になります。以降、同様に続きます。
FM
Fill mode(埋込みモード)です。Oracleは、書式要素に空白文字を埋め込んで、現行のセッション言語の関連する書式モデルの最大要素と等しい固定幅になるようにします。たとえば、NLS_LANGUAGEがAMERICANの場合、MONTHの最大要素はSEPTEMBERであるため、MONTH書式要素のすべての値は表示文字が9文字になるまで空白が埋め込まれます。この修飾子は、TO_CHARファンクションの戻り値における空白の埋込みを回避します。
TO_CHARファンクションの日時書式要素では、この修飾子は後続の文字要素(MONTHなど)では空白を回避し、日時書式モデルの後続の数要素(MIなど)では先行0(ゼロ)を回避します。FMを指定していない場合、文字要素の結果は常に右に空白を埋め込んだ固定長となり、数要素に対しては常に先行0(ゼロ)が戻されます。FMを指定した場合、空白の埋込みが回避されるために、戻り値の長さが異なることもあります。
TO_CHARファンクションの数値書式要素では、この修飾子は数値の左に加えられた空白を回避します。これによって、その結果は出力バッファ中で左揃えになります。FMを指定していない場合、結果は常に右揃えとなり、数の左に空白が埋め込まれます。
FX
Format exact(厳密な書式一致)です。この修飾子は、TO_DATEファンクションの文字引数と日時書式モデルに対して、厳密な一致を指定します。
文字引数における句読点と引用符で囲まれたテキストは、書式モデルの対応する部分と(大/小文字の違いを除いて)厳密に一致する必要があります。
文字引数には余分な空白を含めることはできません。FXを指定していない場合、Oracleは余分な空白を無視します。
文字引数における数値データの桁数は、書式モデルの対応する要素と同じ桁数である必要があります。FXを指定していない場合、文字引数における数値によっては先行0(ゼロ)が省略されます。
FXが使用可能になっているとき、FM修飾子を指定して、この先行0(ゼロ)のチェックを使用禁止にできます。
文字引数の位置がこれらの条件に違反する場合、Oracleはエラー・メッセージを戻します。
書式モデルの例
次の文は、日付書式モデルを使用して文字式を戻します。
SELECT TO_CHAR(SYSDATE, 'fmDDTH')||' of '||TO_CHAR
(SYSDATE, 'fmMonth')||', '||TO_CHAR(SYSDATE, 'YYYY') "Ides" 
FROM DUAL; 
Ides 
------------------ 
3RD of April, 1998
この文はFM修飾子も使用していることに注目してください。FMを指定しないと、月は、次のように空白を埋め込んで9文字にして戻されます。
SELECT TO_CHAR(SYSDATE, 'DDTH')||' of '||
TO_CHAR(SYSDATE, 'Month')||', '||
TO_CHAR(SYSDATE, 'YYYY') "Ides"
FROM DUAL; 
Ides 
----------------------- 
03RD of April    , 1998 
次の文は、2つの連続した一重引用符を含む日付書式モデルを使用することによって、戻り値に一重引用符を含めます。
SELECT TO_CHAR(SYSDATE, 'fmDay')||'''s Special' "Menu"
FROM DUAL; 
Menu 
----------------- 
Tuesday's Special 
書式モデル内の文字リテラルにおいても、同じ目的で一重引用符を2つ連続して使用できます。
表2-17に、char値と'fmt'の様々な組合せに対し、次の文がFXを使用した一致条件を満たしているかどうかを示します(tableという名前の表にはDATEデータ型の列date_columnがあります)。
UPDATE table 
SET date_column = TO_DATE(char, 'fmt');
表2-17    FX書式モデル修飾子による文字データと書式モデルの一致 
char 
'fmt' 
一致とエラー 
'15/JAN/1998' 
'DD-MON-YYYY' 
一致 
' 15! JAN % /1998' 
'DD-MON-YYYY' 
エラー 
'15/JAN/1998' 
'FXDD-MON-YYYY' 
エラー 
'15-JAN-1998' 
'FXDD-MON-YYYY' 
一致 
'1-JAN-1998' 
'FXDD-MON-YYYY' 
エラー 
'01-JAN-1998' 
'FXDD-MON-YYYY' 
一致 
'1-JAN-1998' 
'FXFMDD-MON-YYYY' 
一致 
戻り値の書式例
書式モデルを使用して、データベースから値を戻す場合にOracleが使用する書式を指定できます。
次の文は、部門80の従業員の給与を選択し、TO_CHARファンクションを使用して、その給与を数値書式モデル'$99,990.99'で指定した書式の文字値に変換します。
SELECT last_name employee, TO_CHAR(salary, '$99,990.99')
FROM employees
WHERE department_id = 80;
Oracleはこの書式モデルによって、ドル記号を先頭に付け、3桁ごとにカンマで区切り、小数点以下2桁を持つ給与を戻します。
次の文は、部門20の各従業員の入社した日付を選択し、TO_CHARファンクションを使用して、その日付を日付書式モデル'fmMonth DD, YYYY'で指定した書式の文字列に変換します。
SELECT last_name employee, 
TO_CHAR(hire_date,'fmMonth DD, YYYY') hiredate
FROM employees
WHERE department_id = 20;
Oracleはこの書式モデルによって、2桁の日、世紀も含めた4桁の年で示された入社日付(fmで指定)を空白で埋めないで戻します。
参照:
fm書式要素の説明については、「書式モデルの修飾子」を参照してください。 
正しい書式モデルの付与例
列の値を挿入または更新する場合、指定する値のデータ型は列のデータ型と一致している必要があります。書式モデルを使用して、あるデータ型の値を列が必要とする別のデータ型の値に変換する書式を指定できます。
たとえば、DATE列に挿入する値は、DATEデータ型の値か、またはデフォルト日付書式の文字列値である必要があります(Oracleは、暗黙的にデフォルト日付書式の文字列をDATEデータ型に変換します)。値が別の書式で与えられる場合、TO_DATEファンクションを使用して値をDATEデータ型に変換する必要があります。また、文字列の書式を指定する場合にも、書式モデルを使用する必要があります。
次の文は、TO_DATEファンクションを使用してHunoldの入社日を更新します。文字列'1998 05 20'をDATE値に変換するために、書式マスク'YYYY MM DD'を指定します。
UPDATE employees 
SET hire_date = TO_DATE('1998 05 20','YYYY MM DD') 
WHERE last_name = 'Hunold'; 
文字列から日付への変換に関する規則 
次の追加の書式化規則は、文字列値を日付値に変換する場合に適用されます(ただし、書式モデルで修飾子FMとFXを使用して書式検査を制御した場合は適用できません)。
先行0(ゼロ)を含む数値書式要素の桁がすべて指定されている場合は、日付文字列から書式文字列に含まれる句読点を省略できます。たとえば、MM、DD、YYなどの2桁の書式要素については、2のかわりに02を指定した場合です。
日付文字列から、書式文字列の最後にある時刻フィールドを省略できます。
日時書式要素と日付文字列内の対応する文字の一致に失敗した場合、表2-18に示すとおり、元の書式要素のかわりに、別の書式要素の適用が試みられます。
表2-18    Oracleの書式一致 
元の書式要素 
元の書式要素のかわりに試行する書式要素 
'MM'     
'MON'および'MONTH' 
'MON 
'MONTH' 
'MONTH' 
'MON' 
'YY' 
'YYYY' 
'RR' 
'RRRR' 
XML書式モデル 
SYS_XMLGENファンクションは、XML文書を含むXMLType型のインスタンスを戻します。Oracleでは、SYS_XMLGENファンクションの結果をフォーマットするXMLFormatオブジェクトを提供します。
表2-19に、XMLFormatオブジェクトの属性を示します。表に示すように、ファンクションはこの型を実装します。
参照:
SYS_XMLGENファンクションの詳細は、「SYS_XMLGEN」を参照してください。
XMLFormatオブジェクトの実装およびその使用の詳細は、『Oracle XML Developer's Kitプログラマーズ・ガイド』を参照してください。
表2-19    XMLFormatオブジェクトの属性 
属性 
データ型 
用途 
enclTag 
VARCHAR2(100) 
SYS_XMLGENファンクションの結果の囲みタグ名です。ファンクションへの入力が列名である場合、デフォルトはその列名です。それ以外の場合、デフォルトはROWです。schemaTypeをUSE_GIVEN_SCHEMAに設定すると、この属性によってXML Schemaの要素名を指定することもできます。 
schemaType 
VARCHAR2(100) 
出力された文書のスキーマ生成の型です。有効な値は、'NO_SCHEMA'および'USE_GIVEN_SCHEMA'です。デフォルトは、'NO_SCHEMA'です。 
schemaName 
VARCHAR2(4000) 
schemaTypeの値が'USE_GIVEN_SCHEMA'のときに、Oracleが使用するターゲット・スキーマの名前です。schemaNameを指定すると、囲みタグが要素名として使用されます。 
targetNameSpace 
VARCHAR2(4000) 
スキーマが指定されている場合(つまり、schemaTypeがGEN_SCHEMA_*またはUSE_GIVEN_SCHEMAの場合)のターゲット・ネームスペースです。 
dburl 
VARCHAR2(2000) 
WITH_SCHEMAが指定されている場合に使用するデータベースのURLです。この属性が指定されていない場合、Oracleはその型へのURLを相対URL参照として宣言します。 
processingIns 
VARCHAR2(4000) 
ファンクションの出力の最上位に、要素の前に追加されるユーザーの処理命令です。 
XMLFormatオブジェクトを実装するファンクションは、次のとおりです。
STATIC FUNCTION createFormat(
enclTag IN varchar2 := 'ROWSET',
schemaType IN varchar2 := 'NO_SCHEMA',
schemaName IN varchar2 := null,
targetNameSpace IN varchar2 := null,
dburlPrefix IN varchar2 := null, 
processingIns IN varchar2 := null) RETURN XMLGenFormatType
deterministic parallel_enable,
MEMBER PROCEDURE genSchema (spec IN varchar2),
MEMBER PROCEDURE setSchemaName(schemaName IN varchar2),
MEMBER PROCEDURE setTargetNameSpace(targetNameSpace IN varchar2),
MEMBER PROCEDURE setEnclosingElementName(enclTag IN varchar2), 
MEMBER PROCEDURE setDbUrlPrefix(prefix IN varchar2),
MEMBER PROCEDURE setProcessingIns(pi IN varchar2),
CONSTRUCTOR FUNCTION XMLGenFormatType (
enclTag IN varchar2 := 'ROWSET',
schemaType IN varchar2 := 'NO_SCHEMA',
schemaName IN varchar2 := null,
targetNameSpace IN varchar2 := null,
dbUrlPrefix IN varchar2 := null, 
processingIns IN varchar2 := null) RETURN SELF AS RESULT
deterministic parallel_enable . . .
NULL 
行のある列の値がない場合、その列はNULLである、またはNULLを含むといいます。NOT NULL整合性制約またはPRIMARY KEY整合性制約によって制限されていない列の場合は、どのデータ型の列でもNULLを含むことができます。実際のデータ値が不定または値に意味がない場合に、NULLを使用してください。
NULLは値0(ゼロ)と同じではないため、0(ゼロ)を表すためにNULL値を使用しないでください。
注意:
現在、Oracleデータベースは、長さが0(ゼロ)の文字値をNULLとして処理します。ただし、この処理はOracleの今後のバージョンでも継続されるとはかぎらないため、空の文字列をNULLとして処理しないことをお薦めします。 
NULLを含む算術式は、必ずNULLに評価されます。たとえば、NULLに10を加算しても結果はNULLです。実際、オペランドにNULLを指定した場合、(連結演算子を除く)すべての演算子はNULLを戻します。
SQLファンクションでのNULL 
引数としてNULLを指定した場合、(REPLACE、NVLおよびCONCATを除く)すべてのスカラー・ファンクションではNULLが戻されます。NVLファンクションを使用した場合、NULLが発生したときに値を戻すことができます。たとえば、式NVL(commission_pct,0)は、commission_pctがNULLの場合は0(ゼロ)を戻し、commission_pctがNULLでなければその値を戻します。
ほぼすべての集計ファンクションでは、NULLは無視されます。たとえば、1000、NULL、NULL、NULL、2000という5つの値の平均を得る問合せを考えます。そのような問合せではNULLは無視され、平均は(1000+2000)/2=1500となります。
比較条件でのNULL 
NULLを検査するには、比較条件IS NULLおよびIS NOT NULLのみを使用します。NULLを他の条件で使用して、その結果がNULLの値に依存する場合、結果はUNKNOWNになります。NULLはデータの欠落を表すため、任意の値や別のNULLとの関係で等号や不等号は成り立ちません。ただし、OracleはDECODEファンクションを評価するときに2つのNULLを等しい値とみなします。構文および追加情報については、「DECODE」を参照してください。
コンポジット・キーの場合、2つのNULLは等しいと判断されます。NULLを含む2つのコンポジット・キーは、そのキーのNULL以外のコンポーネントのすべてが等しい場合、同一であると判断されます。
条件でのNULL 
UNKNOWNとして評価される条件は、FALSEと評価される場合とほとんど同じ働きをします。たとえば、UNKNOWNと評価される条件をWHERE句に持つSELECT文からは、行が戻されません。ただし、UNKNOWNと評価される条件はFALSE条件とは異なり、UNKNOWN条件をさらに評価してもUNKNOWNと評価されます。したがって、NOT FALSEはTRUEと評価されますが、NOT UNKNOWNはUNKNOWNと評価されます。
表2-20は、条件にNULLを含む評価の例です。SELECT文のWHERE句でUNKNOWNと評価される条件が使用された場合、その問合せに対して行は戻されません。
表2-20    NULLを含む条件 
条件 
aの値 
評価 
a IS NULL 
10 
FALSE 
a IS NOT NULL 
10 
TRUE 
a IS NULL 
NULL 
TRUE 
a IS NOT NULL 
NULL 
FALSE 
a = NULL 
10 
UNKNOWN 
a != NULL 
10 
UNKNOWN 
a = NULL 
NULL 
UNKNOWN 
a != NULL 
NULL 
UNKNOWN 
a = 10 
NULL 
UNKNOWN 
a != 10 
NULL 
UNKNOWN 
NULLを含む論理条件の結果を示した真理値表は、表7-5、表7-6、および表7-7を参照してください。
コメント 
SQL文とスキーマ・オブジェクトに対してコメントを付けることができます。
SQL文中のコメント 
コメントは、アプリケーションを読みやすく、メンテナンスしやすくします。たとえば、文にはアプリケーションでのその文の目的を記述したコメントを含めることができます。SQL文中のコメントは文の実行には影響しませんが、ヒントは例外です。この特殊なコメント形式を使用する場合の詳細は、「ヒントの使用方法」を参照してください。
コメントは、文中のキーワード、パラメータまたは句読点の間に入れることができます。次のいずれかの方法を使用します。
スラッシュとアスタリスク(/*)を使用してコメントを開始します。コメントのテキストを続けます。このテキストは複数行にまたがってもかまいません。アスタリスクとスラッシュ(*/)を使用してコメントを終了します。開始文字と終了文字は、空白や改行によってテキストから切り離す必要はありません。
--(ハイフン2個)を使用してコメントを開始します。コメントのテキストを続けます。このテキストは複数行にまたがることはできません。改行によってコメントを終了します。
SQLの入力に使用するツール製品には、追加の制限事項があるものもあります。たとえば、SQL*Plusを使用している場合、デフォルトでは複数行のコメント内に空白行を入れることはできません。詳細は、データベースのインタフェースとして使用するツール製品のドキュメントを参照してください。
SQL文の中に両方のスタイルのコメントが複数あってもかまいません。コメントのテキストには、使用しているデータベース・キャラクタ・セットの印字可能文字を含めることができます。
例
次の文には多くのコメントが含まれています。
SELECT last_name, salary + NVL(commission_pct, 0), 
job_id, e.department_id
/* Select all employees whose compensation is
greater than that of Pataballa.*/
FROM employees e, departments d
/*The DEPARTMENTS table is used to get the department name.*/
WHERE e.department_id = d.department_id
AND salary + NVL(commission_pct,0) >   /* Subquery:       */
(SELECT salary + NVL(commission_pct,0)
/* total compensation is salar + commission_pct */
FROM employees 
WHERE last_name = 'Pataballa');
SELECT last_name,                    -- select the name
salary + NVL(commission_pct, 0),-- total compensation
job_id,                         -- job
e.department_id                 -- and department
FROM employees e,                 -- of all employees
departments d
WHERE e.department_id = d.department_id
AND salary + NVL(commission_pct, 0) >  -- whose compensation 
-- is greater than
(SELECT salary + NVL(commission_pct,0)  -- the compensation
FROM employees 
WHERE last_name = 'Pataballa')        -- of Pataballa.
;
スキーマ・オブジェクトに関するコメント 
COMMENTコマンドを使用して、表、ビュー、マテリアライズド・ビューまたは列にコメントを付けることができます。スキーマ・オブジェクトに付けたコメントは、データ・ディクショナリに格納されます。コメントについては、「COMMENT」を参照してください。
ヒントの使用方法 
Oracleデータベースのオプティマイザに指示(ヒント)を与えるために、SQL文中でコメントを使用できます。オプティマイザは、オプティマイザの動作を阻止する条件が存在しないかぎり、これらのヒントを使用して文の実行計画を選択します。ヒントを使用する場合は注意が必要です。ヒントは、関連する表の統計情報を収集し、ヒントを使用せずにEXPLAIN PLAN文を使用してオプティマイザ計画を評価した後で使用してください。さらに、データベースの条件を変更するとコード内のヒントがパフォーマンスに重大な影響を与えることに注意してください。
文ブロックには、ヒントを含むコメントは1つのみ指定できます。このコメントは、SELECT、UPDATE、INSERT、MERGEまたはDELETEのいずれかのキーワードの後でのみ指定できます。INSERT文では次の2つのヒントのみを使用します。APPENDヒントは常にINSERTキーワードの後で指定し、PARALLELヒントはINSERTキーワードの後で指定できます。
次の構文図は、Oracleが文ブロック内でサポートする両方のスタイルのコメントに含まれるヒントの構文です。ヒント構文は、文ブロックを開始するINSERT、UPDATE、DELETE、SELECTまたはMERGEのいずれかのキーワードの直後でのみ指定できます。
hint::=
画像の説明
それぞれの意味は、次のとおりです。
+(プラス記号)は、コメントをヒントのリストとして、Oracleに解析させます。プラス記号は、コメント・デリミタの直後に置く必要があります。空白を入れてはいけません。
hintは、この項で説明するヒントの1つです。プラス記号とヒントの間の空白は入れても入れなくてもかまいません。コメントに複数のヒントが含まれている場合は、1つ以上の空白で区切る必要があります。
stringは、ヒントに含めることができるその他のコメント・テキストです。
--+構文では、コメント全体を単一行で指定する必要があります。
Oracleデータベースは、次の状況ではヒントを無視し、エラーを戻しません。
ヒントにスペルの誤りまたは構文エラーがある場合。ただし、データベースは、同一コメント内に正しく指定された他のヒントがある場合はそれを採用します。
ヒントを含むコメントが、DELETE、INSERT、MERGE、SELECTまたはUPDATEのいずれかのキーワードの後で指定していない場合。
ヒントの組合せが互いに競合している場合。ただし、データベースは、同一コメント内に他のヒントがあればそれを採用します。
データベース環境が、Formsバージョン3トリガー、Oracle Forms 4.5、Oracle Reports 2.5など、PL/SQLバージョン1を使用している場合。
多くのヒントは、特定の表や索引に適用することも、ビュー内の表や、索引の一部である列によりグローバルに適用することもできます。このようなグローバル・ヒントは、構文要素tablespecおよびindexspecによって定義します。
tablespec::=
画像の説明
アクセスする表は、文で示されるとおり正確に指定する必要があります。文が表の別名を使用している場合は、ヒントでも表名を使用せずに別名を使用します。ただし、文でスキーマ名を指定している場合でも、ヒント内ではスキーマ名を表名に含めないでください。
参照:
次の内容の詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。
グローバル・ヒントを使用するタイミングとその解析方法
EXPLAIN PLANを使用して、オプティマイザが問合せを実行する方法の確認
ビュー内の表へのヒントの参照
indexspec::=
画像の説明
ヒントでの問合せブロックの指定
多くのヒントでオプションの問合せブロック名を指定して、ヒントが適用される問合せブロックを指定できます。この構文によって、インライン・ビューに適用されるヒントを外部問合せ内で指定できます。ヒントが適用される問合せブロック内でヒントを指定する場合は、@queryblock構文を指定しません。
問合せブロックの引数の構文は、@queryblockの形式になります。ここでqueryblockは問合せ内で問合せブロック指定する識別子です。queryblock識別子は、システムで生成されるかまたはユーザーによって指定されます。
システム生成の識別子は、問合せに対するEXPLAIN PLAN文を使用して取得できます。変換前の問合せブロック名は、NO_QUERY_TRANSFORMATIONヒントを使用している問合せに対してEXPLAIN PLANを実行することで調べることができます。「NO_QUERY_TRANSFORMATIONヒント」を参照してください。
ユーザー指定の名前はQB_NAMEヒントで指定できます。「QB_NAMEヒント」を参照してください。
表2-21に、機能のカテゴリに分類したヒントと、各ヒントの構文とセマンティクスの参照先を示します。表の後には、ヒントをアルファベット順に示します。
参照:
次の内容の詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。
ヒントを使用したSQL文の最適化と、tablespecおよびindexspec構文の使用方法の詳細。
ヒントでの問合せブロックの指定。
ヒントのカテゴリ分類の説明と、それを使用するタイミング。
表2-21    機能のカテゴリに分類したヒント 
ヒント 
構文とセマンティクスの参照先 
最適化目標と方法 
ALL_ROWSヒント
FIRST_ROWSヒント 
-- 
RULEヒント 
アクセス・パスのヒント 
CLUSTERヒント 
-- 
FULLヒント 
-- 
HASHヒント 
-- 
INDEXヒント
NO_INDEXヒント 
-- 
INDEX_ASCヒント
INDEX_DESCヒント 
-- 
INDEX_COMBINEヒント 
-- 
INDEX_JOINヒント 
-- 
INDEX_FFSヒント 
-- 
INDEX_SSヒント 
-- 
INDEX_SS_ASCヒント 
-- 
INDEX_SS_DESCヒント 
-- 
NO_INDEX_FFSヒント 
-- 
NO_INDEX_SSヒント 
結合順序のヒント 
ORDEREDヒント 
-- 
LEADINGヒント 
結合操作のヒント 
USE_HASHヒント
NO_USE_HASHヒント 
-- 
USE_MERGEヒント
NO_USE_MERGEヒント 
-- 
USE_NLヒント
USE_NL_WITH_INDEXヒント
NO_USE_NLヒント 
パラレル実行のヒント 
PARALLELヒント
NO_PARALLELヒント 
-- 
PARALLEL_INDEXヒント
NO_PARALLEL_INDEXヒント 
-- 
PQ_DISTRIBUTEヒント 
問合せ変換のヒント 
FACTヒント
NO_FACTヒント 
-- 
MERGEヒント
NO_MERGEヒント 
-- 
NO_EXPANDヒント
USE_CONCATヒント 
-- 
REWRITEヒント
NO_REWRITEヒント 
-- 
UNNESTヒント
NO_UNNESTヒント 
-- 
STAR_TRANSFORMATIONヒント
NO_STAR_TRANSFORMATIONヒント 
-- 
NO_QUERY_TRANSFORMATIONヒント 
その他のヒント 
APPENDヒント
NOAPPENDヒント 
-- 
CACHEヒント
NOCACHEヒント 
-- 
CURSOR_SHARING_EXACTヒント 
-- 
DRIVING_SITEヒント 
-- 
DYNAMIC_SAMPLINGヒント 
-- 
PUSH_PREDヒント
NO_PUSH_PREDヒント 
-- 
PUSH_SUBQヒント
NO_PUSH_SUBQヒント 
-- 
PX_JOIN_FILTERヒント
NO_PX_JOIN_FILTERヒント 
-- 
NO_XML_QUERY_REWRITEヒント 
-- 
QB_NAMEヒント 
-- 
MODEL_MIN_ANALYSISヒント 
ヒントのリスト(アルファベット順)
この項では、すべてのヒントの構文とセマンティクスをアルファベット順に説明します。
ALL_ROWSヒント 
画像の説明
ALL_ROWSヒントは、文ブロックが最高のスループットになるよう(リソースの消費が最小になるよう)、オプティマイザに最適化の指示をします。たとえば、オプティマイザは問合せの最適化アプローチを使用して、この文を最高のスループットに最適化します。
SELECT /*+ ALL_ROWS */ employee_id, last_name, salary, job_id
FROM employees
WHERE employee_id = 7566;
ALL_ROWSまたはFIRST_ROWSヒントのいずれかをSQL文で指定する場合に、この文でアクセスする表の統計情報がデータ・ディクショナリにないと、オプティマイザは該当する表に割り当てられている記憶域など、デフォルトの統計値を使用して欠落している統計値を推定し、実行計画を選択します。このような推定値は、DBMS_STATSパッケージで収集した値ほど正確でない場合があるため、統計情報の収集にはDBMS_STATSパッケージを使用する必要があります。
アクセス・パスまたは結合操作のヒントをALL_ROWSまたはFIRST_ROWSヒントとともに指定する場合、オプティマイザでは、ヒントで指定されたアクセス・パスまたは結合操作が優先されます。
APPENDヒント 
画像の説明
APPENDヒントは、データベースがシリアル・モードで実行されている場合、ダイレクト・パス・インサート文を使用するようにオプティマイザに指示します。Enterprise Editionを使用していない場合、データベースはシリアル・モードで実行されています。従来型INSERTはシリアル・モードでのデフォルトです。またダイレクト・パス・インサートはパラレル・モードでのデフォルトです。
ダイレクト・パス・インサートの場合、データは現在表に割り当てられている既存の空き領域を使用せず、表の最後に追加されます。その結果、ダイレクト・パス・インサートは、従来型INSERTよりも高速に処理されます。
参照:
ダイレクト・パス・インサートの詳細は、『Oracle Database管理者ガイド』を参照してください。 
CACHEヒント
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
CACHEヒントは、全表スキャンの実行時に、この表に対して取り出されたブロックを、バッファ・キャッシュ内のLRUリストの最高使用頻度側に入れるようオプティマイザに指定します。このヒントは、小規模な参照表で有効です。
次の例では、CACHEヒントが表のデフォルト・キャッシュ仕様を上書きします。
SELECT /*+ FULL (hr_emp) CACHE(hr_emp) */ last_name
FROM employees hr_emp;
CACHEおよびNOCACHEヒントは、V$SYSSTATデータ・ディクショナリ・ビューで示すように、システム統計情報table scans (long tables)およびtable scans (short tables)に影響を与えます。
CLUSTERヒント
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
CLUSTERヒントは、クラスタ・スキャンを使用して、指定した表にアクセスするようオプティマイザに指示します。このヒントは、クラスタ化された表にのみ適用されます。
CURSOR_SHARING_EXACTヒント
画像の説明
Oracleでは、置換しても安全な場合には、SQL文内のリテラルをバインド変数に置き換えることができます。この置換処理は、CURSOR_SHARING初期化パラメータを使用して制御します。CURSOR_SHARING_EXACTヒントは、この動作を行わないようオプティマイザに指示します。つまり、Oracleは、リテラルのバインド変数への置換を試行せずにSQL文を実行します。
DRIVING_SITEヒント
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
DRIVING_SITEヒントは、データベースによって選択されたサイトとは異なるサイトで問合せを実行するようオプティマイザに指示します。このヒントは、分散化された問合せの最適化を使用している場合に有効です。
次に例を示します。
SELECT /*+ DRIVING_SITE(departments) */ * 
FROM employees, departments@rsite 
WHERE employees.department_id = departments.department_id;
この問合せがヒントなしで実行されている場合、departmentsからの行がローカル・サイトに送信され、そこで結合が実行されます。このヒントを使用している場合、employeesからの行がリモート・サイトに送信され、そこで問合せが実行されて結果セットがローカル・サイトに戻されます。
DYNAMIC_SAMPLINGヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
DYNAMIC_SAMPLINGヒントは、動的なサンプリングを制御する方法をオプティマイザに指示し、より正確な述語の選択性と表および索引に対する統計情報を調べることでサーバーのパフォーマンスを改善します。
DYNAMIC_SAMPLINGの値は、0〜10の範囲で設定できます。このレベルが高いほど、コンパイラは多くのリソースを動的なサンプリングに費やし、その適用範囲も広がります。tablespecを指定しない場合、サンプリングのデフォルトは、カーソルのレベルになります。
integerの値は0〜10となり、サンプリングの度合いを示します。
カーディナリティ統計情報が表にすでに存在する場合、オプティマイザはその情報を使用します。存在しない場合、オプティマイザは動的なサンプリングによってカーディナリティ統計情報を推定します。
tablespecを指定しており、カーディナリティ統計情報がすでに存在している場合は、次のようになります。
単一表述語(1つの表のみを評価するWHERE句)がない場合、オプティマイザは既存の統計情報を信頼し、このヒントを無視します。たとえば、employeesが分析される場合、次の問合せは動的なサンプリングにはなりません。
SELECT /*+ dynamic_sampling(e 1) */ count(*) 
FROM employees e;
単一表述語がある場合、オプティマイザは既存のカーディナリティ統計情報を使用し、この既存の統計情報を使用して述語の選択性を推定します。
動的なサンプリングを特定の表に適用するには、次の形式のヒントを使用します。
SELECT /*+ dynamic_sampling(employees 1) */ * 
FROM employees 
WHERE ..,
参照:
動的なサンプリングおよび設定可能なサンプリング・レベルの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
FACTヒント
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
FACTヒントは、スター型変換のコンテキストで使用されます。このヒントは、tablespec内で指定されている表をファクト表とみなす必要があることをオプティマイザに指示します。
FIRST_ROWSヒント 
画像の説明
FIRST_ROWSヒントは、最初のn行を最も効率的に戻す計画を選択し、個々のSQL文を最適化して応答時間を速くするようOracleに指示します。integerには、戻される行数を指定します。
注意:
最善の計画を実現するために最初の単一行を戻すよう最適化する、引数なしで指定されたFIRST_ROWSヒントは、下位互換性とプラン・スタビリティのみを目的として保持されます。 
たとえば、オプティマイザは問合せの最適化アプローチを使用して、次の文を最善の応答時間に最適化します。
SELECT /*+ FIRST_ROWS(10) */ employee_id, last_name, salary, job_id
FROM employees
WHERE department_id = 20;
この例では、各部門に多数の従業員がいます。ユーザーは、部門20の最初の10人の従業員を迅速に表示する必要があります。
オプティマイザは、DELETEおよびUPDATEの文ブロック、およびソートまたはグループ化などのブロッキング操作を含むSELECT文ブロックではこのヒントを無視します。Oracleデータベースでは最初の行を戻す前に、この文でアクセスされるすべての行を取り出す必要があるため、このような文は最善の応答時間に最適化することができません。このヒントをこのような文で指定する場合は、データベースを最善のスループットに最適化します。
参照:
FIRST_ROWSヒントと統計情報の詳細は、「ALL_ROWSヒント」を参照してください。 
FULLヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
FULLヒントは、指定した表に対して全表スキャンを実行するようオプティマイザに指示します。次に例を示します。
SELECT /*+ FULL(e) */ employee_id, last_name
FROM hr.employees e 
WHERE last_name LIKE :b1;
Oracleデータベースは、WHERE句内の条件によって使用可能になるlast_name列に索引がある場合でも、employees表に対して全表スキャンを実行し、この文を実行します。
employees表は、FROM句の中に別名eを持つため、ヒントは表名ではなく別名で表を参照する必要があります。スキーマ名がFROM句の中で指定されている場合でも、ヒントではスキーマ名を指定しないでください。
HASHヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
HASHヒントは、ハッシュ・スキャンを使用して、指定した表にアクセスするようオプティマイザに指示します。このヒントは、テーブル・クラスタ内に格納されている表にのみ適用されます。
INDEXヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEXヒントは、指定した表について索引スキャンを使用するようオプティマイザに指示します。ファンクション索引、ドメイン索引、Bツリー索引、ビットマップ索引およびビットマップ結合索引について、INDEXヒントを使用できます。
ヒントの動作は、indexspecの仕様によって異なります。
INDEXヒントが使用可能な単一の索引を指定すると、データベースはこの索引でスキャンを実行します。オプティマイザは、全表スキャンおよび表上の別の索引のスキャンを考慮しません。
複数の索引の組合せに対するヒントの場合、INDEXではなくINDEX_COMBINEヒントの使用をお薦めします。これは、後者のほうがより多目的なヒントであるためです。INDEXヒントが使用可能な索引のリストを指定すると、オプティマイザは、リスト内の各索引でのスキャンのコストを検討し、最低のコストで索引スキャンを実行します。アクセス・パスのコストが最低となる場合、データベースは、このリストから複数の索引をスキャンするように選択し、結果をマージすることもあります。データベースは、全表スキャンおよびヒント内でリスト化されていない索引でのスキャンを検討しません。
INDEXヒントが索引を指定しない場合、オプティマイザは、表にある使用可能な各索引でのスキャンのコストを検討し、最低のコストで索引スキャンを実行します。アクセス・パスのコストが最低となる場合、データベースは複数の索引をスキャンするように選択し、結果をマージすることもあります。オプティマイザは全表スキャンを検討しません。
次に例を示します。
SELECT /*+ INDEX (employees emp_department_ix)*/ 
employee_id, department_id 
FROM employees 
WHERE department_id > 50;
INDEX_ASCヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_ASCヒントは、指定した表について索引スキャンを使用するようオプティマイザに指示します。文で索引レンジ・スキャンを使用する場合、Oracleデータベースは、索引付きの値の昇順で索引エントリをスキャンします。各パラメータは、「INDEXヒント」と同じ目的で使用されます。
レンジ・スキャンのデフォルトの動作は、索引付きの値の昇順で索引エントリをスキャンします。降順索引の場合は、降順でスキャンします。このヒントは索引のデフォルトの順序を変更しないため、INDEXヒントにないものは指定しません。ただし、デフォルトの動作を変更する必要がある場合は、INDEX_ASCヒントを使用して昇順レンジ・スキャンを明示的に指定できます。
INDEX_COMBINEヒント
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_COMBINEヒントは、表へのビットマップ・アクセス・パスを使用するようオプティマイザに指示します。indexspecがINDEX_COMBINEヒントから省略されている場合、オプティマイザは、表のスキャンにかかるコスト効率が最大になる索引のブールの組合せを使用します。indexspecを指定すると、オプティマイザは、指定した索引のブールのいくつかの組合せの使用を試行します。各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次のようになります。
SELECT /*+ INDEX_COMBINE(e emp_manager_ix emp_department_ix) */ *
FROM employees e
WHERE manager_id = 108
OR department_id = 110;
INDEX_DESCヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_DESCヒントは、指定した表に降順索引スキャンを使用するようオプティマイザに指示します。文で索引レンジ・スキャンを使用しており、索引が昇順の場合、Oracleは索引付きの値の降順で索引エントリをスキャンします。パーティション索引では、結果は各パーティション内で降順になります。降順索引の場合、このヒントは降順を効果的に取り消すため、索引エントリは昇順でスキャンされます。各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次のようになります。
SELECT /*+ INDEX_DESC(e emp_name_ix) */ *
FROM employees e;
参照:
全体スキャンの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
INDEX_FFSヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_FFSヒントは、全表スキャンではなく高速全索引スキャンを実行するようオプティマイザに指示します。
各パラメータは、「INDEXヒント」と同じ目的で使用されます。次に例を示します。
SELECT /*+ INDEX_FFS(e emp_name_ix) */ first_name
FROM employees e;
INDEX_JOINヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_JOINヒントは、アクセス・パスとして索引結合を使用するようオプティマイザに指示します。ヒントが正しく機能するためには、問合せの解決に必要なすべての列を含む索引が最小限の数だけ存在している必要があります。
各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次の問合せは、索引結合を使用してmanager_idおよびdepartment_id列にアクセスします。これらの列はどちらも、employees表内で索引付けされています。
SELECT /*+ INDEX_JOIN(e emp_manager_ix emp_department_ix) */ department_id
FROM employees e
WHERE manager_id < 110
AND department_id < 50;
INDEX_SSヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_SSヒントは、指定した表について索引スキップ・スキャンを実行するようオプティマイザに指示します。文で索引レンジ・スキャンを使用する場合、Oracleは索引付きの値の昇順で索引エントリをスキャンします。パーティション索引では、結果は各パーティション内で昇順になります。
各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次のようになります。
SELECT /*+ INDEX_SS(e emp_name_ix) */ last_name
FROM employees e
WHERE first_name = 'Steven';
参照:
索引スキップ・スキャンの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
INDEX_SS_ASCヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_SS_ASCヒントは、指定した表について索引スキップ・スキャンを実行するようオプティマイザに指示します。文で索引レンジ・スキャンを使用する場合、Oracleデータベースは、索引付きの値の昇順で索引エントリをスキャンします。パーティション索引では、結果は各パーティション内で昇順になります。各パラメータは、「INDEXヒント」と同じ目的で使用されます。
レンジ・スキャンのデフォルトの動作は、索引付きの値の昇順で索引エントリをスキャンします。降順索引の場合は、降順でスキャンします。このヒントは索引のデフォルトの順序を変更しないため、INDEX_SSヒントにないものは指定しません。ただし、デフォルトの動作を変更する必要がある場合は、INDEX_SS_ASCヒントを使用して昇順レンジ・スキャンを明示的に指定できます。
参照:
索引スキップ・スキャンの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
INDEX_SS_DESCヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
INDEX_SS_DESCヒントは、指定した表について索引スキップ・スキャンを実行するようオプティマイザに指示します。文で索引レンジ・スキャンを使用しており、索引が昇順の場合、Oracleは索引付きの値の降順で索引エントリをスキャンします。パーティション索引では、結果は各パーティション内で降順になります。降順索引の場合、このヒントは降順を効果的に取り消すため、索引エントリは昇順でスキャンされます。
各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次のようになります。
SELECT /*+ INDEX_SS_DESC(e emp_name_ix) */ last_name
FROM employees e
WHERE first_name = 'Steven';
参照:
索引スキップ・スキャンの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
LEADINGヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
LEADINGヒントは、実行計画において、指定した一連の表を接頭辞として使用するようオプティマイザに指示します。このヒントは、ORDEREDヒントより多目的なヒントです。たとえば、次のようになります。
SELECT /*+ LEADING(e j) */ *
FROM employees e, departments d, job_history j
WHERE e.department_id = d.department_id
AND e.hire_date = j.start_date;
図形結合の依存性により、指定の表を指定の順序の最初に結合できない場合、LEADINGヒントは無視されます。2つ以上の競合するLEADINGヒントを指定すると、指定したすべてのヒントが無視されます。ORDEREDヒントを指定すると、このヒントがすべてのLEADINGヒントに優先します。
MERGEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
MERGEヒントを使用すると、問合せ内のビューをマージできます。
ビューの問合せブロックにGROUP BY句、またはSELECTリスト内のDISTINCT演算子が含まれている場合、複雑なビューのマージが可能であれば、オプティマイザはビューをアクセス文のみにマージできます。複雑なマージは、副問合せに相関関係がない場合、IN副問合せをアクセス文にマージする際に使用することもできます。
たとえば、次のようになります。
SELECT /*+ MERGE(v) */ e1.last_name, e1.salary, v.avg_salary
FROM employees e1,
(SELECT department_id, avg(salary) avg_salary 
FROM employees e2
GROUP BY department_id) v 
WHERE e1.department_id = v.department_id AND e1.salary > v.avg_salary;
引数なしでMERGEヒントを使用する場合、ビューの問合せブロック内に配置する必要があります。ビュー名を引数としてMERGEヒントを使用する場合、周囲の問合せに挿入する必要があります。
MODEL_MIN_ANALYSISヒント 
画像の説明
MODEL_MIN_ANALYSISヒントは、スプレッドシート・ルールのコンパイル時間の最適化(主に、詳細な依存グラフ分析)を省略するようオプティマイザに指示します。スプレッドシートのアクセス構造に選択的に移入するためのフィルタの作成や制限されたルールのプルーニングなど、他のスプレッドシートの最適化は、引き続きオプティマイザによって使用されます。
スプレッドシート・ルールの数が数百を超えると、スプレッドシート分析に長い時間がかかることがあるため、このヒントによってコンパイル時間を減らします。
NOAPPENDヒント 
画像の説明
NOAPPENDヒントは、INSERT文が有効な間、パラレル・モードを無効にして従来型のINSERTを使用するようにオプティマイザに指示します。従来型のINSERTはシリアル・モードでのデフォルトです。また、ダイレクト・パス・インサートはパラレル・モードでのデフォルトです。
NOCACHEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NOCACHEヒントは、全表スキャンの実行時に、この表に対して取り出されたブロックを、バッファ・キャッシュ内のLRUリストの最低使用頻度側に入れるようオプティマイザに指定します。これは、バッファ・キャッシュ内のブロックの通常動作です。たとえば、次のようになります。
SELECT /*+ FULL(hr_emp) NOCACHE(hr_emp) */ last_name
FROM employees hr_emp;
CACHEおよびNOCACHEヒントは、V$SYSSTATビューで示すように、システム統計情報table scans(long tables)およびtable scans(short tables)に影響を与えます。
参照:
表のサイズよって異なる表の自動キャッシングの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
NO_EXPANDヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
NO_EXPANDヒントは、OR条件を持つ問合せ用のOR拡張、またはWHERE句内にあるINリストを検討しないようオプティマイザに指示します。通常、オプティマイザは、OR拡張を使用しない場合よりもコストが低減できると判断すると、OR拡張の使用を検討します。たとえば、次のようになります。
SELECT /*+ NO_EXPAND */ *
FROM employees e, departments d
WHERE e.manager_id = 108
OR d.department_id = 110;
参照:
OR拡張の詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。
「USE_CONCATヒント」を参照してください(このヒントの反対の機能です)。
NO_FACTヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_FACTヒントは、スター型変換のコンテキストで使用されます。このヒントは、問合せ対象の表をファクト表とみなす必要がないことをオプティマイザに指示します。
NO_INDEXヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
NO_INDEXヒントは、指定した表について1つ以上の索引を使用しないようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_INDEX(employees emp_empid) */ employee_id 
FROM employees 
WHERE employee_id > 200; 
各パラメータは「INDEXヒント」と同じ目的で使用されますが、次の変更が加えられています。
このヒントが使用可能な単一の索引を指定すると、オプティマイザはこの索引でのスキャンを検討しません。その他の指定されていない索引については、スキャンを検討します。
このヒントが使用可能な索引のリストを指定すると、オプティマイザは指定された索引でのスキャンを検討しません。リスト内に指定されていないその他の索引については、スキャンを検討します。
このヒントが索引を指定しない場合、オプティマイザは表のいずれの索引でのスキャンを考慮しません。この動作は、表について使用可能なすべての索引のリストを指定するNO_INDEXヒントと同様になります。
NO_INDEXヒントは、ファンクション索引、Bツリー索引、ビットマップ索引、クラスタ索引およびドメイン索引に適用されます。NO_INDEXヒントと索引ヒント(INDEX、INDEX_ASC、INDEX_DESC、INDEX_COMBINEまたはINDEX_FFS)の両方が同じ索引を指定する場合、データベースは、NO_INDEXヒントと、指定した索引の索引ヒントの両方を無視し、これらの索引を文の実行中に使用することを検討します。
NO_INDEX_FFSヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
NO_INDEX_FFSヒントは、指定された表の指定された索引の高速全索引スキャンを除外するようオプティマイザに指示します。各パラメータは、「INDEXヒント」と同じ目的で使用されます。たとえば、次のようになります。
SELECT /*+ NO_INDEX_FFS(items item_order_ix) */ order_id
FROM order_items items;
NO_INDEX_SSヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
NO_INDEX_SSヒントは、指定された表の指定された索引のスキップ・スキャンを除外するようオプティマイザに指示します。各パラメータは、「INDEXヒント」と同じ目的で使用されます。
参照:
索引スキップ・スキャンの詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
NO_MERGEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_MERGEヒントは、外部問合せとインライン・ビュー問合せを結合して単一の問合せにしないようオプティマイザに指示します。
このヒントを使用すると、ビューへのアクセス方法に強い影響を与えることができます。たとえば、次の文は、ビューseattle_deptがマージされないようにします。
SELECT /*+NO_MERGE(seattle_dept)*/ e1.last_name, seattle_dept.department_name 
FROM employees e1, 
(SELECT location_id, department_id, department_name 
FROM departments 
WHERE location_id = 1700) seattle_dept 
WHERE e1.department_id = seattle_dept.department_id;
ビューの問合せブロック内でNO_MERGEヒントを使用する場合は、引数なしで指定します。また、周囲の問合せでNO_MERGEを指定する場合には、ビュー名を引数として指定します。
NO_PARALLELヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_PARALLELヒントは、表を作成するか変更したDDL内のPARALLELパラメータを上書きします。たとえば、次のようになります。
SELECT /*+ NO_PARALLEL(hr_emp) */ last_name
FROM employees hr_emp;
NOPARALLELヒント
NOPARALLELヒントは現在使用されていません。NO_PARALLELヒントをかわりに使用します。
NO_PARALLEL_INDEXヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
NO_PARALLEL_INDEXヒントは、索引を作成するか変更したDDL内のPARALLELパラメータを上書きし、パラレル索引スキャン操作を防止します。
NOPARALLEL_INDEXヒント
NOPARALLEL_INDEXヒントは現在使用されていません。NO_PARALLEL_INDEXヒントをかわりに使用します。
NO_PUSH_PREDヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_PUSH_PREDヒントは、結合述語をビューにプッシュしないようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_MERGE(v) NO_PUSH_PRED(v) */ *
FROM employees e,
(SELECT manager_id
FROM employees
) v
WHERE e.manager_id = v.manager_id(+)
AND e.employee_id = 100;
NO_PUSH_SUBQヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
NO_PUSH_SUBQヒントは、実行計画における最後の手順として、マージされていない副問合せを評価するようオプティマイザに指示します。これにより、副問合せのコストが比較的高い場合や、副問合せによって行数が大幅に減少しない場合に、パフォーマンスが向上する場合があります。
NO_PX_JOIN_FILTERヒント 
画像の説明
このヒントは、オプティマイザがパラレル結合のビットマップ・フィルタ処理を使用するのを防ぎます。
NO_REWRITEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
NO_REWRITEヒントは、パラメータQUERY_REWRITE_ENABLEDの設定を上書きして、問合せブロック用のクエリー・リライトを無効にするようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_REWRITE */ sum(s.amount_sold) AS dollars
FROM sales s, times t
WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
NOREWRITEヒント
NOREWRITEヒントは現在使用されていません。NO_REWRITEヒントをかわりに使用します。
NO_QUERY_TRANSFORMATIONヒント 
画像の説明
NO_QUERY_TRANSFORMATIONヒントは、すべての問合せ変換をスキップするようオプティマイザに指示します。この中には、OR拡張、ビュー・マージ、副問合せのネスト解除、スター型変換、マテリアライズド・ビュー・リライトなどが含まれますが、これのみに限定されません。たとえば、次のようになります。
SELECT /*+ NO_QUERY_TRANSFORMATION */ employee_id, last_name
FROM (SELECT *
FROM employees e) v
WHERE v.last_name = 'Smith';
NO_STAR_TRANSFORMATIONヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
NO_STAR_TRANSFORMATIONヒントは、問合せのスター型問合せ変換を実行しないようオプティマイザに指示します。
NO_UNNESTヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
NO_UNNESTヒントを使用するとネスト解除をオフに切り替えます。
NO_USE_HASHヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_USE_HASHヒントは、指定された表を内部表として使用して、指定された各表を別の行のソースに結合する際にハッシュ結合を除外するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_USE_HASH(e d) */ *
FROM employees e, departments d
WHERE e.department_id = d.department_id;
NO_USE_MERGEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_USE_MERGEヒントは、指定された表を内部表として使用して、指定された各表を別の行のソースに結合する際にソート/マージ結合を除外するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_USE_MERGE(e d) */ *
FROM employees e, departments d
WHERE e.department_id = d.department_id
ORDER BY d.department_id;
NO_USE_NLヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
NO_USE_NLヒントは、指定された表を内部表として使用して、指定された各表を別の行のソースに結合する際に、ネストしたループ結合を除外するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_USE_NL(l h) */ *
FROM orders h, order_items l
WHERE l.order_id = h.order_id
AND l.order_id > 3500;
このヒントを指定すると、指定された表についてハッシュ結合とソート/マージ結合のみが検討されます。ただし、ネストしたループのみを使用して表を結合する場合もあります。この場合、オプティマイザは、それらの表に関するヒントを無視します。
NO_XML_QUERY_REWRITEヒント
画像の説明
NO_XML_QUERY_REWRITEヒントは、SQL文のXPath式のリライトを禁止するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+NO_XML_QUERY_REWRITE*/ XMLQUERY('<A/>')
FROM dual;
ORDEREDヒント 
画像の説明
ORDEREDヒントは、FROM句に現れる順序で表を結合するようOracleに指示します。ORDEREDヒントより多目的なLEADINGヒントを使用することをお薦めします。
結合を要求するSQL文からORDEREDヒントを削除すると、オプティマイザが表の結合順序を選択します。各表から選択した行数をオプティマイザが把握していないと考えられる場合、ORDEREDヒントを使用して結合順序を指定することがあります。この情報を使用すると、オプティマイザによる選択よりも効率良く内部表と外部表を選択できます。
次の問合せは、ORDEREDヒントの使用例です。
SELECT  /*+ORDERED */ o.order_id, c.customer_id, l.unit_price * l.quantity
FROM customers c, order_items l, orders o
WHERE c.cust_last_name = :b1
AND o.customer_id = c.customer_id
AND o.order_id = l.order_id;
PARALLELヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
PARALLELヒントは、指定された数の同時サーバーをパラレル操作に使用するようオプティマイザに指示します。このヒントは、文のSELECT、INSERT、MERGE、UPDATEおよびDELETE部分と表のスキャン部分に適用されます。
注意:
ソート操作またはグループ操作も実行する場合、使用可能なサーバー数はPARALLELヒントの値の2倍となります。 
パラレル制限に違反すると、ヒントは無視されます。
integer値は、指定された表の並列度を指定します。DEFAULTを指定するか、いかなる値も指定しない場合、問合せコーディネータはデフォルトの並列度を決定するために初期化パラメータの設定を検証する必要があります。次の例では、PARALLELヒントが、employees表定義内で指定された並列度を上書きします。
SELECT /*+ FULL(hr_emp) PARALLEL(hr_emp, 5) */ last_name
FROM employees hr_emp;
次の例では、PARALLELヒントが、employees表定義内で指定された並列度を上書きし、初期化パラメータが決定したデフォルトの並列度を使用するようオプティマイザに指示します。
SELECT /*+ FULL(hr_emp) PARALLEL(hr_emp, DEFAULT) */ last_name
FROM employees hr_emp;
Oracleは、一時表に関するパラレル・ヒントを無視します。パラレル実行の詳細は、「CREATE TABLE」および『Oracle Database概要』を参照してください。
PARALLEL_INDEXヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
PARALLEL_INDEXヒントは、パーティション索引について索引レンジ・スキャンをパラレル化するために、指定された数の同時サーバーを使用するようオプティマイザに指示します。
integer値は、指定された索引の並列度を示します。DEFAULTを指定するか、いかなる値も指定しない場合、問合せコーディネータはデフォルトの並列度を決定するために初期化パラメータの設定を検証する必要があります。たとえば、次のヒントは、3つのパラレル実行プロセスが使用されることを示します。
SELECT /*+ PARALLEL_INDEX(table1, index1, 3) */
PQ_DISTRIBUTEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
PQ_DISTRIBUTEヒントは、結合表の行を、プロデューサおよびコンシューマ問合せサーバーに分散させる方法をオプティマイザに指示します。この分散処理により、パラレル結合操作のパフォーマンスが向上します。
outer_distributionは、外部表への分散処理です。
inner_distributionは、内部表への分散処理です。
分散の値は、HASH、BROADCAST、PARTITIONおよびNONEです。表2-22で説明するとおり、6つの組合せの表分散のみが有効です。
表2-22    分散ヒントの組合せ 
分散 
説明 
HASH、HASH 
各表の行は、結合キーにハッシュ関数を使用して、コンシューマ問合せサーバーにマップされます。マッピングが完了すると、各問合せサーバーは、結果として生成されるパーティションの組で結合を実行します。この分散は、表のサイズがほぼ等しく、結合操作がハッシュ結合またはソート/マージ結合で実施される場合にお薦めします。 
BROADCAST、NONE 
外部表のすべての行が各問合せサーバーにブロードキャストされます。内部表の行は、ランダムにパーティション化されます。この分散は、外部表のサイズが内部表よりもきわめて小さい場合にお薦めします。一般的に、内部表のサイズに問合せサーバーの数を乗じた数値が外部表のサイズよりも大きい場合、この分散を使用します。 
NONE、BROADCAST 
内部表のすべての行が各コンシューマ問合せサーバーにブロードキャストされます。外部表の行は、ランダムにパーティション化されます。この分散は、内部表のサイズが外部表よりもきわめて小さい場合にお薦めします。一般的に、内部表のサイズに問合せサーバーの数を乗じた数値が外部表のサイズより小さい場合、この分散を使用します。 
PARTITION、NONE 
外部表の行は、内部表のパーティション化を使用してマップされます。内部表は、結合キーでパーティション化されている必要があります。この分散は、外部表のパーティションの数が問合せサーバーの数と等しいかほぼ等しい(たとえば、パーティション数が14で問合せサーバー数が15)場合にお薦めします。
注意: オプティマイザは、内部表がパーティション化されていないか、パーティション化キーと等価結合関係にない場合、このヒントを無視します。 
NONE、PARTITION 
内部表の行は、外部表のパーティション化を使用してマップされます。外部表は、結合キーでパーティション化されている必要があります。この分散は、外部表のパーティションの数が問合せサーバーの数と等しいかほぼ等しい(たとえば、パーティション数が14で問合せサーバー数が15)場合にお薦めします。
注意: オプティマイザは、外部表がパーティション化されていないか、パーティション化キーと等価結合関係にない場合、このヒントを無視します。 
NONE、NONE 
各問合せサーバーは、各表から抽出した一致パーティションの組で結合操作を実行します。両方の表は、結合キーに基づいて同一レベルでパーティション化されている必要があります。 
たとえば、rとsという2つの表がハッシュ結合によって結合されている場合、次の問合せには、ハッシュ分散を使用するためのヒントが含まれます。
SELECT /*+ORDERED PQ_DISTRIBUTE(s HASH, HASH) USE_HASH (s)*/ column_list
FROM r,s
WHERE r.c=s.c;
外部表rをブロードキャストするための問合せは、次のとおりです。
SELECT /*+ORDERED PQ_DISTRIBUTE(s BROADCAST, NONE) USE_HASH (s) */ column_list
FROM r,s
WHERE r.c=s.c;
参照:
Oracleでの結合操作のパラレル化の詳細は、『Oracle Database概要』を参照してください。 
PUSH_PREDヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
PUSH_PREDヒントは、結合述語をビューにプッシュするようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ NO_MERGE(v) PUSH_PRED(v) */ *
FROM employees e,
(SELECT manager_id
FROM employees
) v
WHERE e.manager_id = v.manager_id(+)
AND e.employee_id = 100;
PUSH_SUBQヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
PUSH_SUBQヒントは、実行計画の初期段階で実行可能な手順で、マージされていない副問合せを評価するようオプティマイザに指示します。通常、マージされていない副問合せは、実行計画の最終手順で実行されます。副問合せのコストが比較的低く、副問合せによって行数が大幅に減少する場合、副問合せの早期評価によってパフォーマンスが向上する可能性があります。
このヒントは、副問合せがリモート表か、マージ結合によって結合されている表に適用される場合には効果がありません。
PX_JOIN_FILTERヒント 
画像の説明
このヒントは、パラレル結合のビットマップ・フィルタ処理の使用をオプティマイザに強制します。
QB_NAMEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
QB_NAMEヒントを使用すると、問合せブロックの名前を定義できます。この名前は外部問合せ内のヒントまたはインライン・ビュー内のヒントで使用でき、名前が付けられた問合せブロックにある表で実行する問合せに影響をおよぼします。
2つ以上の問合せブロックが同じ名前の場合、または同じ問合せブロックが異なる名前でヒントが2回行われている場合、オプティマイザは、その問合せブロックを参照するすべての名前とヒントを無視します。このヒントを使用して名前が付けられていない問合せブロックには、システムが生成する一意の名前が付けられます。この名前は計画表に表示できます。また、問合せブロック内のヒントや問合せブロック・ヒントでも使用できます。たとえば、次のようになります。
SELECT /*+ QB_NAME(qb) FULL(@qb e) */ employee_id, last_name
FROM employees e
WHERE last_name = 'Smith';
REWRITEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
REWRITEヒントは、可能な場合、コストを考慮することなく、マテリアライズド・ビューに関する問合せをリライトするようオプティマイザに指示します。REWRITEヒントは、ビュー・リストとともに、またはビュー・リストなしで使用します。ビュー・リストとともにREWRITEを使用し、リストに適切なマテリアライズド・ビューが含まれている場合、Oracleはコストを考慮せずにそのビューを使用します。
Oracleでは、リスト外のビューを検討しません。ビュー・リストを指定しない場合、Oracleは適切なマテリアライズド・ビューを検索し、最終計画のコストを考慮することなく常にそのビューを使用します。
参照:
マテリアライズド・ビューの詳細は、
『Oracle Database概要』および『Oracle Databaseアドバンスト・レプリケーション』を参照してください。
マテリアライズド・ビューでREWRITEを使用する場合の詳細は、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
RULEヒント 
画像の説明
RULEヒントは、オプティマイザの使用を無効にします。このヒントはサポートされていないため、使用できません。
STAR_TRANSFORMATIONヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
STAR_TRANSFORMATIONヒントは、変換を行う際に最適な計画を使用するようオプティマイザに指示します。このヒントを使用しない場合、オプティマイザは、変換された問合せ用の最適な計画のかわりに、変換なしで生成された最適な計画を使用するという、問合せの最適化に関する決定を行う場合があります。たとえば、次のようになります。
SELECT /*+ STAR_TRANSFORMATION */  *
FROM sales s, times t, products p, channels c
WHERE s.time_id = t.time_id
AND s.prod_id = p.product_id
AND s.channel_id = c.channel_id
AND p.product_status = 'obsolete';
ヒントが指定された場合でも、変換が実行される保証はありません。オプティマイザは、妥当と考えられる場合にかぎって副問合せを生成します。副問合せが生成されない場合には、変換された問合せが存在しないため、ヒントに関係なく、未変換の問合せに関する最適な計画が使用されます。
参照:
スター型変換の詳細は、『Oracle Databaseデータ・ウェアハウス・ガイド』を参照してください。
STAR_TRANSFORMATION_ENABLED初期化パラメータの詳細は、『Oracle Databaseリファレンス』を参照してください。
UNNESTヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
UNNESTヒントは、副問合せの本体のネストを解除し、その副問合せを含む問合せブロック本体にマージするようオプティマイザに指示します。これによって、アクセス・パスおよび結合の評価時に、オプティマイザが副問合せと問合せブロックを総合して考慮できるようになります。
副問合せのネストを解除する前に、オプティマイザは、文が有効かどうかをまず検討します。文は、経験則に基づくテストと問合せ最適化テストに合格する必要があります。UNNESTヒントは、副問合せブロックの有効性のみをチェックするようオプティマイザに指示します。副問合せブロックが有効な場合、経験則またはコストをチェックすることなく副問合せのネストを解除できます。
参照:
ネスト化された副問合せのネスト解除、および副問合せブロックが有効となる条件については、「コレクションのネスト解除例:」を参照してください
副問合せのネスト解除の詳細は、『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。
USE_CONCATヒント 
画像の説明
(「ヒントでの問合せブロックの指定」を参照)
USE_CONCATヒントは、問合せのWHERE句内で組み合わされたOR条件を、集合演算子UNION ALLを使用して複合問合せに変換するようオプティマイザに指示します。このヒントを使用しない場合、この変換は、連結を使用した問合せのコストが、使用しない場合よりも低い場合にのみ実行されます。USE_CONCATヒントは、コストより優先します。たとえば、次のようになります。
SELECT /*+ USE_CONCAT */ *
FROM employees e
WHERE manager_id = 108
OR department_id = 110;
参照:
OR拡張の詳細については、このヒントの反対の機能である「NO_EXPANDヒント」、および『Oracle Databaseパフォーマンス・チューニング・ガイド』を参照してください。 
USE_HASHヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
USE_HASHヒントは、指定された各表を、ハッシュ結合を使用して別の行のソースに結合するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ USE_HASH(l h) */ *
FROM orders h, order_items l
WHERE l.order_id = h.order_id
AND l.order_id > 3500;
USE_MERGEヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
USE_MERGEヒントは、指定された各表を、ソート/マージ結合を使用して別の行のソースに結合するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ USE_MERGE(employees departments) */ * 
FROM employees, departments 
WHERE employees.department_id = departments.department_id; 
LEADINGおよびORDEREDヒントとともに、USE_NLおよびUSE_MERGEヒントを使用することをお薦めします。オプティマイザは、参照表を結合の内部表にする必要がある場合に、これらのヒントを使用します。参照表が外部表の場合、ヒントは無視されます。
USE_NLヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=を参照)
USE_NLヒントは、指定された表を内部表として使用し、指定された各表をネストしたループ結合とともに別の行のソースに結合するようオプティマイザに指示します。
LEADINGおよびORDEREDヒントとともに、USE_NLおよびUSE_MERGEヒントを使用することをお薦めします。オプティマイザは、参照表を結合の内部表にする必要がある場合に、これらのヒントを使用します。参照表が外部表の場合、ヒントは無視されます。
次の例では、ネストしたループがヒントによって強制される場合、全表スキャンを介してordersがアクセスされ、各行にフィルタ条件l.order_id = h.order_idが適用されます。フィルタ条件を満たす各行については、索引order_idを介してorder_itemsがアクセスされます。
SELECT /*+ USE_NL(l h) */ h.customer_id, l.unit_price * l.quantity
FROM orders h ,order_items l
WHERE l.order_id = h.order_id;
INDEXヒントを問合せに追加すると、ordersの全表スキャンを回避し、より大規模なシステムで使用される実行計画と同様の実行計画を生成できる場合があります。ただし、ここでは特に効果的ではない場合があります。
USE_NL_WITH_INDEXヒント 
画像の説明
(「ヒントでの問合せブロックの指定」、tablespec::=、indexspec::=を参照)
USE_NL_WITH_INDEXヒントは、指定された表を内部表として使用し、指定された表をネストしたループ結合とともに別の行のソースに結合するようオプティマイザに指示します。たとえば、次のようになります。
SELECT /*+ USE_NL_WITH_INDEX(l item_product_ix) */ *
FROM orders h, order_items l
WHERE l.order_id = h.order_id
AND l.order_id > 3500;
次の条件が適用されます。
索引を指定しない場合、オプティマイザは、1つ以上の結合述語とともに、索引キーとして一部の索引を使用できる必要があります。
索引を指定する場合、オプティマイザは、1つ以上の結合述語とともに、索引キーとしてその索引を使用できる必要があります。
データベース・オブジェクト
次の項で説明するとおり、Oracleデータベースは、特定のスキーマに対応付けられたオブジェクトと、特定のスキーマに対応付けられていないオブジェクトを認識します。
スキーマ・オブジェクト 
スキーマは、論理的なデータの構造(スキーマ・オブジェクト)の集まりです。スキーマは、データベース・ユーザーによって所有され、そのユーザーと同じ名前を持ちます。各ユーザーは、1つのスキーマを所有します。スキーマ・オブジェクトは、SQLを使用して作成および操作できます。スキーマ・オブジェクトには次のタイプのオブジェクトがあります。
クラスタ
制約
データベース・リンク
データベース・トリガー
ディメンション
外部プロシージャ・ライブラリ
索引構成表
索引
索引タイプ
Javaクラス、Javaリソース、Javaソース
マテリアライズド・ビュー
マテリアライズド・ビュー・ログ
オブジェクト表
オブジェクト型
オブジェクト・ビュー
演算子
パッケージ
順序
ストアド・ファンクション、ストアド・プロシージャ
シノニム
表
ビュー
非スキーマ・オブジェクト 
次のタイプのオブジェクトもデータベースに格納され、SQLで作成および操作されますが、スキーマには含まれません。
コンテキスト
ディレクトリ
パラメータ・ファイル(PFILE)およびサーバー・パラメータ・ファイル(SPFILE)
プロファイル
ロール
ロールバック・セグメント
表領域
ユーザー
各タイプのオブジェクトは、このマニュアルの第10章〜第19章のデータベース・オブジェクトを作成する文の項で簡単に定義されています。これらの文は、キーワードCREATEで始まります。たとえば、クラスタの定義については、「CREATE CLUSTER」を参照してください。
参照:
データベース・オブジェクトの概要については、『Oracle Database概要』を参照してください。 
ほとんどのデータベース・オブジェクトでは、作成時に名前を指定する必要があります。名前は、この後の項に示す規則に従って付けてください。
スキーマ・オブジェクト名および修飾子
スキーマ・オブジェクトの中には、名前を付けることができる、または名前を付ける必要のある部分で構成されるものもあります。たとえば、表やビューの中の列、索引と表のパーティションおよびサブパーティション、表に対する整合性制約、パッケージ内に格納されるオブジェクト(プロシージャおよびストアド・ファンクションを含む)などです。この項では、次の内容について説明します。
スキーマ・オブジェクトとスキーマ・オブジェクトの位置修飾子のネーミング規則
スキーマ・オブジェクトと修飾子のネーミングのガイドライン
スキーマ・オブジェクトのネーミング規則 
すべてのデータベース・オブジェクトには、名前があります。SQL文では、引用識別子または非引用識別子を使用して、オブジェクトの名前を表します。
引用識別子は、二重引用符(")で囲みます。引用識別子を使用してスキーマ・オブジェクトを指定した場合、そのオブジェクトを参照するときは、必ず二重引用符を使用します。
非引用識別子の前後に句読点は付けません。
データベース・オブジェクトを指定する場合、引用識別子または非引用識別子を使用できます。データベース名、グローバル・データベース名およびデータベース・リンク名では大/小文字は区別されませんが、大文字として保存されます。このような名前を引用識別子として指定する場合、引用符は特に警告もなく無視されます。ユーザー名とパスワードのネーミング規則の詳細は、「CREATE USER」を参照してください。
特に指定がないかぎり、次の規則は、引用識別子と非引用識別子の両方に適用されます。
名前は、1〜30バイトの長さで指定する必要があります。ただし、次の2つは例外です。
データベースの名前は、8バイトまでに制限されています。
データベース・リンクの名前は、128バイトまで指定できます。
識別子にピリオドで区切られた複数の部分が含まれる場合、各属性の長さは最大30バイトにできます。ピリオドによる各セパレータおよび周囲の二重引用符は1バイトとしてカウントします。たとえば、次のように列を識別するとします。
"schema"."table"."column"
スキーマ名、表名、列名の長さはそれぞれ30バイトです。各引用符やピリオドはシングルバイト文字のため、この例での識別子の総バイト長は、最大98バイトになります。
非引用識別子にOracleデータベースの予約語は使用できません。引用識別子には、予約語を使用できますが、お薦めしません。
名前は、データベース・オブジェクトにアクセスするために使用するOracle製品固有のその他の予約語によって、さらに制限されることもあります。
注意:
予約語ROWIDは、この規則の例外です。引用識別子または非引用識別子のいずれであっても、大文字のROWIDを列名として使用することはできません。ただし、列名ではない引用識別子には大文字を使用できます。また列名を含む引用識別子には、1つ以上の小文字(たとえば、"Rowid"や"rowid")を使用できます。 
参照:
Oracleデータベースの予約語のすべてのリストは、付録D「Oracleデータベース予約語」を参照してください。
製品の予約語のリストについては、『Oracle Database PL/SQLユーザーズ・ガイドおよびリファレンス』などの各製品のマニュアルを参照してください。
OracleのSQL言語には、特別な意味を持つ文字が含まれています。これらの文字には、データ型、スキーマ名、ファンクション名、ダミーのシステム表DUALおよびキーワード(DIMENSION、SEGMENT、ALLOCATE、DISABLEなど、SQL文中の大文字の単語)が含まれます。これらの文字は予約語ではありません。ただし、Oracleは固有の方法でこれらの文字を内部的に使用します。したがって、これらの文字をオブジェクトおよびオブジェクトの部分の名前として使用した場合、使用しているSQL文が読みにくくなり、予期しない結果になることがあります。
特に、SYS_で始まる文字をスキーマ・オブジェクト名として使用しないでください。また、SQL組込みファンクションの名前を、スキーマ・オブジェクトまたはユーザー定義ファンクションの名前として使用しないでください。
参照:
「データ型」、「SQLファンクション」および「DUAL表からの選択」を参照してください。 
異なるプラットフォームおよびオペレーティング・システム間では、ASCII文字を使用することで最適な互換性を得ることができます。データベース名、グローバル・データベース名、データベース・リンク名にはASCII文字を使用してください。
注意:
ユーザー名およびパスワードは、ご使用のプラットフォームに応じて、ASCIIまたはEBCDIC文字のみでエンコードすることをお薦めします。詳細は、『Oracle Database管理者ガイド』を参照してください。 
非引用識別子は、データベース・キャラクタ・セットのアルファベット文字で開始する必要があります。引用識別子の開始文字には、任意の文字を使用できます。
非引用識別子には、データベース・キャラクタ・セットの英数字、アンダースコア(_)、ドル記号($)およびシャープ記号(#)のみ含めることができます。データベース・リンクの名前には、ピリオド(.)とアットマーク(@)を含めることもできます。非引用識別子では、$と#はできるだけ使用しないでください。
引用識別子には、すべての文字、句読点および空白を使用できます。ただし、引用識別子と非引用識別子のいずれにも、二重引用符またはNULL文字(たとえば\0)は使用できません。
ネームスペース内では、2つのオブジェクトに同じ名前を付けることはできません。
次のスキーマ・オブジェクトは、1つのネームスペースを共有します。
表
ビュー
順序
プライベート・シノニム
スタンドアロン・プロシージャ
スタンドアロン・ストアド・ファンクション
パッケージ
マテリアライズド・ビュー
ユーザー定義型
次の各スキーマ・オブジェクトは、固有のネームスペースを持ちます。
索引
制約
クラスタ
データベース・トリガー
プライベート・データベース・リンク
ディメンション
表およびビューが同じネームスペースにあるため、同じスキーマの表およびビューが同じ名前を持つことはできません。ただし、表と索引は異なるネームスペースに存在します。このため、同じスキーマ内の表と索引には、同じ名前を付けることができます。
データベース内の各スキーマには、その中のオブジェクトのために固有のネームスペースがあります。たとえば、異なるスキーマ内の2つの表は異なるネームスペースに存在し、同じ名前を付けることができます。
次の各非スキーマ・オブジェクトは、固有のネームスペースを持ちます。
ユーザー・ロール
パブリック・シノニム
パブリック・データベース・リンク
表領域
プロファイル
パラメータ・ファイル(PFILE)およびサーバー・パラメータ・ファイル(SPFILE)
これらのネームスペース内のオブジェクトはスキーマに含まれないため、これらのネームスペースはデータベース全体で使用されます。
非引用識別子は、大/小文字が区別されず、すべて大文字として解析されます。引用識別子は、大/小文字が区別されます。
名前を二重引用符で囲むことによって、同じネームスペース内の異なるオブジェクトに対して次の名前を指定できます。
employees
"employees"
"Employees"
"EMPLOYEES"
ただし、Oracleは次の名前を同じ名前として解析するため、同じネームスペース内の異なるオブジェクトには、次の名前を使用できません。
employees
EMPLOYEES
"EMPLOYEES"
同じ表やビューでは、複数の列に同じ名前を付けることはできません。ただし、異なる表やビューでは、複数の列に同じ名前を付けることができます。
引数の数およびデータ型が異なる場合、同じパッケージに含まれるプロシージャやファンクションに同じ名前を付けることができます。異なる引数を持ち、同じ名前のプロシージャやファンクションを同じパッケージ内に複数作成することを、オーバーロードといいます。
スキーマ・オブジェクトのネーミング例 
次に、有効なスキーマ・オブジェクト名の例を示します。
last_name
horse
hr.hire_date
"EVEN THIS & THAT!"
a_very_long_and_valid_name
これらのすべての例は、「スキーマ・オブジェクトのネーミング規則」に示す規則に従っています。次の例は、30文字を超えているため、無効となります。
a_very_very_long_and_valid_name
列別名、表別名、ユーザー名およびパスワードは、オブジェクトまたはオブジェクトの部分ではありませんが、特に指定がないかぎり、同様にこれらのネーミング規則に従う必要があります。
スキーマ・オブジェクトのネーミングのガイドライン 
オブジェクトとその部分に名前を付ける場合に有効なガイドラインを次に示します。
わかりやすい名前(またはよく知られている省略形)を使用します。
一貫したネーミング規則を使用します。
複数の表にまたがる同一のエンティティや属性を記述するためには、同一の名前を使用します。
オブジェクトに名前を付ける場合は、短くて簡単な名前とわかりやすい名前のバランスを考えてください。迷ったときには、わかりやすい名前にしてください。これは、データベース内のオブジェクトは、多くの人々が長期間にわたって使用する可能性があるためです。payment_due_dateのかわりにpmddという名前を使用すると、10年後の担当者は表の列の理解に苦労することになります。
一貫したネーミング規則を使用すると、アプリケーション上の各表の働きが理解しやすくなります。そのような規則の例として、FINANCEアプリケーションに属している表の名前をすべてfin_で始めるような場合が考えられます。
同一のエンティティや属性に対しては、複数の表にまたがっていても同じ名前を使用してください。たとえば、employeesサンプル表とdepartmentsサンプル表の部門番号列には、どちらにもdepartment_idという名前を付けます。
スキーマ・オブジェクトの構文およびSQL文の構成要素
SQL文のコンテキストでスキーマ・オブジェクトとそれらの部分を参照する方法について説明します。次の項目について説明します。
オブジェクトを参照するための一般的な構文
Oracleがオブジェクトへの参照を変換する方法
自分のスキーマ以外のスキーマ内のオブジェクトを参照する方法
リモート・データベース内のオブジェクトを参照する方法
表と索引のパーティションおよびサブパーティションを参照する方法
次に、オブジェクトやそれらの部分を参照するための一般的な構文を示します。
database_object_or_part::=
画像の説明
それぞれの意味は、次のとおりです。
objectは、オブジェクトの名前です。
schemaは、オブジェクトを含むスキーマです。この修飾子を指定することによって、自分のスキーマ以外のスキーマ内のオブジェクトを参照できます。その場合には、自分のスキーマ以外のスキーマ内のオブジェクトを参照するための権限が必要です。この修飾子を指定しないと、自分自身のスキーマ内のオブジェクトを参照するものとみなされます。
スキーマ・オブジェクトのみがschemaで修飾できます。スキーマ・オブジェクトについては、規則7を参照してください。規則7に示す非スキーマ・オブジェクトはスキーマ・オブジェクトではないため、schemaでは修飾できません。ただし、パブリック・シノニムは例外で、「PUBLIC」で修飾できます。この場合、引用符が必要です。
partは、オブジェクトの部分です。この識別子によって、スキーマ・オブジェクトの部分(たとえば、表の列またはパーティション)を参照できます。なお、すべてのタイプのオブジェクトが部分を持っているとはかぎりません。
dblinkは、Oracleデータベースの分散オプションを使用している場合にのみ適用されます。オブジェクトを含むデータベースの名前です。この修飾子dblinkを指定することによって、ローカル・データベース以外のデータベース内のオブジェクトを参照できます。このdblinkを指定しないと、自分自身のローカル・データベース内のオブジェクトを参照するものとみなされます。なお、すべてのSQL文でリモート・データベースのオブジェクトにアクセスできるとはかぎりません。
オブジェクトを参照する際のコンポーネントを区切っているピリオドの前後には、空白を入れることができます。ただし、通常は入れません。
Oracleデータベースによるスキーマ・オブジェクト参照の変換方法
SQL文内のオブジェクトが参照される場合、OracleはそのSQL文のコンテキストを検討して、該当するネームスペース内でそのオブジェクトの位置を確認します。そのオブジェクトの位置を確認してから、そのオブジェクトに対して文が指定する操作を実行します。指定した名前のオブジェクトが適切なネームスペース内に存在しない場合、Oracleはエラーを戻します。
次の例で、OracleがSQL文内のオブジェクト参照を変換する方法について説明します。名前departmentsで識別される表にデータ行を追加する次の文を考えます。
INSERT INTO departments VALUES (
280, 'ENTERTAINMENT_CLERK', 206, 1700);
文のコンテキストに基づいて、Oracleは、departmentsが次のようなオブジェクトであると判断します。
自分のスキーマ内の表
自分のスキーマ内のビュー
表またはビューに対するプライベート・シノニム
パブリック・シノニム
Oracleは、文を発行したユーザーのスキーマ外のネームスペースを考慮する前に、そのユーザーのスキーマ内のネームスペースからオブジェクト参照を変換しようとします。この例では、Oracleは次の方法で名前departmentsを変換しようとします。
Oracleは、最初に、表、ビューおよびプライベート・シノニムを含む文を発行したユーザーのスキーマ内のネームスペースで、オブジェクトの位置を確認しようとします。オブジェクトがプライベート・シノニムの場合、Oracleはそのシノニムが表すオブジェクトの位置を確認します。このオブジェクトは、ユーザー自身のスキーマ、他のスキーマ、または他のデータベースにあることもあります。このオブジェクトが別のシノニムである場合もあります。その場合、Oracleはそのシノニムが表すオブジェクトの位置を確認します。
オブジェクトがネームスペース内に存在する場合、Oracleはそのオブジェクトに対して文を実行しようとします。この例では、Oracleはデータ行をdepartmentsに追加しようとします。オブジェクトがその処理にとって正しい型でない場合、Oracleはエラーを戻します。この場合、departmentsは、表またはビュー、あるいは表またはビューとなるプライベート・シノニムである必要があります。departmentsが順序である場合、Oracleはエラーを戻します。
前述の処理で検索されたネームスペースにオブジェクトが存在しない場合、Oracleはパブリック・シノニムを含むネームスペースを検索します。オブジェクトがそのネームスペースに存在する場合、Oracleはそのオブジェクトに対して文を実行しようとします。オブジェクトがその処理にとって正しい型でない場合、Oracleはエラーを戻します。この例では、departmentsが順序のパブリック・シノニムである場合、Oracleはエラーを戻します。
パブリック・シノニムに、依存表またはユーザー定義型がある場合は、依存オブジェクトと同じスキーマに、シノニムと同じ名前でオブジェクトを作成することはできません。
シノニムに、依存表またはユーザー定義型がない場合は、依存オブジェクトと同じスキーマに、依存オブジェクトと同じ名前で、オブジェクトを作成できます。すべての依存オブジェクトが無効になり、次のアクセス時に妥当性チェックが再実行されます。
参照:
PL/SQLのデータ型については、『Oracle Database PL/SQLユーザーズ・ガイドおよびリファレンス』を参照してください。 
他のスキーマ内のオブジェクトの参照 
自分が所有するスキーマ以外のスキーマ内のオブジェクトを参照するには、次のように、オブジェクト名の前にスキーマ名を付けます。
schema.object
たとえば、次の文は、サンプル・スキーマhr内のemployees表を削除します。
DROP TABLE hr.employees
リモート・データベース内のオブジェクトの参照 
ローカル・データベース以外のデータベース内のオブジェクトを参照するには、オブジェクト名の後に、そのデータベースへのデータベース・リンクの名前を続けます。データベース・リンクはスキーマ・オブジェクトであり、これによってOracleがリモート・データベースに接続され、そこにあるオブジェクトにアクセスします。この項では、次の項目について説明します。
データベース・リンクを作成する方法
SQL文でデータベース・リンクを使用する方法
データベース・リンクの作成 
「CREATE DATABASE LINK」を使用して、データベース・リンクを作成します。この文では、データベース・リンクに関する次の情報を指定できます。
データベース・リンク名
リモート・データベースにアクセスするためのデータベース接続文字列
リモート・データベースに接続するためのユーザー名およびパスワード
これらの情報はデータ・ディクショナリに格納されます。
データベース・リンク名
データベース・リンクを作成するとき、データベース・リンク名を指定する必要があります。データベース・リンク名は、他のオブジェクト型の名前とは異なります。データベース・リンク名は128バイト以内の長さで指定し、ピリオド(.)とアットマーク(@)を使用できます。
データベース・リンクに付ける名前は、データベース・リンクが参照するデータベースの名前、およびデータベース名の階層内のそのデータベースの位置に一致している必要があります。次に、データベース・リンク名の書式を示します。
dblink::=
画像の説明
それぞれの意味は、次のとおりです。
databaseには、データベース・リンクが接続するリモート・データベースのグローバル名の名前の部分を指定します。このグローバル名は、リモート・データベースのデータ・ディクショナリに格納されます。この名前は、GLOBAL_NAMEデータ・ディクショナリ・ビューで見ることができます。
domainには、データベース・リンクが接続するリモート・データベースのグローバル名のドメイン部分を指定します。データベース・リンクの名前にdomainを指定しないと、Oracleは、現在、データ・ディクショナリに存在しているローカル・データベースのドメインに、データベース・リンク名を付加します。
connect_descriptorによって、データベース・リンクをさらに修飾できます。接続修飾子を使用する場合、同じデータベースに複数のデータベース・リンクを作成できます。たとえば、接続修飾子を使用して、同じデータベースにアクセスするReal Application Clustersの異なるインスタンスに、複数のデータベース・リンクを作成できます。
database.domainの組合せは、サービス名と呼ばれることもあります。
参照:
『Oracle Database Net Services管理者ガイド』 
ユーザー名およびパスワード
リモート・データベースに接続するために、ユーザー名およびパスワードを使用します。データベース・リンクでは、ユーザー名およびパスワードはオプションです。
データベース接続文字列
データベース接続文字列は、Oracle Netがリモート・データベースにアクセスするために使用する仕様です。データベース接続文字列の記述方法については、使用しているネットワーク・プロトコル用のOracle Netのドキュメントを参照してください。データベース・リンク用のデータベース文字列はオプションです。
データベース・リンクの参照 
データベース・リンクは、分散オプションを指定してOracleを使用している場合にのみ利用できます。データベース・リンクを含むSQL文の発行時に、次のいずれかの方法でデータベース・リンク名を指定します。
データ・ディクショナリ内に格納される、database、domain、およびオプションのconnect_descriptorコンポーネントを含む完全なデータベース・リンク名を指定します。
databaseおよびオプションのconnect_descriptorコンポーネントを含むが、domainコンポーネントを含まない、部分的なデータベース・リンク名を指定します。
Oracleは、リモート・データベースに接続する前に次のタスクを実行します。
文中に指定されているデータベース・リンク名が部分指定の場合、Oracleは、データ・ディクショナリ内に格納されているグローバル・データベース名に見られるとおり、そのリンク名にローカル・データベースのドメイン名を付加します。現在のグローバル・データベース名は、GLOBAL_NAMEデータ・ディクショナリ・ビューで見ることができます。
Oracleは、最初に、文を発行したユーザーのスキーマ内で、文の中のデータベース・リンクと同じ名前を持つプライベート・データベース・リンクを検索します。必要に応じて、同じ名前を持つパブリック・データベース・リンクを検索します。
Oracleは、必ず最初に一致したデータベース・リンク(プライベートまたはパブリック)のユーザー名およびパスワードを採用します。最初に一致したデータベース・リンクに対応付けられているユーザー名およびパスワードがあると、Oracleはそれを使用します。対応付けられているユーザー名およびパスワードがない場合、Oracleは、現在のユーザー名およびパスワードを使用します。
最初に一致したデータベース・リンクに対応付けられているデータベース文字列が存在する場合、Oracleは、そのデータベース文字列を使用します。データベース文字列がない場合、Oracleは一致する次の(パブリック)データベース・リンクを検索します。一致するデータベース・リンクが存在しない場合、または一致するリンクに対応付けられているデータベース文字列が存在しない場合、Oracleはエラーを戻します。
Oracleは、リモート・データベースにアクセスするためにデータベース文字列を使用します。リモート・データベースにアクセスした後で、GLOBAL_NAMESパラメータの値がtrueの場合は、Oracleは、データベース・リンク名のdatabase.domain部分がリモート・データベースの完全なグローバル名に一致しているかどうかを確認します。この条件が満たされている場合、Oracleは手順2で選択したユーザー名とパスワードを使用して接続を続行します。それ以外の場合、Oracleはエラーを戻します。
データベース文字列、ユーザー名およびパスワードを使用した接続が成功した場合、Oracleは、リモート・データベース上の指定されたオブジェクトにアクセスしようとします。このとき、この項の前半で説明した、オブジェクト参照を変換するための規則、および他のスキーマ内のオブジェクトを参照するための規則が使用されます。
リモート・データベースの完全なグローバル名が、データベース・リンクのdatabase.domain部分と一致する必要があるという要件を無効にするには、初期化パラメータGLOBAL_NAMESか、ALTER SYSTEMまたはALTER SESSION文のGLOBAL_NAMESパラメータにfalseを設定します。
参照:
リモート・データベースの名前の変換の詳細は、『Oracle Database管理者ガイド』を参照してください。 
パーティション表と索引の参照 
表および索引はパーティション化できます。パーティション化されたスキーマ・オブジェクトは、パーティションと呼ばれる多数の部分で構成され、各パーティションのすべての論理属性は同じです。たとえば、表のパーティションはすべて同じ列定義と制約定義を共有し、索引のパーティションはすべて同じ索引列を共有します。
拡張パーティションおよび拡張サブパーティション名を使用した場合、1つのパーティションまたはサブパーティションのみ、パーティション・レベルおよびサブパーティション・レベルの操作(あるパーティションまたはサブパーティションからのすべての行の削除など)ができます。拡張された名前がない場合、そのような操作には述語(WHERE句)を指定する必要があります。レンジおよびリスト・パーティション表では、パーティション・レベル操作を述語で表そうとすると(特にレンジ・パーティション・キーで複数の列を使用しているときは)、非常に複雑になる可能性があります。ハッシュ・パーティションおよびサブパーティションの場合、述語の使用はより難しくなります。これは、これらのパーティションおよびサブパーティションが、システムが定義するハッシュ・ファンクションに基づいているためです。
拡張パーティション名を使用した場合、パーティションを表のように使用できます。この方法のメリットは、これらのビューに対する権限を他のユーザーやロールに付与する(または取り消す)ことによって、パーティション・レベルのアクセス制御機構を構築できることです。このメリットは、レンジ・パーティション表に最も有効です。パーティションを表として使用するには、単一のパーティションからデータを選択してビューを作成し、そのビューを表として使用します。
次のデータ操作言語(DML)文では、拡張パーティションまたは拡張サブパーティションの表名を指定できます。
DELETE
INSERT
LOCK TABLE
SELECT
UPDATE
構文
拡張パーティション表名および拡張サブパーティション表名を使用する場合の基本的な構文は次のとおりです。
partition_extended_name::=
画像の説明
拡張表名の制限事項:
現在、拡張パーティション表名および拡張サブパーティション表名を使用するときには、次の制限があります。
リモート表は使用できません。拡張パーティション表名または拡張サブパーティション表名には、データベース・リンク(dblink)、またはdblinkを使用して表に変換するシノニムを含めることはできません。リモート・パーティションおよびリモート・サブパーティションを使用するには、拡張表名の構文を使用してリモート・サイトにビューを作成し、そのリモート・ビューを参照します。
シノニムは使用できません。拡張パーティションまたは拡張サブパーティションは、実表を使用して指定する必要があります。シノニム、ビューまたはその他のオブジェクトは使用できません。
例
次の文のsalesは、パーティションsales_q1_2000を持つパーティション表です。単一パーティションsales_q1_2000のビューを作成でき、それを表のように使用できます。この例では、パーティションから行が削除されます。
CREATE VIEW Q1_2000_sales AS
SELECT * FROM sales PARTITION (SALES_Q1_2000);
DELETE FROM Q1_2000_sales WHERE amount_sold < 0; 
オブジェクト型の属性とメソッドの参照
SQL文のオブジェクト型の属性とメソッドを参照するには、参照を表の別名で完全に修飾する必要があります。次の例では、cust_address_typ型、およびcust_address_typに基づくcust_address列を持つ表customersを含むサンプル・スキーマoeについて考えます。
CREATE TYPE cust_address_typ
OID '82A4AF6A4CD1656DE034080020E0EE3D'
AS OBJECT
( street_address     VARCHAR2(40)
, postal_code        VARCHAR2(10)
, city               VARCHAR2(30)
, state_province     VARCHAR2(10)
, country_id         CHAR(2)
);
/
CREATE TABLE customers
( customer_id        NUMBER(6)     
, cust_first_name    VARCHAR2(20) CONSTRAINT cust_fname_nn NOT NULL
, cust_last_name     VARCHAR2(20) CONSTRAINT cust_lname_nn NOT NULL
, cust_address       cust_address_typ
.
.
.
次に示すとおり、SQL文では、postal_code属性への参照は表別名を使用して完全に修飾する必要があります。
SELECT c.cust_address.postal_code FROM customers c;
UPDATE customers c SET c.cust_address.postal_code = 'GU13 BE5' 
WHERE c.cust_address.city = 'Fleet';
引数を取らないメンバー・メソッドを参照する場合は、空のカッコを付ける必要があります。たとえば、サンプル・スキーマoeには、メンバー・ファンクションgetCatalogNameを含むcatalog_typに基づくオブジェクト表categories_tabが含まれます。SQL文でこのメソッドをコールするには、次の例のように、空のカッコを付ける必要があります。
SELECT TREAT(VALUE(c) AS catalog_typ).getCatalogName() "Catalog Type"
FROM categories_tab c
WHERE category_id = 90;
Catalog Type
------------------------------------
online catalog
参照:
ユーザー定義データ型の詳細は、『Oracle Database概要』を参照してください。 
Copyright &copy; 2005 Oracle Corporation. 
All Rights Reserved.
目次
索引
Oracle SQLの基本要素
