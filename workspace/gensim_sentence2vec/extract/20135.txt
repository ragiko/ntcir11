前節では、既にあるインデックスの列の順番を変えることで、 インデックスから得られるメリットを大きくする方法について説明しました。 しかし、例に挙げたのは2つのSQL文だけでした。本来は、インデックスを変更 すると、そのインデックスが作成されたテーブルに対する全てのクエリが影響を 受けます。この節では、データベースがどのようにインデックスを選ぶのかを 説明し、既存のインデックスを変更することによる副作用を見ていきます。
前節で採用したEMPLOYEE_PKインデックスは、 子会社だけで検索する全てのクエリのパフォーマンスを改善します。 実際のところこのインデックスは、他にどのような検索条件が追加されたと しても、SUBSIDIARY_IDを検索に使う全てのクエリに使う ことができます。つまり、where句の他の部分で 他のインデックスを使っていたクエリに対しても有効になるということです。 この場合、複数のアクセスパスがある時には、オプティマイザがどの インデックスが最適かを判断する役目を持ちます。
クエリオプティマイザ(あるいはクエリプランナ)は、SQL文を実行 計画に変換する、データベースのコンポーネントの1つです。この処理は、 コンパイルまたはパースとも呼ばれます。オプティマイザには、2つの種類が あります。コストベースオプティマイザ (CBO)は、複数の実行計画のバリエーションを出し、それぞれの 実行に必要な コストを計算します。このコストは、実行される処理の 種類と、アクセスされる予定の行数を元にして割り出します。最終的に、 このコスト値が、「ベストな」実行計画を選ぶための基準になるのです。ルールベースオプティマイザ (RBO)は、ハードコードされたルールを元に実行計画を決定します。 ルールベースオプティマイザは、柔軟性に欠けることから、今日では あまり使われません。
インデックスを変更すると、好ましくない副作用が出る場合もあります。 ここでは、社内用の社員検索アプリケーションが合併後から非常に遅くなって しまった例を考えてみましょう。まず最初に、以下のクエリがスローダウンの 原因でないかどうかを調べます。
SELECT first_name, last_name, subsidiary_id, phone_number
FROM employees
WHERE last_name  = 'WINAND'
AND subsidiary_id = 30
実行計画は以下のようになります。
---------------------------------------------------------------
|Id |Operation                   | Name         | Rows | Cost |
---------------------------------------------------------------
| 0 |SELECT STATEMENT            |              |    1 |   30 |
|*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |    1 |   30 |
|*2 |  INDEX RANGE SCAN          | EMPLOYEES_PK |   40 |    2 |
---------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
1 - filter("LAST_NAME"='WINAND')
2 - access("SUBSIDIARY_ID"=30)
実行計画では、インデックスを使っており、その合計コストは30と 出ています。まあまあの結果でしょう。ただし、変更したばかりの インデックスを使っている点が少々気になるところです。これは、 インデックスの変更がパフォーマンスに影響を及ぼしている可能性を 疑うには十分だと言えるでしょう。変更前のインデックスが EMPLOYEE_IDから始まっていたことを覚えていればなおさら です。つまり、where句に含まれていない列から 始まっていたわけです。従って、以前はこのクエリはインデックスを 使えなかったはずです。
詳しい調査のためには、変更前後の実行計画を比べてみるのがよいで しょう。元々の実行計画を見るために、以前のインデックス定義をもう一度 適用してみることもできますが、多くのデータベースでは、あるクエリに 対してインデックスを使わないようにする簡単な方法が提供されています。 以下は、Oracleにおけるその機能であるオプティマイザ ヒントの例です。
SELECT /*+ NO_INDEX(EMPLOYEES EMPLOYEE_PK) */ 
first_name, last_name, subsidiary_id, phone_number
FROM employees
WHERE last_name  = 'WINAND'
AND subsidiary_id = 30
インデックスの変更前に使われていたであろう実行計画では、 インデックスを使っていませんでした。
----------------------------------------------------
| Id | Operation         | Name      | Rows | Cost |
----------------------------------------------------
|  0 | SELECT STATEMENT  |           |    1 |  477 |
|* 1 |  TABLE ACCESS FULL| EMPLOYEES |    1 |  477 |
----------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
1 - filter("LAST_NAME"='WINAND' AND "SUBSIDIARY_ID"=30)
TABLE ACCESS FULLでは、全テーブルを 読み込む必要がありますが、この場合はインデックスを使うよりも高速な ようです。1行のみに一致するクエリでは、こういったことはあまり ないことです。1行のみを検索するのにインデックスを使うのは、フル テーブルスキャンより高速なはずですが、今回はそうではありませんでした。 インデックスが悪さをしているように思えます。
このような時には、問題のある実行計画を順に追っていきましょう。 まず最初は、EMPLOYEES_PKインデックスでの INDEX RANGE SCANです。このインデックスは、 LAST_NAMEを含んでいませんので、INDEX RANGE SCANは SUBSIDIARY_IDのフィルタだけを使っているものと考え られます。Oracleでは、これについてPredicate Information(述語情報) の欄に、今回の場合は実行計画のエントリ2番として 書かれています。ここで、各処理にどの条件が適用されたかがわかります。 
ID 2(例2.1) のINDEX RANGE SCANでは、SUBSIDIARY_ID=30 フィルタだけを適用しています。つまり、SUBSIDIARY_IDが 30の最初のエントリを見つけるために、インデックスツリーをたどります。 それから、その子会社に属する全てのエントリを見つけるために、 リーフノードチェーンをたどります。INDEX RANGE SCANの 結果は、SUBSIDIARY_IDの条件を満たすROWIDsの リストになります。子会社の規模によって、このリストは数行かもしれませんし、 数百行かもしれません。
次は、TABLE ACCESS BY INDEX ROWIDの処理です。 前段階で得たROWIDを使って、テーブルから行(の全ての列)を 取得します。LAST_NAME列が得られたら、データベースは where句の残りの部分を評価します。つまり、データベースは LAST_NAMEのフィルタを適用する前に、SUBSIDIARY_ID=30 に一致する全ての行を取得する必要があることになります。
SQL文の応答時間は、結果のサイズではなく、該当する子会社の 従業員数に依存します。子会社に従業員が少数しかいない場合、 INDEX RANGE SCANのパフォーマンスは比較的良くなります。 しかし、大きな子会社の場合はTABLE ACCESS FULLの方が、 テーブルから大きなデータを一度に読みだすので、より速くなる可能性も あります(「フルテーブルスキャン」を参照)。
インデックスの探索で、従業員一人一人にあたるROWIDsを たくさん返す場合には、その後データベースが1行ずつデータを読み出すことに なるので、クエリは遅くなります。インデックスを遅くする、完璧な組み合わせ ——それが、広い範囲のインデックス探索と、たくさんの行を1行ずつ読み出す 処理です。
最適な実行計画を選ぶには、テーブル上のデータの分散状態にも依存 します。そのため、オプティマイザはデータベースの中身についての統計情報も 利用します。今回の例では、子会社間の従業員の分散状態を含むヒストグラムが 使われます。これにより、オプティマイザはインデックス探索でどのくらいの 行が返されるかを見積もり、それをコスト計算に使うことができます。
遅いインデックス パートII | Use The Index, Luke!
