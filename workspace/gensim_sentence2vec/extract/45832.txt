
[ << ]
[ >> ]
[Top]
[Contents]
[Index]
[ ? ]
14. defun 内の単語のカウント 
次の計画の目標は、関数定義の中の単語の数を数えることである。当たり前のこ
とだが、これは count-words-region の使い方をちょっと工夫すれば出
来てしまう。カウント:繰り返しと正規表現, を参照
のこと。例えば、ある一つの定義の中の単語数を数えたければ、C-M-h
(mark-defun) コマンドを使って定義部分をマークしてから 
count-words-region を呼び出せばよい。
しかしながら、ここではもっと大きなことをやってみたいと思う。Emacs のソー
スの中の全ての定義の中の単語とシンボルの数を数えて、そこにどれだけの関数
があり、各々がどのくらいの長さかをグラフにして出力するとか、40個から49個
までの単語とシンボルをもつ関数がどれだけあるか、50個から59個までではどうか、
といったことを調べるのである。私はしばしば典型的な関数というのがどのくらい
の長さかを知りたくなる。これは、そういったことを教えてくれるものである。
分割による困難の克服  
14.1 何を数えればよいか?  
14.2 単語やシンボルは何から構成されているか  
14.3 関数 count-words-in-defun  count-words とほぼ同じ
14.4 一つのファイルにある複数の defun を数える  
14.5 ファイルを見つける  
14.6 lengths-list-file についての詳細  沢山の定義の長さのリスト
14.7 異なるファイルの中の定義を数える  
14.8 異なるファイルの定義を再帰を使って数える  
14.9 データをグラフに表示するための準備  
分割による困難の克服 
はっきり言って、このヒストグラムを書く計画は人をひるませる類のものである。
しかし、これをいくつもの細かいステップに分けて、各々を一つずつ見ていくこ
とにすれば、それほど恐れるほどのものではない。そこで、どんなステップに分
けるべきかを書いてみることにする。
まず最初に、一つの定義の中に単語がどれだけあるかを数える関数を書く。ここ
では、単語と同じくシンボルをどう扱うかが問題になる。
二番目に各々の関数の中の単語数をリストにする関数を書く。この関数では 
count-words-in-defun を使うことが出来る。
三番目に、各ファイルの中の各関数の中の単語数をリストにする関数を書く。こ
れをやろうとすると、必然的に、自動的に様々なファイルを見つけてそれらに移
り、それに含まれる関数定義の中の単語数を数えるということをしなければなら
なくなる。
四番目に、三番目のステップで作成した数のリストをグラフとして出力するのに
適した形に変換する関数を書く。
五番目に結果をグラフとして表示する関数を書く。
これはかなりの大計画である。しかし、各々のステップをゆっくりと進んでいけ
ば、それ程困難なものではない。
14.1 何を数えればよいか? 
関数定義の中の単語数を数えるにはどうしたらよいか、を最初に考え始めた時に、 
まず疑問に思うこと (あるいは、考えるべきこと) は、我々は何を数えればよい
かということである。Lisp の関数定義に関して単語のことを話す場合、実際に
は大抵シンボルのことを言っている。例えば、次の multiply-by-seven 
関数は、defun、multiply-by-seven、number、*、
そして7という5個のシンボルを含んでいる。これに加えて説明文字列の
中に `Multiply'、`NUMBER'、`by'、そして `seven' とい
う単語が含まれている。`number' は繰り返して使われているので、関数定
義の中には合計10個の単語とシンボルが含まれていることになる。
ところが、もし multiply-by-seven の定義を C-M-h
(mark-defun) でマークして、そこで count-words-region を呼
び出してみると、10個ではなく11個の単語があるという答えが帰ってくる。何かが
おかしい!
実は、問題は二重になっている。count-words-region は `*' を単
語とは数えないが、逆に、一つのシンボル multiply-by-seven を三つの
単語だと数えてしまうのである。これはハイフンが一つの単語内でのつながりを
示すものとしてではなく、単語間の間の空白と同じように扱われるためのである。
従って、`multiply-by-seven' は `multiply by seven' と書かれて
いるように扱われることになる。このような混乱の原因は、
count-words-region の定義内で一つの単語ずつ移動する際に使っている
正規表現にある。標準的な count-words-region のバージョンで使われ
ている正規表現は
である。この正規表現は一つ以上単語構成文字が続いた後に0個以上の非単語構
成文字が続くというパターンである。「単語構成文字」によって何が意味される
かという問題は、構文 (syntax) の問題になる。これには一つのセクションを割
当てて論じる価値がある。
14.2 単語やシンボルは何から構成されているか 
Emacs では、各々の文字はある構文カテゴリ (syntax categories) 
に属するものとして扱われる。例えば正規表現 `\\w+' は一つ以上の「単
語構成文字」(word constituent) が続くパターンを表している。単語構
成文字というのは、ある一つの構文カテゴリーの要素のことである。他の構文カ
テゴリーの要素は、例えば終止符やカンマ等の句読点文字のクラス、スペースや
タブ等の空白文字のクラスを含んでいる。(より詳しいことについては 
section `The Syntax Table' in The GNU Emacs Manual, 及
び section `Syntax Tables' in The GNU Emacs Lisp Reference Manual,を参照のこと。)
構文テーブルとはどの文字がどのカテゴリーに属するかを定めるものである。普
通、ハイフンは「単語構成文字」には分類されない。そうではなく「シンボルの
名前ではあるが、単語ではないものの一部をなす文字のクラス」に分類される。
これは count-words-region 関数がハイフンを単語間の空白文字と同じ
扱いをすることを意味する。これが count-words-region が 
`multiply-by-seven' を三つの単語だと数える理由である。
Emacs に multiply-by-seven を一つの単語だと数えさせるには二つの方
法がある。一つは構文テーブルを書き換える方法、もう一つは正規表現を書き直
す方法である。
Emacs が各々のモードに対して持つ構文テーブルを書き換えることで、ハイフン
を単語構成文字だと再定義することが出来る。この動作は我々の目的に殆ど合う
のだが、ハイフンだけが単語の中には現れずシンボルの中には出てくる文字とい
うわけではない。似たような文字は他にもある。
代わりに、count-words の定義中の正規表現の方を書き直してシンボル
を含むようにすることも出来る。こちらの方法の方がより簡明である。ただし、
実際にやることは少々トリッキーだ。
最初の部分は十分に単純である。パターンとしては「少なくとも一つ以上続く、
単語ないしはシンボルの構成要素」にマッチするもの、つまり、
になる。`\\(' は `\\w' と `\\s_' のいずれかを表わす正規表
現のグループの開始を示す部分である。対象となる二つの部分は `\\|' で
区切られている。`\\w' は任意の単語構成文字にマッチし、`\\s_' 
はシンボル名の一部になり得るが、単語構成文字ではないような任意の文字にマッ
チする。後に続く `+' は、このグループに属する文字、即ち単語かシンボ
ルの構成文字が少くとも一回はマッチしなければならないことを意味する。
しかしながら、正規表現の二番目の部分はもっと難しい。欲しいものは、一番目
の正規表現に続けて「単語の一部にもシンボルの一部にもならない文字が一つ以
上続いてもかまわない」ことを表わす表現である。まず思い浮んだのは次のよう
なものである。
上の大文字の `W' と `S' は各々単語、あるいはシンボルの構成文字
ではないような文字にマッチする。しかし、この表現では、単語構成文
字ではないか、もしくはシンボル構成文字ではない文字に一致してしまう。これ
ではどんな文字にもマッチしてしまう。
次に私は、テストしているリージョン内の全ての単語やシンボルの後には空白文
字 (スペース、タブ、もしくは改行) があることに気がついた。そこで、単語か
シンボルの構成文字が一つ以上続くというパターンの後に、一つ以上の空白文字
が続くというパターンを置いてみた。しかし、これも失敗した。通常は単語やシ
ンボルは空白で終わるのだが、実際のコードでは、シンボルの後に括弧が来たり、
単語の後に句読点が来たりすることだってある。というわけで、結局、単語かシ
ンボルの構成文字の後に0個以上の空白文字以外の文字が続き、その後に0個以上
の空白文字が来る、というパターンにすることにした。
次がその正規表現である。
Programming in Emacs Lisp: Words in a defun
