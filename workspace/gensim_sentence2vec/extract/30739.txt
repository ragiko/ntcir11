
説明
Vectorインスタンスは、予め定めたひとつのデータ型の複数の値をエレメントとしてもつことができます。エレメントのデータ型が厳密に指定されることにより、その処理が最適化されたいわば厳格な配列と考えられます[*1]。
VectorとArrayクラス
まず、Vectorクラスのインスタンスには、配列(Arrayクラス)と同じく、複数の値がエレメントとして納められます。つぎに、VectorクラスのプロパティやメソッドはArrayとほとんどが同じで、lengthプロパティやpush()、pop()、slice()、sort()といったメソッドを備えています。
【配列と似ている点】
複数のエレメントを操作できる。
プロパティやメソッドはArrayクラスとほとんど同じ。
しかし、Vectorインスタンスはおもにふたつの点で、配列(Arrayインスタンス)とは扱いが異なります。第1に、すべてのエレメントがひとつのデータ型で指定されます。したがって、他の型のデータをエレメントにすることはできません。第2に、エレメントのインデックスは連番、つまり密(dence)でなければなりません。Vector.lengthプロパティの値より大きいインデックスには、エレメントが加えられません。
【配列と異なる点】
すべてのエレメントにひとつのデータ型が指定される。
エレメントのインデックスは密(連番)でなければならない。
Vectorクラスはエレメントにひとつのデータ型が指定され、エレメントは密であることにより、大きくふたつの利点があります[*2]。
【Vectorクラスの利点】
パフォーマンスが高い。
データ型のチェックが厳格。
第1は、パフォーマンスの高さです。Vectorインスタンスのエレメントへのアクセスは、配列よりもずっと高速です(なお、後述注[*6]参照)。第2は、データ型のチェックが厳格なことです。[Strictモード][*3]では、コンパイラがデータ型の適合性を調べます[*4]。Vectorエレメントにデータ型の合わない値を設定したり、取出したエレメントを異なる型のデータとして扱わないか確認します。
[*1] Vectorというクラス名は、複数の値をひと組で扱うという数学的なベクトルの概念からつけられたものと想像されます。3次元空間の座標や空間ベクトルを処理するVector3Dクラスとは関係がありませんので、ご注意ください。
[*2] Vectorクラスの特長や配列と比べた利点については、Adobeデベロッパーセンター「ActionScript 3.0におけるパフォーマンス向上のヒント」の05「ArrayとVectorクラス」をご参照ください。また、F-site「Vectorクラス対Arrayクラスの処理速度比較」ではサンプルスクリプトで速さを比べています。
[*3] [Strictモード]は、コンパイラ警告を報告するデフォルトの設定です。[ファイル]メニューの[パブリッシュ設定]で[Flash]タブからActionScript 3.0の[設定]ボタンをクリックし、[ActionScript 3.0の詳細設定]ダイアログボックスで選択できます(図001)。
図001[ActionScript 3.0の詳細設定]ダイアログボックスで[Strictモード]を設定
[*4] ただし、Vector.push()やVector.unshift()メソッドによりVectorにエレメントを加えると、後述(「Vectorエレメントの操作」)のとおり引数値のデータ型はコンパイル時には確認されず、ランタイム(実行時)にチェックされます。
Vectorクラスのコンストラクタメソッドとデータ型指定
Vectorクラスのコンストラクタメソッドは、以下のようなシンタックスでインスタンスを生成します。山括弧<>内に記述するベース型は、エレメントのデータ型を指定します。なお、山括弧<>でベース型を指定する記述は、「型パラメータシンタックス」と呼ばれます。
【Vectorコンストラクタ】
Vector.<ベース型>(長さ:uint=0, 長さの固定:Boolean=false)
コンストラクタの呼出しには、必ずベース型を記述しなければなりません。ベース型を指定しないと、ランタイムエラーが生じます。ベース型には、変数宣言や関数定義のデータ型と同じく、どのようなクラスでも指定することができます。
第1引数の[長さ]として正の整数を渡すと、生成されるVectorインスタンスのエレメント数(長さ)がその値に設定されます。デフォルト値は0です。長さを定めると、各エレメントの値はベース型のデフォルト値として扱われます[*5]。第2引数の[長さの固定]にtrueを指定すると、Vectorインスタンスのエレメント数(長さ)は後から変えることができません[*6]。デフォルト値は、変更を可能とするfalseです。
変数の宣言や関数の定義でデータ型としてVectorクラスを指定するときは、型パラメータシンタックスでベース型を指定する必要があります。たとえば、エレメントを整数とするVectorインスタンス(長さ0)を生成して、変数myVectorに代入するステートメントはつぎのようになります。
Vector型データの代入式の両辺は、ベース型まで厳密に一致しなければなりません。つまり、ベース型が整数(int)のVectorインスタンスは、数値(Number)型Vectorの変数には代入できません。また、ベース型をSpriteで指定したVectorインスタンスは、スーパークラスであってもDisplayObjectをベース型とするVectorの変数に設定することもできません。したがって、つぎのふたつのステートメントは、いずれもランタイムエラーになります[*7]。
var myVector:Vector.<Number> = new Vector.<int>();
var myObject:Vector.<DisplayObject> = new Vector.<Sprite>();
Vectorインスタンスのベース型に、Vectorデータ型を指定することもできます。その場合、ベース型として記述したVectorにも、さらにベース型の指定が必要になります。たとえば、ベース型が整数(int)のVectorデータをエレメントとするVectorインスタンスは、つぎのように生成して、変数myVectorに代入できます。
FN0902001 - Vectorクラス - Flash : テクニカルノート
