
私が知っているテスト担当者の多くは変異テストについて耳にしたことがあっても、実際に実行した人はほとんどいません。変異テストは、難しいうえに、高価なサードパーティ製のソフトウェア ツールが必要だと考えられています。しかし、今月は、C# と Visual Studio を使用して、ごく単純な (2 ページ未満のコードと 4 時間未満の作業で作成できる) 変異テスト システムを作成する方法について説明します。変異テスト システムを単純に保っておくと、わずかな時間と労力で本格的な変異システムのメリットの大半を享受できます。
変異テストとは、一連のテスト ケースの効果を測定する手段です。考え方はシンプルです。テスト ケースが 100 とおりあり、テスト対象のシステム (SUT: System Under Test) がこの 100 とおりのテスト ケースすべてに合格するとします。SUT を変異させる (">" を "<" に変えたり "+" を "-" に変えたりする) と、この SUT ではバグが発生すると推定されます。ここで、100 とおりのテスト ケースを再実行すると、少なくとも 1 つのテスト ケースで問題のあるコードが検出されたことが示され、不合格になると予想されます。しかし、どのテストも不合格にならなければ、用意したテスト ケースでは問題のあるコードを検出できず、SUT を完全にはテストできていない可能性が非常に高くなります。
今回の目的は、図 1 をご覧いただければ一目瞭然です。
図 1 変異テストのデモの実行
この例の SUT は、MathLib.dll というライブラリです。ここで紹介する技法は、DLL、WinForms アプリケーション、ASP.NET Web アプリケーションなど、ほとんどの Microsoft .NET Framework システムのテストに使用できます。変異システムでは、まず SUT の元のソース コードをスキャンして、変異させる候補となるコードを探します。ここではごく単純なシステムにし、"<" 演算子と ">" 演算子だけを探します。テスト システムは、2 つの変異形を作成して評価するよう設定します。運用シナリオでは、多くの場合、数百または数千の変異形を作成することになります。最初の変異形は、変異させる演算子をランダムに選択し (この例では、SUT ソース コードの文字位置 189 にある ">" 演算子)、その演算子を "<" に変異させます。次に、変異させた DLL のソース コードをビルドして、変異させた MathLb.dll ライブラリを作成します。続いて、変異させた SUT に対してテスト ケースのスイートを呼び出し、結果をファイルにログ記録します。2 回目の反復処理でも、同じ方法で 2 つ目の変異形を作成してテストします。ログ ファイルの結果は次のとおりです。
=============Number failures = 0Number test case failures = 0 indicates possible weak test suite!=============Number failures = 3This is good.=============
最初の変異形では不合格となったテスト ケースがありませんでした。つまり、位置 189 のソース コードを調べて、いずれのテスト ケースでもそのコードがテストされなかった理由を突き止める必要があります。
SUT
このごく単純な変異テストのデモは、3 つの Visual Studio プロジェクトから構成されています。1 つ目のプロジェクトは SUT を含み、このデモでは MathLib という C# クラス ライブラリです。2 つ目のプロジェクトはテスト ハーネスの実行可能ファイルで、このデモでは TestMutation という C# コンソール アプリケーションです。3 つ目のプロジェクトは変異形を作成してビルドします。このデモでは Mutation という C# コンソール アプリケーションです。利便性のため、3 つのプロジェクトすべてを MutationTesting という 1 つのディレクトリに配置しました。変異テストでは、追跡対象のファイルやフォルダーが多数になるため、ファイルやフォルダーを整理する手間を軽視しないでください。このデモでは、Visual Studio 2008 を使用して (ただし、任意のバージョンの Visual Studio で動作します) ダミーの MathLib クラス ライブラリを作成しています。ダミーの SUT の完全なソース コードを図 2 に示します。
図 2 ダミー SUT の完全なソース コード
using System;
namespace MathLib
{
public class Class1
{
public static double TriMin(double x, double y, double z)
{
if (x < y)
return x;
else if (z > y)
return y;
else
return z;
}
}
}
既定のクラス名 Class1 をそのまま使用しています。このクラスは、3 つの double 型パラメーターの最小値を返す、TriMin という静的メソッドを 1 つ含みます。また、この SUT では処理をわざと間違えていることに注意してください。たとえば、x = 2.0、y = 3.0、z = 1.0 の場合、TriMin メソッドは正しい 1.0 ではなく 2.0 を返します。しかし、重要なのは、変異テストは SUT の正確性を直接測定するのではなく、一連のテスト ケースの効果を測定することです。SUT をビルドしたら、次はソース ファイル Class1.cs のベースラインとなるコピーを変異テスト システムのルート ディレクトリに保存します。各変異形が SUT の元のソース コードを 1 か所変更するという考え方から、元の SUT ソースのコピーを保持しておく必要があります。この例では、元のソースを Class1-Original.cs という名前で C:\MutationTesting\Mutation に保存しました。
テスト ハーネス
テスト状況によっては、テスト ケース データの既存セットがあることも、既存のテスト ハーネスが存在することもあります。ここでは今回のごく単純な変異テスト用に、TestMutation という C# コンソール アプリケーション テスト ハーネスを作成します。Visual Studio でプロジェクトを作成したら、SUT (C:\MutationTesting\MathLib\bin\Debug にある MathLib.dll) への参照を追加します。テスト ハーネス プロジェクトの完全なソース コードを図 3 に示します。
図 3 テスト ハーネスとテスト データ
using System;
using System.IO;
namespace TestMutation
{
class Program
{
static void Main(string[] args)
{
string[] testCaseData = new string[]
{ "1.0, 2.0, 3.0, 1.0",
"4.0, 5.0, 6.0, 4.0",
"7.0, 8.0, 9.0, 7.0"};
int numFail = 0;
for (int i = 0; i < testCaseData.Length; ++i) {
string[] tokens = testCaseData[i].Split(',');
double x = double.Parse(tokens[0]);
double y = double.Parse(tokens[1]);
double z = double.Parse(tokens[2]);
double expected = double.Parse(tokens[3]);
double actual = MathLib.Class1.TriMin(x, y, z);
if (actual != expected) ++numFail;
}
FileStream ofs = new FileStream("..\\..\\logFile.txt",
FileMode.Append);
StreamWriter sw = new StreamWriter(ofs);
sw.WriteLine("=============");
sw.WriteLine("Number failures = " + numFail);
if (numFail == 0)
sw.WriteLine(
"Number test case failures = " +
"0 indicates possible weak test suite!");
else if (numFail > 0)
sw.WriteLine("This is good.");
sw.Close(); ofs.Close();
}
}
}
テスト ハーネスに 3 とおりのテスト ケースをハードコーディングしていることに注目してください。運用環境では、多くの場合、数百とおりのテスト ケースをテキスト ファイルに格納して、ファイル名を args[0] として Main に渡します。"1.0, 2.0, 3.0, 1.0" という最初のテスト ケースは、SUT の TriMin メソッドの、x パラメーター、Y パラメーター、および z パラメーター (1.0、2.0、および 3.0) と、想定する結果 (1.0) を表します。テスト セットが不適切なのは明らかです。3 とおりのテスト ケースはすべて基本的に同じことを意味し、最小値は x パラメーターになります。このまま元の SUT を調べれば、3 とおりのテスト ケースすべてに合格することがわかります。今回の変異テスト システムでは、このテスト セットの弱点を検出できるでしょうか。
テスト ハーネスでは各テスト ケースを反復処理し、入力パラメーターと想定する戻り値を解析します。次に、入力パラメーターを指定して SUT を呼び出し、実際の戻り値を取得し、想定する戻り値と比較して、テスト ケースの合格または不合格を判断します。最後に、テスト ケースが不合格になった合計数を集計します。変異テストでは、テスト ケースが合格した数ではなく、新たに不合格が少なくとも 1 つ生じるかどうかに着目していることを思い出してください。テスト ハーネスは、呼び出し元プログラムのルート フォルダーにログ ファイルを書き込みます。
変異テスト システム
ここでは、変異テスト プログラムを 1 行ずつ説明します。ただし、図 1 に表示されている出力の生成に使用する、WriteLine ステートメントのほとんどは省略します。ルートの MutationTesting ディレクトリに Mutation という C# コンソール アプリケーションを作成しています。プログラムの冒頭は次のとおりです。
MSDN マガジン: テストの実行 - ごく単純な変異テスト
